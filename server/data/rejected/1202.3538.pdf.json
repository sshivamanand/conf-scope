{
  "name" : "1202.3538.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Laura Bozzelli", "Hans van Ditmarsch", "Tim French", "James Hales", "Sophie Pinchinat" ],
    "emails" : [ "laura.bozzelli@fi.upm.es", "hans.van-ditmarsch@loria.fr", "tim@csse.uwa.edu.au", "james@csse.uwa.edu.au", "Sophie.Pinchinat@irisa.fr" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n20 2.\n35 38\nv2 [\ncs .L\nO ]\n2 5\nContents"
    }, {
      "heading" : "1 Introduction 2",
      "text" : ""
    }, {
      "heading" : "2 Technical preliminaries 5",
      "text" : ""
    }, {
      "heading" : "3 Refinement 8",
      "text" : "3.1 Refinement and its basic properties . . . . . . . . . . . . . . . . . . . . . . 8 3.2 Game and logical characterization of refinement . . . . . . . . . . . . . . . 10 3.3 Refinement as bisimulation plus model restriction . . . . . . . . . . . . . . 13 3.4 Refinement and action models . . . . . . . . . . . . . . . . . . . . . . . . . 15 3.5 Modal specifications refinement . . . . . . . . . . . . . . . . . . . . . . . . 16\n∗Informática, Universidad Politécnica de Madrid, Spain, laura.bozzelli@fi.upm.es †LORIA, CNRS – Université de Lorraine, France, hans.van-ditmarsch@loria.fr ‡Computer Science and Software Engineering, University of Western Australia, tim@csse.uwa.edu.au §Computer Science and Software Engineering, University of Western Australia, james@csse.uwa.edu.au ¶IRISA, University of Rennes, Sophie.Pinchinat@irisa.fr"
    }, {
      "heading" : "4 Refinement modal logic 16",
      "text" : "4.1 Syntax and semantics of refinement modal logic . . . . . . . . . . . . . . . 16 4.2 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 4.3 Refinement quantification is bisimulation quantification plus relativization 21 4.4 Alternating refinement relations . . . . . . . . . . . . . . . . . . . . . . . . 26"
    }, {
      "heading" : "5 Axiomatization RML 27",
      "text" : "5.1 Soundness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 5.2 Example derivations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 5.3 Completeness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 5.4 The single-agent case . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 5.5 Refinement epistemic logic . . . . . . . . . . . . . . . . . . . . . . . . . . . 37"
    }, {
      "heading" : "6 Axiomatization RMLµ 37",
      "text" : "6.1 Soundness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 6.2 Completeness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44"
    }, {
      "heading" : "7 Complexity 45",
      "text" : "7.1 RMLµ is non-elementary . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 7.2 Succinctness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51"
    }, {
      "heading" : "8 Conclusions and perspectives 56",
      "text" : ""
    }, {
      "heading" : "1 Introduction",
      "text" : "Modal logic is frequently used for modelling knowledge in multi-agent systems. The semantics of modal logic uses the notion of “possible worlds”, between which an agent is unable to distinguish. In dynamic systems agents acquire new knowledge (say by an announcement, or the execution of some action) that allows agents to distinguish between worlds that they previously could not separate. From the agent’s point of view, what were “possible worlds” become inconceivable. Thus, a future informative event may be modelled by a reduction in the agent’s accessibility relation. In [55] the future event logic is introduced. It augments the multi-agent logic of knowledge with an operation ∀ϕ that stands for “ϕ holds after all informative events” — the diamond version ∃ϕ stands for “there is an informative event after which ϕ.” The proposal was a generalization of a so-called arbitrary public announcement logic with an operator for “ϕ holds after all announcements” [8]. The semantics of informative events encompasses action model execution à la Baltag et al. [9]: on finite models, it can be easily shown that a model resulting from action model execution is a refinement of the initial model, and for a given refinement of a model we can construct an action model such that the result of its execution is bisimilar to that refinement. In [56] an axiomatization of the single-agent version of this logic is presented, and also expressivity and complexity results. These questions were visited in both the context of modal logic, and of the modal µ-calculus.\nIn the original motivation, the main operator ∃ had a rather temporal sense — therefore the ‘future event’ name. However, we have come to realize that the structural transformation that interprets this operator is of much more general use, on many very different kinds of modal logic, namely anywhere where more than a mere model restriction or pruning is required. We have therefore come to call this the refinement operator, and the logic refinement modal logic.\nThus we may consider refinement modal logic to be a more abstract perspective of future event logic [55] applicable to other modal logics. To any other modal logic! This is significant in that it motivates the application of the new operator in many different settings. In logics for games [42, 2] or in control theory [47, 51], it may correspond to a player discarding some moves; for program logics [29] it may correspond to operational refinement [40]; and for logics for spatial reasoning it may correspond to sub-space projections [41].\nLet us give an example. Consider the following structure. The ◦ state is the designated point. The arrows can be associated with a modality.\n◦ • • •\nE.g., 3332⊥ is true in the point. From the point of view of the modal language, this structure is essentially the same structure (it is bisimilar) as\n• • • ◦ • • •\nThis one also satisfies 3332⊥ and any other modal formula for that matter. A more radical structural transformation would be to consider submodels, such as\n◦ • •\nA distinguishing formula between the two is 332⊥, which is true here and false above. Can we consider other ‘submodel-like’ transformations that are neither bisimilar structures nor strict submodels? Yes, we can. Consider\n• ◦ • •\nIt is neither a submodel of the initial structure, nor is it bisimilar. It satisfies the formula 332⊥∧3332⊥ that certainly is false in any submodel. We call this structure a refinement (or ‘a refinement of the initial structure’), and the original structure a simulation of the latter. Now note that if we consider the three requirements ‘atoms’, ‘forth’, and ‘back’ of a bisimulation, that ‘atoms’ and ‘back’ are satisfied but not ‘forth’, e.g., from the length-three path in the original structure the last arrow has no image. There seems to be still some ‘submodel-like’ relation with the original structure. Look at its bisimilar duplicate (the one with seven states). The last structure is a submodel of that copy.\nSuch a relation always holds: a refinement of a given structure can always be seen as the model restriction of a bisimilar copy of the given structure. This work deals with the semantic operation of refinement, as in this example, in full generality, and also applied to the multi-agent case.\nPrevious works [19, 37] employed a notion of refinement. In [37] it was shown that model restrictions were not sufficient to simulate informative events, and they introduced refinement trees for this purpose — a precursor of the dynamic epistemic logics developed later (for an overview, see [57]). This usage of refinement as a more general operation than model restriction is similar to ours.\nIn formal methods literature, see e.g. [62], refinement of datatypes is considered such that (datatype) C refines A if A simulates C. This usage of refinement as the converse of simulation [1, 11] comes close to ours — in fact, it inspired us to propose a similar notion, although the correspondence is otherwise not very close. A similar usage of refinement as in [62] is found in [3, 4]. In the theory of modal specifications a refinement preorder is used, known as modal refinement [45, 49]. Modal specifications are deterministic automata equipped with may-transitions and must-transitions. A must-transition is available in every component that implements the modal specification, while a may-transition need not be. This is close to our definition of refinement, as it also is some kind of submodel quantifier, but the two notions are incomparable, because ‘must’ is a subtype of ‘may’.\nWe incorporate implicit quantification over informative events directly into the language using, again, a notion of refinement; also in our case a refinement is the converse of simulation. Our work is closely related to some recent work on bisimulation quantified modal logics [17, 22]. The refinement operator, seen as refinement quantifier, is weaker than a bisimulation quantifier [55], as it is only based on simulations rather than bisimulations, and as it only allows us to vary the interpretation of a propositional variable that does not occur in the formula bound by it. Bisimulation quantified modal logic has previously been axiomatized by providing a provably correct translation to the modal µ-calculus [16]. This is reputedly a very complicated one. The axiomatization for the refinement operator, in stark contrast, is quite simple and elegant.\nOverview of the paper Section 2 gives a wide overview of our technical apparatus: modal logic, cover logic, modal µ-calculus, and bisimulation quantified logic. Section 3 introduces the semantic operation of refinement. This includes a game and (modal) logical characterization. Then, in Section 4, we introduce two logics with a refinement quantifier that is interpreted with the refinement relation: refinement modal logic and refinement µ-calculus. Section 5 contains the axiomatization of that refinement modal logic and the completeness proof. We demonstrate that it is equally expressive as modal logic. We mention results for model classes KD45 and S5. Section 6 gives the axiomatization of refinement µ-calculus. Again, we have a reduction here, to standard µ-calculus. In Section 7 we show that, although the use of refinement quantification does not change the expressive power of the logics, they do make each logic exponentially more succinct. We give a nonelementary complexity bound for refinement modal µ-calculus."
    }, {
      "heading" : "2 Technical preliminaries",
      "text" : "Throughout the paper we assume a finite set of agents A and a countable set of propositional variables P as background parameters when defining the structures and the logics. Agents are named a, b, a′, b′, . . . , and propositional variables are p, q, r, p′, p′′, p1, p2, . . . . Agent a is assumed female, and b male.\nStructures A model M = (S,R, V ) consists of a domain S of (factual) states (or worlds), an accessibility function R : A → P(S × S), and a valuation V : P → P(S). States are s, t, u, v, s′, . . . , s1, . . . A pair consisting of a model M (with domain S) and a state s ∈ S is called a pointed model, for which we write Ms. For R(a) we write Ra; accessibility function R can be seen as a set of accessibility relations Ra, and V as a set of valuations V (p). Given two states s, s′ in the domain, Ra(s, s\n′) means that in state s agent a considers s′ a possibility. We will also use a relation Ra simply as a set of pairs ⊆ S × S, and use the abbreviation sRa = {t ∈ S | (s, t) ∈ Ra}. As we will be often required to discuss several models at once, we will use the convention that M = (SM , RM , V M), N = (SN , RN , V N), etc. The class of all models (given parameter sets of agents A and propositional variables P ) is denoted K. The class of all models where for all agents the accessibility relation is reflexive, transitive and symmetric is denoted S5, and the model class with a serial, transitive and euclidean accessibility relation is denoted KD45.\nThe restriction M ′ of a model M , notation M ′ ⊆ M , is a model M ′ = (S ′, R′, V ′) such that S ′ ⊆ S, for each a ∈ A, R′a = Ra ∩ (S ′ × S ′), and for each p ∈ P , V ′(p) = V (p) ∩ S ′.\nMulti-agent modal logic The language L of multi-agent modal logic is inductively defined as\nϕ ::= p | ¬ϕ | (ϕ ∧ ϕ) | 2aϕ\nwhere a ∈ A and p ∈ P . Without the construct 2aϕ we get the language L0 of propositional logic. Standard abbreviations are: ϕ ∨ ψ iff ¬(¬ϕ ∧ ¬ψ), ϕ → ψ iff ¬ϕ ∨ ψ, ⊤ iff p ∨ ¬p, ⊥ iff p ∧ ¬p, and 3aϕ iff ¬2a¬ϕ. If there is a single agent only (|A| = 1), we may write 2ϕ instead of 2aϕ. Formula variables are ϕ, ψ, χ, ϕ ′, . . . , ϕ1, . . . and for sets of formulas we write Φ,Ψ, . . . For a finite set Φ of L formulas we let the cover operator ∇aΦ be an abbreviation for 2a ∨ ϕ∈Φ ϕ ∧ ∧ ϕ∈Φ 3aϕ; we note ∨ ϕ∈∅ ϕ is always false, whilst ∧ ϕ∈∅ ϕ is always true. Let a finite set of formulas Ψ = {ψ1, . . . , ψn} and a formula ϕ with possible occurrences of a propositional variable p be given. Let ϕ[ψ\\p] denote the substitution of all occurrences of p in ϕ by ψ. Then ϕ[Ψ\\p] abbreviates {ϕ[ψ1\\p], . . . , ϕ[ψn\\p]}, and similarly ∨ ϕ[Ψ\\p]\nstands for ϕ[ψ1\\p] ∨ . . . ∨ ϕ[ψn\\p] and ∧ ϕ[Ψ\\p] stands for ϕ[ψ1\\p] ∧ . . . ∧ ϕ[ψn\\p]. For example, 3aΦ abbreviates {3aϕ | ϕ ∈ Φ}, and the definition of ∇aΦ, above, is then written as 2a ∨ Φ ∧ ∧ 3aΦ.\nWe now define the semantics of modal logic. Assume a model M = (S,R, V ). The\ninterpretation of ϕ ∈ L is defined by induction.\nMs |= p iff s ∈ Vp Ms |= ¬ϕ iff Ms 6|= ϕ Ms |= ϕ ∧ ψ iff Ms |= ϕ and Ms |= ψ Ms |= 2aϕ iff for all t ∈ S : (s, t) ∈ Ra implies Mt |= ϕ\nA formula ϕ is valid on a model M , notation M |= ϕ, iff for all s ∈ S, Ms |= ϕ; and ϕ is valid iff ϕ is valid on all M (in the model class K, given agents A and basic propositions P ). The set of validities, i.e., the logic in the stricter sense of the word, is called K.\nCover logic The cover operator ∇ has also been used as a syntactic primitive in modal logics [16]. It has recently been axiomatized [10]. The language L∇ of cover logic is defined as\nϕ ::= p | ¬ϕ | (ϕ ∧ ϕ) | ∇a{ϕ, . . . , ϕ},\nwhere p ∈ P , and a ∈ A. The semantics of ∇aΦ is the obvious one if we recall our introduction by abbreviation of the cover operator:\nMs |= ∇aΦ iff for all ϕ ∈ Φ there is a t ∈ sRa such that Mt |= ϕ, and for all t ∈ sRa there is a ϕ ∈ Φ such that Mt |= ϕ.\nThe set of validities of cover logic is called K∇. The conjunction of two cover formulas is again equivalent to a cover formula:\n∇aΦ ∧ ∇aΨ ⇔ ∇a((Φ ∧ ∨ Ψ) ∪ (Ψ ∧ ∨ Φ)) .\nThe modal box and diamond are definable as 2aϕ iff ∇a∅∨∇a{ϕ}, and 3aϕ iff ∇a{ϕ,⊤}, respectively. Cover logic K∇ is equally expressive as modal logic K (also in the multi-agent version) [10, 34]. We use cover operators in the presentation of the axioms.\nModal µ-calculus For the modal µ-calculus, apart from the set of propositional variables P we have another parameter set X of variables to be used in the fixed-point construction. The language Lµ of modal µ-calculus is defined as follows.\nϕ ::= x | p | ¬ϕ | (ϕ ∧ ϕ) | 2aϕ | µx.ϕ\nwhere a ∈ A, x ∈ X , p ∈ P , and where in µx.ϕ the variable x only occurs positively (i.e. in the scope of an even number of negations) in the formula ϕ. We will refer to a variable x in an expression µx.ϕ as a fixed-point variable. The formula νx.ϕ is an abbreviation for ¬µx.¬ϕ[¬x\\x]. Here, we extend the notion of substitution to modal µ-calculus by ruling out the substitution of bound variables, i.e., to give the crucial clauses: (µx.ϕ)[ψ\\x] = µx.ϕ whereas (µx.ϕ)[ψ\\y] = µx.ϕ[ψ\\y].\nFor the semantics of the µ-calculus, the valuation V of propositional variables is extended to include fixed-point variables. We write V [x 7→T ] for the operation that changes a\ngiven valuation V into one wherein V (x) = T (where T ⊆ S) and the valuation of all other fixed-point and propositional variables remains the same. Given a model M = (S,R, V ), we similarly write M [x 7→T ] for the model M = (S,R, V [x 7→T ]). The semantics of µx.ϕ (the top-down presentation, not the bottom-up presentation) is now as follows: Let ϕ ∈ Lµ and model M be given.\nMs |= µx.ϕ iff s ∈ ⋂ {T ⊆ S | {u | M [x 7→T ]u |= ϕ} ⊆ T}\nDisjunctive formula An important technical definition we require later on is that of a disjunctive formula. A disjunctive Lµ formula is specified by the following abstract syntax:\nϕ ::= x | (ϕ ∨ ϕ) | (ϕ0 ∧ ∧\na∈B\n∇a{ϕ, . . . , ϕ}) | µx.ϕ | νx.ϕ (1)\nwhere x ∈ X , ϕ0 ∈ L0 (propositional logic), and B ⊆ A. To get the disjunctive L formula (of modal logic) we omit the clauses containing µ-calculus variables x:\nϕ ::= (ϕ ∨ ϕ) | (ϕ0 ∧ ∧ a∈B ∇a{ϕ, . . . , ϕ}).\nIf the context of the logic is clear, we simply write disjunctive formula (or df). If B = ∅, we have that ∧ a∈B ∇a{ϕ1, . . . , ϕn} = ⊤, as expected.\nEvery Lµ formula is equivalent to a disjunctive Lµ formula [31]. (2a)\nEvery L formula is equivalent to a disjunctive L formula [58]. (2b)\nBisimulation quantified modal logic The language L∀̃ is defined as\nϕ ::= p | ¬ϕ | (ϕ ∧ ϕ) | 2aϕ | ∀̃pϕ\nwhere a ∈ A and p ∈ P . We let ∃̃pϕ abbreviate ¬∀̃p¬ϕ. We write ∀̃ and ∃̃ for the bisimulation quantifiers in order to distinguish them from the refinement quantifiers ∀ and ∃, to be introduced later. Given an atom p and a formula ϕ, the expression ∃̃pϕ means that there exists a denotation of propositional variable p such that ϕ. It is interpreted as follows (restricted bisimulation ≃p is introduced further below in Definition 1):\nMs |= ∀̃pϕ iff for all Nt such that Nt ≃ p Ms, Nt |= ϕ\nIn [22, Lemma 2.43] a bisimulation quantifier characterization of fixed points is given (the details of which are deferred to Section 6 on refinement µ-calculus, where they are pertinent), and from [15] we know that bisimulation quantifiers are also expressible in the modal µ-calculus. For more information on the modal µ-calculus, see [16, 58]."
    }, {
      "heading" : "3 Refinement",
      "text" : "In this section we define the notion of structural refinement, investigate its properties, give a game characterization in (basic) modal logic, and compare refinement to bisimulation and other established semantic notions in the literature."
    }, {
      "heading" : "3.1 Refinement and its basic properties",
      "text" : "Definition 1 (Bisimulation, simulation, refinement) Let two models M = (S,R, V ) and M ′ = (S ′, R′, V ′) be given. A non-empty relation R ⊆ S × S ′ is a bisimulation if for all (s, s′) ∈ R and a ∈ A:\natoms s ∈ V (p) iff s′ ∈ V ′(p) for all p ∈ P ;\nforth-a for all t ∈ S, if Ra(s, t), then there is a t ′ ∈ S ′ such that R′a(s ′, t′) and (t, t′) ∈ R;\nback-a for all t′ ∈ S ′, if R′a(s ′, t′), then there is a t ∈ S such that Ra(s, t) and (t, t ′) ∈ R.\nWe write M ≃ M ′ (M and M ′ are bisimilar) iff there is a bisimulation between M and M ′, and we write Ms ≃ M ′ s′ (Ms and M ′ s′ are bisimilar) iff there is a bisimulation between M and M ′ linking s and s′. A restricted bisimulation Rp : Ms ≃ p M ′s′ is a bisimulation that satisfies atoms for all variables except p. A total bisimulation is a bisimulation such that all states in the domain and codomain occur in a pair of the relation.\nA relation RB that satisfies atoms, back-a, and forth-a for every a ∈ A \\ B, and that satisfies atoms, and back-b for every b ∈ B, is a B-refinement, we say that M ′s′ refines Ms for group of agents B, and we write Ms B M ′ s′.\n1 An A-refinement we call a refinement (plain and simple) and for {a}-refinement we write a-refinement.\nDually to refinement, we similarly define B-simulation RB. I.e., a relation RB that satisfies atoms, back-a, and forth-a for every a ∈ A \\B, and that satisfies atoms, and forth-b for every b ∈ B, is a B-simulation.\nRestricted refinement and restricted simulation are defined similarly to restricted bisimulation. ⊣\nThe definition of simulation varies slightly from the one given by Blackburn et al. [11, p.110]. Here we ensure that simulations (and refinements) preserve the interpretations (i.e., the truth and falsity) of atoms, whereas [11] has them only preserve the truth of propositional variables in a simulation—and presumably preserve their falsity in a refinement. We prefer to preserve the entire interpretation, as we feel it suits our applications better. For example, in the case where refinement represents information change, we would not wish basic facts to become false in the process. The changes are supposed to be merely of information, and not factual. Another, inessential, difference with [11] is that in their case atoms and forth are required for all modalities (in the similarity type), i.e., they consider RB for B = A only.\n1We will overload the meaning of refinement and also say that M ′s′ is a refinement of Ms\nIf RB : Ms B M ′ s′ is a B-refinement, then the converse relation R − B ::= {(s, s ′) | (s′, s) ∈ RB} is a B-simulation, and if M ′ s′ refines Ms then we can also say that Ms simulates M ′s′. In an epistemic setting a refinement corresponds to the diminishing uncertainty of agents. This means that there is a potential decrease in the number of states and transitions in a model. On the other hand, the number of states as a consequence of refinement may also increase, because the uncertainty of agents over the extent of decreased uncertainty in other agents may still increase. This is perhaps contrary to the concept of program refinement [40] where detail is added to a specification. However, in program refinement the added detail requires a more detailed state space (i.e., extra atoms) and as such is more the domain of bisimulation quantifiers, rather than refinement quantification. Still, the consequence of program refinement is a more deterministic system which agrees with the notion of diminishing uncertainty.\nProposition 2 The relation a is reflexive and transitive (a pre-order), and satisfies the Church-Rosser property. ⊣\nProof Reflexivity follows from the observation that the identity relation satisfies atoms, and back-a and forth-a for all agents a, and therefore also the weaker requirement for refinement. Similarly, given two a-refinements R1, andR2, we can see that their composition, {(x, z) | there is a y for which (x, y) ∈ R1, (y, z) ∈ R2} is also an a-refinement. This is sufficient to demonstrate transitivity. The Church-Rosser property states that if Nt a Ms and Nt a M ′ s′ , then there is some model N ′ t′ such that Ms a N ′ t′ and M ′ s′ a N ′ t′ . From Definition 1 it follows that Ms and M ′ s′ must be bisimilar to one another with respect to A − {a}. We may therefore construct such a model N ′t′ by taking Ms (or M ′ s′) and setting RN ′\na = ∅ and R N ′ b = R M b for all b ∈ A − {a}. It can be seen that N ′ t′ , where\nN ′ = (SM , RN ′ , V M) and t′ = s, satisfies the required properties.\nAn elementary result is the following.\nProposition 3 Let B = {a1, ..., an}, and let Ms and Mt be given. Then Ms( a1 ◦ · · · ◦ an )Mt iff Ms B Mt. ⊣\nExample 4 If Nt a Ms and Ms a Nt, it is not necessarily the case that Ms ≃a Nt. For example, consider the one-agent models M and N where:\n• SM = {1, 2, 3}, RMa = {(1, 2), (2, 3)} and V M(p) = ∅ for all p ∈ P ; and\n• SN = {4, 5, 6, 7}, RNa = {(4, 5), (5, 6), (4, 7)} and V M(p) = ∅ for all p ∈ P .\nThese two models are clearly not bisimilar, although N4 a M1 via {(4, 1), (5, 2), (6, 3)} and M1 a N4 via {(1, 4), (2, 5), (3, 6), (2, 7)}. See Figure 1. ⊣\nGiven that the equivalence Ms ≡ Nt defined by Ms Nt and Ms Nt is not a bisimulation, an interesting question seems to be what it then represents. It seems to formalize that two structures are only different in resolvable differences in uncertainty (for the agent of the refinement), but not in hard and necessary facts. So the positive formulas (for that agent) should be preserved under this ‘equivalence’ ≡. Such matters will now be addressed."
    }, {
      "heading" : "3.2 Game and logical characterization of refinement",
      "text" : "It is folklore to associate a (infinite duration) two-player game with refinement, in the spirit of [3].\nDefinition 5 (Refinement game) Let Ms and Nt be two models. We define a turn-based game Ga(Ms, Nt) between two players Spoiler and Duplicator (male and female, respectively) by Ga(Ms, Nt) = (V,E, (s, t)) where the set of positions V is partitioned into the positions VSpoiler = S M×SN of Spoiler and the positions VDuplicator = S M×[{forth, back}× (A ∪ P )] × SN of Duplicator. Since the initial position (s, t) ∈ VSpoiler, Spoiler starts. The set of moves E ⊆ VSpoiler × VDuplicator ∪ VDuplicator × VSpoiler is the least set such that the following pairs belong to E (we take the convention that b 6= a, and for convenience, we name those moves with names similar to the properties of refinement in Definition 1):\nSpoiler’s moves Move Name ((s′, t′), (s′, (forth, p), t′)) whenever s′ ∈ V M(p) forth-p? ((s′, t′), (s′, (back, p), t′)) whenever t′ ∈ V N(p) back-p? ((s′, t′), (s′′, (forth, b), t′)) whenever s′′ ∈ RMb (s\n′) forth-b? ((s′, t′), (s′, (back, b), t′′)) whenever t′′ ∈ RNb (t\n′) back-b? ((s′, t′), (s′, (back, a), t′′)) whenever t′′ ∈ RNa (t\n′) back-a? Duplicator’s moves\nMove Name ((s′, (forth, p), t′), (s′, t′)) whenever t′ ∈ V N(p) forth-p! ((s′, (back, p), t′), (s′, t′)) whenever s′ ∈ V M(p) back-p! ((s′′, (forth, b), t′), (s′′, t′′)) whenever t′′ ∈ RNb (t\n′) forth-b! ((s′, (back, b), t′′), (s′′, t′′)) whenever s′′ ∈ RMb (s\n′) back-b! ((s′, (back, a), t′′), (s′′, t′′)) whenever s′′ ∈ RMa (s ′) back-a!\n⊣\nIn the game Ga(Ms, Nt), a play is a maximal (possibly infinite) sequence of consecutive moves, or equivalently a maximal sequence of adjacentes positions in the arena. The play is winning for Duplicator if it is infinite or if it is finite and ends in position of Spoiler, otherwise, the play ends in a position of Duplicator and it is winning for Spoiler.\nA strategy of Duplicator (resp. Spoiler) is a mapping σ : V ∗VDuplicator → V (resp. σ : V ∗VSpoiler → V ) which recommends which moves to choose after each prefix of a play.\nA play is an outcome of a strategy for Duplicator (resp. Spoiler) if each time Duplicator (resp. Spoiler) had to play, she (resp. he) has selected the move recommended by her (resp. his) strategy. A strategy is winning if all its outcomes are winning.\nRemark 6 One easily sees that the refinement game of Definition 5 is a particular parity game [38]. Henceforth, according to [35], the refinement game is determined2, and memoryless3 strategies suffice. ⊣\nNotice that there is no forth-a move in the game Ga(Ms, Nt), which captures the refinement relation between the structures:\nLemma 7 Ms a Nt iff Duplicator has a winning strategy in Ga(Ms, Nt). ⊣\nProof Assume Duplicator has a winning strategy σ in Ga(Ms, Nt). By Remark 6 and without loss of generality, this winning σ can be taken to be memoryless. Namely, σ : VDuplicator → VSpoiler. Now, define the binary relation Rσ ⊆ S\nM × SN as the set of pairs (s′, t′) ∈ VSpoiler that are reachable when Duplicator follows her strategy σ. Then it is easy to check that Rσ is an a-refinement from Ms to Nt. Also it is not difficult to see that if some a-refinement Ra exists from Ms to Nt, then any strategy of Duplicator which maintains Spoiler’s positions in Ra, is winning. Note that by Definition 1 of a refinement, this is always possible for her.\nWe now consider a characterization of the refinement in terms of the logic L∀. Namely, given an agent a, we define the fragment of the a-positive formulas La+ ⊆ L by\nLa+ ∋ ϕ ::= p | ¬p | (ϕ ∧ ϕ) | (ϕ ∨ ϕ) | 2bϕ | 3bϕ | 3aϕ\nwhere b ∈ A \\ {a} and p ∈ P .\nProposition 8 For any finitely branching (every state has only finitely many successors) pointed models Ms0 and Nt0, and for any agent a ∈ A,\nMs0 a Nt0 if, and only if, for every ϕ ∈ L a+, Nt0 |= ϕ implies Ms0 |= ϕ. ⊣\nProof Let us first establish that for every t ∈ SN and s ∈ SM , if Spoiler has a winning strategy in Ga(Ms, Nt), then there exists a formula ϕ(s, t) ∈ L\na+ called a distinguishing formula for (Ms, Nt), for which Nt |= ϕ(s, t) but Ms 6|= ϕ(s, t). Note that if Spoiler has a winning strategy in Ga(Ms, Nt), all plays induced by this strategy have finite length and end in a position where Duplicator cannot move. Moreover, by a simple application of König’s Lemma (as the game graph Ga(Ms, Nt) is finitely branching), the length of those plays is bounded.\nWe reason by induction on k, the maximal length of these plays; note that because Spoiler starts, k > 0.\nIf k = 1, Spoiler has a winning move from (s, t) to some v ∈ VDuplicator, where Duplicator is blocked. We reason on the form of v:\n2In each position, either Duplicator or Spoiler has a winning strategy from that position. 3Strategies σ that only take into account the current position in the game, instead of the entire prefix\nof the game that is currently played.\n• if v = (s, (forth, p), t) (resp. v = (s, (back, p), t)), then there is no move back to (s, t) because t 6∈ V N (p) (resp. s 6∈ V M(p)). A distinguishing formula is ¬p (resp. p).\n• if v = (s′, (forth, b), t) (resp. v = (s, (back, b), t′)), then tRNb = ∅ (resp. sR M b = ∅).\nA distinguishing formula is 2b⊥ (resp. 3b⊤). The case v = (s, (back, a), t ′) is the same as (s, (back, b), t′). Since forth-a moves are not allowed in the game, position v = (s′, (forth, a), t) is not reachable in the game Ga(Ms, Nt), so that the formula 2a⊥ 6∈ L a+ is not needed.\nAssume now that k > 1, and pick a winning strategy of Spoiler in Ga(Ms, Nt). We explore the move from the initial position (s, t) that is given by this strategy;\nbecause k > 1, this move cannot be either forth-p?, or back-p?. Three cases remain.\nforth-b? The reached position becomes (s′, (forth, b), t), and from there Duplicator loses. That is, for each t′ ∈ tRNb , Spoiler wins the game Ga(Ms′, Nt′) in at most k − 2 steps. By the induction hypothesis, there exists a distinguishing formula ϕ(s′, t′) ∈ La+ for (Ms′ , Nt′). It is easy to see that ϕ(s, t) = 2b( ∨ t′∈tRN b ϕ(s′, t′))\nis a distinguishing formula for (Ms, Nt); notice that since N is finitely branching, the conjunction is finitary.\nback-b? This case applies to b 6= a and to b = a.\nThe reached position becomes (s, (back, b), t′), and from there Duplicator loses. Using a similar reasoning as for forth-b moves, it is easy to establish that there exists a formula ϕ(s′, t′) ∈ La+, such that ϕ(s, t) = 3b( ∧ s′∈sRM b ϕ(s′, t′)) is a distinguishing formula for (Ms, Nt); here, as M is finitely branching, a finitary disjunction is guaranteed.\nNow, according to the game characterization of refinement (Lemma 7) and the determinacy of the refinement games (Remark 6), the existence of a winning strategy for Spoiler from position (s0, t0) is equivalent to Ms0 6 a Nt0 ; this provides us with the right to left direction of the proposition.\nFor the other direction, assume Ms a Nt, and let ϕ ∈ L a+ with Nt |= ϕ. We prove that Ms |= ϕ, by induction over the structure of the formula. Basic cases where ϕ is either p or ¬p, but also the cases ϕ ∧ ψ and ϕ ∨ ψ, are immediate.\nAssume Nt |= 2bϕ. Then for every t ′ ∈ tRNb , Nt′ |= ϕ. If tR N b = ∅, then by Property forth-b of Definition 1 this entails sRMb = ∅ and consequently Ms |= 2bϕ (whatever ϕ is). Otherwise, tRNb 6= ∅. Take an arbitrary s\n′ ∈ sRMb . By Property forth-b of Definition 1, there is a t′s′ ∈ tR M b with Ms′ b Nt′s′ and Nt ′ s′ |= ϕ. By induction hypothesis, Ms′ |= ϕ, which entails Ms |= 2bϕ. Assume Nt |= 3bϕ, and let t\n′ ∈ tRNb be such that Nt′ |= ϕ. By Property back-b of Definition 1, there is some s′ ∈ sRMb , such that Ms′ b Nt′ . By induction hypothesis, Ms′ |= ϕ which entails Ms |= 3bϕ.\nNote that the argument still holds if we take b = a."
    }, {
      "heading" : "3.3 Refinement as bisimulation plus model restriction",
      "text" : "A bisimulation is also a refinement, but refinement allows much more semantic variation. How much more? There is a precise relation. Semantically, a refinement is a bisimulation followed by a model restriction.\nAn a-refinement needs to satisfy back for that agent, but not forth. Let an (‘initial’) model and a refinement of that model be given. For the sake of the exposition we assume that the initial model and the refined model are minimal, i.e., they are bisimulation contractions. Now take an arrow (a pair in the accessibility relation) in that initial model. This arrow may be missing in the refined model namely when forth is not satisfied for that arrow. On the other hand, any arrow in the refinement should be traceable to an arrow in the initial model – the back condition. There may be several arrows in the refinement that are traceable to the same arrow in the initial model, because the states in which such arrows finish may be non-bisimilar. In other words, we can see the refined model as a blowup of the initial model of which bits and pieces are cut off.\nExample 9 A simple example is as follows. Consider the structure\n•1 •2 •3 •4\nand its refinement\n•b′ •a •b •c\nby way of refinement relation R = {(1, a), (2, b), (3, c), (2, b′)}. The arrow (3, 4) has no image in the refined model. On the other hand, the arrow (1, 2) has two images, namely (a, b) and (a, b′). These two arrows cannot be identified, because b and b′ are non-bisimilar, because there is yet another arrow from b but no other arrow from b′: arrow (2, 3) has only one image in the refined model. ⊣\nThe cutting off phase can be described such that the relation to restricted bisimulation becomes clear. When expanding the initial model, the blowing up phase, make a certain propositional variable false in all states of the blowup that you want to prune (that are not in the refinement relation) and make it true in all states that you want to keep. Therefore, the blown up model is bisimilar to the initial model except for that variable. (In other words, it is a restricted bisimulation.) Then, remove arrows to states where that atom is false.\nExample 10 Continuing the previous example, consider the following structure bisimilar to the initial model, except for the value of atom p—in the visualization • represents that p is true and ◦ represents that p is false.\n◦d′ ◦c′ •b′ •a •b •c ◦d\nThe relation R = {(1, a), (2, b), (3, c), (4, d), (2, b′), (3, c′), (4, d′)} is a bisimulation, except for the value of p. The refinement from the previous example is a restriction of this structure, namely the result of removing the ◦ states and the arrows leading to those states.⊣\nWinding up, performing an a-refinement clearly corresponds to the following operation:\nGiven a pointed model, first choose a bisimilar pointed model, then remove some pairs from the accessibility relation for a in that model.\nGiven a propositional variable q, this has the same semantic effect as\nGiven a pointed model, first choose a bisimilar pointed model except for variable q, such that q is (only) false in some states that are accessible for a, then remove all those pairs from the accessibility relation for a.\nIn other words:\nGiven a pointed model, first choose a bisimilar pointed model except for variable q, then remove all pairs from the accessibility relation for a pointing to states where q is false.\nIf we do this for all agents at the same time (or if we strictly regard tree unwindings of models only), we can even see the latter operation as follows:\nGiven a pointed model, first choose a bisimilar pointed model except for variable q, then restrict the model to the states where q is true.\nFormally, the result is as follows. First, let M be a model with accessibility relation (set of accessibility relations) R, and let R′ be such that for all a ∈ A, R′a ⊆ Ra, then (analogously to a model restriction) M |R′ is the model that is the same as M but with the accessibility restricted to R′.\nLemma 11 Given Ms a Nt, there is an N ′ t (with accessibility function R ′) and some R′′ that is the same as R′ except that R′′a ⊆ R ′ a, such that Ms ≃ N ′ t and N ′ t |R ′′ ≃ Nt. ⊣\nProof Let an a-refinement relation Ra ⊆ S M × SN be given, such that (s, t) ∈ Ra. We expand the model N and this relation Ra as follows to a model N ′ and a bisimulation R ⊆ SM × SN ′\n. Consider SM− := S M \\R−1a (S N) (SM− is the set of all states in M that do not have an image in N). Now consider N ′ = (S ′, R′, V ′) with domain S ′ = SN ∪SM− , such that for each agent b (including a), (u′, v′) ∈ R′b iff:\n• (u′, v′) ∈ RNb , or\n• (u′, v′) ∈ RMb , or\n• b = a, u′ ∈ SN , v′ ∈ SM− , there is a u such that (u, u ′) ∈ Ra, and (u, v ′) ∈ RMa ;\nand such that V ′ = V N on the SN part of the domain whereas V ′ = V M on the new SM− part of the domain. Now define R : SM → S ′ as follows: (u, u′) ∈ R iff (u, u′) ∈ Ra or (u ∈ SM− and u = u ′). Then R is a bisimulation linking Ms and N ′ t . If we restrict R ′ a to RNa , we get Nt back (states in the S M − part of N\n′ have become unreachable). We have satisfied the proof requirement that Ms ≃ N ′ t and N ′ t |R ′′ a ≃ Nt (for R ′′ a = R N a ).\nLemma 12 Given Ms a Nt, there is an N ′ t (with accessibility function R ′) and some p ∈ P such that Ms ≃ p N ′t and N ′ t |R ′′ ≃p Nt, where R ′′ is the same as R′ except that (u, u′) ∈ R′′a iff N ′ u′ |= p. ⊣\nProof To satisfy the requirement for p, we make p false on the SM− part of the domain of N ′, and true anywhere else on N ′ (i.e., on the part of N ′ corresponding to the R−1a (S\nN) part of M). (We do not change the value of other propositional letters on N ′.)\nBelow, M |p is the restriction of M to the set of states satisfying p.\nProposition 13 Given Ms a Nt, there is a N ′ t and some p ∈ P such that Ms ≃ p N ′t and N ′t |p is identical to Nt except for maybe the value of p. ⊣\nProof Clearly, in Lemma 12, N ′t |R ′′ ≃ N ′t |p. The model restriction gets rid of the the SM− part of N ′, so we now have that N ′t |p is identical to (and not merely bisimilar to) Nt except for maybe the value of p.\nIn Section 4.3 we build upon this semantic result by translating the logic with refinement quantifiers into the logic with bisimulation quantifiers plus relativization of formulas."
    }, {
      "heading" : "3.4 Refinement and action models",
      "text" : "We recall another important result connecting structural refinement to action model execution [9]. For full details, see [55]. An action model M = (S,R, pre) is like a model M = (S,R, V ) but with the valuation replaced by a precondition function pre : S → L (for a given language L). The elements of S are called action points. A restricted modal product (M ⊗M) consists of pairs (s, s) such that Ms |= pre(s), the product of accessibility relations namely such that ((s, s), (t, t)) ∈ Ra iff (s, t) ∈ Ra and (s, t) ∈ Ra, and keeping the valuation of the state in the pair: (s, s) ∈ V (p) iff s ∈ V (p). A pointed action model Ms is an epistemic action.\nProposition 14 [55, Prop. 4, 5] The result of executing an epistemic action in a pointed model is a refinement of that model. Dually, for every refinement of a finite pointed model there is an epistemic action such that the result of its execution in that pointed model is a model bisimilar to the refinement. ⊣\nIt is instructive to outline the proof of these results. Given pointed model Ms and epistemic action Ms, the resulting (M ⊗M)(s,s) is a refinement of Ms by way the relation R consisting of all pairs (t, (t, t)) such that Mt |= pre(t). Some states of the original model may get lost in the modal product, namely if there is no action whose precondition can be executed there. But all ‘surviving’ (state,action)-pairs simply can be traced back to their first argument: clearly a refinement.\nFor the other direction, construct an epistemic action Ms′ that is isomorphic to a given refinement Ns′ of a model Ms, but wherein valuations (determining the value of propositional variables) in states t ∈ N are replaced by preconditions for action execution\nof the corresponding action points (also called) t. Precondition pre(t) should be satisfied in exactly those states s ∈ M such that (s, t) ∈ R, where R is the refinement relation linking Ms and Ns′. Now in a finite model, we can single out states (up to bisimilarity) by a distinguishing formula [13]. One then shows that (M ⊗M, (s, s′)) can be bisimulationcontracted to Ns′. It is unknown if the finiteness restriction can be lifted, because the existence of distinguishing formulas plays a crucial part in the proof.\nExample 4.2 presents an action model and its execution in an initial information state, and we will there continue our reflections on the comparison of the frameworks."
    }, {
      "heading" : "3.5 Modal specifications refinement",
      "text" : "Modal specifications are classic, convenient, and expressive mathematical objects that represent interfaces of component-based systems [36, 44, 45, 46, 4, 49]. Modal specifications are deterministic automata equipped with transitions of two types: may and must . The components that implement such interfaces are deterministic automata; an alternative language-based semantics can therefore be considered, as presented in [44, 45]. Informally, a must-transition is available in every component that implements the modal specification, while a may-transition need not be. Modal specifications are interpreted as logical specifications matching the conjunctive ν-calculus fragment of the µ-calculus [20]. In order to abstract from a particular implementation, an entire theory of modal specifications has been developed, which relies on a refinement preorder, known as modal refinement. However, although its definition is close to our definition of refinement, the two notions are incomparable: there is no way to interpret may and must as different agents (agent a and another agent b 6= a have clearly independent roles in the semantics of a-refinement), because ‘must’ is a subtype of ‘may’."
    }, {
      "heading" : "4 Refinement modal logic",
      "text" : "In this section we present the refinement modal logic, wherein we add a modal operator that we call a refinement quantifier to the language of multi-agent modal logic, or to the language of the modal µ-calculus. From prior publications [55, 56] refinement modal logic is known as ‘future event logic’. In that interpretation different 2a operators stand for different epistemic operators (each describing what an agent knows), and refinement modal logic is then able express what informative events are consistent with a given information state. However, here we take a more general stance.\nWe list some relevant validities and semantic properties, and also relate the logic to well-known logical frameworks such as bisimulation quantified modal logic (by way of relativization), and dynamic epistemic logics."
    }, {
      "heading" : "4.1 Syntax and semantics of refinement modal logic",
      "text" : "The syntax and the semantics of refinement modal logic are as follows.\nDefinition 15 (Languages L∀ and L µ ∀ ) Given a finite set of agents A and a countable set of propositional atoms P , the language L∀ of refinement modal logic is inductively defined as\nϕ ::= p | ¬ϕ | (ϕ ∧ ϕ) | 2aϕ | ∀aϕ\nwhere a ∈ A and p ∈ P . Similarly, the language Lµ∀ of refinement µ-calculus has an extra inductive clause µx.ϕ, where X is the set of variables and x ∈ X.\nϕ ::= x | p | ¬ϕ | (ϕ ∧ ϕ) | 2aϕ | ∀aϕ | µx.ϕ ⊣\nWe write ∃aϕ for ¬∀a¬ϕ. For a subset {a1, . . . , an} = B ⊆ A of agents we introduce the abbreviation ∃Bϕ for ∃a1 . . .∃anϕ (in any order), where we write ∃ϕ for ∃Aϕ, and similarly for ∀B and ∀. (So in the single-agent version we are also entitled to write ∀ and ∃.)\nNote the two differences between bisimulation quantifiers ∀̃p and the refinement quantifier ∀. The former we write with a ‘tilde’-symbol over the quantifier. The latter (and also ∀a) has no variable. A refinement quantifier can be seen as implicitly quantifying over a variable, namely over a variable that does not occur in the formula ϕ that it binds (nor should it occur in a formula of which ∃ϕ is a subformula). Section 4.3 will relate bisimulation quantification to the refinement operator.\nDefinition 16 (Semantics of refinement) Assume a model M = (S,R, V ).\nMs |= ∀aϕ iff for all M ′ s′ : Ms a M ′ s′ implies M ′ s′ |= ϕ\nThe set of validities of L∀ is the logic RML (refinement modal logic) and the set of validities of Lµ∀ is the logic RML µ (refinement µ-calculus).4 ⊣\nIn other words, ∀aϕ is true in a pointed model iff ϕ is true in all its a-refinements. Typical model operations that produce an a-refinement are: blowing up the model (to a bisimilar model) such as adding copies that are indistinguishable from the current model and one another, and removing pairs of the accessibility relation for the agent a (or, alternatively worded: removing states accessible only by agent a). In the final part of this section we relate these semantics to the well-known frameworks action model logic and bisimulation quantified logic (and see also [55]).\nProposition 17 (Bisimulation invariance) Refinement modal logic and refinement µcalculus are bisimulation invariant. ⊣\nProof Bisimulation invariance is the following property: given Ms ≃ Nt and a formula ϕ, then Ms |= ϕ iff Nt |= ϕ. If the logic has operators beyond the standard modalities 2a, this property does not automatically follow from bisimilarity.\nFor refinement modal logic bisimulation invariance is straightforward, noting that 2a is bisimulation invariant, and that µx is bisimulation invariant. The new operator ∀a is\n4As is usual in the area, we will continue to use the term ‘logic’ in a general sense, beyond that of a set of validities.\nbisimulation invariant, because a-refinement is transitive and bisimulation is just a specific type of a-refinement. Formally, let Ms ≃ Nt, and Ms |= ∀aϕ, we have to prove that Nt |= ∀aϕ. Let Ou be arbitrary such that Nt a Ou. From Ms ≃ Nt follows Ms a Nt. From Ms a Nt and Nt a Ou follows by Proposition 2 that Ms a Ou. From Ms |= ∀aϕ and Ms a Ou follows Ou |= ϕ. As Ou was arbitrary, we therefore conclude Nt |= ∀aϕ. The reverse direction is symmetric.\nThe following result justifies our notation ∃B for sets of agents.\nProposition 18 For all agents a, b, |= ∃a∃bϕ ↔ ∃b∃aϕ. ⊣\nProof Let Ms be given and let Mt and Mu be such that Ms a Mt and Mt b Mu. We have that Ms( a ◦ b)Mu iff Ms {a,b} Mu iff Ms( b ◦ a)Mu. (See Proposition 3.)\nProposition 19 The following are validities of RML.\n• ∀aϕ → ϕ (reflexivity)\n• ∀aϕ → ∀a∀aϕ (transitivity)\n• ∃a(ϕ ∨ ψ) ↔ (∃aϕ ∨ ∃aψ) and ∀a(ϕ ∧ ψ) ↔ (∀aϕ ∧ ∀aψ)\n• ∃a∀aϕ → ∀a∃aϕ (Church-Rosser)\n• ∃a3aϕ ↔ 3a∃aϕ ⊣\nProof The first three items directly follow from Proposition 2. The trivial refinement is an a-refinement; composition of two refinements is a refinement; and indeed it satisfies the Church-Rosser property. The fourth item directly follows from the semantics; consider the diamond form of the equivalence: the right-to-left direction is trivial, for the left-to-right direction note that if ϕ ∨ ψ is true in some refinement of a given model, then ϕ is true or ψ is true in that refinement, so ∃aϕ is true or ∃aψ is true in the given model.\nFor the fourth, from left to right: let Ms be such that Ms |= ∃a3aϕ, and let M ′ s′ and\nt′ ∈ s′R′a be such that Ms a M ′ s′ , M ′ s′ |= 3aϕ, and M ′ t′ |= ϕ. Because of back, there is a t ∈ sRa such that Mt a M ′ t′ . Therefore Mt |= ∃aϕ and thus Ms |= 3a∃aϕ.\nFrom right to left: let Ms be such that Ms |= 3a∃aϕ, and let t ∈ sRa and M ′ t′ be such\nthat Mt a M ′ t′ , Mt |= ∃aϕ, and M ′ t′ |= ϕ. Consider the model N with point s that is the disjoint union of M and M ′ except that: all outgoing a-arrows from s in M are removed (all pairs (s, t) ∈ Ra), a new a-arrow links s to t\n′ in M ′ (add (s, t′) to the new Ra). Then Ns is an a-refinement of Ms that, obviously, satisfies 3aϕ, so Ms satisfies ∃a3aϕ. (This construction is typical for refinement modal logic semantics. It will reappear in various more complex forms later, e.g., in the soundness proof of the axiomatization RML.)\nThe semantics of refinement modal logic is with respect to the class K of all models (for a given set of agents and atoms). If we restrict the semantics to a specific model class only, we get a very different logic. For example ∃2⊥ is a validity in RML: just remove all access. But in refinement epistemic logic, interpreted on S5 models, this is not a validity: seriality of models must be preserved in every refinement. See [56, 27]."
    }, {
      "heading" : "4.2 Examples",
      "text" : "Change of knowledge Given are two agents that are uncertain about the value of a fact p, and where this is common knowledge, and where p is true. Both accessibility relations are equivalence relations, so the epistemic operators model the agents’ knowledge. An informative event is possible after which a knows that p but b does not know that; this is expressed by\n∃a(2ap ∧ ¬2b2ap)\nIn Figure 2, the initial state of information is on the left, and its refinement validating the postcondition is on the right. In the visualization the actual states are underlined. If states are accessible for both a and b we have labelled the (single) arrow with ab.\nOn the left, the formula ∃(2ap∧¬2b2ap) is true, because 2ap∧¬2b2ap is true on the right. On the right, in the actual state there is no alternative for agent a (only the actual state itself is considered possible by a), so 2ap is true, whereas agent b also considers another state possible, wherein agent a considers it possible that p is false. Therefore, ¬2b2ap is also true in the actual state on the right.\nThe model on the right in the figure is neither an a-refinement of the model on the left, nor a b-refinement of it, but an {a, b}-refinement.\nRecalling Section 3.4 on action models, a refinement of a pointed model can also be obtained by executing an epistemic action (Proposition 14). Therefore, we should be able to see the refinement in this example as produced by an epistemic action. This is indeed the case. The epistemic action consists of two action points t and p, they can be distinguished by agent a but not by agent b. What really happens is p; it has precondition p. Agent b cannot distinguish this from t with precondition ⊤.\nThe execution of this action is depicted in Figure 3. The point of the structure is the one with precondition p: in fact, a is learning that p, but b is uncertain between that action and the ‘trivial’ action wherein nothing is learnt. The trivial action has precondition ⊤. It can be executed in both states of the initial model. The actual action can only be executed in the state where p is true. Therefore, the resulting structure is the refinement with three states.\nAction models can also be added as primitives to the multi-agent modal logical language and are then interpreted with a dynamic modal operator — similar to automata-PDL. To get a well-defined logical language, the set of action model frames needs to be enumerable, and therefore such action models must be finite. Thus we get action model logic. We now recall the result in Proposition 14 that on finite models every refinement corresponds to the execution of an action model and vice versa (where the action model constructed from a given refinement may be infinite), but that it is unknown if that finiteness restriction can be lifted. If that result can be generalized, that would be of interest, as that would suggest that refinement modal logic is equally expressive as action model logic with quantification over action models. If these logics were equally expressive, action model logic with quantification would be decidable—a surprising fact, given that public announcement logic with quantification over public announcements (singleton action models) is undecidable [23].\nSoftware verification and design Consider a class of discrete-event systems, whose elements represent devices that interact with an environment. Each device is described by means of actions c and u, respectively called ‘controllable’ and ‘uncontrollable’ actions. Given an expected property described by some formula ϕ, say in Lµ, we use refinement quantifiers to express several classic verification/synthesis problems. We let 2ϕ stand for 2cϕ ∧ 2uϕ.\nThe the control problem [48], known as the question “is there a way to control actions c of the system S so that property ϕ is guaranteed?”, can be expressed in L∀ by wondering whether\nS |= ∃cϕ .\nThemodule checking problem [33] is the problem of determining whether an open system satisfies a given property. In other words, whether the property holds when the system is composed with an arbitrary environment. Let us say that action c is an abstract action that denotes internal ones, while action u abstracts all external actions, i.e. actions performed by the environment. Also, assume there is an atomic proposition e that distinguishes states where it is the turn of the system to act (thus only action c is available) from states where it\nis the turn of the environment (thus only action u is available). In this setting, we answer positively to the module checking problem iff S |= ∀uϕ. As arbitrary environments are too permissive, we may force hypotheses such as restricting to non-blocking environments: the property can be captured by the Lµ-formula NonBlockingEnv := νx.(e ⇒ 3u⊤) ∧ 2x, which formally says that it is always the case (νx.(....) ∧ 2x) that whenever in an environment state, there is an outgoing transition from that state (e ⇒ 3u⊤). Now, by ‘guarding’ the universal quantification over all u-refinements (i.e. all environments) with the NonBlockingEnv assumption, the statement becomes\nS |= ∀u(NonBlockingEnv ⇒ ϕ)\nThe generalized control problem is the combination of the two previous problems, by questioning the existence of a control such that the controlled system satisfies the property in all possible environments. This is expressed by wondering whether\nS |= ∃c∀u(NonBlockingEnv ⇒ ϕ) .\nA last example is borrowed from protocol synthesis problems. Consider a specification, MUTEX, of a mutual exclusion protocol involving processes 1, 2, . . . k, and some property ϕ specified in Lµ. Now we may ask if we can find a refinement of MUTEX that satisfies ϕ but also such that if process i is in the critical section (csi) at time n + 1, then this is known at time n. This is expressed as\nMUTEX |= ∃[AG(3csi ⇒ 2csi) ∧ ϕ]\nwhere AG is the CTL-modality, which is defined in Lµ as AG(ψ) ≡ νx.ψ∧2x and meaning that this is true at any time. The refinement consists in moving the nondeterministic choices forward, so that a fork at time n becomes a fork at time n − 1 with each branch having a single successor at time n, as depicted in Figure 4."
    }, {
      "heading" : "4.3 Refinement quantification is bisimulation quantification plus",
      "text" : "relativization\nIn Section 3.3 we presented a semantic perspective of refinement as bisimulation followed by model restriction, or, alternatively and equivalently, as a restricted bisimulation, namely except for some propositional variable, followed by a model restriction to that variable. We now lift this result to a corresponding syntactic, logical, perspective of the refinement quantifier as a bisimulation quantifier followed by relativization.\nMore precisely, in this section we will show that a refinement formula ∃aϕ is equivalent to a bisimulation quantification over a variable not occurring in ϕ, followed by a (nonstandard) relativization for that agent to that variable, for which we write ∃̃qϕ(a,q) (to be defined shortly). For refinement for the set of all agents (recall that we write for A, and ∃ for ∃A) we can expand this perspective to even more familiar ground: a refinement formula ∃ϕ is equivalent to a bisimulation quantification over a variable not in ϕ followed\nby (standard) relativization to that variable: ∃̃qϕq. These results immediately clarify in what sense the refinement modality constitutes ‘implicit’ quantification, namely over a variable not occurring in the formula bound by it.\nFor the syntactic correspondence we first introduce the notion of relativization (for settings in modal logic, see [53, 39]). We propose a definition of relativization that may be considered non-standard for several reasons. Firstly, it is relativization not merely to a propositional variable but also for a given agent only. The standard definition is then the special case of relativization to that variable for all agents (we will prove that consecutive relativization to the same variable for two different agents is commutative, in other words, order independent). Secondly, the relativization that we propose corresponds in the semantics to arrow elimination and not to state elimination (in other words, it does not correspond to submodel restriction). From the modal logical literature, the approach in [39] is arrow-eliminating but that in [53] is state-eliminating.\nThe arrow-eliminating relativization need only be done in accessible states but not in the actual state (e.g., the relativization of a variable q to a variable p is that same variable q and not p ∧ q).\nThe difference between state-eliminating relativization and arrow-eliminating relativization is similar to the difference between state-eliminating public announcement semantics [43, 9] and arrow-eliminating public announcement semantics [32, 24], in the area of dynamic epistemic logic. As our relativization is with respect to a given agent, we have no option but to use arrow-eliminating relativization.\nGiven our purpose to translate refinement modal logic into bisimulation quantified modal logic, we also expand the definition of relativization to include quantifiers. This definition will then be used in Section 6.\nDefinition 20 (Relativization) Relativization •(a,p) : L∀̃ → L∀̃ to propositional variable\np for agent a ∈ A is defined as follows.\nq(a,p) = q (¬ϕ)(a,p) = ¬ϕ(a,p) (ϕ ∧ ψ)(a,p) = ϕ(a,p) ∧ ψ(a,p) (2aϕ) (a,p) = 2a(p → ϕ\n(a,p)) (2bϕ) (a,p) = 2bϕ (a,p) for b 6= a (∀̃qϕ)(a,p) = ∀̃qϕ(a,p) for q 6= p (∀̃pϕ)(a,p) = ∀̃qϕ[q\\p](a,p) choose q that does not occur in ϕ ⊣\nLemma 21 Let Ms be a model with accessibility function R and R ′ a ⊆ Ra such that: (t, t′) ∈ R′a iff Mt′ |= p. Then Ms |= ϕ (a,p) if and only if Ms|R ′ a |= ϕ. ⊣\nProof The proof is by induction on the structure of ϕ.\n• Ms |= q (a,p) ⇔\nMs |= q ⇔ propositional variables do not change value Ms|R ′ a |= q\n• The clauses for negation and conjunction are elementary.\n• Ms |= (2aϕ) (a,p) ⇔\nMs |= 2a(p → ϕ (a,p)) ⇔ for all t ∈ sRa : Mt |= p → ϕ (a,p) ⇔ for all t ∈ sRa : Mt |= p implies Mt |= ϕ (a,p) ⇔ I.H. for all t ∈ sRa : Mt |= p implies Mt|R ′ a |= ϕ ⇔ t ∈ sRa and t |= p iff t ∈ sR ′ a for all t ∈ sR′a : Mt|R ′ a |= ϕ ⇔ Ms|R ′ a |= 2aϕ\n• Ms |= (2bϕ) (a,p) ⇔\nMs |= 2bϕ (a,p) ⇔ for all t ∈ sRb : Mt |= ϕ (a,p) ⇔ I.H. for all t ∈ sRb (in Mt) : Mt|R ′ a |= ϕ ⇔ sRb in M equals sRb in M |R ′ a for all t ∈ sRb (in Mt|R ′ a) : Mt|R ′ a |= ϕ ⇔ Ms|R ′ a |= 2bϕ\n• For a more natural argument we take the existential quantifier instead of the universal quantifier. First, observe that:\nMs |= (∃̃qϕ) (a,p) ⇔ Ms |= ∃̃qϕ (a,p) ⇔ there is an Nt ≃ q Ms : Nt |= ϕ\n(a,p) ⇔ I.H. there is an Nt ≃ q Ms : Nt|R ′′ a |= ϕ where R ′′ a ⊆ R N a s.t. (u, u ′) ∈ R′′a iff Mu′ |= p\nWe also have that, by definition:\nMs|R ′ a |= ∃̃qϕ ⇔ there is an N ′t′ ≃ q Ms|R ′ a : N ′ t′ |= ϕ\nIt remains to show that the two final statements in these chains of equivalences are also equivalent.\nFrom left to right is easy. If R : Nt ≃ q Ms, then also R : Nt|R ′′ a ≃ q Ms|R ′ a. In N and M we remove all a-arrows to ¬p states; and if it is already a bisimulation, then the forth and back requirements still hold for fewer pairs in the accessibility relation for a. So we can take N ′t′ = Nt|R ′′ a. From right to left is not easy. Let us first explain this informally. Given that N ′t′ ≃ q Ms|R ′ a, the part of M that is inaccessible from Ms|R ′ a (i.e., not in the s-generated submodel) may not be bisimilar to anything in N ′. This is problematic, because we need to transform N ′t′ to some Nt in a way that establishes a q restricted bisimulation between Nt and all of Ms. Fortunately, the transformation can be an extension of N ′t′ , wherein we uniformly treat states in that inaccessible part of M and other states of M : we do not need to be economic in our construction. These are the details.\nLetR : N ′t′ ≃ q Ms|R ′ a be the restricted bisimulation. To be explicit, letM = (S,R, V ) and let N ′ = (S ′, R′, V ′). Consider Sap = {u ∈ SM | ∃v ∈ S, (v, u) ∈ Ra \\ R ′ a}. For each u ∈ Sap we need an exact copy Mu of M (let Mu = (Su, Ru, V u)) in our construction. We now define N = (SN , RN , V N) as follows:\n– SN = S ′ ∪ ⋃ {Su | u ∈ Sap};\n– for all b 6= a, RNb = R ′ b ∪ ⋃ {Rub | u ∈ S ap}; – RNa = R ′ a ∪ ⋃ {Rua | u ∈ S ap} ∪ {(v′, u) | (v′, v) ∈ R and (v, u) ∈ Ra \\R ′ a}; – for all p ∈ P , V N (p) = V ′(p) ∪ ⋃ {V u(p) | u ∈ Sap}.\nNow take t = t′, and let R′′a as before be restriction of R N a to pairs (u, u ′) ∈ RNa such that u′ satisfies p. It is now immediate that Nt ≃ q Ms and therefore also Nt|R ′′ a |= ϕ.\n• The other clause for the universal quantifier starts with a renaming operation (that equally applies to the existential quantifier), and then proceeds as in the previous clause.\nAgent relativization relates as expected to the standard notion of relativization (for the set of all agents simultaneously). This is because relativization to different variables for different agents is commutative.\nLemma 22 Let ϕ ∈ L∀̃. Then (ϕ (a,p))(b,q) = (ϕ(b,q))(a,p). ⊣\nProof By induction on the structure of ϕ. The non-trivial cases are 2aϕ, 2bϕ (follows dually), ∀̃pϕ, and ∀̃qϕ (also follows dually). Note that (a, p)-relativization distributes over implication.\n• ((2aϕ) (a,p))(b,q) ⇔\n(2a(p → ϕ (a,p)))(b,q) ⇔ 2a(p → ϕ (a,p))(b,q) ⇔ 2a(p (b,q) → (ϕ(a,p))(b,q)) ⇔ I.H., and clause for variables 2a(p → (ϕ (b,q))(a,p)) ⇔ (2aϕ (b,q))(a,p) ⇔ ((2aϕ) (b,q))(a,p)\n• ((∀̃pϕ)(a,p))(b,q) ⇔ choose r 6= q (or else, yet another step) (∀̃rϕ[r\\p](a,p))(b,q) ⇔ ∀̃r(ϕ[r\\p](a,p))(b,q) ⇔ I.H. ∀̃r(ϕ[r\\p](b,q))(a,p) ⇔ substitution of other variables than q ∀̃r(ϕ(b,q)[r\\p])(a,p) ⇔ (∀̃pϕ(b,q))(a,p) ⇔ ((∀̃pϕ)(b,q))(a,p)\nGiven Lemma 22, we may view a nesting of relativizations (. . . (ϕ(a1,p)) . . .(an,p)) as a relativization ϕ({a1,...,an},p) for the set of agents {a1, . . . , an}. Furthermore, for ϕ\n(A,p) we can write ϕp: the usual relativization for all agents simultaneously.\nTo make the syntactic correspondence we now introduce a translation.\nDefinition 23 The translation t : L∀ → L∀̃ is defined by induction on ϕ ∈ L∀. All clauses except ∀aϕ are trivial.\nt(p) = p t(¬ϕ) = ¬t(ϕ) t(ϕ ∧ ψ) = t(ϕ) ∧ t(ψ) t(2aϕ) = 2at(ϕ) t(∀aϕ) = ∀̃p t(ϕ) (a,p) where p does not occur in ϕ ⊣\nExample 24\nt(∃a∃br) = ∃̃p t(∃br) (a,p) = ∃̃p(∃̃p t(r)(b,p))(a,p) = ∃̃p(∃̃p r(b,p))(a,p) = ∃̃p(∃̃p r)(a,p) = ∃̃p∃̃q r(a,q) = ∃̃p∃̃q r ⊣\nProposition 25 Let ϕ ∈ L∀. Then ϕ is equivalent to t(ϕ). ⊣\nProof In the proposition we allowed ourselves a slight abuse of language: it means that, given any Ms, the value of ϕ in the semantics for refinement modal logic is equivalent to the value of t(ϕ) in the semantics for bisimulation quantified modal logic. The proposition\nfollows from Lemma 12, Lemma 21 and Def. 23. We show the case ∀aϕ of the inductive proof—and to suit the intuition we take the existential quantifier ∃a.\nMs |= ∃aϕ iff there is an M ′s′ such that Ms a M ′ s′ and M ′ s′ |= ϕ iff (I.H.) there is an M ′s′ such that Ms a M ′ s′ and M ′ s′ |= t(ϕ) iff (Lemma 12) there is an N ′t′ with R ′′ a ⊆ R ′ a (restr. to p true) s.t. Ms ≃ p N ′t′ and N ′ t′ |R ′′ a |= t(ϕ) iff (Lemma 21) there is an N ′t′ such that Ms ≃ p N ′t′ and N ′ t′ |= t(ϕ) (a,p) iff Ms |= ∃̃p t(ϕ) (a,p) iff Ms |= t(∃aϕ).\nThis corollary makes the characteristic cases of Proposition 25 stand out.\nCorollary 26 Consider ∃ϕ with ϕ ∈ L (i.e., ∃-free). Then\n• a-refinement is bisimulation quantification plus a-relativization: ∃aϕ is equivalent to ∃̃pϕ (a,p);\n• refinement is bisimulation quantification plus relativization: ∃ϕ is equivalent to ∃̃pϕp. ⊣\nIn the logic of public announcements, the latter is written as: ∃ϕ is equivalent to ∃̃p〈p!〉ϕ."
    }, {
      "heading" : "4.4 Alternating refinement relations",
      "text" : "Alternating transition systems (ATS) were introduced [3] to model multi-agent systems, where in each move of the game between the agents of an ATS, the choice of an agent at a state is a set of states and the successor state is determined by considering the intersection of the choices made by all agents. A notion of a-alternating refinement was introduced to reflect a refined behavior of agent a while keeping intact the behavior of the others. When restricting to turn-based ATS where only one agent plays at a time (concurrent moves are also allowed in the full setting), a-alternating refinement amounts to requiring ‘forth’ for all b ∈ A\\{a} as we do, but ‘back’ just for agent a. As a consequence, an a-refinement is a particular a-alternating refinement. A logical characterization of a-alternating refinement has been proposed (it essentially relies on the modality ∃a combined with the linear time temporal logic LTL) in the sense that if an ATS S ′ a-refines an ATS S, every formula true in S ′ is also true in S. Notice however that the operator ∃a has a more restricted semantics than the one we propose, since the quantification does not range over all possible refinements of the structure but only over refinements obtained by pruning the unraveling\nof the ATS. Soon after, the more general setting of alternating-time temporal logics [2] considered universal and existential quantifications over a-refinements, for arbitrary a, combined with LTL formulas. It is worthwhile noticing that the quantifiers still range over particular refinements, and always in the original structure. As a consequence, the language cannot express the ability to nest refinements for different agents. This is easily done in our language L∀, as the formula ∃a(2bp ∧ 3a(∃b2ap)) exemplifies. This formula tells us that one of the choices that a can make, results in b knowing p and a contemplating a subsequent choice by b that makes her to get to know p as well."
    }, {
      "heading" : "5 Axiomatization RML",
      "text" : "Here we present the axiomatization RML for the logic RML. We show the axioms and rules to be sound, we give example derivations, and this is followed by the completeness proof.\nThe axiomatization presented is a substitution schema, since the substitution rule is not valid. The substitution rule says that: if ϕ is a theorem, and p occurs in ϕ, and ψ is any formula, then ϕ[ψ\\p] is a theorem. Note that for all atomic propositions p, p → ∀p is valid, but the same is not true for an arbitrary formula, e.g. 3a⊤ → ∀3a⊤ is not valid, because after the maximal refinement there is no accessible state, so that 3a⊤ is then false even if it was true before. The logic RML is therefore not a normal modal logic.\nDefinition 27 (Axiomatization RML) The axiomatization RML consists of all substitution instances of the axioms\nProp All tautologies of propositional logic K 2a(ϕ → ψ) → 2aϕ → 2aψ R ∀a(ϕ → ψ) → ∀aϕ → ∀aψ\nRProp ∀ap ↔ p and ∀a¬p ↔ ¬p RK ∃a∇aΦ ↔ ∧ 3a∃aΦ\nRKmulti ∃a∇bΦ ↔ ∇b∃aΦ where a 6= b RKconj ∃a ∧ b∈B ∇bΦ b ↔ ∧ b∈B ∃a∇bΦ b\nand the rules MP From ϕ → ψ and ϕ infer ψ\nNecK From ϕ infer 2aϕ NecR From ϕ infer ∀aϕ\nwhere a, b ∈ A, p ∈ P , and B ⊆ A. If ϕ is derivable, we write ⊢ ϕ, and ϕ is called a theorem, as usual. The well-known axiomatization K for the logic K consists of the axioms Prop, K, and the rules MP and NecK. ⊣ In the definition, given Φ = {ϕ1, . . . , ϕn}, note that ∃a∇aΦ ↔ ∧\n3a∃aΦ stands for ∃a∇aΦ ↔ ∧ ϕ∈Φ 3a∃aϕ (see the technical preliminaries) and so for ∃a∇a{ϕ1, . . . , ϕn} ↔ 3a∃aϕ1 ∧ . . . ∧ 3a∃aϕn. The axiomatization RML is surprisingly simple given the complexity of the semantic definition of the refinement operator ∀; and given the well-known\ncomplexity of axiomatizations for logics involving bisimulation quantifiers instead of this single refinement quantifier. We note that while refinement is reflexive, transitive and satisfies the Church-Rosser property (Proposition 2, and Proposition 19), the corresponding modal axioms are not required. These properties are schematically derivable. First, we demonstrate soundness of RML.\nGiven the definitions of 2 and 3 in terms of cover, it may be instructive to see how the RK axiom works as a reduction principle for ∃2ϕ and ∃3ϕ—note that we need both, as there is no principle for ∃¬ϕ. For simplicity we do not label the operators with agents. We get:\n∃2ϕ ↔ ∃(∇{ϕ} ∨ ∇∅) ↔ ∃∇{ϕ} ∨ ∃∇∅\n(use RK) ↔ ∃∇{ϕ} ∨ ∧\n3∃∅ (empty conj. is true) ↔ ∃∇{ϕ} ∨ ⊤\n↔ ⊤\nand ∃3ϕ ↔ ∃∇{ϕ,⊤} (use RK) ↔ 3∃ϕ ∧ 3∃⊤\n↔ 3∃ϕ\nOne may wonder why we did not choose ∃2ϕ ↔ ⊤ and ∃3ϕ ↔ 3∃ϕ (we recall Proposition 19) as primitives in the axiomatization, as, after all, these are very simple axioms. They are of course valid, but the axiomatization would not be complete. The axiom RK is much more powerful, as this not merely allows Φ = {ϕ}, Φ = ∅, and Φ = {ϕ,⊤}, but any finite set of formulas."
    }, {
      "heading" : "5.1 Soundness",
      "text" : "Theorem 28 The axiomatization RML is sound for RML. ⊣\nProof As all models of L∀ are models of L, the schemas Prop, K and the rule MP and NecK are all sound. We deal with the remaining schemas and rules below.\nR Suppose that Ms is a model such that Ms |= ∀a(ϕ → ψ), and Ms |= ∀aϕ. Then for every Nt, where Nt a Ms, we have Nt |= ϕ → ψ, and also Nt |= ϕ. From Nt |= ϕ → ψ and Nt |= ϕ follows Nt |= ψ. As Nt was arbitrary model such that Nt a Ms, from that and Nt |= ψ follows Ms |= ∀aψ.\nRProp Let Ms and Nt be given such that Nt a Ms. By Definition 1 for the semantics of refinement, we have that s ∈ V M(p) if and only if t ∈ V N(p). Therefore Ms |= p iff Nt |= p,\nfor every Ms and Nt with Nt a Ms. Therefore Ms |= p iff Ms |= ∀ap for every Ms, i.e. |= p ↔ ∀ap. Similarly, for |= ¬p ↔ ∀a¬p, using that s 6∈ V M(p) if and only if t 6∈ V N(p).\nRK Suppose Ms is a model, where M = (S,R, V ), such that for some set Φ, Ms |= ∃a∇aΦ. Therefore, there is a model Nt a Ms such that Nt |= ∇aΦ—where N = (S Φ, RΦ, V Φ). Expanding the definition, we have that for every ϕ ∈ Φ there is some u ∈ tRΦa such that Nu |= ϕ. Also, because of back, for every such u ∈ tR Φ a there is some v ∈ sRa such that Nu a Mv. Combining these statements we have that for every ϕ ∈ Φ there is some v ∈ sRa such that Mv |= ∃aϕ, and thus Ms |= ∧ 3a∃aΦ.\nConversely, suppose that Ms |= ∧\n3a∃aΦ. Therefore, for every ϕ ∈ Φ there is some tϕ ∈ sRa such that Mtϕ |= ∃aϕ. Thus, for each ϕ ∈ Φ, there is some model N ϕ uϕ a Mtϕ , where Nϕ = (Sϕ, Rϕ, V ϕ), such that Nϕuϕ |= ϕ. Without loss of generality, we may assume that for all ϕ, ϕ′ ∈ Φ the models Nϕ and Nϕ ′\nare disjoint. We construct the model MΦ = (SΦ, RΦ, V Φ) such that:\nSΦ = {s′} ∪ S ∪ ⋃\nϕ∈Φ S ϕ\nRΦa = {(s ′, uϕ) | ϕ ∈ Φ} ∪Ra ∪ ⋃ ϕ∈ΦR ϕ a RΦb = {(s ′, t) | (s, t) ∈ Rb} ∪ Rb ∪ ⋃ ϕ∈Φ R ϕ b for b 6= a\nV Φ(p) = {s′} ∪ V (p) ∪ ⋃\nϕ∈Φ V ϕ(p) for p ∈ P\nwhere {s′} = {s′} if s ∈ V (p) and else {s′} = ∅. We can see that Ms a M Φ s′ , via the relation R Φ = {(s, s′)} ∪ I ∪ ⋃ ϕ∈Φ R ϕ where I is the identity on S and each Rϕ is the refinement relation corresponding to Mtϕ a N ϕ uϕ (see also [25]). Furthermore, for each t ∈ s′RΦa it is clear that M Φ t ≃ N ϕ uϕ for some ϕ, and thus MΦt |= ϕ, and so M Φ t |= ∨ Φ. Therefore MΦs′ |= 2a ∨ Φ. Finally, for each ϕ ∈ Φ there is some uϕ ∈ s′RΦa where M Φ uϕ |= ϕ, so for each ϕ ∈ Φ we have M Φ s |= 3aϕ, so we have\nMΦs′ |= ∧ 3aΦ. Combined, M Φ s′ |= 2a ∨ Φ and MΦs′ |= ∧ 3aΦ state that M Φ s′ |= ∇aΦ, and therefore Ms |= ∃a∇aΦ.\nRKmulti Suppose that Ms |= ∃a∇bΦ. Therefore, there is a model M ′ t a Ms such that M ′ t |= ∇bΦ—let the accessibility relation for agent b in M ′ be R′b. Expanding the definition, we have that for every ϕ ∈ Φ there is some u ∈ tR′b such that M ′ u |= ϕ. Also, because of back, for every such u ∈ tR′b there is some v ∈ sRb such that M ′ u a Mv. Combining these statements we have that for every ϕ ∈ Φ there is some v ∈ sRb such that Mv |= ∃aϕ, and thus Ms |= ∧ 3b∃aΦ. However, as forth also holds for agent b, the v ∈ sRb we could construct above are also all the states v accessible from s. Therefore we also have Ms |= 2b ∨ ∃aΦ, so together we get Ms |= ∇b∃aΦ.\nFor the converse direction, suppose that Ms |= ∇b∃aΦ. From the definition of ∇b it follows that Ms |= ∧ 3b∃aΦ. We now proceed in a similar way as in the case RK. From\nMs |= ∧ 3b∃aΦ it follows that for every ϕ ∈ Φ there is some t ϕ ∈ sRb such thatMtϕ |= ∃aϕ. Thus, for each ϕ ∈ Φ, there is some model Nϕuϕ a Mtϕ , where N ϕ = (Sϕ, Rϕ, V ϕ), such\nthat Nϕuϕ |= ϕ. Define the model M Φ = (SΦ, RΦ, V Φ) similar to the case RK, except that: the roles of a and b have been swapped, and the accessibility relation for all agents c different from a and b is defined as that for a.\nSΦ = {s′} ∪ S ∪ ⋃\nϕ∈Φ S ϕ\nRΦb = {(s ′, uϕ) | ϕ ∈ Φ} ∪Rb ∪ ⋃ ϕ∈Φ R ϕ b RΦc = {(s ′, t) | (s, t) ∈ Rc} ∪ Rc ∪ ⋃ ϕ∈ΦR ϕ c for c 6= b\nV Φ(p) = {s′} ∪ V (p) ∪ ⋃\nϕ∈Φ V ϕ(p) for p ∈ P\nwhere {s′} = {s′} if s ∈ V (p) and else {s′} = ∅ (RΦc also defines R Φ a , namely for c = a).\nWe can see that Ms a M Φ s′ , via the relation R\nΦ = {(s, s′)} ∪ I ∪ ⋃\nϕ∈Φ R ϕ where I\nis the identity on S and each Rϕ is the refinement relation corresponding to Mtϕ a N ϕ uϕ (see also [25]). Furthermore, for each t ∈ s′RΦb it is clear that M Φ t ≃ N ϕ uϕ for some ϕ, and thus MΦt |= ϕ, and so M Φ t |= ∨ Φ. Therefore MΦs′ |= 2b ∨ Φ. Finally, for each ϕ ∈ Φ there is some uϕ ∈ s′RΦb where M Φ uϕ |= ϕ, so for each ϕ ∈ Φ we have M Φ s |= 3bϕ, so we have\nMΦs′ |= ∧ 3bΦ. Combined, M Φ s′ |= 2b ∨ Φ and MΦs′ |= ∧ 3bΦ state that M Φ s′ |= ∇bΦ, and therefore Ms |= ∃a∇bΦ.\nRKconj The direction ∃a ∧ b∈B ∇bΦ b → ∧ b∈B ∃a∇bΦ b is merely a more complex form of pattern ∃a(ϕ ∧ ψ) → (∃aϕ ∧ ∃aψ) which is derivable similar to 3a(ϕ ∧ ψ) → (3aϕ ∧ 3aψ) in the modal logic K, using the axiom R in place of K.\nFor the other direction, suppose thatMs is such thatMs |= ∧ b∈B ∃a∇bΦ b, where B ⊆ A.\nWe need to show that Ms |= ∃a ∧ b∈B ∇bΦ b. To do this we follow the same strategy as for\nproving RK: we construct an a-refinement Nt of Ms, and show that Nt |= ∧ b∈B ∇bΦ b.\nWe begin by constructing the model Nt. Suppose that a ∈ B. Then we have Ms |= ∃a∇aΦ a, and by RK this implies that Ms |= ∧ 3a∃aΦ a. We also have that for every b ∈ B − {a}, Ms |= ∃a∇bΦ b, and by RKmulti this implies that Ms |= ∇b∃aΦ\nb, and by the definition of the cover operator, this implies that Ms |= ∧ 3b∃aΦ\nb. Hence for every b ∈ B and ϕ ∈ Φb, we have that 3b∃aϕ. (In other words, for some big set of formulas Ψ we have that Ms |= ∧ 3b∃aΨ.) At this stage it suffices to refer to the very similar construction in the soundness proof for axiom RK, from which, similarly to there, it follows that Nt |= ∧ b∈B ∇bΦ b.\nNecR If ϕ is a validity, then it is satisfied by every model, so for any model Ms, ϕ is satisfied by every model Nt a Ms, and hence every model Ms satisfies ∀aϕ.\nThe soundness of axiomRK is visualized in Figure 5. It depicts the interaction between refinement and modality involved in this axiom ∃a∇aΦ ↔ ∧ 3a∃aΦ, for the case that Φ = {ϕ1, ϕ2, ϕ3}. The single lines are modal accessibility, and the double lines the refinement relations. The solid lines are given, and the dashed lines are required. Accessibility relations for other agents than a are omitted. The picture on the left depicts the implication from left to right in the axiom, and the picture on the right depicts the implication from right\nto left. Note that the states satisfying ϕ2 and ϕ3 have the same origin u in M—the typical sort of duplication (resulting in non-bisimilar states) allowed when having back but not forth. Apart from u and t, state s in M has yet another accessible state v, that does not occur in the refinement relation: the other typical sort of thing when having back but not forth. Therefore, on the right side of the equivalence in axiom RK we only have ∧ 3a∃aΦ\nand we cannot guarantee that 2a ∨\n∃aΦ also follows from the left-hand side. The axiom RKmulti, defined as ∃a∇bΦ ↔ ∇b∃aΦ for a 6= b, says that refinement with respect to one agent does not interact with the modalities (the uncertainty, say) for another agent: the operators ∇b and ∃a simply commute. This in contrast to the axiom RK where on the right-hand side a construct 2a ∨ ∃aΦ is ‘missing’, so to speak. If it\nhad been 2a ∨ ∃aΦ∧ ∧ 3a∃aΦ, then we would have had ∇a∃aΦ, as in RKmulti but with a = b. The axioms RK and RKmulti are different, because in an a-refinement the condition forth is not required, whereas for other agents b forth is required. Given some refinement wherein we have a cover of Φ, so that at least one of Φ is necessary (the ∃a∇aΦ bit), for each of the covered states we can trace an origin before the refinement, because of back. But there may be more originally accessible states, so whatever holds in those origins, although it is all possible, is not necessary. So we have ∧ 3a∃aΦ, but we do not have 2a ∨ ∃aΦ. In contrast, when the agents are different, back and forth must hold for agent b in a refinement a witnessing the operator ∃a: for an a-refinement, back and forth must hold for all agents b 6= a. Figure 6 should further clarify the issue—compare this to Figure 5. The main difference between the figures is that there cannot now be yet another state v accessible from s but not ‘covered’ as the origin of one of the refined states. In Figure 5 what holds in t and u is not necessary for a, but in Figure 6 what holds in t and u is necessary for b."
    }, {
      "heading" : "5.2 Example derivations",
      "text" : "In these examples we also use ‘substitution of equivalents’, see Proposition 32, ahead.\nExample 29 ⊢ 3a⊤ → ∃a(3a⊤ ∧ (2ap ∨ 2a¬p)) ⊣\nIn an epistemic setting, where 2ap means that the agent knows p, and where (in S5 models) the condition 3a⊤ is always satisfied, this validity expresses that the agent can always find out the truth about p: if true, announce p to the agent (and announcement is a model restriction, and therefore a refinement), after which p is known by the agent to be true, and if false, announce that p is false, after which p is known to be false. This validity is indeed also a theorem of RML. For that, it suffices to derive the equivalent 3a⊤ → ∃a(∇a{p} ∨ ∇a{¬p}). In some cases several deductions have been combined into single statements, but this is restricted to cases of well-known modal theorems.\n⊢ 3a⊤ ↔ 3a(p ∨ ¬p) Prop,NecK,K ⊢ 3a(p ∨ ¬p) ↔ (3ap ∨ 3a¬p) Prop,NecK,K ⊢ 3ap → ∃a∇a{p} See below ⊢ 3a¬p → ∃a∇a{¬p} See below ⊢ 3ap → ∃a(∇a{p} ∨ ∇a{¬p}) Prop,NecR,R ⊢ 3a¬p → ∃a(∇a{p} ∨ ∇a{¬p}) Prop,NecR,R ⊢ 3a⊤ → ∃a(∇a{p} ∨ ∇a{¬p}) Prop,MP\nLines 3 and 4 of the derivation require the following derivation, where ϕ is a propositional formula (i.e., ϕ ∈ L0).\n⊢ ϕ ↔ ∃aϕ Proposition 34, ahead ⊢ 3aϕ ↔ 3a∃aϕ Prop,NecK,K ⊢ 3aϕ ↔ ∃a∇a{ϕ} RK[Φ = {ϕ}]\nExample 30 ⊢ (3ap ∧ 3bp ∧ 3a¬p ∧ 3b¬p) → ∃a(2ap ∧ ¬2bp) ⊣\nConsider the informative development described in Example 4.2: given an initial information state wherein agents a and b consider either value of p possible, a can be informed such that afterwards a believes that p but not b. This theorem formalizes that. In the following, let ϕ be (3ap ∧ 3bp ∧ 3a¬p ∧ 3b¬p).\n⊢ ϕ → 3ap ∧ 3b¬p Prop ⊢ ϕ → 3ap ∧∇b{¬p,⊤} Definition of ∇ ⊢ ϕ → 3a¬¬p ∧ ∇b{¬¬¬p,¬¬⊤} Prop ⊢ ϕ → 3a¬∀a¬p ∧ ∇b{¬∀a¬¬p,¬∀a¬⊤} RProp ⊢ ϕ → 3a∃ap ∧ ∇b{∃a¬p, ∃a⊤} Definition of ∃ ⊢ ϕ → ∃a∇a{p} ∧ ∇b{∃a¬p, ∃a⊤} RK ⊢ ϕ → ∃a∇a{p} ∧ ∃a∇b{¬p,⊤} RKmulti ⊢ ϕ → ∃a(∇a{p} ∧ ∇b{¬p,⊤}) RKconj ⊢ ϕ → ∃a(2ap ∧ 3ap ∧ 3b¬p) Definition of ∇ ⊢ ϕ → ∃a(2ap ∧ 3b¬p) Prop ⊢ ϕ → ∃a(2ap ∧ ¬2bp) Definition of 3"
    }, {
      "heading" : "5.3 Completeness",
      "text" : "Completeness is shown by a fairly but not altogether straightforward reduction argument: every formula in refinement modal logic is equivalent to a formula in modal logic. So it is a theorem, if its modal logical equivalent is a theorem. In the axiomatization RML we can observe that all axioms involving refinement operators ∃ are equivalences, except for R; however, ∃a(ϕ ∨ ψ) ↔ ∃aϕ ∨ ∃aψ is a derivable theorem. This means that by socalled ‘rewriting’ we can push the ∃ operators further inward into a formula, until we reach some expression ∃ϕ where ϕ contains no refinement operators. Now we come to the less straightforward part. Because there is a hitch: there is no general way to push a ∃ beyond a negation (or, for that matter, beyond a conjunction). For that, we use another trick, namely that all modal logical formulas are equivalent to formulas in the cover logic syntax, and that all those are equivalent to formulas in disjunctive form (see the introduction) in cover logic. Using that, once we reached some innermost ∃ϕ where ϕ contains no refinement operators, we can continue pushing that refinement operator downward until it binds a propositional formula only, and disappears in smoke because of the RProp axiom. Then, iterate this. All ∃ operators have disappeared in smoke. We have a formula in modal logic.\nFor a smooth argument we first give some general results, after which we apply the reduction argument and demonstrate completeness.\nDefinition 31 (Substitution of equivalents) An axiomatization satisfies substitution of equivalents if the following holds. Let ϕ1, ϕ2, ϕ3 ∈ L and p ∈ P . If ⊢ ϕ1 ↔ ϕ2 then ⊢ ϕ3[ϕ2\\p] ↔ ϕ3[ϕ1\\p]. ⊣\nProposition 32 The axiomatization RML satisfies substitution of equivalents. ⊣\nProof This can be shown by induction on ϕ3. All cases are standard. The case 2aϕ is shown by using an inductive hypothesis ⊢ ϕ[ϕ2\\p] ↔ ϕ[ϕ1\\p] and then successively applying NecK, K, and some elementary tautologies and applications of MP. (The required pattern is: from ⊢ x → y, to ⊢ 2(x → y), to ⊢ 2x → 2y. Then, similarly, for the other direction of the equivalence x ↔ y. Then, some more propositional steps to wind it up.) Whereas the case ∀aϕ is shown with the same inductive hypothesis but applying NecR and R instead of NecK and K.\nProposition 33\n1. ⊢ ∀a(ϕ ∧ ψ) ↔ ∀aϕ ∧ ∀aψ\n2. ⊢ ∃a(ϕ ∨ ψ) ↔ ∃aϕ ∨ ∃aψ\n3. ⊢ ∃a(ϕ ∧ ψ) → ∃aϕ ∧ ∃aψ ⊣\nProof Item 1. can be easily derived from R, NecR and MP, similarly to the way that in modal logic we derive ⊢ 2(ϕ ∧ ψ) ↔ 2ϕ ∧ 2ψ. Item 2. is the dual of item 1. and requires mere propositional reasoning. Item 3. can be derived using the tautologies ϕ∧ψ → ϕ and ϕ ∧ ψ → ψ, respectively, propositional reasoning, and R. (Alternatively, for Item 3., we can think of deriving its dual, with the crucial steps in the derivation that ϕ → ϕ ∨ ψ is a tautology, from which with R and MP we get ∀ϕ → ∀(ϕ ∨ ψ).)\nProposition 34\n1. ⊢ ∀aϕ ↔ ϕ for all propositional ϕ.\n2. ⊢ ∃aϕ ↔ ϕ for all propositional ϕ.\nProof We show ⊢ ∀aϕ ↔ ϕ for all propositional ϕ. 5 The proof of ⊢ ∃aϕ ↔ ϕ for all propositional ϕ is similar. For convenience in the proof we omit the agent label and write ∀.\nWe first show ⊢ ϕ → ∀ϕ. Assume that ϕ is in disjunctive normal form (i.e., for propositional logic, different from the disjunctive form, df, often used in this work). Formula ϕ therefore has the form ∨ γ∈Γ, where each formula γ is a conjunction of atoms or their\nnegation, for which we write, slightly abusing the language, γ = ∧\np∈γ p — where p = p if p is a conjunct of γ and p = ¬p if ¬p is a conjunct of γ. We now get the following. We omit trivial steps of chaining implications and applying MP. For readability we assume the ‘ϕ →’ part in some derived formulas.\n5Of course we do not have for all ϕ ∈ L∀ that ⊢ ∀aϕ ↔ ϕ. But we then still have ⊢ ∀ϕ → ϕ, or, dually, ⊢ ϕ → ∃ϕ. This can be easily shown by induction on the disjunctive form structure of a formula.\n⊢ ϕ → ∨\nγ∈Γ ∧ p∈γ p DNF of ϕ,Prop\n⊢ . . . ∨\nγ∈Γ ∧ p∈γ ∀p RProp\n⊢ . . . ∨ γ∈Γ ∀ ∧\np∈γ p R, NecR, and Prop. 33.1 (∀(ϕ ∧ ψ) ↔ ∀ϕ ∧ ∀ψ) ⊢ . . . ∀ ∨ γ∈Γ ∧ p∈γ p R, NecR, and tautology ϕ → ϕ ∨ ψ ⊢ ϕ → ∀ϕ DNF of ϕ\nFor the converse direction we convert ϕ to the conjunctive normal form for propositional formulas, i.e., ϕ is equivalent to ∧ γ∈Γ ∨ p∈γ p (where we now write p = p if p is a disjunct— not conjunct—of γ and p = ¬p if ¬p is a disjunct of γ).\n⊢ ∀ϕ → ∀ ∧\nγ∈Γ ∨ p∈γ p CNF of ϕ,Prop,NecR,R\n⊢ . . . ∧ γ∈Γ ∀ ∨ p∈γ p Prop. 33.1\n⊢ . . . ∧\nγ∈Γ ∨ p∈γ p ∗\n⊢ ∀ϕ → ϕ CNF of ϕ\nWe show why * holds by outlining the method and giving an example: write the conjunct∨ p∈γ p in implicative fashion, e.g., instead of p ∨ q ∨ ¬r ∨ s we write ¬p → ¬q → r → s. Then, applying NecR and R and MP repeatedly, we get first ∀(¬p → ¬q → r → s) and then ∀¬p → ∀¬q → ∀r → ∀s. Then, applying RProp, we get ¬p → ¬q → r → s, in other words, we have p ∨ q ∨ ¬r ∨ s back.\nProposition 35 ⊢ (ϕ ∧ ∃aψ) ↔ ∃a(ϕ ∧ ψ) for all propositional ϕ (and any ψ ∈ L∀). ⊣\nProof Proposition 33 demonstrated that ∃a(ϕ∧ψ) → ∃aϕ∧∃aψ from which, using Proposition 34.2, also follows ϕ∧∃aψ. For the other direction we first derive (∀aϕ∧∃aψ) → ∃a(ϕ∧ψ) by propositional means and applications of Nec and R. This goes as follows. For convenience of applying the available axioms, instead of (∀aϕ ∧ ∃aψ) → ∃a(ϕ ∧ ψ) use the equivalent form ∀a¬(ϕ∧ψ) → ∀aϕ → ∀a¬ψ. Now we observe that ¬(ϕ∧ψ) → ϕ → ¬ψ is a tautology and therefore derivable, applying NecR gets us ∀a(¬(ϕ ∧ ψ) → ϕ → ¬ψ) and successively applying R gets us ∀a¬(ϕ ∧ ψ) → ∀aϕ → ∀a¬ψ. Then, finally, we use that ∀aϕ ↔ ϕ (Proposition 34.1) and thus get (ϕ ∧ ∃aψ) → ∃a(ϕ ∧ ψ).\nWe now first show that every L∀ formula is logically equivalent to a L formula. We then show that if the latter is a theorem in K, the former is a theorem in RML.\nProposition 36 Every formula of L∀ is logically equivalent to a formula of L. ⊣\nProof Given a formula ψ ∈ L∀, we prove by induction on the number of the occurrences of ∃a in ψ (for any a ∈ A) that it is equivalent to an ∃a-free formula, and therefore to a formula ϕ ∈ L, the standard modal logic. The base is trivial. Now assume ψ contains n + 1 occurrences of ∃a-operators for some a ∈ A (so these may be refinement operators for different agents). Choose a subformula of type ∃aϕ of our given formula ψ, where ϕ is ∃b-free for any b ∈ A (i.e. choose an innermost ∃a). Let ϕ\n′ be a disjunctive formula that is equivalent to ϕ. We prove by induction on the structure of ϕ′ that ∃aϕ\n′ is logically equivalent to a formula χ without ∃a. There are two cases:\n• ∃a(ϕ ∨ ψ); • ∃a(ϕ0 ∧ ∧ b∈B ∇bΦ b) where ϕ0 is propositional, B ⊆ A, and each Φ b a set of dfs.\nIn the first case, apply Proposition 33.2, we get ∃aϕ ∨ ∃aψ, and then apply induction. In the second case, if B = ∅ we use that ∃aϕ0 ↔ ϕ0 (Proposition 34.2). If B 6= ∅, then from Proposition 35 follows that this is equivalent to ϕ0 ∧ ∃a ∧ b∈B ∇bΦ\nb, and we further reduce the right conjunct with one of the axioms RK (if B = {a}), RKmulti (if B = {b} with b 6= a), or RKconj (if |B| > 1), and apply induction again.\nThus we are able to push the refinement operators deeper into the formula until they eventually reach a propositional formula, at which point they disappear and we are left with the required ∃-free formula χ that is equivalent to ∃ϕ. Replacing ∃ϕ′ by χ in ψ gives a result with one less ∃-operator, to which the (original) induction hypothesis applies.\nProposition 37 Let ϕ ∈ L∀ be given and ψ ∈ L be equivalent to ϕ. If ψ is a theorem in K, then ϕ is a theorem in RML. ⊣\nProof Given a ϕ ∈ L∀, Proposition 36 gives us an equivalent ψ ∈ L. Assume that ψ is a theorem in K. We can extend the derivation of ψ to a derivation of ϕ by observing that all steps used in Proposition 36 are not merely logical but also provable equivalences — where we also apply Proposition 32 of substitution of equivalents.\nTheorem 38 The axiom schema RML is sound and complete for the logic RML. ⊣\nProof The soundness proof is given in Theorem 28, so we are left to show completeness. Suppose that ϕ ∈ L∀ is valid: |= ϕ. Applying Lemma 36 we know that there is some equivalent formula ψ ∈ L, i.e., not containing any refinement operator. As ϕ is valid, from that and the validity ϕ ↔ ψ it follows that ψ is also valid in refinement modal logic, and therefore also valid in the logic K (note that the model class is the same). From the completeness of K it follows that ψ is derivable, i.e. it is a theorem. From Proposition 37 it follows that ϕ is a theorem."
    }, {
      "heading" : "5.4 The single-agent case",
      "text" : "The axiomatization for the single-agent case is the unlabelled version of RML, minus the axioms RKmulti and RKconj.6 The single-agent axiomatization was presented in [56]. The completeness proof there is (slightly) different from the multi-agent case of the proof here. In [56] it is used that every refinement modal logical formula is equivalent to a formula in cover logic with the special syntax ϕ ::= ⊥ | ⊤ | ϕ ∨ ϕ | p ∧ ϕ | ¬p ∧ ϕ | ∇{ϕ, . . . , ϕ} [10, 34], plus induction on that form. (This syntax is of course very ‘disjunctive formula like’.) That proof was suggested by Yde Venema, as a shorter alternative to the proof with disjunctive forms.\n6It is clear that axiom RKmulti is not needed in the single-agent case, as this is for different agents. But axiom RKconj is also not necessary in the single-agent case. We recall that ∇aΦ∧∇aΨ is equivalent to ∇a((Φ ∧ ∨ Ψ) ∪ (Ψ ∧ ∨ Φ)), see page 6. So, we can assume that there are no conjunctions of cover formulas in the single-agent case."
    }, {
      "heading" : "5.5 Refinement epistemic logic",
      "text" : "Refinement modal logic RML is presented with respect to the class of all models. As mentioned in Section 4.1, by restricting the class of models that the logic is interpreted over, we may associate different meanings with the modalities. For example, the epistemic logic S5, a.k.a. the logic of knowledge, is interpreted over the model class S5, and the logic of belief KD45 is interpreted over the class KD45. Given any class of models C, the semantic interpretation of ∀ is given by:\nMs |= ∀aϕ iff for all M ′ s′ ∈ C : Ms a M ′ s′ implies M ′ s′ |= ϕ.\nThus we can consider various refinement epistemic logics. Although ∃2⊥ is a validity in RML (just remove all access) it is not so in the refinement logic of knowledge, interpreted on S5 models, because seriality of models must be preserved in every refinement. And therefore it is also not valid in the refinement logic of belief.\nOur axiomatization RML may not be sound for more restricted model classes. Let us consider the single-agent case, and the axiom\nRK ∃∇Φ ↔ ∧ 3∃Φ.\nFor example, in S5 we have that ∃∇{2p,¬2p} is inconsistent, but that 3∃2p∧3∃¬2p is consistent: you do not consider an informative development possible after which you both know and don’t know p at the same time. Therefore, axiom RK is invalid for that class.\nThe axioms replacing RK in refinement logic of knowledge and refinement logic of belief are, respectively:\nRS5 ∃∇Φ ↔ ( ∨ Φ ∧ ∧ 3Φ),\nand, for Φ 6= ∅,\nRKD45 ∃∇Φ ↔ ∧ 3Φ,\nwhere Φ is a set of purely propositional formulas. Now if apart from RS5 we also add the usual S5 axioms T, 4, and 5, we have a complete axiomatization for the refinement logic of knowledge. In the case of the refinement logic of belief, we add axioms D (for seriality), 4, and 5 and RKD45 to get a complete axiomatization. For details, see [27].\nA study of how various classes of models affect the properties of bisimulation quantified logics is given in [22]. Refinement epistemic logics are investigated in [27, 25]. In [25] a multi-agentKD45 axiomatization is also reported. (For multi-agent S5, see ‘Recent results’ in Section 8.)"
    }, {
      "heading" : "6 Axiomatization RMLµ",
      "text" : "In this section we give the axiomatization for refinement modal µ-calculus. We restrict ourselves to single-agent refinement modal µ-calculus. The axiomatization is an extension of the (single-agent) axiomatization RML for refinement modal logic.\nWe recall the definition of modal µ-calculus in the technical introductory Section 2. In [22, Lemma 2.43] a bisimulation quantifier characterization of fixed points is given. The characterization employs the universal modality which quantifies over all states in the model. Let L∀̃ be the language of bisimulation quantified modal logic with as well. First, observe that this impacts the semantics of bisimulation quantification. For two models to be bisimilar, it must now also be the case that every state in one model is bisimilar to a state in the other.\nWe can inductively define a truth-preserving translation t : Lµ 7→ L∀̃ . The crucial clauses are those for the fixed-point operators. The atoms p introduced in the translation are required not to occur in ϕ.\nt(νx.ϕ) is equivalent to ∃̃p(p ∧ (p → t(ϕ[p\\x])))\nt(µx.ϕ) is equivalent to ∀̃p( (t(ϕ[p\\x]) → p) → p)\nThe first equation captures the intuition of a greatest fixed point as a least upper bound of the set of states that are postfixed points of ϕ, whereas the second equation captures a least fixed point as the greatest lower bound of the set of states that are prefixed points of ϕ. From [15] we know that bisimulation quantifiers are also expressible in the modal µ-calculus, and thus these equivalences also hold in the modal µ-calculus.\nHaving these tools for modal µ-calculus at our disposition, let us now apply them in refinement modal µ-calculus. In order to demonstrate the soundness of the axiomatization defined below, we need to expand the relativization •p : L∀̃ → L∀̃ (Definition 20), singleagent version, to a version •p : L∀̃ → L∀̃ by including a clause for the universal modality:\n( ϕ)p = ϕp\nEmploying that expanded relativization we can expand the translation t : L∀ → L∀̃ (Definition 23) to a translation\nt : Lµ∀ → L∀̃\nby adding the two clauses above for fixed points (this explains why we also wrote t(•) there). This translation t remains truth-preserving (due to Proposition 25 and [22, Lemma 2.43]). We recall the crucial interaction of the translation and the relativization, namely that t(∃ϕ) is equivalent to ∃̃p t(ϕ)p. The translation plays an important role in the soundness proof: axioms are shown to be sound by showing that their translations are valid.\nDefinition 39 (axiomatization RMLµ) The axiomatization RMLµ is a substitution schema of the (single-agent) axioms and rules of RML along with the axiom and rule for the modal µ-calculus:\nF1 ϕ[µx.ϕ\\x] → µx.ϕ F2 From ϕ[ψ\\x] → ψ infer µx.ϕ → ψ\nand two new interaction axioms:"
    }, {
      "heading" : "Rµ ∀µx.ϕ ↔ µx.∀ϕ where ϕ is a df",
      "text" : "Rν ∀νx.ϕ ↔ νx.∀ϕ where ϕ is a df\nFor single-agent RML, see Definition 27 and Section 5.4. We recall that single-agent RML does not contain the axioms RKmulti and RKconj.\nWe emphasize that the interaction axioms have the important associated condition that the refinement quantification will only commute with a fixed-point operator if the fixed-point formula is a disjunctive formula."
    }, {
      "heading" : "6.1 Soundness",
      "text" : "The soundness proofs of Section 5.1 still apply and the soundness of F1 and F2 are well known [5], so we are left to show that Rµ and Rν are sound. In the proof we use the characterization of refinement quantification in terms of bisimulation quantification and relativization that was established in Proposition 25. We will also use the characterization of both fixed points in terms of bisimulation quantification as in the previous subsection.\nTheorem 40 The axioms Rµ and Rν are sound. ⊣\nProof The proof consists of two cases, Rµ and Rν .\nCase Rµ\nIt is more convenient in this proof to reason about the axiom in its contrapositive form: ∃νx.ϕ ↔ νx.∃ϕ. The proof demonstrates that t(∃νx.ϕ) is equivalent to t(νx.∃ϕ) in bisimulation quantified logic (with the universal modality). Using the translation and relativization equivalences above we have that, for any ϕ ∈ L∀:\nt(∃νx.ϕ) ⇔ ∃̃p t(νx.ϕ)p\n⇔ ∃̃p(∃̃q(q ∧ (q → t(ϕ[q\\x]))))p ⇔ ∃̃p∃̃q(q ∧ ( (q → t(ϕ[q\\x])))p) ⇔ ∃̃p∃̃q(q ∧ (q → t(ϕ[q\\x])p)) ⇔ ∃̃q∃̃p(q ∧ (q → t(ϕ[q\\x])p)) ⇔ ∃̃q(q ∧ ∃̃p (q → t(ϕ[q\\x])p)) ⇒ ∃̃q(q ∧ ∃̃p(q → t(ϕ[q\\x])p)) (∗) ⇔ ∃̃q(q ∧ (q → ∃̃p t(ϕ[q\\x])p))\n⇔ ∃̃q(q ∧ (q → t(∃ϕ[q\\x]))) ⇔ t(νx.∃ϕ)\nThis proof simply applies known validities of bisimulation quantifiers. Note that line (∗) is not an equivalence. The other direction holds if ϕ is a df . This we now prove.\nWe may assume w.l.o.g. that disjunctive formula νx.ϕ contains no free variables, i.e., ϕ is (also) a disjunctive formula with only the free variable x. We recall that in a disjunctive formula, a conjunction can only be between a purely propositional part and a cover modality part, and that fixed-point variables are not allowed in the propositional part (see Section 2). Importantly this means that propositional variable q (witnessing fixed-point variable x), that occurs in the formula (ϕ[q\\x])p, can only appear in a conjunction, if it appears in the scope of a cover operator within that conjunction. This has the following significant consequence:\nIf Ms |= ϕ[q\\x], where ϕ is a disjunctive formula, then there is a model Nu ≃ q Ms such that N ∗ u |= ϕ[q\\x] where N ∗ u is the restriction of Nu to states that are not successors of q states.\nThat is, whether or not Nu satisfies ϕ[q\\x] is invariant to any successors of states in V N ∗\n(q).7 To see this, we note that a disjunctive formula ϕ[q\\x] is true at Ms, if and only if there is some pointed model Nu that is bisimilar to Ms, and some minimal relation ρ between the states of SNu and subformulas of ϕ[q\\x] such that:\n1. u ρ ϕ[q\\x];\n2. if v ρ (ψ1 ∨ ψ2), then either v ρ ψ1 or v ρ ψ2 but not both;\n3. if v ρ (χ∧∇Φ), then Nv |= χ and for every successor v ′ of v there is a unique ψ ∈ Φ\nsuch that v′ ρ ψ, and for every ψ ∈ Φ, there is at least one successor v′ of v where v′ ρ ψ;\n4. if v ρ νy.ψ, then v ρ ψ[νy.ψ\\y].\nIt is clear that if such a relation exists then Nu |= ϕ. As q is replacing the fixed-point variable x (which can only appear in the scope of a cover operator), the minimality of ρ guarantees that if v ρ q, then there is no formula ψ 6= q such that v ρ ψ, and hence, for all successors v′ of v there is no formula ψ such that v′ ρ ψ. Consequently these successors do not impact the existence of the relation ρ, and thus do not affect whether or not Nu |= ϕ[q\\x].\nAn explicit construction for Nu can be given via the tableaux of Janin and Walukiewicz [30]. Using their tableaux [30, Def. 3.1], the concept of a marking [30, Def. 3.6] can be adapted to give the required model, Nu. This construction is important for the proof now to follow.\nSuppose Ms is any countable model such that Ms |= ∃̃q(q ∧ ∃̃p(q → t(ϕ[q\\x]) p)),\nwhere ϕ is a df . We would like to build some model Mωu such that\n• Mωu ≃ p,q Ms,\n• Mωu |= q ∧ (q → t(ϕ[q\\x]) p)\nWe inductively build a sequence of (pointed) models M iu = (S i, Ri, V i, u) such that\nM iu ≃ p,q Ms, and furthermore, the models M i are fixed up to a given set of states.\nDefinition 41 Suppose that Ms = (S,R, V, s) is a pointed tree like model (so for each t ∈ S, there is at most one t′ ∈ S such that (t′, t) ∈ R). Let T ⊆ S − {s}. The model Ms up to T (written Ms ↑ T ) is the model (S\n′, R′, V, s) where S ′ is the set of states that are not proper descendants of T and R′ = R ∩ (S ′ × S ′). ⊣\n7Throughout this proof we will assume that all models are trees or forests (i.e. every state has at most one predecessor). As every model is bisimilar to a tree, and Lµ∀ and L∀̃ are bisimulation invariant, this will not affect the validity of the presented argument.\nEffectively, the model Ms ↑ T is the model Ms with all the successors of any state in T removed. For each i there will be a set of states T i ⊂ Si such that for all j > i, M i ↑ T i = M j ↑ T i.\nThis means we are able to give a well-defined limit for this sequence. At each point of the induction, T i will represent a frontier of states in the model where we require q∧ t(ϕ[q\\x])p to be true. Because we are working with disjunctive formulas, we can change the submodels rooted at states in T i, without affecting the interpretation of t(ϕ[q\\x])p in other parts of the model. This way we are able to find a single model Mωs with the required properties.\nWe now define the sequence of models M i. For each i we define a model and a set of states T i ⊆ Si on which we will extend the construction. The proposition to be shown by inductive proof is\nM iu ≃ p,q Ms ∀u′ ∈ T i, M iu′ |= ∃̃q(q ∧ ∃̃p(q → t(ϕ[q\\x]) p)), ∀j < i, ∀u′ ∈ T j, M iu′ |= q ∧ t(ϕ[q\\x]) p, and ∀j < i,N i ↑ T j = N j ↑ T j.\nTo define the base case, it is sufficient to let M0 = M and T 0 = {s}. It is clear that the induction hypothesis holds here. Now, for the inductive step, assume that the proposition holds for i. For each u ∈ T i, we have\nM iu |= ∃̃q(q ∧ ∃̃p(q → t(ϕ[q\\x]) p)).\nHence, for each u ∈ T i, there is some (tree-like) Nuvu ≃ p,q M iu such that\nNuvu |= q ∧ t(ϕ[q\\x]) p ∧ ∃̃p(q → t(ϕ[q\\x])p).\nWe will assume w.l.o.g. that all models Nu for u ∈ T i and M i have disjoint sets of states. As ϕ is a disjunctive formula, we may further assume that Nuvu |= t(ϕ[q\\x])\np is invariant to any successors of V N u\n(q)\\{vu}. This allows us (as the induction proceeds) to replace the submodels rooted at vu without affecting whether t(ϕ[q\\x])p is satisfied in other parts of the model.\nWe now append the models Nuvu (for u ∈ T i) to the model M i. Formally, let M ′ ="
    }, {
      "heading" : "M i ↑ T i = (S ′, R′, V ′), then",
      "text" : "Si+1 = S ′ ∪ ⋃\nu∈T i S Nu ;\nRi+1 = R′ ∪ ⋃\nu∈T i R Nu ∪ {(u, v) | u ∈ T i, vuRN u\nv}; for all r : V i+1(r) = V ′(r) ⋃ u∈T i V Nu(r).\nFinally, we let T i+1 = ⋃\nu∈T i V Nu(q).\nWe can see that the proposition to be shown holds for i+ 1 as follows:\n• M i+1s ≃ p,q Ms since, for all u ∈ T i, M iu ≃ p,q Nuvu , and M i s ≃ p,q Ms from the induction hypothesis. A {p, q}-bisimulation between M i+1s and Ms can be constructed by composing these bisimulations.8\n• ∀v ∈ T i+1, M i+1v |= ∃̃q(q∧ ∃̃p(q → t(ϕ[q\\x]) p)), since for all u ∈ T i+1, u ∈ V i+1(q),\nand Nuvu |= q ∧ ∃̃p(q → t(ϕ[q\\x]) p).\n• ∀j < i + 1, ∀u ∈ T j, M ju |= q ∧ t(ϕ[q\\x]) q; by the reasoning presented above, M ju |=\nt(ϕ[q\\x])q is invariant to the successors of the states in T j+1. Therefore, if M ju |= q ∧ t(ϕ[q\\x])q, then M j+1u |= t(ϕ[q\\x]) q.\n• ∀j < i,M i ↑ T j = M j ↑ T j follows immediately from the construction.\nWe now let Mω = (Sω, Rω, V ω) where\n• s′ ∈ Sω iff for some i, s′ ∈ Sj for all j > i,\n• uRωv iff for some i, uRjv for all j > i,\n• u ∈ V ω(r) iff for some i, u ∈ V j(r) for all j > i,\nand let T ω = ∅. It is clear that the limit step will also preserve the induction hypothesis, so we have Mωu ≃ p,q Ms and N ω |= q ∧ (q → t(ϕ[q\\x])p), since by construction V ω(q) =⋃\ni<ω T i. Thus, Ms |= ∃̃p∃̃q(q ∧ (q → t(ϕ[q\\x]) p)) (i.e., Ms |= ∃νx.ϕ) as required. The construction is represented in Figure 7.\nCase Rν\nWe also use the contrapositive form of the axiom: ∃µx.ϕ ↔ µx.∃ϕ. For any ϕ ∈ L∀ we have that:\nt(∃µx.ϕ) ⇔ ∃̃p t(µx.ϕ)p\n⇔ ∃̃p(∀̃q( (t(ϕ[q\\x]) → q) → q))p ⇔ ∃̃p∀̃q( (t(ϕ[q\\x])p → q) → q) ⇒ ∀̃q∃̃p( (t(ϕ[q\\x])p → q) → q) (∗∗) ⇔ ∀̃q∃̃p( (t(ϕ[q\\x])p ∧ ¬q) ∨ q) ⇔ ∀̃q(∃̃p (t(ϕ[q\\x])p ∧ ¬q) ∨ q) ⇔ ∀̃q( ∃̃p(t(ϕ[q\\x])p ∧ ¬q) ∨ q) (∗ ∗ ∗) ⇔ ∀̃q( (∃̃p t(ϕ[q\\x])p ∧ ¬q) ∨ q) ⇔ ∀̃q( (∃̃p t(ϕ[q\\x])p → q) → q)\n⇔ ∀̃q( (∃ϕ[q\\x] → q) → q) ⇔ t(µx.∃ϕ)\n8Specifically, let Ru be the {p, q}-bsimulation between M iu and N u vu , and R i be the {p, q}-bisimulation between M is and Ms. We define the {p, q}-bisimulation R i+1 from M i+1s to Ms by: for all t ∈ S i+1, for all t′ in S, (t, t′) ∈ Ri+1 if and only if either (t ∈ Si and (t, t′) ∈ Ri), or (t ∈ SN u\n, and for some v ∈ Si, (t, v) ∈ Ru and (v, t′) ∈ Ri). It is straightforward to check that Ri+1 is a bisimulation.\nThe equivalence in (***) is true because is the existential modality which quantifies over all states in the model. Obviously, the implication in line (**) is only true in one direction (the usual quantifier swap ∃∀ → ∀∃).\nTo prove the other direction in the equivalence ∃µx.ϕ ↔ µx.∃ϕ, we now show directly that |= µx.∃ϕ → ∃µx.ϕ in refinement µ-calculus, for ϕ a df (observe that µx.ϕ is then a df as well). We use the inductive characterization of µx.∃ϕ of [5] which tells that Ms |= µx.∃ϕ if and only if s ∈ ‖∃ϕ‖τ for some ordinal τ , where we recall the definition of the semantic operation ‖ • ‖: ‖∃ϕ‖0 = ∅, and s ∈ ‖∃ϕ‖τ whenever M τ s |= ∃ϕ, where M\nτ = M [σ] with σ = x 7→ ⋃ τ ′<τ ‖∃ϕ‖τ ′.\nSuppose Ms |= µx.∃ϕ. Since L µ ∀ is bisimulation invariant, without loss of generality we may suppose that M is a countable tree-like model. As Ms satisfies µx.∃ϕ, there must be some least ordinal τ whereby s ∈ ‖∃ϕ‖τ . We give a proof by induction over τ that s ∈ ‖∃ϕ‖τ implies Ms |= ∃µx.ϕ. The base case where τ = 0 is trivial. Now consider M τ = M [σ] with σ = x 7→ ⋃ τ ′<τ ‖∃ϕ‖τ ′. Then M τ s |= ∃ϕ. As µx.ϕ is a df , there is a refinement of M τ with a frontier such that x may only be true at s or on this frontier, and no point beyond the frontier affects the interpretation of ϕ. Formally, there is a set of states {u0, u1, ...} ∈ V τ (x) such that M ′s |= ∃ϕ (i.e., M ′ s |= ∃̃p t(ϕ)\np), where M ′ = (S ′, R′, V ′) with\n• S ′ ⊆ Sτ is the set of states reachable from s, but not from any ui;\n• V ′(x) = {t, u0, u1, ...}, V ′(y) = V M\nτ\n(y) for y 6= x; and\n• R′ = Rτ\\{(ui, t) | t ∈ S τ , i = 0, 1, ...}.\nWe note that M ′s is a refinement of M τ s . Now as for each i, ui ∈ ‖∃ϕ‖j for some j < τ , by the inductive hypothesis we may assume there is some model N i = (Si, Ri, V i) where N ivi\nM τui and N i ui |= µx.ϕ. We may append these models to M ′, to define M∗ = (S∗, R∗, V ∗) where S∗ = S ′∪ ⋃ i S i, R∗ = R′∪ ⋃ i R i∪{(t, vi) | (t, ui) ∈ R ′}, and V ∗(y) = V ′(y)∪ ⋃ i V i(y) for all y ∈ P . (Notice the similar construction in the soundness proof of axiom RK.) It is clear that M∗s is a refinement of Ms, and by the axiom F1 we can see M ∗ s |= µx.ϕ as required.\nThe general form of Rµ is not sound. For example, take ϕ = µz.3(p → q) → 3(¬p → x). Then ∀µx.ϕ is true if p is true at every immediate successor of the current state, whereas µx.∀ϕ is only true at states with no successor. Likewise Rν is not true in the general case, as can be seen by taking ϕ = p ∧ 2(3⊤ → x). Then νx.∀ϕ is true if and only if p is true at every reachable state, and ∀νx.ϕ is true only if p is true at every state within one step."
    }, {
      "heading" : "6.2 Completeness",
      "text" : "The completeness proof of RMLµ proceeds exactly as for Theorem 38, replacing the formulas in cover logic with disjunctive formulas, to get a statement similar to that of Proposition 36.\nProposition 42 Every formula of Lµ∀ is equivalent to a formula of L µ. ⊣\nProof Given a formula ψ, we prove by induction on the number of the occurrences of ∃ in ψ that it is equivalent to an ∃-free formula, and therefore to a formula in the modal µ-calculus Lµ. The base is trivial. Now assume ψ contains n + 1 ∃-operators. Choose a subformula of type ∃ϕ of our given formula ψ, where ϕ is ∃-free (i.e. choose an innermost ∃). As ϕ is ∃-free, it is semantically equivalent to a formula in disjunctive normal form, and by the completeness of Kozen’s axiom system [59] this equivalence is provable in RMLµ. By NecR and R it follows that ∃ϕ is provably equivalent to some formula ∃ψ where ψ is a disjunctive formula (analogously to Proposition 32 one can easily show that RMLµ satisfies substitution of equivalents). Thus without loss of generality, we may assume in the following that ϕ is in disjunctive normal form. We may now proceed by induction over the complexity of ϕ, and conclude that ∃ϕ is logically equivalent to a formula χ without ∃. All cases of this induction are as before, we only show the final two, different cases:\n• ∃µx.ϕ iff µx.∃ϕ (by Rν noting that all subformulas of a disjunctive formula are themselves disjunctive); IH.\n• ∃νx.ϕ iff νx.∃ϕ (by Rµ); IH.\nReplacing ∃ϕ by χ in ψ gives a result with one less ∃-operator, to which the (original) induction hypothesis applies.\nTheorem 43 The axiom schema RMLµ is sound and complete for the logic RMLµ ⊣\nProof Soundness follows from Theorem 40 and Theorem 28. To see RMLµ is complete, suppose ϕ ∈ Lµ∀ is a valid formula. Then by Lemma 42, ϕ is provably equivalent to some valid formula ψ ∈ Lµ. As ψ is valid, it must be provable since Prop, K, F1, F2, NecK, and MP give a sound and complete proof system for the modal µ-calculus [59]. A proof of ϕ follows by MP."
    }, {
      "heading" : "7 Complexity",
      "text" : "Decidability for both L∀ and L µ ∀ follows from the fact that a computable translation is given in the completeness proofs of Sections 5 and 6: note that the given translations to L and Lµ respectively, are recursive and involve transforming formulas into their disjunctive normal forms. Hence they are non-elementary in the size of the original formula. This non-elementary procedure for Lµ∀ is optimal as shown in Section 7.1 below.\nUnfortunately we were not able to corroborate in this paper the upper complexity claims for RML reported in [56]. But towards some indication of a result in that direction, we further establish a doubly exponential succinctness proof for L∀ in Section 7.2. (On complexity, see also ‘Recent results’ in Section 8.)"
    }, {
      "heading" : "7.1 RMLµ is non-elementary",
      "text" : "This section is dedicated to the proof of the following result.\nTheorem 44 The satisfiability problem for RMLµ is non-elementary, even for the singleagent setting. ⊣\nIn the rest of this section, we only consider a single-agent setting. First, we recall a fragment, written CTL−, of the standard branching-time logic Computation Tree Logic (CTL) [14], which in turn is a fragment of Lµ (see also the example Section 4.2).\nCTL− ∋ ϕ ::= ⊤ | ⊥| p | ¬ϕ | ϕ ∧ ϕ |2ϕ | 3ϕ | EFϕ | AFϕ\nLet M be a model and s be an M-state. A path from s is a finite or infinite sequence of states π = s0, s1, . . . s.t. s0 = s and each si+1 is an successor of si. Only the semantics of AF and EF is recalled (as for other formulas it is clear):\nMs |= EFϕ iff there are a maximal path π = s0, s1, . . . from s and i ≥ 0 such that Msi |= ϕ Ms |= AFϕ iff for each maximal path π = s0, s1, . . . from s, there is i ≥ 0 such that Msi |= ϕ\nDirectly translating CTL− in Lµ is routine via the following mapping τ : CTL− → Lµ, defined by induction over the formulas: τ(⊤) = ⊤, τ(p) = p, τ(¬ϕ) = ¬τ(ϕ), τ(ϕ ∧ ϕ′) =\nτ(ϕ) ∧ τ(ϕ′), τ(2ϕ) = 2τ(ϕ), τ(3ϕ) = 3τ(ϕ), τ(EFϕ) = µx.τ(ϕ) ∨ 3x, τ(AFϕ) = µx.τ(ϕ) ∨ 2x.\nWe also use standard abbreviations for the duals AGϕ iff ¬EF¬ϕ (‘universal always’), and EGϕ iff ¬AF¬ϕ (‘existential always’). A CTL− formula is in positive form if negation is applied only to propositional variables. A CTL− formula ϕ is existential if it is in positive form and there are no occurrences of the universal modalities AF and AG and the modality 2. The following can be proved by using Proposition 8, enriched for the case of EF formulas (with a transfinite induction argument for this fixed-point formula).\nProposition 45 Let Ms and Nt be two models with Ms Nt. Then for each existential CTL− formula ϕ, Nt |= ϕ implies Ms |= ϕ. ⊣\nDefinition 46 (Refinement CTL−) Refinement CTL− (CTL−∀ , for short) is the extension of CTL− with the refinement quantifiers ∃ and ∀. ⊣\nDefinition 47 (Refinement Quantifier Alternation Depth) We first define the alternation length ℓ(χ) of finite sequence χ ∈ {∃, ∀}∗ of quantifiers, as the number of alternations of existential and universal refinement quantifiers in χ. Formally, ℓ(ǫ) = 0, ℓ(Q) = 0 for every Q ∈ {∃, ∀}∗, and ℓ(QQ′χ) = ℓ(Q′χ) if Q = Q′, ℓ(Q′χ) + 1 otherwise.\nGiven a L∀ (resp., L µ ∀, resp., CTL − ∀ ) formula ϕ, the refinement quantifier alternation depth δ(ϕ) of ϕ is defined via the standard tree-encoding T (ϕ) of ϕ, where each node is labeled by either a modality, a boolean connective, or a propositional variable. Then, δ(ϕ) is the maximum of the alternation lengths ℓ(χ) where χ is the sequence of refinement quantifiers along a maximal path of T (ϕ) from the root. ⊣\nTheorem 48 Let the class Ck = {ϕ ∈ CTL − ∀ | δ(ϕ) ≤ k}. The satisfiability problem for Ck is k-Expspace-hard, for any k. ⊣\nTheorem 48 is proved by a polynomial-time reduction from satisfiability of Quantified Propositional Temporal Logic (QPTL) [50]. First, we recall the syntax and the semantics of QPTL. The syntax of QPTL formulas ϕ over a countable set P of propositional variables is defined as follows:\nϕ ::= p | ¬ϕ | ϕ ∧ ϕ | ϕ ∨ ϕ | Xϕ | Fϕ | ∃p.ϕ\nwhere p ∈ P , X is the ‘next’ modality, F is the ‘eventually’ modality, and ∃ is the existential quantifier.9 We also use standard abbreviation Gϕ for ¬F¬ϕ (‘always’).\nThe semantics is given w.r.t. elements of (2P )ω, namely infinite words w over 2P . Beforehand, we need some technical notions. Let w ∈ (2P )ω. For each i ≥ 0, w(i) denotes the ith symbol of w. Moreover, for each P ′ ⊆ P , we define the equivalence relation ≡P ′ over (2P )ω: two infinite words w1 and w2 are ≡P ′-equivalent whenever their projections onto P ′ are equal. The projection of an infinite word w onto P ′, written proj(w, P ′), is obtained\n9We distinguish (domain) quantifiers ∃ and ∀ in use here, from the refinement quantifiers ∃ and ∀, and from the bisimulation quantifiers ∃̃ and ∀̃.\nby removing from each symbol of w all the propositions in P \\ P ′. Hence, w1 ≡P ′ w2 iff proj(w1, P ′) = proj(w2, P ′).\nGiven a QPTL formula ϕ, an infinite word w over 2P , and a position h ≥ 0 along w, the satisfaction relation (w, h) |= ϕ is inductively defined as follows (we omit the clauses for the boolean connectives):\n(w, h) |= p iff p ∈ w(h) (w, h) |= Xϕ iff (w, h+ 1) |= ϕ (w, h) |= Fϕ iff there is h′ ≥ h such that (w, h) |= ϕ (w, h) |= ∃p.ϕ iff there is w′, w′ ≡P\\{p} w and (w ′, h) |= ϕ\nWe say that the word w satisfies ϕ, written w |= ϕ, if (w, 0) |= ϕ. A QPTL formula ϕ is in positive normal form if it is of the form Q1p1.Q2p2. . . . Qnpn.ϕn+1, where Qj ∈ {∃, ∀} for each 1 ≤ j ≤ n, and ϕn+1 is a quantification-free QPTL-formula in which negation is applied only to propositional variables10. The quantifier alternation depth of Q1p1.Q2p2. . . . Qnpn.ϕn+1 is the number of alternations of (existential and universal) quantifiers in the string Q1Q2 . . . Qn. The following is a well-known result.\nTheorem 49 [50] Let k ≥ 0. Then, the satisfiability problem for the class of QPTL formulas in positive normal form whose quantifier alternation depth is k is k-Expspacehard. ⊣\nNote that Theorem 49 holds even if we assume that formulas in positive normal form like Q1p1.Q2p2. . . .Qnpn.ϕn+1 (with ϕn+1 quantification-free) are such that p1, . . . , pn are pairwise distinct, each proposition occurring in ϕn+1 is in {p1, . . . , pn}, and Qn = ∀.\nTheorem 48 directly follows from Theorem 49 and the following theorem, whose proof is given in the rest of this section.\nTheorem 50 For every ϕ ∈ QPTL, one can construct in time polynomial in the size of ϕ a formula ϕ̃ ∈ CTL−∀ , such that ϕ is satisfiable if, and only if, ϕ̃ is satisfiable. Moreover, the refinement quantifier alternation depth of ϕ̃, δ(ϕ̃), is equal to the quantifier alternation depth of ϕ. ⊣\nBefore proving Theorem 50, we need additional definitions. Let P = {p1, . . . , pn} and P̃ = P ∪ {p0, p1, . . . , pn}, where p0, p1, . . . , pn are fresh propositional variables (intuitively, pi is used to encode the negation of pi for each 1 ≤ i ≤ n, and p0 is a new variable that will be used to mark a path). For a model M and two states s and s′ in M , s′ is reachable from s if there is a finite path from s leading to s′. Let 0 ≤ j ≤ n. A pointed model Ms (over P̃ ) is well-formed w.r.t. j if the following holds:\n1. for each state s′ of M which is reachable from s, there is exactly one proposition p ∈ P̃ such that s′ ∈ V M(p) (we say that s′ is a p-state); moreover, s is a p0-state;\n10Every QPTL formula is constructively equivalent to a formula in positive normal form, with linear size.\n2. each state s′ reachable from s which is not a p0-state has no successor;\n3. each p0-state s ′ which is reachable from s satisfies: (i) s′ has some p0-successor, (ii)\nfor all 1 ≤ i ≤ j, either s′ has a pi-state successor or (exclusive) a pi-state successor, and (iii) for all j+1 ≤ i ≤ n, s′ has both a pi-state successor and a pi-state successor.\nFor each 0 ≤ j ≤ n, the following CTL− formula ψj over P̃ characterizes the set of pointed models which are well-formed w.r.t. j:\nψj := p0 ∧ AG {[∨ p∈P̃ (p ∧ ∧ p′∈P̃\\{p} ¬p ′) ] ∧ [ ¬p0 → 2⊥ ] ∧\np0 → [ 3p0 ∧ ∧ j+1≤i≤n(3pi ∧ 3pi) ∧ ∧ 1≤i≤j(3(pi ∨ pi) ∧ (2¬pi ∨ 2¬pi))\n]}\nIntuitively, ψj enforces the existence of infinite paths π = s0s1 . . . which visit only p0states si such that the following holds: the set of successors of si ‘encodes’ a specific truth valuation of the variables p1, . . . , pj and all the possible truth valuations of the variables pj+1, . . . , pn.\nA pointed model Ms is well-formed if it is well-formed w.r.t. j for some 0 ≤ j ≤ n. In this case, we say that Ms is minimal if, additionally, each p0-state which is reachable from s has exactly one p0-successor.\nA well-formed pointed model Ms encodes a set of infinite words over 2 P , written words(Ms), given by: w ∈ words(Ms) iff there is an infinite path π = s0, s1, . . . of M from s (note that π consists of p0-states) such that for all h ≥ 0 and 1 ≤ j ≤ n, either pj ∈ w(h) and sh has some pj-successor, or pj /∈ w(h) and sh has some pj-successor.\nNote that if Ms is well-formed w.r.t. 0, then words(Ms) = (2 P )ω. If instead Ms is well-formed w.r.t. j for some 0 < j ≤ n and Ms is also minimal, then there is an infinite word uj ∈ (2 {p1,...,pj})ω such that words(Ms) = {w ∈ (2 P )ω | proj(w, {p1, . . . , pj}) = uj}. In particular, when j = n, words(Ms) is a singleton. Also, one can easily see that if Ms Nt then words(Ms) ⊇ words(Nt).\nConstruction of the CTL−∀ formula ϕ̃ (in Theorem 50). Pick an QPTL formula ϕ = Q1p1.Q2p2. . . . Qnpn.ϕn+1. For each 1 ≤ j ≤ n, we let ϕj = Qjpj.Qj+1pj+1. . . . Qnpn.ϕn+1 (note that ϕ1 corresponds to ϕ).\nFirst, we construct a CTL−∀ formula ϕ̃j over P̃ by using the CTL − formulas ψj−1, for each 1 ≤ j ≤ n + 1. The construction is based on an induction on n+ 1 − j = 0, . . . , n as follows:\nBase case (j = n+1). Recall that ϕn+1 is a quantification-free QPTL formula in positive normal form over P . Let Υ be the following mapping from the set of quantificationfree QPTL formulas ξ over P in positive normal form to the set of existential CTL−\nformulas over P̃ (it is defined by induction).\n• Υ(p) = 3p and Υ(¬p) = 3p for each p ∈ P ;\n• Υ(ξ1 ∨ ξ2) = Υ(ξ1) ∨Υ(ξ2) and Υ(ξ1 ∧ ξ2) = Υ(ξ1) ∧Υ(ξ2);\n• Υ(Xξ) = 3(p0 ∧ Υ(ξ)), Υ(Fξ) = EF(p0 ∧ Υ(ξ)), and Υ(Gξ) = EG(p0 ∧ Υ(ξ)).\nThen, ϕ̃n+1 := Υ(ϕn+1).\nInduction case (1 ≤ j ≤ n). Recall ϕj = Qjpj.ϕj+1.\nThen, ϕ̃j := { ∃(ψj ∧ ϕ̃j+1) if Qj = ∃ ∀(ψj → ϕ̃j+1) if Qj = ∀\nFinally, the CTL−∀ formula ϕ̃ over P̃ is given by ϕ̃ := ψ0 ∧ ϕ̃1.\nCorrectness of the construction. Note that the size of ϕ̃ is polynomial in the size of ϕ. Moreover, the refinement quantifier alternation depth of ϕ̃ is equal to the quantifier alternation depth of ϕ. Thus, in order to prove Theorem 50, it remains to show that ϕ is satisfiable iff ϕ̃ is satisfiable. For this, we need three preliminary lemmata.\nLemma 51 Let Ms be a pointed model which is well-formed w.r.t. n and minimal, with words(Ms) = {w}. Then, for each quantification-free QPTL formula ξ in positive normal form, w |= ξ if and only if Ms |= Υ(ξ). ⊣\nProof Let π = s0, s1, . . . be the unique infinite path of M from state s (note that π consists of p0-states). Then, by a straightforward structural induction, one can show that for each quantification-free QPTL formula in positive normal form ξ, the following holds: for all h ≥ 0, Msh |= Υ(ξ) iff (w, h) |= ξ. Hence, the result follows.\nLet 0 ≤ j ≤ n and let Ms be a pointed model which is well-formed w.r.t. j. For each j ≤ i ≤ n, an h-segment of Ms is a refinement Nt of Ms which is well-formed w.r.t. h and minimal. Note that for each w ∈ words(Ms) and for each j ≤ h ≤ n, by construction, there exists an h-segment Nt of Ms such that w ∈ words(Nt).\nLemma 52 Let 1 ≤ j ≤ n and Ms be a pointed model which is well-formed w.r.t. j − 1 such that for each w ∈ words(Ms), w |= ϕj. Then, Ms |= ϕ̃j. ⊣\nProof The proof is by induction on n− j = 0, . . . , n− 1.\nBase case (j = n). Recall ϕn = ∀pn.ϕn+1, where ϕn+1 is a quantification-free QPTL formula in positive normal form. By construction, ϕ̃n = ∀(ψn → Υ(ϕn+1) ). Let Nt be a refinement of Ms which satisfies formula ψn (if any). We need to show that Nt |= Υ(ϕn+1). By definition of ψn, Nt is well-formed w.r.t. n. Let N ′ u be any n-\nsegment of Nt, and let words(N ′ u) = {w}. By transitivity, N ′ u is a refinement of Ms, so that w ∈ words(Ms). Thus, by hypothesis, w |= ϕn = ∀ pn.ϕn+1, which implies w |= ϕn+1. By Lemma 51, it follows that N ′ u |= Υ(ϕn+1). Since N ′ u is a refinement of Nt and Υ(ϕn+1) is an existential CTL − formula, by Proposition 45 we deduce that Nt |= Υ(ϕn+1) as well. Hence, the result holds.\nInduction step (1 ≤ j ≤ n− 1). By construction, there are two cases:\n(1) ϕj = ∃ pj .ϕj+1 and ϕ̃j = ∃(ψj ∧ ϕ̃j+1): let w0 ∈ words(Ms). By hypothesis, w0 |= ϕj . Hence, there is infinite word w ′ 0 over 2\nP such that w′0 ≡P\\{pj} w0 and w′0 |= ϕj+1. Since Ms is well-formed w.r.t. j − 1 and w0 ∈ words(Ms), it follows that w′0 ∈ words(Ms) as well. Let Ns be any j-segment of Ms such that w ′ 0 ∈ words(Ns). By definition of ψj , Ns |= ψj . Thus, it suffices to show that Ns |= ϕ̃j+1. Since Ns is well-formed w.r.t. j and minimal, and w ′ 0 ∈ words(Ns), it holds that for each w′ ∈ words(Ns), w ′ ≡{p1,...,pj} w ′ 0. Since every proposition in {pj+1, . . . , pn} does not occur free in ϕj+1 and w ′ 0 |= ϕj+1, it follows that for each w ′ ∈ words(Ns), w ′ |= ϕj+1. Thus, by the induction hypothesis, we obtain that Ns |= ϕ̃j+1, and the result holds.\n(2) ϕj = ∀ pj.ϕj+1 and ϕ̃j = ∀(ψj → ϕ̃j+1): let Nt be a refinement of Ms which satisfies formula ψj (if any). We need to show that Nt |= ϕ̃j+1. By definition of ψj , Nt is well-formed w.r.t. j. Thus, by the induction hypothesis it suffices to show that for each w ∈ words(Nt), w |= ϕj+1. Let w ∈ words(Nt). Since Nt is a refinement of Ms, it holds that w ∈ words(Ms). Thus, by hypothesis, w |= ϕj = ∀ pj .ϕj+1. Hence, w |= ϕj+1, and the result follows.\nLemma 53 Let 1 ≤ j ≤ n and let Ms be a pointed model which is well-formed w.r.t. (j−1) and such that Ms |= ϕ̃j. Then, there is a (j − 1)-segment Nt of Ms such that Nt |= ϕ̃j and for each w ∈ words(Nt), w |= ϕj. ⊣\nProof The proof is by induction on n − j = 0, . . . , n − 1, for which there are two cases. Recall that ϕn = ∀pn.ϕn+1. (1) ϕj = ∀ pj .ϕj+1 and ϕ̃j = ∀(ψj → ϕ̃j+1): let Nt be any (j − 1)-segment of Ms. By hypothesis Ms |= ϕ̃j . Since every refinement of Nt is also a refinement of Ms, it follows that Nt |= ϕ̃j. Thus, it suffices to show that for each w ∈ words(Nt), w |= ϕj . Fix w ∈ words(Nt) and let w′ be an infinite word over 2P such that w′ ≡P\\{pj} w. Since Nt is well-formed w.r.t. j−1, w′ ∈ words(Nt) as well. Let N ′ u be a j-segment of Nt such that w\n′ ∈ words(N ′u). By definition of ψj , N ′ u |= ψj . Thus, since Nt |= ϕ̃j, we deduce that N ′ u |= ϕ̃j+1. There are two cases:\n• j = n (base step): by construction, words(N ′u) is a singleton, ϕ̃n+1 = Υ(ϕn+1), and ϕn+1 is a quantification-free QPTL-formula in positive normal form. Since w\n′ ∈ words(N ′u) and N ′ u |= ϕ̃n+1, by Lemma 51, it follows that w ′ |= ϕn+1.\n• j ≤ n − 1 (induction step): since w′ ∈ words(N ′u) and N ′ u |= ϕ̃j+1, by the induction\nhypothesis (note that since N ′u is minimal, for each j-segment N ′′ v of N ′ u, words(N ′′ v ) = words(N ′u)), it follows that w ′ |= ϕj+1.\nThus, in both cases w′ |= ϕj+1. Since w ′ is an arbitrary infinite word over 2P such that w′ ≡P\\{pj} w, we obtain that w |= ∀ pj .ϕj+1 = ϕj, and the result follows.\n(2) ϕj = ∃ pj.ϕj+1, ϕ̃j = ∃(ψj ∧ ϕ̃j+1), and j ≤ n − 1 (induction step): since Ms |= ϕ̃j , there is a refinement Nt of Ms satisfying both ψj and ϕ̃j+1. By definition of ψj , Nt is well-formed w.r.t. j. Thus, since Nt |= ϕ̃j+1 and j ≤ n − 1, by the induction hypothesis, there is a j-segment N ′u of Nt such that N ′ u |= ψj , N ′ u |= ϕ̃j+1, and for each w ∈ words(N ′ u), w |= ϕj+1. Since Nt is a refinement of Ms, it easily follows that N ′ u is the refinement of some (j − 1)-segment M ′v of Ms. Since N ′ u |= ψj ∧ ϕ̃j+1, it holds that M ′ v |= ϕ̃j . Hence, it suffices to show that for each w ∈ words(M ′v), w |= ϕj. Let w ∈ words(M ′ v). Then, since M ′v (resp., N ′ u) is minimal and well-formed w.r.t. j − 1 (resp., j) and N ′ u is a refinement of M ′v, it follows that there is w ′ ∈ words(N ′u) such that w ′ ≡P\\{pj} w. Since w ′ |= ϕj+1, we obtain that w |= ∃ pj.ϕj+1 = ϕj, and the result follows.\nNow, we can prove the correctness of the construction.\nTheorem 54 ϕ is satisfiable if, and only if, ϕ̃ is satisfiable. ⊣\nProof First, assume that ϕ̃ = ψ0 ∧ ϕ̃1 is satisfiable. Hence, there is a pointed model Ms which satisfies both ψ0 and ϕ̃1. By definition of formula ψ0, it follows that Ms is wellformed w.r.t. 0. Since Ms |= ϕ̃1, by Lemma 53, we deduce that there is an infinite word w over 2P such that w |= ϕ1. Since ϕ = ϕ1, it follows that ϕ is satisfiable.\nNow, assume that ϕ is satisfiable. Since any proposition in P does not occur free in ϕ, it follows that for each infinite word w over 2P , w |= ϕ. Let Ms be any pointed model which is well-formed w.r.t. 0. By definition of formula ψ0, it holds that Ms |= ψ0. Moreover, since w |= ϕ for each w ∈ words(Ms), and ϕ = ϕ1, by Lemma 52 it follows that Ms |= ϕ̃1. Therefore, Ms |= ψ0 ∧ ϕ̃1 = ϕ̃. Hence, ϕ̃ is satisfiable.\nBy using Theorem 48 and the fact that there exists a linear time translation of CTL−∀ into Lµ∀ (see page 45) we now obtain the required proof of Theorem 44."
    }, {
      "heading" : "7.2 Succinctness",
      "text" : "In this section we establish the following result.\nTheorem 55 RML is doubly exponentially more succinct than K, and RMLµ is doubly exponentially more succinct than modal µ-calculus. ⊣\nTheorem 55 directly follows from the following result whose proof is given in the rest of this section.\nProposition 56 There is a finite set P of propositional variables and a family (ϕn)n∈N of one-agent L∀ formulas over P such that for each n ∈ N, ϕn has size O(n\n2) and refining quantifier alternation depth 2, and each equivalent one-agent Lµ formula has size at least 22 Ω(n) .11 ⊣\n11Recall that f(n) ∈ Ω(g(n)) iff g(n) ∈ O(f(n)).\nConstruction of the L∀ formulas ϕn in Proposition 56: let P = {l, r,#, 0, 1, a, b}. An n-configuration is a string on {a, b} of length exactly 22 n\n. We define a class Cn of pointed models, where each pointed model in the class encodes, in a suitable way, a pair of n-configurations. Then, we construct the L∀ formula ϕn in such a way that the following holds: a pointed model Ms ∈ Cn satisfies ϕn iff the two n-configurations encoded by Ms coincide. In order to formally define the class Cn, we need additional definitions. An nblock is a pair bl = (c, i) such that c ∈ {a, b} and 1 ≤ i ≤ 22 n\n. We say that c is the content of bl and i is the position of bl. Intuitively, bl represents the ith symbol of some n-configuration. First, we define an encoding of (c, i) by a set code(c, i) of strings over 2P of length n + 3. Since 1 ≤ i ≤ 22 n\n, i can be encoded by a binary string over {0, 1} of length exactly 2n. Moreover, we keep track, for each 1 ≤ j ≤ 2n, of the binary encoding (a string over {0, 1} of length n)12 of the position j of the jth bit in the binary encoding of i. This leads to the following definition. An n-sub-block is a string over 2P of length n+2 of the form sbl = {#}, {b1}, . . . , {bn}, {B}, where b1, . . . , bn, B ∈ {0, 1}. The content of sbl is B and the position of sbl is the integer 1 ≤ j ≤ 2n whose binary encoding is b1, . . . , bn. Intuitively, sbl encodes the position and the content B of a bit along the binary encoding of an integer 1 ≤ i ≤ 22 n\n. Then, code(c, i) is the set of strings over 2P of length n+3 such that\n• for each u ∈ code(c, i), u = sbl · {c}, where sbl is an n-sub-block whose position j and content b satisfy the following: b is the jth bit in the binary encoding of i.\n• for each 1 ≤ j ≤ 2n, let Bj be the jth bit in the binary encoding of i and sblj be the n-sub-block whose position is j and whose content is Bj . Then, sblj · {c} ∈ code(c, i).\nLet Ms be a pointed model over P . We denote by Traces(Ms) the set of finite or infinite strings over 2P of the form (V M)−1(s0), (V\nM)−1(s1), . . . such that s0, s1, . . . is a maximal path of M starting from s. A pointed model Ms encodes an n-block (c, i) if\nTraces(Ms) = code(c, i) and Ms |= n−1∧\nd=0\n2 d(31 ∧ 30) ∈ L\nNote that the set of pointed models encoding (c, i) is nonempty. Let (wl, wr) be a pair of n-configurations. A pointed model Ms encodes the pair (wl, wr) if it holds that:\n• s has two successors sl and sr (called the left successor and right successor of s, respectively). Moreover, (V M)−1(s) = ∅, (V M)−1(sl) = {l} and (V M)−1(sr) = {r};\n• for each dir ∈ {l, r}, sdir has 2 2n successors s1,dir, . . . , s22n ,dir. Moreover, for each\n1 ≤ i ≤ 22 n\n, Msi,dir encodes the n-block (ci,dir, i), where ci,dir is the ith symbol of the n-configuration wdir.\n12Here, it is not relevant to specify the form of the binary encoding which is used.\nIf additionally wl = wr, then we say that Ms is balanced. The class Cn is the class of pointed models Ms such that Ms encodes some pair (wl, wr) of n-configurations. In order to define the L∀ formula ϕn (for each n ≥ 0), we first show Lemma 57. This lemma asserts that there is an L∀ formula ψn of size O(n\n2) which allows one to select, for a given pointed model Ms ∈ Cn, only the n-blocks encoded by Ms having the same position.\nLemma 57 For each n ≥ 0, one can construct a one-agent L∀ formula ψn of size O(n 2) and refinement quantifier alternation depth 1 satisfying the following for all pairs (wl, wr) of n-configurations: for each Ms ∈ Cn encoding the pair (wl, wr) and each refinement M ′ s′ of Ms,\n• M ′s′ satisfies ψn iff there is 1 ≤ i ≤ 2 2n such that the set of #-states (i.e. states whose\nlabel is {#}) s′# reachable from s ′ is nonempty and for each of such states s′#, M ′ s′# encodes an n-block whose position is i and whose content is either the ith symbol of wl or the ith symbol of wr. ⊣\nProof The L∀ formula ψn is defined as follows:\nψn := ξn ∧ ∀(θn → ∨\nb∈{0,1}\n2 n+3b)\nwhere ξn and θn are L formulas defined as follows:\nξn := 3⊤ ∧ 23⊤ ∧ n−1∧\nd=0\n2 d+2(31 ∧ 30) ∧ 2n+23⊤ ∧ 2n+33⊤\nθn := 3⊤ ∧ 23⊤ ∧ 2 2 3⊤ ∧\nn∧\nd=1\n∨\nb∈{0,1}\n2 d+2(b ∧ 3⊤) ∧ 2n+33⊤\nNote that ψn has size O(n 2) and that δ(ψn) = 1 (refinement alternation depth). Thus, it remains to prove the second part of the lemma. Fix Ms ∈ Cn encoding some pair (wl, wr) of n-configurations, and let M ′s′ be a refinement of Ms. By construction, for each #-state s′# reachable from s\n′ in M ′, there is a #-state s# reachable from s in M such that M ′ s′# is\na refinement of Ms# . Moreover, Ms# encodes some n-block (c, i), where the content c is either the ith symbol of wl or the ith symbol of wr. Thus, by definition of ξn, we obtain the following.\nFact 1: M ′s′ satisfies ξn iff the set of #-states s ′ # reachable from s ′ is nonempty and for each of such states s′#, M\n′ s′# encodes some n-block (c, i), where the content c is either the\nith symbol of wl or the ith symbol of wr.\nIn the second conjunct ∀(θn → ∨ b∈{0,1} 2 n+3b) of the definition of ψn, the formula θn intuitively enforces one to select the refinements M ′s′ of Ms encoding only n-blocks having the same position. Formally, by definition of θn, we obtain the following.\nFact 2: Let M ′′s′′ be a refinement of M ′ s′ . Then, M ′′ s′′ satisfies θn iff for all u, u ′ ∈ Traces(M ′′s′′), u, u ′ ∈ Traces(Ms) and the n-sub-block in u and the n-sub-block in u ′ have the same position.\nThus, by Fact 2 it follows that the second conjunct ∀(θn → ∨ b∈{0,1} 2 n+3b) of definition of ψn requires that all the n-sub-blocks in Traces(M ′ s′) having the same position have also the same content, i.e., all the n-blocks encoded by M ′s′ have the same position. Thus, by Fact 1 the result follows.\nFor each n ≥ 0, let ψn be the L∀ formula satisfying the statement of Lemma 57. Then, the one-agent L∀ formula ϕn is defined as follows:\nϕn = ∀(ψn → ∨\nc∈{a,b}\n2 n+4c)\nBy construction and Lemma 57, we easily obtain the following result.\nLemma 58 For each n ≥ 0, the L∀ formula ϕn has size O(n 2) and δ(ϕn) = 2 (refinement alternation depth). Moreover, for each Ms ∈ Cn, Ms satisfies ϕn iff Ms is balanced. ⊣\nProof of Proposition 56: by Lemma 58, in order to complete the proof of Proposition 56, we need to show that for each n ≥ 0, each one-agent Lµ formula equivalent to ϕn has size at least 22 Ω(n) . For this, we use a well-known automata-characterization of (oneagent) Lµ in terms of parity symmetric alternating (finite-state) automata (PSAA) which operate on pointed models [61]. First, we recall the class of PSAA. We need additional definitions.\nA tree T is a prefix closed subset of N∗. The elements of T are called nodes and the empty word ε is the root of T . For x ∈ T , the set of children of x (in T ) is {x·i ∈ T | i ∈ N}. A path of T is a maximal sequence π = x0x1 . . . of T -nodes such that x0 = ε and for any i, xi+1 is a child of xi. For an alphabet Σ, a Σ-labeled tree is a pair 〈T, r〉 where T is a tree and r : T → Σ. For a set X , B+(X) denotes the set of positive boolean formulas over X , built from elements in X using ∨ and ∧ (we also allow the formulas true and false). A subset Y of X satisfies θ ∈ B+(X) iff the truth assignment that assigns true to the elements in Y and false to the elements of X \\ Y satisfies θ.\nA parity symmetric alternating automaton (PSAA) over P is a tupleA = 〈P,Q, q0, δ, Acc〉, whereQ is a finite set of locations, q0 ∈ Q is an initial location, δ : Q×2 P → B+ ( {2,3}×Q) is the transition function, and Acc : Q → N is a parity acceptance condition assigning to each location q ∈ Q an integer (called priority). Intuitively, a target of a move of A is encoded by an element in {2,3}×Q. An atom (3, q) means that from the current state s (of the pointed input model) A moves to some successor of s and the location is updated to q. On the other hand, an atom (2, q) means that from the current state s the automaton splits in multiple copies and, for each successor s′ of s, one of such copies moves to s′ and the location is updated to q.\nFormally, for a pointed model Ms0 over P , a run of A over Ms0 is a (Q× S M)-labeled tree 〈T, r〉.13 Moreover, we require that r(ε) = (q0, s0) (initially, A is in the initial location q0 reading state s0), and for each y ∈ T with r(y) = (q, s), there is a (possibly empty) minimal set H ⊆ {2,3}×Q satisfying δ(q, (V M)−1(s)) such that the set L(y) of labels of children of y in T is the smallest set satisfying the following: for all atoms at ∈ H ,\n• if at = (3, q′), then for some successor s′ of s in M , (q′, s′) ∈ L(y);\n• if at = (2, q′), then for each successor s′ of s in M , (q′, s′) ∈ L(y).\nFor an infinite path π = y0y1 . . . of T , let inf(π) be the set of locations in Q that appear in r(y0)r(y1) . . . infinitely often. The run 〈T, r〉 is accepting if for each infinite path π of T , the smallest priority of the locations in inf(π) is even. The language of A is the set of pointed models Ms over P such that A has an accepting run over Ms. The following is a well-known result.\nProposition 59 [61] Given a one-agent Lµ formula ϕ over P , one can construct a PSAA Aϕ with O(|ϕ|) locations whose language is the set of pointed models over P satisfying ϕ.⊣\nProposition 56 directly follows from Proposition 59 and the following result.\nLemma 60 Let n ≥ 0 and An be a PSAA over P whose language is the set of pointed models satisfying the L∀ formula ϕn. Then, the number of locations of An is at least 2 2n.⊣\nProof Let n ≥ 0 and An as in the statement of the lemma (note that An exists by Proposition 59 together with Proposition 42), and Q be the set of An-locations. For each n-configuration w, let Mwsw be some balanced pointed model encoding the pair (w,w), and H(w) be the set of sets Ql ⊆ Q such that there is an accepting run 〈T, r〉 of An over the pointed model Mwsw so that:\n• Ql is the set of locations associated with the replicas ofAn in the run 〈T, r〉 which read the left successor sl of sw in M\nw, i.e., Ql = {q ∈ Q | for some x ∈ T, r(x) = (q, sl)}. (Note that Ql = ∅ if 〈T, r〉 does not visit the left successor sl of sw.)\nFirst, we show that H(w) 6= ∅. By hypothesis and Lemma 58, there must exist some accepting run of An over the input M w sw . Now, by construction, H(w) is a set of subsets of Q, and H(w) is non-empty if and only if there is some accepting run of An over M w sw . (If no accepting run of An visits the left successor sl of sw in M w, then H(w) is a singleton containing just the empty set.) Hence, non-emptiness of H(w) follows. Next, we prove the following.\nClaim: for all n-configurations w and w′ such that w 6= w′, H(w) ∩H(w′) = ∅. Proof of the claim: for a model M and a set S ′ ⊆ SM , the restriction of M to S ′ is defined in the obvious way. For s ∈ SM , let [Ms] denote the restriction of M to the set of\n13Intuitively, each node of T labeled by (q, s) describes a copy of A that is in location q and reads the state s of M .\nstates reachable from s in M . For all n-configurations w and dir ∈ {l, r}, let sw,dir be the dir-successor of sw in M\nw. We prove the claim by contradiction. So, assume that there are two distinct n-configurations w and w′ such that H(w) ∩H(w′) 6= ∅. Without loss of generality we can assume that Mw and Mw ′ have no states in common. Let Mw,w ′\nsw be any\npointed model satisfying the following: the successors of sw in M w,w′ are sw′,l and sw,r, and [Mw,w ′\nsw′,l ] = [Mw\n′\nsw′,l ] and [Mw,w\n′\nsw,r ] = [Mwsw,r ]. Evidently, M w,w′ sw is a pointed model encoding\nthe pair (w′, w). Since w 6= w′, by hypothesis and Lemma 58, An does not accept M w,w′\nsw .\nOn the other hand, since there is Q ∈ H(w) ∩ H(w′), by definition of the sets H(w) and H(w′) and the semantics of PSAA, it easily follows that there is an accepting run of An over Mw,w ′\nsw , which is a contradiction. Hence, the claim holds.\nBy the claim above, it follows that for each n-configuration w, there is Qw ∈ H(w) (recall that H(w) 6= ∅) such that for all n-configurations w′ distinct from w, Qw /∈ H(w ′). Since the number of distinct n-configurations is 22 2n\nand the number of subsets of Q is 2|Q|, we obtain that |Q| ≥ 22 n , and the result holds."
    }, {
      "heading" : "8 Conclusions and perspectives",
      "text" : "Conclusions We conclude that we hope to have established a platform for structural refinement in various modal logics. We established results on axiomatization, complexity, expressivity, and we gave applications to software verification and design, and to dynamic epistemic logics. We clearly established the relation to bisimulation quantified logics: refinement quantification is bisimulation followed by relativization. The multi-agent refinement modal logic and the furthest generalization in the form of refinement µ-calculus are only the beginning. One could think of refinement CTL, refinement PDL, (yet other) refinement epistemic logics, refinement with further structural restrictions or with protocol restrictions, and so on. Each of these logics may have different axiomatizations and complexities, and equal expressivity as the logic without refinement is certainly not to be expected; e.g., we estimate that refinement modal logic is more expressive than the base modal logic on the KT model class.\nRecent results Following the initial submission of the paper, some further results have been obtained in this area, typically involving one of the authors. In [12] it was established that the complexity of refinement modal logic for a single agent is AEXPpol-complete, which means that the satisfiability of an RML formula can be decided by an exponential-time bounded Alternating Turing Machine with a linearly-bounded number of alternations. In [28] an axiomatization of the multi-agent refinement modal logic of knowledge is given, among other results. As a generalization of quantifying over announcements (arbitrary announcements), in [8] semantics were also given for quantifying over action models and the question was posed how to axiomatize this logic: in [26] it is shown that quantifying over action models is equally expressive as the refinement quantifier, i.e., ‘there is a refinement after which ϕ is true’ means the same as ‘there is an action model such that after its\nexecution ϕ is true’. This answers one of the open questions on logics with quantification over information change, posed in the recent survey [54]. That survey also puts various other proposals on propositional quantification in perspective, such as [52], [18], [7] (going back to [6]), and [60]—for details, see [54]. It should not be forgotten to mention that many of these, including our own proposal, go back to the original publication [21].\nFurther research We wish to determine the complexity of model checking in the various refinement modal logics. On the further horizon loom the detailed investigation of other refinement logics, mainly refinement PDL and refinement CTL, and the exploration of their applications. The relation of refinement quantification to other forms of propositional quantification over information change also needs further investigation."
    }, {
      "heading" : "Acknowledgements",
      "text" : "We acknowledge a very insightful and detailed review from a journal referee. Hans van Ditmarsch is also affiliated to IMSc (Institute of Mathematical Sciences), Chennai, India. We acknowledge support from ERC project EPS 313360, and from EU 7th Framework Programme under grant agreement no. 295261 (MEALS)."
    } ],
    "references" : [ {
      "title" : "Non-Well-Founded Sets",
      "author" : [ "P. Aczel" ],
      "venue" : "CSLI Publications, Stanford, CA",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "Alternating-time temporal logic",
      "author" : [ "R. Alur", "T.A. Henzinger", "O. Kupferman" ],
      "venue" : "Lecture Notes in Computer Science, 1536:23–60",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Alternating refinement relations",
      "author" : [ "Rajeev Alur", "Thomas A. Henzinger", "Orna Kupferman", "Moshe Y. Vardi" ],
      "venue" : "In International Conference on Concurrency Theory,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 1998
    }, {
      "title" : "20 years of modal and mixed specifications",
      "author" : [ "Adam Antonik", "Michael Huth", "Kim G. Larsen", "Ulrik Nyman", "Andrzej Wasowski" ],
      "venue" : "Bulletin of European Association of Theoretical Computer Science,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2008
    }, {
      "title" : "Rudiments of μ-calculus",
      "author" : [ "A. Arnold", "D. Niwinski" ],
      "venue" : "North Holland",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Characterizing updates in dynamic epistemic logic",
      "author" : [ "G. Aucher" ],
      "venue" : "Proceedings of Twelfth KR. AAAI Press",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "DEL-sequents for regression and epistemic planning",
      "author" : [ "G. Aucher" ],
      "venue" : "Journal of Applied Non-Classical Logics, 22(4):337–367",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "H",
      "author" : [ "P. Balbiani", "A. Baltag" ],
      "venue" : "van Ditmarsch, A. Herzig, T. Hoshi, and T. De Lima. ‘Knowable’ as ‘known after an announcement’. Review of Symbolic Logic, 1(3):305– 334",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "The logic of public announcements",
      "author" : [ "A. Baltag", "L.S. Moss", "S. Solecki" ],
      "venue" : "common knowledge, and private suspicions. In Proc. of 7th TARK, pages 43–56. Morgan Kaufmann",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Proof systems for the coalgebraic cover modality",
      "author" : [ "M. Bilkova", "A. Palmigiano", "Y. Venema" ],
      "venue" : "Carlos Areces and Robert Goldblatt, editors, Advances in Modal Logic, pages 1–21. College Publications",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "M",
      "author" : [ "P. Blackburn" ],
      "venue" : "de Rijke, and Y. Venema. Modal Logic. Cambridge University Press, Cambridge",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "The complexity of one-agent refinement modal logic",
      "author" : [ "Laura Bozzelli", "Hans P. van Ditmarsch", "Sophie Pinchinat" ],
      "venue" : null,
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2012
    }, {
      "title" : "Characterizing Kripke structures in temporal logic",
      "author" : [ "M. Browne", "E. Clarke", "O. Grümberg" ],
      "venue" : "H. Ehrig, R. Kowalski, G. Levi, and U. Montanari, editors, TAPSOFT ’87, LNCS 249, pages 256–270. Springer",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 1987
    }, {
      "title" : "Design and Verification of Synchronization Skeletons using Branching Time Temporal Logic",
      "author" : [ "E.M. Clarke", "E.A. Emerson" ],
      "venue" : "Proceedings of Workshop on Logic of Programs, LNCS 131, pages 52–71. Springer-Verlag",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 1981
    }, {
      "title" : "Logical questions concerning the μ-calculus: Interpolation, Lyndon and Los-Tarski",
      "author" : [ "G. d’Agostino", "M. Hollenberg" ],
      "venue" : "Journal of Symbolic Logic,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2000
    }, {
      "title" : "An axiomatization of bisimulation quantifiers via the μ-calculus",
      "author" : [ "G. d’Agostino", "G. Lenzi" ],
      "venue" : "Theor. Comput. Sci.,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2005
    }, {
      "title" : "A note on bisimulation quantifiers and fixed points over transitive frames",
      "author" : [ "G. d’Agostino", "G. Lenzi" ],
      "venue" : "J. Log. Comput.,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2008
    }, {
      "title" : "Extensions and Applications of Dynamic Epistemic Logic",
      "author" : [ "P. Economou" ],
      "venue" : "PhD thesis, Oxford University",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Reasoning about Knowledge",
      "author" : [ "R. Fagin", "J.Y. Halpern", "Y. Moses", "M.Y. Vardi" ],
      "venue" : "MIT Press, Cambridge MA",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Modal specifications for the control theory of discrete-event systems",
      "author" : [ "Guillaume Feuillade", "Sophie Pinchinat" ],
      "venue" : "Discrete Event Dynamic Systems,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2007
    }, {
      "title" : "Propositional quantifiers in modal logic",
      "author" : [ "K. Fine" ],
      "venue" : "Theoria, 36(3):336–346",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 1970
    }, {
      "title" : "Bisimulation quantifiers for modal logic",
      "author" : [ "T. French" ],
      "venue" : "PhD thesis, University of Western Australia",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Undecidability for arbitrary public announcement logic",
      "author" : [ "T. French", "H. van Ditmarsch" ],
      "venue" : "Advances in Modal Logic",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2008
    }, {
      "title" : "Reasoning about information change",
      "author" : [ "J.D. Gerbrandy", "W. Groeneveld" ],
      "venue" : "Journal of Logic, Language, and Information, 6:147–169",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "Refinement quantifiers for logics of belief and knowledge",
      "author" : [ "J. Hales" ],
      "venue" : "Honours Thesis, University of Western Australia",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Arbitrary action model logic and action model synthesis",
      "author" : [ "J. Hales" ],
      "venue" : "Proc. of 28th LICS, pages 253–262. IEEE",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Refinement quantified logics of knowledge",
      "author" : [ "J. Hales", "T. French", "R. Davies" ],
      "venue" : "Electr. Notes Theor. Comput. Sci., 278:85–98",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Refinement quantified logics of knowledge and belief for multiple agents",
      "author" : [ "J. Hales", "T. French", "R. Davies" ],
      "venue" : "Advances in Modal Logic 9, pages 317–338. College Publications",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Dynamic Logic",
      "author" : [ "D. Harel", "D. Kozen", "J. Tiuryn" ],
      "venue" : "MIT Press, Cambridge MA",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Automata for the modal mu-calculus and related results",
      "author" : [ "D. Janin", "I. Walukiewicz" ],
      "venue" : "Proc. of 20th MFCS, LNCS 969, pages 552–562. Springer",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "On the expressive completeness of the propositional mu-calculus with respect to monadic second order logic",
      "author" : [ "D. Janin", "I. Walukiewicz" ],
      "venue" : "Concurrency Theory, 7th International Conference, volume 1119 of LNCS, pages 263–277. Springer",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "Expressivity and completeness for public update logics via reduction axioms",
      "author" : [ "B. Kooi" ],
      "venue" : "Journal of Applied Non-Classical Logics, 17(2):231–254",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Module checking",
      "author" : [ "O. Kupferman", "M. Vardi", "P. Wolper" ],
      "venue" : "Information and Computation, 164(2):322–344",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Completeness of the finitary moss logic",
      "author" : [ "C. Kupke", "A. Kurz", "Y. Venema" ],
      "venue" : "C. Areces and R. Goldblatt, editors, Advances in Modal Logic 7, pages 193–217. College Publications",
      "citeRegEx" : "34",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Memoryless determinacy of parity games. In Automata logics, and infinite games, pages 95–106",
      "author" : [ "Ralf Küsters" ],
      "venue" : null,
      "citeRegEx" : "35",
      "shortCiteRegEx" : "35",
      "year" : 2002
    }, {
      "title" : "Modal I/O automata for interface and product line theories",
      "author" : [ "Kim G. Larsen", "Ulrik Nyman", "Andrzej Wasowski" ],
      "venue" : "In Proceedings of the 16th European Symposium on Programming (ESOP’07),",
      "citeRegEx" : "36",
      "shortCiteRegEx" : "36",
      "year" : 2007
    }, {
      "title" : "An algorithmic approach to knowledge evolution",
      "author" : [ "A.R. Lomuscio", "M.D. Ryan" ],
      "venue" : "Artificial Intelligence for Engineering Design, Analysis and Manufacturing (AIEDAM), 13(2)",
      "citeRegEx" : "37",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Infinite games. Automata logics, and infinite games, pages 197–204",
      "author" : [ "René Mazala" ],
      "venue" : null,
      "citeRegEx" : "38",
      "shortCiteRegEx" : "38",
      "year" : 2002
    }, {
      "title" : "The undecidability of iterated modal relativization",
      "author" : [ "J.S. Miller", "L.S. Moss" ],
      "venue" : "Studia Logica, 79(3):373–407",
      "citeRegEx" : "39",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Programming from Specifications: Second Edition",
      "author" : [ "C. Morgan" ],
      "venue" : "Prentice Hall International, Hempstead, UK",
      "citeRegEx" : "40",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "Topology and epistemic logic",
      "author" : [ "R. Parikh", "L.S. Moss", "C. Steinsvold" ],
      "venue" : "M. Aiello, I. Pratt-Hartmann, and J. van Benthem, editors, Handbook of Spatial Logics, pages 299–341. Springer Verlag",
      "citeRegEx" : "41",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Logic for social software",
      "author" : [ "M. Pauly" ],
      "venue" : "PhD thesis, University of Amsterdam",
      "citeRegEx" : "42",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Logics of public communications",
      "author" : [ "J.A. Plaza" ],
      "venue" : "Proc. of the 4th ISMIS, pages 201–216. Oak Ridge National Laboratory",
      "citeRegEx" : "43",
      "shortCiteRegEx" : null,
      "year" : 1989
    }, {
      "title" : "Quotient de spécifications pour la réutilisation de composants",
      "author" : [ "Jean-Baptiste Raclet" ],
      "venue" : "PhD thesis, Université de Rennes I, December",
      "citeRegEx" : "44",
      "shortCiteRegEx" : "44",
      "year" : 2007
    }, {
      "title" : "Residual for component specifications",
      "author" : [ "Jean-Baptiste Raclet" ],
      "venue" : "In Proc. of the 4th International Workshop on Formal Aspects of Component Software (FACS’07),",
      "citeRegEx" : "45",
      "shortCiteRegEx" : "45",
      "year" : 2008
    }, {
      "title" : "Why are modalities good for interface theories",
      "author" : [ "Jean-Baptiste Raclet", "Eric Badouel", "Albert Benveniste", "Benoit Caillaud", "Roberto Passerone" ],
      "venue" : "In Proceedings of the 9th International Conference on Application of Concurrency to System Design (ACSD’09),",
      "citeRegEx" : "46",
      "shortCiteRegEx" : "46",
      "year" : 2009
    }, {
      "title" : "On the supervisory control of discrete event systems",
      "author" : [ "P. Ramadge", "W. Wonham" ],
      "venue" : "Proc. of the IEEE, pages 81–98",
      "citeRegEx" : "47",
      "shortCiteRegEx" : null,
      "year" : 1989
    }, {
      "title" : "Quantified mu-calculus for control synthesis",
      "author" : [ "Stéphane Riedweg", "Sophie Pinchinat" ],
      "venue" : "MFCS, volume 2747 of Lecture Notes in Computer Science,",
      "citeRegEx" : "48",
      "shortCiteRegEx" : "48",
      "year" : 2003
    }, {
      "title" : "Agents and roles: Refinement in alternating-time temporal logic",
      "author" : [ "M. Ryan", "P.-Y. Schobbens" ],
      "venue" : "Revised Papers from the 8th International Workshop on Intelligent Agents VIII (ATAL ’01), pages 100–114. Springer",
      "citeRegEx" : "49",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "The Complementation Problem for Buchi Automata with Appplications to Temporal Logic",
      "author" : [ "A.P. Sistla", "M.Y. Vardi", "P. Wolper" ],
      "venue" : "Theoretical Computer Science, 49:217–237",
      "citeRegEx" : "50",
      "shortCiteRegEx" : null,
      "year" : 1987
    }, {
      "title" : "On the control of discrete event dynamical systems",
      "author" : [ "J. Tsitsoklis" ],
      "venue" : "Mathematics of Control Signals and Systems, 2(2):95–107",
      "citeRegEx" : "51",
      "shortCiteRegEx" : null,
      "year" : 1989
    }, {
      "title" : "An essay on sabotage and obstruction",
      "author" : [ "J. van Benthem" ],
      "venue" : "In Mechanizing Mathematical Reasoning,",
      "citeRegEx" : "52",
      "shortCiteRegEx" : "52",
      "year" : 2005
    }, {
      "title" : "One is a lonely number: on the logic of communication",
      "author" : [ "J. van Benthem" ],
      "venue" : "In Logic colloquium 2002. Lecture Notes in Logic,",
      "citeRegEx" : "53",
      "shortCiteRegEx" : "53",
      "year" : 2006
    }, {
      "title" : "Quantifying notes",
      "author" : [ "H. van Ditmarsch" ],
      "venue" : "In Proc. of 19th WoLLIC,",
      "citeRegEx" : "54",
      "shortCiteRegEx" : "54",
      "year" : 2012
    }, {
      "title" : "Simulation and information",
      "author" : [ "H. van Ditmarsch", "T. French" ],
      "venue" : "Presented at LOFT 2008 and KRAMAS",
      "citeRegEx" : "55",
      "shortCiteRegEx" : "55",
      "year" : 2008
    }, {
      "title" : "Future event logic - axioms and complexity",
      "author" : [ "H. van Ditmarsch", "T. French", "S. Pinchinat" ],
      "venue" : "Advances in Modal Logic, Moscow,",
      "citeRegEx" : "56",
      "shortCiteRegEx" : "56",
      "year" : 2010
    }, {
      "title" : "Dynamic Epistemic Logic, volume 337 of Synthese Library",
      "author" : [ "H. van Ditmarsch", "W. van der Hoek", "B. Kooi" ],
      "venue" : null,
      "citeRegEx" : "57",
      "shortCiteRegEx" : "57",
      "year" : 2007
    }, {
      "title" : "Lecture notes on the modal μ-calculus",
      "author" : [ "Y. Venema" ],
      "venue" : "(Draft)",
      "citeRegEx" : "58",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Completeness of Kozen’s axiomatisation of the propositional mucalculus",
      "author" : [ "I. Walukiewicz" ],
      "venue" : "INFCTRL: Information and Computation (formerly Information and Control), 157",
      "citeRegEx" : "59",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "An alternative logic for knowability",
      "author" : [ "X. Wen", "H. Liu", "F. Huang" ],
      "venue" : "Logic, Rationality, and Interaction (Proceedings of LORI-3), LNCS 6953, pages 342–355. Springer",
      "citeRegEx" : "60",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "CTL is exponentially more succinct than CTL",
      "author" : [ "T. Wilke" ],
      "venue" : "Proc. 19th FSTTCS, LNCS 1738, pages 110–121. Springer",
      "citeRegEx" : "61",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Using Z — Specification",
      "author" : [ "J. Woodcock", "J. Davies" ],
      "venue" : "Refinement and Proof. Prentice Hall",
      "citeRegEx" : "62",
      "shortCiteRegEx" : null,
      "year" : 1996
    } ],
    "referenceMentions" : [ {
      "referenceID" : 54,
      "context" : "In [55] the future event logic is introduced.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 7,
      "context" : "” The proposal was a generalization of a so-called arbitrary public announcement logic with an operator for “φ holds after all announcements” [8].",
      "startOffset" : 142,
      "endOffset" : 145
    }, {
      "referenceID" : 8,
      "context" : "[9]: on finite models, it can be easily shown that a model resulting from action model execution is a refinement of the initial model, and for a given refinement of a model we can construct an action model such that the result of its execution is bisimilar to that refinement.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 55,
      "context" : "In [56] an axiomatization of the single-agent version of this logic is presented, and also expressivity and complexity results.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 54,
      "context" : "Thus we may consider refinement modal logic to be a more abstract perspective of future event logic [55] applicable to other modal logics.",
      "startOffset" : 100,
      "endOffset" : 104
    }, {
      "referenceID" : 41,
      "context" : "In logics for games [42, 2] or in control theory [47, 51], it may correspond to a player discarding some moves; for program logics [29] it may correspond to operational refinement [40]; and for logics for spatial reasoning it may correspond to sub-space projections [41].",
      "startOffset" : 20,
      "endOffset" : 27
    }, {
      "referenceID" : 1,
      "context" : "In logics for games [42, 2] or in control theory [47, 51], it may correspond to a player discarding some moves; for program logics [29] it may correspond to operational refinement [40]; and for logics for spatial reasoning it may correspond to sub-space projections [41].",
      "startOffset" : 20,
      "endOffset" : 27
    }, {
      "referenceID" : 46,
      "context" : "In logics for games [42, 2] or in control theory [47, 51], it may correspond to a player discarding some moves; for program logics [29] it may correspond to operational refinement [40]; and for logics for spatial reasoning it may correspond to sub-space projections [41].",
      "startOffset" : 49,
      "endOffset" : 57
    }, {
      "referenceID" : 50,
      "context" : "In logics for games [42, 2] or in control theory [47, 51], it may correspond to a player discarding some moves; for program logics [29] it may correspond to operational refinement [40]; and for logics for spatial reasoning it may correspond to sub-space projections [41].",
      "startOffset" : 49,
      "endOffset" : 57
    }, {
      "referenceID" : 28,
      "context" : "In logics for games [42, 2] or in control theory [47, 51], it may correspond to a player discarding some moves; for program logics [29] it may correspond to operational refinement [40]; and for logics for spatial reasoning it may correspond to sub-space projections [41].",
      "startOffset" : 131,
      "endOffset" : 135
    }, {
      "referenceID" : 39,
      "context" : "In logics for games [42, 2] or in control theory [47, 51], it may correspond to a player discarding some moves; for program logics [29] it may correspond to operational refinement [40]; and for logics for spatial reasoning it may correspond to sub-space projections [41].",
      "startOffset" : 180,
      "endOffset" : 184
    }, {
      "referenceID" : 40,
      "context" : "In logics for games [42, 2] or in control theory [47, 51], it may correspond to a player discarding some moves; for program logics [29] it may correspond to operational refinement [40]; and for logics for spatial reasoning it may correspond to sub-space projections [41].",
      "startOffset" : 266,
      "endOffset" : 270
    }, {
      "referenceID" : 18,
      "context" : "Previous works [19, 37] employed a notion of refinement.",
      "startOffset" : 15,
      "endOffset" : 23
    }, {
      "referenceID" : 36,
      "context" : "Previous works [19, 37] employed a notion of refinement.",
      "startOffset" : 15,
      "endOffset" : 23
    }, {
      "referenceID" : 36,
      "context" : "In [37] it was shown that model restrictions were not sufficient to simulate informative events, and they introduced refinement trees for this purpose — a precursor of the dynamic epistemic logics developed later (for an overview, see [57]).",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 56,
      "context" : "In [37] it was shown that model restrictions were not sufficient to simulate informative events, and they introduced refinement trees for this purpose — a precursor of the dynamic epistemic logics developed later (for an overview, see [57]).",
      "startOffset" : 235,
      "endOffset" : 239
    }, {
      "referenceID" : 61,
      "context" : "[62], refinement of datatypes is considered such that (datatype) C refines A if A simulates C.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 0,
      "context" : "This usage of refinement as the converse of simulation [1, 11] comes close to ours — in fact, it inspired us to propose a similar notion, although the correspondence is otherwise not very close.",
      "startOffset" : 55,
      "endOffset" : 62
    }, {
      "referenceID" : 10,
      "context" : "This usage of refinement as the converse of simulation [1, 11] comes close to ours — in fact, it inspired us to propose a similar notion, although the correspondence is otherwise not very close.",
      "startOffset" : 55,
      "endOffset" : 62
    }, {
      "referenceID" : 61,
      "context" : "A similar usage of refinement as in [62] is found in [3, 4].",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 2,
      "context" : "A similar usage of refinement as in [62] is found in [3, 4].",
      "startOffset" : 53,
      "endOffset" : 59
    }, {
      "referenceID" : 3,
      "context" : "A similar usage of refinement as in [62] is found in [3, 4].",
      "startOffset" : 53,
      "endOffset" : 59
    }, {
      "referenceID" : 44,
      "context" : "In the theory of modal specifications a refinement preorder is used, known as modal refinement [45, 49].",
      "startOffset" : 95,
      "endOffset" : 103
    }, {
      "referenceID" : 48,
      "context" : "In the theory of modal specifications a refinement preorder is used, known as modal refinement [45, 49].",
      "startOffset" : 95,
      "endOffset" : 103
    }, {
      "referenceID" : 16,
      "context" : "Our work is closely related to some recent work on bisimulation quantified modal logics [17, 22].",
      "startOffset" : 88,
      "endOffset" : 96
    }, {
      "referenceID" : 21,
      "context" : "Our work is closely related to some recent work on bisimulation quantified modal logics [17, 22].",
      "startOffset" : 88,
      "endOffset" : 96
    }, {
      "referenceID" : 54,
      "context" : "The refinement operator, seen as refinement quantifier, is weaker than a bisimulation quantifier [55], as it is only based on simulations rather than bisimulations, and as it only allows us to vary the interpretation of a propositional variable that does not occur in the formula bound by it.",
      "startOffset" : 97,
      "endOffset" : 101
    }, {
      "referenceID" : 15,
      "context" : "Bisimulation quantified modal logic has previously been axiomatized by providing a provably correct translation to the modal μ-calculus [16].",
      "startOffset" : 136,
      "endOffset" : 140
    }, {
      "referenceID" : 15,
      "context" : "Cover logic The cover operator ∇ has also been used as a syntactic primitive in modal logics [16].",
      "startOffset" : 93,
      "endOffset" : 97
    }, {
      "referenceID" : 9,
      "context" : "It has recently been axiomatized [10].",
      "startOffset" : 33,
      "endOffset" : 37
    }, {
      "referenceID" : 9,
      "context" : "Cover logic K∇ is equally expressive as modal logic K (also in the multi-agent version) [10, 34].",
      "startOffset" : 88,
      "endOffset" : 96
    }, {
      "referenceID" : 33,
      "context" : "Cover logic K∇ is equally expressive as modal logic K (also in the multi-agent version) [10, 34].",
      "startOffset" : 88,
      "endOffset" : 96
    }, {
      "referenceID" : 30,
      "context" : "Every L formula is equivalent to a disjunctive L formula [31].",
      "startOffset" : 57,
      "endOffset" : 61
    }, {
      "referenceID" : 57,
      "context" : "Every L formula is equivalent to a disjunctive L formula [58].",
      "startOffset" : 57,
      "endOffset" : 61
    }, {
      "referenceID" : 14,
      "context" : "43] a bisimulation quantifier characterization of fixed points is given (the details of which are deferred to Section 6 on refinement μ-calculus, where they are pertinent), and from [15] we know that bisimulation quantifiers are also expressible in the modal μ-calculus.",
      "startOffset" : 182,
      "endOffset" : 186
    }, {
      "referenceID" : 15,
      "context" : "For more information on the modal μ-calculus, see [16, 58].",
      "startOffset" : 50,
      "endOffset" : 58
    }, {
      "referenceID" : 57,
      "context" : "For more information on the modal μ-calculus, see [16, 58].",
      "startOffset" : 50,
      "endOffset" : 58
    }, {
      "referenceID" : 10,
      "context" : ", the truth and falsity) of atoms, whereas [11] has them only preserve the truth of propositional variables in a simulation—and presumably preserve their falsity in a refinement.",
      "startOffset" : 43,
      "endOffset" : 47
    }, {
      "referenceID" : 10,
      "context" : "Another, inessential, difference with [11] is that in their case atoms and forth are required for all modalities (in the similarity type), i.",
      "startOffset" : 38,
      "endOffset" : 42
    }, {
      "referenceID" : 39,
      "context" : "This is perhaps contrary to the concept of program refinement [40] where detail is added to a specification.",
      "startOffset" : 62,
      "endOffset" : 66
    }, {
      "referenceID" : 2,
      "context" : "It is folklore to associate a (infinite duration) two-player game with refinement, in the spirit of [3].",
      "startOffset" : 100,
      "endOffset" : 103
    }, {
      "referenceID" : 37,
      "context" : "Remark 6 One easily sees that the refinement game of Definition 5 is a particular parity game [38].",
      "startOffset" : 94,
      "endOffset" : 98
    }, {
      "referenceID" : 34,
      "context" : "Henceforth, according to [35], the refinement game is determined, and memoryless strategies suffice.",
      "startOffset" : 25,
      "endOffset" : 29
    }, {
      "referenceID" : 8,
      "context" : "We recall another important result connecting structural refinement to action model execution [9].",
      "startOffset" : 94,
      "endOffset" : 97
    }, {
      "referenceID" : 54,
      "context" : "For full details, see [55].",
      "startOffset" : 22,
      "endOffset" : 26
    }, {
      "referenceID" : 12,
      "context" : "Now in a finite model, we can single out states (up to bisimilarity) by a distinguishing formula [13].",
      "startOffset" : 97,
      "endOffset" : 101
    }, {
      "referenceID" : 35,
      "context" : "Modal specifications are classic, convenient, and expressive mathematical objects that represent interfaces of component-based systems [36, 44, 45, 46, 4, 49].",
      "startOffset" : 135,
      "endOffset" : 158
    }, {
      "referenceID" : 43,
      "context" : "Modal specifications are classic, convenient, and expressive mathematical objects that represent interfaces of component-based systems [36, 44, 45, 46, 4, 49].",
      "startOffset" : 135,
      "endOffset" : 158
    }, {
      "referenceID" : 44,
      "context" : "Modal specifications are classic, convenient, and expressive mathematical objects that represent interfaces of component-based systems [36, 44, 45, 46, 4, 49].",
      "startOffset" : 135,
      "endOffset" : 158
    }, {
      "referenceID" : 45,
      "context" : "Modal specifications are classic, convenient, and expressive mathematical objects that represent interfaces of component-based systems [36, 44, 45, 46, 4, 49].",
      "startOffset" : 135,
      "endOffset" : 158
    }, {
      "referenceID" : 3,
      "context" : "Modal specifications are classic, convenient, and expressive mathematical objects that represent interfaces of component-based systems [36, 44, 45, 46, 4, 49].",
      "startOffset" : 135,
      "endOffset" : 158
    }, {
      "referenceID" : 48,
      "context" : "Modal specifications are classic, convenient, and expressive mathematical objects that represent interfaces of component-based systems [36, 44, 45, 46, 4, 49].",
      "startOffset" : 135,
      "endOffset" : 158
    }, {
      "referenceID" : 43,
      "context" : "The components that implement such interfaces are deterministic automata; an alternative language-based semantics can therefore be considered, as presented in [44, 45].",
      "startOffset" : 159,
      "endOffset" : 167
    }, {
      "referenceID" : 44,
      "context" : "The components that implement such interfaces are deterministic automata; an alternative language-based semantics can therefore be considered, as presented in [44, 45].",
      "startOffset" : 159,
      "endOffset" : 167
    }, {
      "referenceID" : 19,
      "context" : "Modal specifications are interpreted as logical specifications matching the conjunctive ν-calculus fragment of the μ-calculus [20].",
      "startOffset" : 126,
      "endOffset" : 130
    }, {
      "referenceID" : 54,
      "context" : "From prior publications [55, 56] refinement modal logic is known as ‘future event logic’.",
      "startOffset" : 24,
      "endOffset" : 32
    }, {
      "referenceID" : 55,
      "context" : "From prior publications [55, 56] refinement modal logic is known as ‘future event logic’.",
      "startOffset" : 24,
      "endOffset" : 32
    }, {
      "referenceID" : 54,
      "context" : "In the final part of this section we relate these semantics to the well-known frameworks action model logic and bisimulation quantified logic (and see also [55]).",
      "startOffset" : 156,
      "endOffset" : 160
    }, {
      "referenceID" : 55,
      "context" : "See [56, 27].",
      "startOffset" : 4,
      "endOffset" : 12
    }, {
      "referenceID" : 26,
      "context" : "See [56, 27].",
      "startOffset" : 4,
      "endOffset" : 12
    }, {
      "referenceID" : 22,
      "context" : "If these logics were equally expressive, action model logic with quantification would be decidable—a surprising fact, given that public announcement logic with quantification over public announcements (singleton action models) is undecidable [23].",
      "startOffset" : 242,
      "endOffset" : 246
    }, {
      "referenceID" : 47,
      "context" : "The the control problem [48], known as the question “is there a way to control actions c of the system S so that property φ is guaranteed?”, can be expressed in L∀ by wondering whether S |= ∃cφ .",
      "startOffset" : 24,
      "endOffset" : 28
    }, {
      "referenceID" : 32,
      "context" : "Themodule checking problem [33] is the problem of determining whether an open system satisfies a given property.",
      "startOffset" : 27,
      "endOffset" : 31
    }, {
      "referenceID" : 52,
      "context" : "For the syntactic correspondence we first introduce the notion of relativization (for settings in modal logic, see [53, 39]).",
      "startOffset" : 115,
      "endOffset" : 123
    }, {
      "referenceID" : 38,
      "context" : "For the syntactic correspondence we first introduce the notion of relativization (for settings in modal logic, see [53, 39]).",
      "startOffset" : 115,
      "endOffset" : 123
    }, {
      "referenceID" : 38,
      "context" : "From the modal logical literature, the approach in [39] is arrow-eliminating but that in [53] is state-eliminating.",
      "startOffset" : 51,
      "endOffset" : 55
    }, {
      "referenceID" : 52,
      "context" : "From the modal logical literature, the approach in [39] is arrow-eliminating but that in [53] is state-eliminating.",
      "startOffset" : 89,
      "endOffset" : 93
    }, {
      "referenceID" : 42,
      "context" : "The difference between state-eliminating relativization and arrow-eliminating relativization is similar to the difference between state-eliminating public announcement semantics [43, 9] and arrow-eliminating public announcement semantics [32, 24], in the area of dynamic epistemic logic.",
      "startOffset" : 178,
      "endOffset" : 185
    }, {
      "referenceID" : 8,
      "context" : "The difference between state-eliminating relativization and arrow-eliminating relativization is similar to the difference between state-eliminating public announcement semantics [43, 9] and arrow-eliminating public announcement semantics [32, 24], in the area of dynamic epistemic logic.",
      "startOffset" : 178,
      "endOffset" : 185
    }, {
      "referenceID" : 31,
      "context" : "The difference between state-eliminating relativization and arrow-eliminating relativization is similar to the difference between state-eliminating public announcement semantics [43, 9] and arrow-eliminating public announcement semantics [32, 24], in the area of dynamic epistemic logic.",
      "startOffset" : 238,
      "endOffset" : 246
    }, {
      "referenceID" : 23,
      "context" : "The difference between state-eliminating relativization and arrow-eliminating relativization is similar to the difference between state-eliminating public announcement semantics [43, 9] and arrow-eliminating public announcement semantics [32, 24], in the area of dynamic epistemic logic.",
      "startOffset" : 238,
      "endOffset" : 246
    }, {
      "referenceID" : 2,
      "context" : "Alternating transition systems (ATS) were introduced [3] to model multi-agent systems, where in each move of the game between the agents of an ATS, the choice of an agent at a state is a set of states and the successor state is determined by considering the intersection of the choices made by all agents.",
      "startOffset" : 53,
      "endOffset" : 56
    }, {
      "referenceID" : 1,
      "context" : "Soon after, the more general setting of alternating-time temporal logics [2] considered universal and existential quantifications over a-refinements, for arbitrary a, combined with LTL formulas.",
      "startOffset" : 73,
      "endOffset" : 76
    }, {
      "referenceID" : 24,
      "context" : "We can see that Ms a M Φ s , via the relation R Φ = {(s, s)} ∪ I ∪ ⋃ φ∈Φ R φ where I is the identity on S and each R is the refinement relation corresponding to Mtφ a N φ uφ (see also [25]).",
      "startOffset" : 184,
      "endOffset" : 188
    }, {
      "referenceID" : 24,
      "context" : "We can see that Ms a M Φ s , via the relation R Φ = {(s, s)} ∪ I ∪ ⋃ φ∈Φ R φ where I is the identity on S and each R is the refinement relation corresponding to Mtφ a N φ uφ (see also [25]).",
      "startOffset" : 184,
      "endOffset" : 188
    }, {
      "referenceID" : 55,
      "context" : "The single-agent axiomatization was presented in [56].",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 55,
      "context" : "In [56] it is used that every refinement modal logical formula is equivalent to a formula in cover logic with the special syntax φ ::= ⊥ | ⊤ | φ ∨ φ | p ∧ φ | ¬p ∧ φ | ∇{φ, .",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 9,
      "context" : ", φ} [10, 34], plus induction on that form.",
      "startOffset" : 5,
      "endOffset" : 13
    }, {
      "referenceID" : 33,
      "context" : ", φ} [10, 34], plus induction on that form.",
      "startOffset" : 5,
      "endOffset" : 13
    }, {
      "referenceID" : 26,
      "context" : "For details, see [27].",
      "startOffset" : 17,
      "endOffset" : 21
    }, {
      "referenceID" : 21,
      "context" : "A study of how various classes of models affect the properties of bisimulation quantified logics is given in [22].",
      "startOffset" : 109,
      "endOffset" : 113
    }, {
      "referenceID" : 26,
      "context" : "Refinement epistemic logics are investigated in [27, 25].",
      "startOffset" : 48,
      "endOffset" : 56
    }, {
      "referenceID" : 24,
      "context" : "Refinement epistemic logics are investigated in [27, 25].",
      "startOffset" : 48,
      "endOffset" : 56
    }, {
      "referenceID" : 24,
      "context" : "In [25] a multi-agentKD45 axiomatization is also reported.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 14,
      "context" : "From [15] we know that bisimulation quantifiers are also expressible in the modal μ-calculus, and thus these equivalences also hold in the modal μ-calculus.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 4,
      "context" : "1 still apply and the soundness of F1 and F2 are well known [5], so we are left to show that R and R are sound.",
      "startOffset" : 60,
      "endOffset" : 63
    }, {
      "referenceID" : 29,
      "context" : "An explicit construction for Nu can be given via the tableaux of Janin and Walukiewicz [30].",
      "startOffset" : 87,
      "endOffset" : 91
    }, {
      "referenceID" : 4,
      "context" : "∃φ of [5] which tells that Ms |= μx.",
      "startOffset" : 6,
      "endOffset" : 9
    }, {
      "referenceID" : 58,
      "context" : "As φ is ∃-free, it is semantically equivalent to a formula in disjunctive normal form, and by the completeness of Kozen’s axiom system [59] this equivalence is provable in RML.",
      "startOffset" : 135,
      "endOffset" : 139
    }, {
      "referenceID" : 58,
      "context" : "As ψ is valid, it must be provable since Prop, K, F1, F2, NecK, and MP give a sound and complete proof system for the modal μ-calculus [59].",
      "startOffset" : 135,
      "endOffset" : 139
    }, {
      "referenceID" : 55,
      "context" : "Unfortunately we were not able to corroborate in this paper the upper complexity claims for RML reported in [56].",
      "startOffset" : 108,
      "endOffset" : 112
    }, {
      "referenceID" : 13,
      "context" : "First, we recall a fragment, written CTL, of the standard branching-time logic Computation Tree Logic (CTL) [14], which in turn is a fragment of L (see also the example Section 4.",
      "startOffset" : 108,
      "endOffset" : 112
    }, {
      "referenceID" : 49,
      "context" : "Theorem 48 is proved by a polynomial-time reduction from satisfiability of Quantified Propositional Temporal Logic (QPTL) [50].",
      "startOffset" : 122,
      "endOffset" : 126
    }, {
      "referenceID" : 49,
      "context" : "Theorem 49 [50] Let k ≥ 0.",
      "startOffset" : 11,
      "endOffset" : 15
    }, {
      "referenceID" : 60,
      "context" : "For this, we use a well-known automata-characterization of (oneagent) L in terms of parity symmetric alternating (finite-state) automata (PSAA) which operate on pointed models [61].",
      "startOffset" : 176,
      "endOffset" : 180
    }, {
      "referenceID" : 60,
      "context" : "Proposition 59 [61] Given a one-agent L formula φ over P , one can construct a PSAA Aφ with O(|φ|) locations whose language is the set of pointed models over P satisfying φ.",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 11,
      "context" : "In [12] it was established that the complexity of refinement modal logic for a single agent is AEXPpol-complete, which means that the satisfiability of an RML formula can be decided by an exponential-time bounded Alternating Turing Machine with a linearly-bounded number of alternations.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 27,
      "context" : "In [28] an axiomatization of the multi-agent refinement modal logic of knowledge is given, among other results.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 7,
      "context" : "As a generalization of quantifying over announcements (arbitrary announcements), in [8] semantics were also given for quantifying over action models and the question was posed how to axiomatize this logic: in [26] it is shown that quantifying over action models is equally expressive as the refinement quantifier, i.",
      "startOffset" : 84,
      "endOffset" : 87
    }, {
      "referenceID" : 25,
      "context" : "As a generalization of quantifying over announcements (arbitrary announcements), in [8] semantics were also given for quantifying over action models and the question was posed how to axiomatize this logic: in [26] it is shown that quantifying over action models is equally expressive as the refinement quantifier, i.",
      "startOffset" : 209,
      "endOffset" : 213
    }, {
      "referenceID" : 53,
      "context" : "This answers one of the open questions on logics with quantification over information change, posed in the recent survey [54].",
      "startOffset" : 121,
      "endOffset" : 125
    }, {
      "referenceID" : 51,
      "context" : "That survey also puts various other proposals on propositional quantification in perspective, such as [52], [18], [7] (going back to [6]), and [60]—for details, see [54].",
      "startOffset" : 102,
      "endOffset" : 106
    }, {
      "referenceID" : 17,
      "context" : "That survey also puts various other proposals on propositional quantification in perspective, such as [52], [18], [7] (going back to [6]), and [60]—for details, see [54].",
      "startOffset" : 108,
      "endOffset" : 112
    }, {
      "referenceID" : 6,
      "context" : "That survey also puts various other proposals on propositional quantification in perspective, such as [52], [18], [7] (going back to [6]), and [60]—for details, see [54].",
      "startOffset" : 114,
      "endOffset" : 117
    }, {
      "referenceID" : 5,
      "context" : "That survey also puts various other proposals on propositional quantification in perspective, such as [52], [18], [7] (going back to [6]), and [60]—for details, see [54].",
      "startOffset" : 133,
      "endOffset" : 136
    }, {
      "referenceID" : 59,
      "context" : "That survey also puts various other proposals on propositional quantification in perspective, such as [52], [18], [7] (going back to [6]), and [60]—for details, see [54].",
      "startOffset" : 143,
      "endOffset" : 147
    }, {
      "referenceID" : 53,
      "context" : "That survey also puts various other proposals on propositional quantification in perspective, such as [52], [18], [7] (going back to [6]), and [60]—for details, see [54].",
      "startOffset" : 165,
      "endOffset" : 169
    }, {
      "referenceID" : 20,
      "context" : "It should not be forgotten to mention that many of these, including our own proposal, go back to the original publication [21].",
      "startOffset" : 122,
      "endOffset" : 126
    } ],
    "year" : 2013,
    "abstractText" : "In this paper we present refinement modal logic. A refinement is like a bisimulation, except that from the three relational requirements only ‘atoms’ and ‘back’ need to be satisfied. Our logic contains a new operator ∀ in addition to the standard modalities 2 for each agent. The operator ∀ acts as a quantifier over the set of all refinements of a given model. As a variation on a bisimulation quantifier, this refinement operator or refinement quantifier ∀ can be seen as quantifying over a variable not occurring in the formula bound by it. The logic combines the simplicity of multi-agent modal logic with some powers of monadic second-order quantification. We present a sound and complete axiomatization of multi-agent refinement modal logic. We also present an extension of the logic to the modal μ-calculus, and an axiomatization for the single-agent version of this logic. Examples and applications are also discussed: to software verification and design (the set of agents can also be seen as a set of actions), and to dynamic epistemic logic. We further give detailed results on the complexity of satisfiability, and on succinctness.",
    "creator" : "LaTeX with hyperref package"
  }
}