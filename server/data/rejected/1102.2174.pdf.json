{
  "name" : "1102.2174.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Vincent Aravantinos", "Ricardo Caferra", "Nicolas Peltier" ],
    "emails" : [ "vincent.aravantinos@imag.fr", "ricardo.caferra@imag.fr", "nicolas.peltier@imag.fr" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n10 2.\n21 74\nv2 [\ncs .L\nO ]\n1 9\nA pr"
    }, {
      "heading" : "1 Introduction",
      "text" : "Linear Temporal Logic (LTL) is a very well-known logic introduced in [Pnu77] for verifying computer programs. It is widely used to reason on finite state transition systems. On the other hand, propositional schemata have been introduced in [ACP09]. They extend the language of propositional logic with indexed propositions (such as pn, p1 or pi+1) and iterated connectives of the form\n∨n i=0 φ or∧n\ni=0 φ. Notice that n denotes a parameter, which must be interpreted as a natural number. If arbitrary expressions for indices and iterations are allowed in the schema, then the satisfiability problem is undecidable, but we have identified in [ACP09,ACP10a,ACP11] some subclasses for which this problem is decidable. The simplest of these classes is called regular : it is defined by restricting both the indices of the propositions, that must be of the form k or n+ k where k ∈ Z and n is a variable, and iterations, that must be non-nested and of the form ∧n+l\ni=k φ where n is a variable and k, l ∈ Z. Decision procedures are designed in [ACP09,ACP10a] and an implementation is available [ACP10c].\nLTL and propositional schemata share many common features and trying to compare them precisely is a rather natural and, hopefully, fruitful idea. In both logics, interpretations can be viewed as arrays of propositional functions and the formulae relate the values of these functions at different states. The indices of the propositions in the schematic case may be viewed as the time in LTL. Thus comparing the expressing powers and complexities of those two logics, and, if possible, defining translations from one logic to the other is a natural and potentially rewarding issue. Notice that there already exist several results relating\n⋆ This work has been partly funded by the project ASAP of the French Agence Nationale de la Recherche (ANR-09-BLAN-04-07-01)\nLTL to other formalisms like monadic second order logic via Büchi automata [WVS83], monadic first order logic over natural numbers [GPSS80] or star-free regular languages [Tho79]. However, there is a fundamental difference between these languages and the logic of schemata: they deal with infinite objects (infinite interpretations in the case of LTL or first order logic over natural numbers, infinite words in the case of star-free regular languages), whereas schemata deal with intrinsically finite (but unbounded) interpretations. This subtle but important difference introduces difficulties in the definition of such translations. This topic bears some similarities with the approach of [CNP94] where problems on Bücchi automata are reduced to problems on finite automata by using the ultimately periodic property of ω-regular languages.\nNote that finite interpretation is sometimes a desired feature: restricting LTL to finite traces has been considered in [EFH+03], and has applications in, e.g., planning or runtime verification [BK95,BM06,BH10]. It can be argued that the use of LTL in such contexts is a bit overkilling. Indeed, often, rather than considering finite traces per se, the preferred approach is to turn them into infinite traces by infinitely repeating the last state. It seems to us that it would be more natural to use schemata for such applications. In the present work, it is shown that doing so entails no loss in expressive power.\nIn the present paper, we show that LTL is equivalent to a particular subclass of regular schemata, referred to as sequential. More precisely, we define functions effectively translating formulae from one logic into the other and show that this transformation preserves satisfiability. We believe that these results are interesting from a theoretical perspective since they provide useful information about the expressive power of the respective formalisms. Furthermore they allow to import the complexity results of LTL into schemata. From a practical point of view, the existence of a polynomial reduction from a class of propositional schemata into LTL allows one to benefit from the many existing efficient decision procedures for this logic (tableaux methods, e.g. [Wol85,Sch98], resolution-based methods, e.g. [FDP01], or reductions to model checking, e.g. [RV07,DWDMR08]), implementations [BHS98,HK03,CCG+02,DWDMR08] and experimentation tools [GHLS05]. Conversely, the reverse reduction might give further ideas for the design of new techniques to decide LTL satisfiability. In particular, since a Dpll-based procedure exists for regular schemata [ACP10a], it might help to design such a procedure for LTL. On another hand, this reduction is very reminiscent of the translation from LTL to propositional logic encountered in bounded model checking (BMC) [BCC+03]. Contrarily to BMC however, our reduction is complete, it might thus give new ideas to achieve completeness in BMC.\nThe paper is structured as follows. In Section 2 we define LTL and the logic of propositional schemata. In Section 3 we show how to relate the interpretations of both formalisms. A polynomial algorithm transforming any sequential schema into an equivalent LTL formula is presented in Section 4, and Section 5 tackles the reverse translation, i.e. from LTL formulae to schemata. Section 6 presents the results about first experiments with those translations and sketches the possible\nimprovements inspired by those experiments. Section 7 presents pros and cons of each logic, and make a very informal comparison of how LTL procedures behave on schema modulo the given translation, and, conversely, how schemata procedures behave on LTL formulae. Of course, with the given translations and the usual reduction of model checking to satisfiability, one can do model checking with schemata, Section 8 gives an example of such model checking. Finally, Section 9 briefly concludes our work."
    }, {
      "heading" : "2 Definitions and notations",
      "text" : "In the following, φ, φ1, φ2 denote LTL formulae, s, s1, s2 denote schemata, σ denotes an LTL or propositional interpretation, I,M denote schema interpretations, e, f, g denote (Presburger) arithmetic expressions, n, i denote arithmetic variables (n will be used for a free arithmetic variable (“parameter”) and i for a bound one). Remark that n, i are written in sans serif in order to distinguish them from meta variables denoting natural numbers, that will be written n, i.\nBoth LTL and schemata have propositional logic as a common basis. Furthermore, in both languages, propositional variables are accompanied with a natural number (an instant in the case of LTL, an index for schemata). So instead of defining, as in classical propositional logic, an interpretation as a function mapping each propositional variable to a truth value, we rather define interpretations as functions mapping pairs of propositional variables and natural numbers to truth values. Formally:\nDefinition 1. Let P be a set of propositional variables. A propositional interpretation over P is a function from P × N to {true, false}.\nExample 2. Let P = {p, q}. Then σ s.t. σ(p, 0) = true, σ(q, 0) = false, σ(p, 1) = false, σ(q, 1) = false, σ(p, 2) = true, σ(q, 2) = true, and, for any k > 2: σ(p, k) = true and σ(q, k) = false, is a propositional interpretation.\nAn interpretation σ is represented by the set of all pairs (variable, natural number) that are true in σ. Most of the time we do not need to make that set explicit. For instance, when interpreting a given formula φ, it will be implicitly assumed that we consider only interpretations over sets that contain the variables of φ."
    }, {
      "heading" : "2.1 LTL",
      "text" : "We now recall the syntax and semantics of LTL.\nDefinition 3. The syntax of LTL formulae over the set of propositional variables P is given by the following grammar:\nφ ::= ⊤ |P | ¬φ |φ ∧ φ |Xφ |φUφ\nXφ means that φ holds at the next instant (“X” for neXt). φUψ means that φ holds until ψ holds (“U” for Until). We will also use the following abbreviations: Fφ def = ⊤Uφ and Gφ def\n= ¬F¬φ, meaning respectively “φ eventually holds” and “φ always holds”. The abbreviations ∨, ⇒ and ⇔ are defined as usual (the naive elimination of ⇔ is exponential but it can be made linear by using renaming of subformulae as usual, which preserves satisfiability). See [Pnu77] for details.\nLTL formulae are usually interpreted over infinite paths in a transition system, together with a labelling that maps every state to a set of propositional variables. Such sequences are often called computations or behaviours. We will simply call them LTL interpretations. For uniformity, we define formally an LTL interpretation as a propositional interpretation in the sense of Definition 1 (we do not make explicit the notions of states, transition systems and labelling).\nExample 4. The interpretation {p, q} → {p} → {q} → {p, q} → {} → {} → . . . is formally represented as the function σ s.t.\nσ(p, 0) = true\nσ(q, 0) = true\nσ(p, 1) = true\nσ(q, 1) = false\nσ(p, 2) = false\nσ(q, 2) = true\nσ(p, 3) = true\nσ(q, 3) = true\nσ(p, 4) = false\nσ(q, 4) = false\nThen σ(t) denotes the set of variables p that are true at time t, i.e. such that (p, t) ∈ σ (in the previous example, σ(0) = {p, q}, σ(1) = {p}, etc.). The satisfaction relation of an LTL formula φ under such an interpretation σ is defined w.r.t. an instant t, written σ, t |= φ. This means that the formula φ holds at time t.\nDefinition 5. Let φ be an LTL formula, σ be a propositional interpretation and t ∈ N. The relation σ, t |= φ is inductively defined as follows:\nσ, t |= ⊤\nσ, t |= p iff (p, t) ∈ σ\nσ, t |= ¬φ iff σ, t 6|= φ\nσ, t |= φ1 ∧ φ2 iff σ, t |= φ1 and σ, t |= φ2\nσ, t |= Xφ iff σ, t+ 1 |= φ\nσ, t |= φ1Uφ2 iff ∃k ∈ N s.t. ∀i ∈ N, i < k ⇒ σ, t+ i |= φ1 and σ, t+ k |= φ2\nThe notation σ |= φ means that φ is true in σ at time 0.\nA fundamental property of LTL is the “ultimately periodic model property”. Namely, if an LTL formula is satisfiable, then it is satisfiable on some ultimately periodic interpretation.\nDefinition 6. An ultimately periodic (“UP”) interpretation is an LTL interpretation σ s.t. there exist k, l ∈ N s.t. l > 0 and for all m ≥ k, σ(m) = σ(m + l). The sequence σ(0) . . . σ(k−1) is the prefix of σ and σ(k) . . . σ(k+ l−1) its loop, k is the prefix index and l is the period.\nTheorem 7 ([SC85]). Any satisfiable LTL formula has a UP model.\nThis important result allows to focus exclusively on finite sets of instants. Indeed it is sufficient to give the values of a UP interpretation for time 0 to k+ l. Other values until ω can then be computed.\nExample 8. Figure 1 represents a UP model of GFp."
    }, {
      "heading" : "2.2 Schemata",
      "text" : "We now recall the syntax and semantics of schemata (for simplicity, the considered definitions are slightly more restrictive than the ones of [ACP09]). Let E be the set of Presburger arithmetic expressions, i.e. terms built over a countably infinite set of arithmetic variables X and on the signature containing 0, succ, + and possibly all the constant symbols in N1. As usual a term is ground iff it contains no variable. Notice that every ground expression will be considered the same as the natural number it represents.\nDefinition 9. The syntax of schemata over the set of propositional variables P is given by the following grammar:\ns ::= ⊤ | pe | ¬s | s ∧ s |\nn−1∧\ni=0\ns\nwhere p ∈ P , e ∈ E and i, n ∈ X . ∨n−1 i=0 s is defined as ¬ ∧n−1\ni=0 ¬s and ∨, ⇒ and ⇔ are defined as usual.\n1 Such constants may be encoded in unary, as terms of the form succk(0) but also in binary, as sequences of digits. As we shall see, the choice between the two encodings has a significant influence on the complexity of the translation: polynomial translation of schemata into LTL is feasible only if numbers are encoded in unary.\nExample 10. p0 ∧ ∧n−1 i=0 (pi ⇒ pi+1) ∧ ¬pn and ∧n−1 i=0 pi ∧ ∨n−1 i=0 ¬pi are schemata.\nRemark 11. This definition is less general than the one originally introduced in [ACP09] because all integers occurring in the schema must be positive (we consider Presburger arithmetic instead of linear arithmetic). This was not the case in [ACP09], but it is easy to check that both formalisms have exactly the same expressive power. Furthermore the iterations are here restricted to go from 0 to n − 1. Once again this is not restrictive w.r.t. to the expressive power, but it allows to get rid of tedious additional restrictions that would be needed otherwise.\nSchemata of the form pe are called indexed propositions, and those of the form∧n−1 i=0 s are called iterated conjunctions or simply iterations. The variable i is bound in ∧n−1\ni=0 s. The essential point of schemata is that iterations are symbolic expressions: n is a formal variable, called a parameter, not a meta variable denoting any number. From now on, we assume that all schemata have only one parameter called n. This is not restrictive for the scope of this paper (see [AMEP10]).\nA schema is interpreted by first giving a value to the parameter – which gives raise to a propositional formula φ, called an “instance” of the schema – and then by giving a value to the propositional variables of φ. Note that a schema has an infinite set of instances. If s is a schema or an arithmetic expression, i is an arithmetic variable and e is an arithmetic expression, then s[e/i] denotes the expression obtained from s by replacing every free occurrence of i by e. Note that, if e is ground and s is an arithmetic expression containing only the variable i, then s[e/i] is a ground arithmetic expression, i.e. a natural number. Then:\nDefinition 12. Let s be a schema of parameter n and m ∈ N. The instance of s w.r.t. m is the propositional formula 〈s〉m inductively defined as follows:\n〈pe〉m def = pe[m/n]\n〈¬s〉m def = ¬〈s〉m\n〈s1 ∧ s2〉m def = 〈s1〉m ∧ 〈s2〉m\n〈 n−1∧\ni=0\ns〉m def = ⊤ if m = 0\n〈\nn−1∧\ni=0\ns〉m def = 〈s[0/i]〉m ∧ . . . ∧ 〈s[m− 1/i]〉m otherwise\nExample 13.\n〈p0 ∧\nn−1∧\ni=0\n(pi ⇒ pi+1) ∧ ¬pn〉0 = p0 ∧ ¬p0\n〈p0 ∧\nn−1∧\ni=0\n(pi ⇒ pi+1) ∧ ¬pn〉1 = p0 ∧ (p0 ⇒ p1) ∧ ¬p1\n〈p0 ∧\nn−1∧\ni=0\n(pi ⇒ pi+1) ∧ ¬pn〉2 = p0 ∧ (p0 ⇒ p1) ∧ (p1 ⇒ p2) ∧ ¬p2\netc.\nAn instance is a usual propositional formula except that each variable is indexed with a natural number. So we just need a propositional interpretation to interpret this formula as usual:\nDefinition 14. Let φ be a propositional formula whose variables are indexed by natural numbers, and σ a propositional interpretation. Then σ |= φ is defined as usual by induction on the structure of φ with the exception that, for any indexed propositional variable pk, σ |= pk iff (p, k) ∈ σ.\nWe thus define a schema interpretation as a pair consisting of a propositional interpretation and a natural number.\nDefinition 15. A schema s is true in a schema interpretation (σ, n) iff σ |= 〈s〉n. We also use the notation |= for schemata: I |= s iff the schema s is true in the schema interpretation I.\nExample 16. p0 ∧ ∧n−1 i=0 (pi ⇒ pi+1) ∧ ¬pn is unsatisfiable (see its set of instances in Example 13) as well as ∧n−1\ni=0 pi∧ ∨n−1 i=0 ¬pi; p0∧ ∧n−1 i=0 (pi ⇒ pi+1) is satisfiable.\nThe satisfiability problem for schemata is undecidable in general [ACP09]. However various decidable classes are investigated in [ACP09,ACP10a,ACP11]. In the following, we will focus on the translation of LTL from/to “sequential” schemata:\nDefinition 17. A schema is a sequential propositional schema (“SPS”) iff all the following conditions hold:\n– it contains no nested iteration (iterations in the scope of another iteration); – every index of a variable outside an iteration is of the form k or n+k, where k ∈ N and n is the parameter; – every index of a variable inside an iteration ∧n−1\ni=0 s is of the form i+k, where k ∈ N.\nExample 18. p0 ∧ ∧n−1 i=0 (pi ⇒ pi+1), p0 ∧ ∧n−1 i=0 (pi ⇒ pi+1) ∧ ¬pn and ∧n−1\ni=0 pi ∧∨n−1 i=0 ¬pi are SPS; ∧n i=0 pi ∧ ∨n i=0 ¬pi, p2n ∧ ∧n−1 i=0 pi, ∧n−1 i=0 p2n, and ∧n−1 i=0 p2i are not.\nInformally, an SPS represents a structure which is sequentially repeated, n being considered as the length of the sequence. SPS belong to the class of “regular” schemata, for which the satisfiability problem is proved to be decidable in [ACP09]."
    }, {
      "heading" : "3 Translating interpretations",
      "text" : "In the next sections we will provide translations of LTL formulae into SPS and conversely. Some semantic translations underlie those syntactic ones. We make them explicit now in order to give preliminary insights."
    }, {
      "heading" : "3.1 From schemata to LTL",
      "text" : "Consider a schema interpretation (σ, n). Given a schema interpretation (σ, n), its first component σ can already be considered as an LTL interpretation, but we still need to represent the second component n. This is done by using special LTL interpretations (which are also propositional interpretations) called “initial segments”:\nDefinition 19. Let σ be a propositional interpretation over a set of variables P. σ is an initial segment of length k ∈ N for some p ∈ P iff (p, t) ∈ σ when t < k, and (p, t) 6∈ σ otherwise.\nExample 20. Figure 2 provides a graphical representation of an initial segment of length 4 for p.\nThe key feature of initial segments is that they can be put in correspondence with natural numbers. Namely, we can associate a canonical initial segment to every natural number and a natural number to every initial segment. This correspondence allows us to define the following transformation for schema interpretations:\nDefinition 21. Let P be a set of propositional variables and let “t < n” 6∈ P be a propositional variable. Let I = (σ, n) be a schema interpretation over P. Then TIU is the propositional interpretation (and thus also an LTL interpretation) over P ∪ {t < n} which is an initial segment of length n for t < n and which is defined as σ over P. Conversely, T.U−1 is the function that maps every initial segment σ of length n for t < n to the schema interpretation (τ, n) where τ is the restriction of σ to P.\nExample 22. Let I be the schema interpretation ({p0, q0, p1, p2, q3}, 3). Then TIU = {p, q, t < n} → {p, t < n} → {p, t < n} → {q} → {} → {} → . . . Conversely, let σ be the LTL interpretation {q, t < n} → {q, t < n} → {p, t < n} → {p, q, t < n} → {p} → {p} → . . . , then TσU−1 = ({q0, q1, p2, p3, q3, p4, p5, . . . }, 4).\nThe map T.U is a bijection between schema interpretations over P and initial segments over P ∪ {t < n}. Indeed, T.U−1 is its inverse.\nRemark 23. An important difference between schemata and LTL is the fact that all interpretations of schemata are finite, whereas those of LTL are infinite (i.e. time is unbounded). Initial segments thus allow us to simulate finite models in LTL.\nFinally notice that the set of initial segments can be specified in LTL as follows:\nProposition 24. Let φt<n< be the following formula:\nφt<n< def = (t < n)UG(¬t < n)\nThen an LTL interpretation is a model of φt<n< iff it is an initial segment for t < n.\nProof. An interpretation is a model of φt<n< iff it makes t < n true until ¬t < n always holds. Let us write k for the first instant where t < n does not hold. Then this is equivalent to say that t < n holds at time t iff t < k. ⊓⊔\nWe can also specify a proposition eqn that is true only at time n. This is axiomatized by:\nAxt=n def = G(t < n ∧ ¬X(t < n) ⇔ X(eqn)) ∧ (¬t < n ⇔ eqn)\nTo improve readability, eqn will be written t = n.\nProposition 25. Let σ be an initial segment for t < n of length n s.t. σ, 0 |= Axt=n. Then σ, t |= t = n iff t = n.\nProof. By definition, t < n holds at time t iff t < n. If n = 0 then t < n never holds, in particular, t < n does not hold at time 0. Since σ |= Axt=n, σ satisfies its second conjunct, and as t < n does not hold at time 0, eqn (i.e. t = n) holds at time 0. Furthermore, since σ satisfies the first conjunct and t < n never holds again, t = n is never satisfied again. Suppose now n 6= 0, then there is indeed at least one instant s.t. t < n holds. Thus t < n holds at time n − 1 and not at time n, which corresponds precisely to the first conjunct of Axt=n. Furthermore n is the only instant with this property hence the result. ⊓⊔"
    }, {
      "heading" : "3.2 From LTL to schemata",
      "text" : "The inverse translation is harder: embedding LTL into schemata means that we must represent the infinite interpretations of LTL using only schema interpretations, which are finite. Of course this is impossible in general. However, as we are concerned with satisfiability, we can make use of Theorem 7 and restrict ourselves to UP interpretations. Since such interpretations can be finitely represented, we will be able to embed them into schema interpretations. The representation of UP interpretations within schemata is achieved via particular schema interpretations called “2-initial segments”:\nDefinition 26. A schema interpretation I = (σ, n) is a 2-initial segment for a propositional variable p iff there exists k ≤ n s.t., for every l ∈ {0, . . . , n}, we have (p, l) ∈ σ ⇔ l < k. We call k the short length of I and n + 1 is its long length.\nExample 27. The schema interpretation ({p0, p1, p2}, 5) is a 2-initial segment w.r.t. p(see Figure 3). Its short length is 3, its long length is 6.\nWe call this a 2-initial segment because two initial segments are characterized: {0, . . . , k − 1} (characterized by I) and {0, . . . , n} (characterized by n). Notice, however, that the segment {0, . . . , k − 1} is characterized by p only below n, i.e. the value of p is not specified above n. This is not a problem since we will not need such values in the translations.\nThe notion of 2-initial segment is useful because, much in the same way in which initial segments correspond to natural numbers, 2-initial segments correspond to pairs of different natural numbers. We can now define the following transformation for UP interpretations:\nDefinition 28. Let σ be a UP interpretation of prefix index k (i.e. the loop starts at time k) and of period l over a set P, and let “pfx” 6∈ P be a propositional variable. Then VσW is the schema interpretation (τ, k+ l− 1) where τ is defined as an initial segment of length k for pfx and preserving the value of σ on P.\nExample 29. Let σ be the UP interpretation of prefix index 2 and period 3 (totally) defined by: {p, q, r} → {p} → {q, r} → {p, q} → {q, r} Then VσW = ({pfx0, p0, q0, r0, pfx1, p1, q2, r2, p3, q3, q4, r4}, 4).\nRemark 30. The map V.W embeds the prefix index and the period inside schema interpretations, but it is impossible to specify the fact that an interpretation is a UP interpretation: indeed this would require to express that the interpretation loops indefinitely. Such a specification of an “infinite” behaviour cannot be achieved with schemata. This will not be a problem in the following because, when focusing on a given LTL formula, one only needs to specify this behaviour in the range {0, . . . , k + l − 1}.\nFor similar reasons, V.W is not a bijection in general, unlike T.U. It is actually a bijection between UP interpretations and 2-initial segments if we restrict the latter to the values assigned to variables whose index is between 0 and k+ l− 1.\nThis will indeed be the case in our reduction since, as just explained, we will not need the values for other indices. Then V.W−1 is defined as follows:\nDefinition 31. Let (σ, n) be a 2-initial segment for pfx. Then Vσ, nW−1 is defined as the unique UP interpretation such that:\n– its prefix is the set of instants s.t. pfx holds in I; – its period l is n− k + 1, where k is the prefix index; – for all p 6= pfx and all t ≤ n, (p, t) ∈ VI, nW−1 iff (p, t) ∈ I.\nExample 32. Let I = ({pfx0, p0, pfx1, q1, p2, p3, q3}, 3). Then VIW −1 is the UP interpretation of prefix index 2 and period 2 defined by VIW−1 = {p} → {q} → {p} → {p, q} → . . . where the contents of the dots can be retrieved by the UP property of the interpretation.\nFinally, 2-initial segments can be specified using schemata:\nProposition 33. Let spfx≤ be the following SPS:\nspfx≤ def = ¬pfxn ∧\nn−1∧\ni=0\n(pfxi+1 ⇒ pfxi)\nThen a schema interpretation is a model of spfx≤ iff it is a 2-initial segment for pfx.\nProof. Let I = (σ, n) be a model of spfx≤ . For any k ∈ N s.t. pfxk holds, pfxk′ holds for every k′ < k, because σ satisfies the second conjunct of spfx≤ . Furthermore there is a maximal such k < n , because pfxk cannot hold at time n, by the first conjunct. Hence I is indeed a 2-initial segment.\nConversely, let I = (σ, n) be a 2-initial segment for pfx of short length k. Then, for every l ∈ {0, . . . , n}, pfxl holds iff l < k. Since k ≤ n, pfxn cannot hold, hence the first conjunct is indeed satisfied. Furthermore for every l ∈ {0, . . . , n}, if pfxl+1 holds then pfxl holds, hence the second conjunct is satisfied. ⊓⊔\nThe beginning of the loop can be referred to by using a propositional variable eqki , intended to be true only when i is equal to the prefix index k of the interpretation. This can be axiomatized as follows:\nAxi=k def = (¬pfx0 ⇔ eq k 0) ∧\nn−1∧\ni=0\n(pfxi ∧ ¬pfxi+1 ⇔ eq k i+1)\nTo improve readability, eqki will be written “ i = k”.\nProposition 34. Let I be a 2-initial segment of short length k for pfx s.t. I |= Axi=k. Then, for every i ∈ {0, . . . , n}, I |= eq k i iff i = k. Proof. If k = 0, then I 6|= pfx0 hence i |= eq k 0 , by the first conjunct of Axi=k. Furthermore I 6|= eqki+1 for any i ∈ {0, . . . , n − 1} because pfxi does not hold and by the second conjunct of Axi=k.\nIf k > 0, then I |= pfxk−1 and I 6|= pfxk hence, by the second conjunct, I |= eqkk. Furthermore, no other instant l between 0 and n has the property that I |= pfxl−1 and I 6|= pfxl, hence the equivalence. ⊓⊔"
    }, {
      "heading" : "4 Embedding SPS in LTL",
      "text" : "We now show how SPS can be translated into LTL: given an SPS s, we build an LTL formula ⌊s⌋ which is satisfiable iff s is satisfiable. Then we show that the size of ⌊s⌋ is polynomial or exponential w.r.t. the size of s, depending on the encoding of natural numbers (in the arithmetic expressions occurring in s). As LTL satisfiability is in PSPACE, we can thus conclude that the satisfiability of SPS is also in PSPACE when numbers are encoded in unary."
    }, {
      "heading" : "4.1 The ⌊.⌋ transformation",
      "text" : "The main desideratum of ⌊.⌋ is that for every model M of an SPS s, the interpretation TMU (Definition 21) is a model of ⌊s⌋. An example is shown on Figure 4 (we represent LTL interpretations as sequences of sets of propositional variables, instead of sets of pairs (variable, number), as they are formally defined; similarly, schema interpretations are represented as the set of true indexed propositions).\nBy Proposition 24, every interpretation such that φt<n< (defined in Proposition 24) holds is an initial segment of length n for a propositional variable “t < n”. Furthermore, Axt=n (defined after Proposition 24) enables to use the variable “t = n”. Our translation thus includes those formulae.\nDefinition 35. Let s be an SPS. Then ⌊s⌋ is an LTL formula defined as ⌊s⌋ def\n= ⌊s⌋prop ∧ φ t<n < ∧ Axt=n where ⌊s⌋prop is inductively defined as follows:\n⌊⊤⌋prop def = ⊤\n⌊pk⌋prop def = Xkp\n⌊pn+k⌋prop def = G(t = n ⇒ Xkp)\n⌊pi+k⌋prop def = Xkp\n⌊¬s⌋prop def = ¬⌊s⌋prop\n⌊s1 ∧ s2⌋prop def\n= ⌊s1⌋prop ∧ ⌊s2⌋prop ⌊ n−1∧\ni=0\ns\n⌋\nprop\ndef = G(t < n ⇒ ⌊s⌋prop)\nwhere k ∈ N, i 6= n, and Xkφ def\n= X. . .X ︸ ︷︷ ︸\n×k\nφ.\nExample 36. We have: ⌊ p0 ∧ ∧n−1 i=0 (pi ⇒ pi+1) ∧ ¬pn ⌋ = p ∧ G(t < n ⇒ p ⇒ Xp)∧¬G(t = n ⇒ p)∧φt<n< ∧Axt=n. Notice that it would be equivalent to have p ∧ G(t < n ⇒ p ⇒ Xp) ∧ G(t = n ⇒ ¬p) ∧ φt<n< ∧ Axt=n because t = n holds at only one moment. This variation is interesting because it does not introduce any eventuality, and is thus easier to handle for LTL decision procedures. It can be generalized, e.g., by putting every schema into n.n.f. before the translation, and then by defining a dedicated case for negative literals.\nFigure 4 can now be updated into Figure 5."
    }, {
      "heading" : "4.2 Soundness and completeness of ⌊.⌋.",
      "text" : "Theorem 37. Let s be a SPS. Then T.U is a bijection between the models of s and the models of ⌊s⌋. The inverse bijection is T.U−1 (Definition 21).\nThis result is more interesting than just “s is satisfiable iff ⌊s⌋ is satisfiable”. Indeed, not only does it provide more insights about the translation, but it also makes explicit the inverse transformation for interpretations, which is useful for model building.\nProof. Notice that T.U−1 is well defined because every model of ⌊s⌋ is an initial segment by Proposition 24. We still have to prove the following:\n1. for every model M of s, TMU is a model of ⌊s⌋; 2. for every model σ of ⌊s⌋, TσU−1 is a model of s.\nIn the following, M is a model of s, n is the value given to n by M, σ is a model of ⌊s⌋ and l is the length of ⌊s⌋ (as an initial segment of t < n). Notice that, by definition, TMU coincides with the propositional part of M on any propositional variable other that t < n. Similarly, σ coincides with the propositional part of TσU−1 on any propositional variable other that t < n.\nWe prove both properties simultaneously by induction on ⌊s⌋prop:\n– Suppose s = pk, where k ∈ N. Then M |= s implies (p, k) ∈ M ⊂ TMU and by a straightforward induction on k this implies that TMU |= Xkp which proves 1. For 2, suppose that σ |= ⌊s⌋, i.e. σ |= Xkp. This easily entails that (p, k) ∈ σ, thus (p, k) ∈ TσU−1 and so TσU−1 |= pk. – Suppose s = pn+k. Then M |= pn+k means that (p, n + k) ∈ M ⊂ TMU. Consequently, Xkp is true at time n. Finally, by Proposition 25, t = n is true only at time n in TMU. Thus, at any time when we have t = n, we have Xkp; i.e. we have t = n ⇒ Xkp at any time; i.e. we have G(t = n ⇒ Xkp). This proves 1. For 2, suppose σ |= ⌊s⌋, i.e. σ |= G(t = n ⇒ Xkp). Thus for every t ∈ N, t = n ⇒ Xkp is true at time t in σ. But we know that t = n is true only at time l (the length of ⌊s⌋). Thus p is true at time l + k. Hence (p, l + k) ∈ σ, thus (p, l + k) ∈ TσU−1, and since the value of n in TσU−1 is l, TσU−1 |= pn+k. – The case s = pi+k is handled in the iteration cases (Lemma 38). – Suppose s = ¬s′. For 1, if M |= s then M 6|= s′. But, as T.U−1 is the inverse\nof T.U, M = T(TMU)U−1. Thus T(TMU)U−1 6|= s′. By induction hypothesis, 2 holds for s′, thus, by contraposition: TMU 6|= ⌊s′⌋. Consequently, TMU |= ¬⌊s′⌋. For 2, suppose σ |= ⌊s⌋, i.e. σ |= ¬⌊s′⌋. Thus σ 6|= ⌊s′⌋, i.e. TTσU−1U 6|= ⌊s′⌋. By induction hypothesis, 1 holds for s′, so, by contraposition: TσU−1 6|= s′. Thus TσU−1 |= ¬s′. – Suppose s = s1 ∧ s2. For 1, if M |= s then M |= s1 and M |= s2 and one easily concludes by induction. For 2, if σ |= ⌊s⌋, i.e. σ |= ⌊s1⌋ ∧ ⌊s2⌋, then σ |= ⌊s1⌋ and σ |= ⌊s2⌋ and one can also conclude by induction. – Suppose s = ∧n\ni=0 s ′. We first prove the following intermediate lemma:\nLemma 38. For every initial segment σ of length l, and every t ≤ l: σ |= ⌊s′[t/i]⌋ iff ⌊s′⌋ holds in σ at time t.\nProof. We prove both implications simultaneously by induction on the structure of s′: • Suppose s′ = pi+k; thus ⌊s ′⌋ = ⌊pi+k⌋ = X kp, and ⌊s′[t/i]⌋ = ⌊pt+k⌋ =\nXt+kp. For the first implication, assume that σ |= ⌊s′[t/i]⌋, i.e. σ |= Xt+kp, which is equivalent to p ∈ TMU(t+k). It is equivalent to say that Xkp, i.e. ⌊s′⌋, is true in σ at time t. This proves the first implication, and also the second as all reasoning steps are equivalences. • As s is strictly bound, there are no other base case (this is precisely why this restriction is essential). • Suppose s′ = ¬s′′: then ⌊s′⌋ = ¬⌊s′′⌋ and ⌊s′[t/i]⌋ = ¬⌊s′′[t/i]⌋. For the first implication, assume that σ |= ⌊s′[t/i]⌋, i.e. σ |= ¬⌊s′′[t/i]⌋. Thus σ 6|= ⌊s′′[t/i]⌋. By the reverse implication of the induction hypothesis (more precisely by its contraposition), this means that ⌊s′′⌋ does not hold in σ at time t. Consequently, ¬⌊s′′⌋ holds in σ at time t, hence the result. Once again, the second implication is obtained by just reversing the reasoning. • The proof for the conjunction case is routine. • As the schema is sequential, iterations cannot be nested, thus s′ cannot contain an iteration, hence there are no more cases. ♦\nNow we can get back to the iteration case of the main proof. For 1, if M |= s then M |= s′[t/i] for every t ∈ N s.t. 0 ≤ t ≤ n by definition of schemata semantics. And thus, by induction hypothesis, TMU |= ⌊s′[t/i]⌋ for every such t. By Lemma 38, this means that ⌊s′⌋ is true in TMU at any time t s.t. 0 ≤ t ≤ n. From the semantics of LTL, it is obvious that t ≥ 0 so it is enough to say that ⌊s′⌋ is true in TMU at any time t ≤ n (notice that this would not be so simple if the schema was not simply iterated). This is equivalent to say that t < n ⇒ ⌊s′⌋ is true at any time, hence the conclusion for 1. For 2, suppose that σ |= ⌊s⌋, i.e. σ |= G(t < n ⇒ ⌊s⌋). Then, by definition of LTL semantics, t < n ⇒ ⌊s⌋ is true in σ at any time. Furthermore t < n is true only at time l or below, hence ⌊s⌋ is true in σ at any time less or equal than l. We can then conclude using the reverse implication of Lemma 38 and the semantics of schemata. ⊓⊔"
    }, {
      "heading" : "4.3 Consequences.",
      "text" : "We then obviously have the expected result:\nCorollary 39. A SPS s is satisfiable iff ⌊s⌋ is satisfiable.\nThus we indeed obtained an embedding of SPS into LTL. Consequently we can use any LTL satisfiability solver to solve the satisfiability problem for SPS: we simply translate the input schema to LTL with ⌊.⌋ and then launch the LTL solver on the output formula. Thus:\nCorollary 40. The satisfiability problem for SPS can be reduced to the satisfiability problem for LTL.\nNotice furthermore that if the solver finds a model, then we can translate it back to a schema model using the inverse translation T.U−1.\nWe can easily study the complexity of this transformation. For an object x (schema, formula, arithmetic expression), let#x stand for the size of x in number of symbols. Let #s denote the size of a schema s, in number of symbols, and let #ints denote the size of the biggest number occurring in s, expressed w.r.t. the size of s. This is to take into account the fact that numbers can be encoded either in unary or in binary: if they are encoded in binary then #ints = O(2\n#s), but if they are encoded in unary then #ints = O(#s). It may also happen that we consider only schemata whose biggest number is bounded by some constant; in such a case, we have #ints = O(1). This case is worth considering since we may easily increase the size of a schema without increasing the numbers that occur in it. Then:\nProposition 41. For every SPS s, we have # ⌊s⌋ = O(#s.#ints).\nProof. First, φt<n< has a constant size. Then since the construction of ⌊s⌋prop is by induction on s, there are#s recursive calls. Each of those calls adds a number of symbols either constant or proportional to some k ∈ N occurring in s (all the cases with “×k”), i.e. at worst #ints. ⊓⊔\nConsequently, ⌊.⌋ is:\n– linear if numbers are bounded by constants; – quadratic if numbers are encoded in unary; – exponential if they are encoded in binary.\nIt is well-known that the satisfiability of LTL is in PSPACE [SC85], thus:\nTheorem 42. The satisfiability of SPS is in PSPACE if numbers are encoded in unary or bounded by constants. It is in EXPSPACE if numbers are encoded in binary.\nThis result improves over the one of [ACP10b], where the satisfiability of regular schemata is proved to be in EXPSPACE (resp. 2-EXPSPACE), if numbers are encoded in unary (resp. binary). Of course Theorem 42 only deals with sequential schemata, but both classes are close enough so that we conjecture that the satisfiability of regular schemata is also in PSPACE."
    }, {
      "heading" : "5 Embedding LTL in SPS",
      "text" : "We now tackle the reverse embedding, i.e. we translate LTL to SPS.\n5.1 A first faulty translation: finiteness vs infiniteness.\nWe provide a first, intuitive but faulty, translation:\nDefinition 43. Let φ be an LTL formula. Then ⌈φ⌉ is a schema defined as ⌈φ⌉0, where ⌈φ⌉e is inductively defined for any expression e as follows:\n⌈⊤⌉e def = ⊤\n⌈p⌉e def = pe\n⌈¬φ⌉e def = ¬⌈φ⌉e\n⌈φ1 ∧ φ2⌉e def = ⌈φ1⌉e ∧ ⌈φ2⌉e\n⌈Xφ⌉e def = ⌈φ⌉e+1\n⌈φ1Uφ2⌉e def =\nn∨\ni=e\n\n⌈φ2⌉i ∧\ni−1∧\nj=e\n⌈φ1⌉j\n\n\nBut this is not satisfactory since the obtained schema is not sequential2 and, more important, because a valid LTL formula can be translated into a non-valid schema as shows the following example:\n2 Actually this is not even a schema in the sense of Definition 9 since the upper bounds of iterations are different from n − 1. Notice that this is neither a regular schema [ACP09] since iterations are nested and the upper bound of one iteration contains a bound variable.\nExample 44.\n⌈Xp⇒ Fp⌉ = p1 ⇒\nn∨\ni=0\npi\nThe formula Xp ⇒ Fp is valid, but the schema p1 ⇒ ∨n\ni=0 pi is not valid (take any interpretation where n = 0). Adding conditions ensuring that n is strictly positive is possible, but obviously not sufficient, e.g. we could consider the formula Xkp⇒ Fp. Then the above translation will work only if n ≥ k (where k is arbitrary).\nThe deep reason of this problem is that the semantics of schemata are intrinsically finite (though unbounded) whereas those of LTL are infinite. Actually, we can consider the previous translation as an indirect way to define “finite semantics LTL”, i.e. LTL formulae interpreted over functions from {1, . . . , n} to 2P for any n ∈ N. As explained in the Introduction, LTL with finite semantics has been studied in the contexts of planning and runtime verification [BK95,BM06,BH10]. But it seems that, rather than considering finite traces per se, the preferred approach in those fields is to turn finite traces into infinite ones by repeating infinitely the last state. Then the usual semantics of LTL can be used. Both systems seem however very similar.\n5.2 A successful translation into non-SPS\nWe actually need the ultimately periodic model property (Definition 6 and Theorem 7) to obtain a successful translation, written ⌈.⌉, of LTL formulae into SPS. The aim of ⌈.⌉ is that for every model σ of an LTL formula φ, the interpretation VσW (Definition 21) is a model of ⌈φ⌉. An example is provided on Figure 6.\nConsider an LTL formula φ. As we shall see, we will make use of the schema spfx≤ (Proposition 33) to enforce the fact that every model of ⌈φ⌉ is a 2-initial segment. As already exposed, this 2-initial segment is intended to denote a UP interpretation of prefix index k and period l (and the parameter n is assigned the value k + l − 1). Then the translation of φ (or its subformulae) will be parametrized by an arithmetic expression e intended to denote the time (it may be either a natural number or a variable, when translating a subformula of an iteration, and it is initially equal to 0). This instant will of course have an influence on the translation. In particular it is important to know if this instant lies in the prefix of a UP model or in its loop. For the prefix, we already have the\npropositional variable pfx, which is specified by spfx≤ . But we need to introduce a new variable for the loop, say “ loope”, that would be true iff e belongs to the loop. By definition, this is the case when e ∈ {k, . . . , k + l − 1}, thus we have to check that e ≥ k and that e ≤ n. By definition, the first property holds iff pfxe does not hold. We thus need to express e ≤ n with a schema, this is done as follows:\nProposition 45. Let (σ, n) be a schema interpretation and e be a Presburger expression. Then σ |= 〈\n∨n i=e⊤〉n iff e[n/n] ≤ n.\nProof. Indeed if e[n/n] > n then the iteration is empty, thus 〈 ∨n\ni=e⊤〉n = ⊥, hence cannot be satisfied by σ. Otherwise, if e[n/n] ≤ n then the iteration is non empty, thus 〈\n∨n i=e⊤〉n is a non empty disjunction of ⊤, thus equivalent to\n⊤, hence necessarily satisfied by σ. ⊓⊔\nThus we define loope as follows:\nloope def = ¬pfxe ∧\nn∨\ni=e\n⊤\nDefinition 46. Let φ be an LTL formula, then ⌈φ⌉ is a schema defined as ⌈φ⌉ def = ⌈φ⌉0 ∧ s pfx ≤ ∧Axi=k\n3 where, for every arithmetic expression e, ⌈φ⌉e is inductively defined as follows:\n⌈⊤⌉e def = ⊤\n⌈p⌉e def = pe\n⌈¬φ⌉e def = ¬⌈φ⌉e\n⌈φ1 ∧ φ2⌉e def = ⌈φ1⌉e ∧ ⌈φ2⌉e\n⌈Xφ⌉e def = (e < n ∧ ⌈φ⌉e+1) ∨ (e = n ∧ n∧\ni=0\n(i = k ⇒ ⌈φ⌉i))\n⌈φ1Uφ2⌉e def =\nn∨\ni=e\n\n\ni−1∧\nj=e\n⌈φ1⌉j ∧ ⌈φ2⌉i\n\n∨\n loope ∧ n∧\nj=e\n⌈φ1⌉j ∧ e∨\ni=0\n loopi ∧ i−1∧\nj=0\n(loopj ⇒ ⌈φ1⌉j) ∧ ⌈φ2⌉i\n\n\n\n\nExample 47. In the cases of F and G, the translation simplifies drastically. For instance (some simple simplifications have been made):\n⌈Fp⌉0 =\nn∨\ni=0\npi\n3 spfx≤ is defined in Proposition 33 and Axi=k is defined before Proposition 34.\n⌈Gp⌉0 =\nn∧\ni=0\npi\nThis is not so simple if we consider a time t > 0:\n⌈Fp⌉t =\nn∨\ni=t\npi ∨\n(\nloopt ∧\nt∨\ni=0\n(loopi ∧ pi)\n)\n⌈Gp⌉t =\nn∧\ni=t\n¬pi ∧\n(\n¬loopt ∨\nt∧\ni=0\n(loopi ⇒ ¬pi)\n)\nWe provide some intuitions on the transformation corresponding to the X and U connectives. First, for the X: when computing the next instant, one has to take into account the fact that we want a UP interpretation. Thus if e = n the next time after e is not e+ 1 but k, where k is the prefix index. This prefix index can be specified as the only index i such as loopi ∧ loopi−1 holds. Second, for the U, the first disjunct is very natural: it corresponds to the typical case, for instance when time e occurs before the loop. Then, according to the definition of the semantics of U, we only have to check that φ1 holds on some interval {e, . . . , i− 1} and then that φ2 holds at instant i. In general i may be arbitrary, but since the interpretation is UP, we can restrict to the case where i is in the interval {e, . . . , k + l − 1}, i.e. i ≤ n. The second disjunct is slightly more complex. It corresponds to the case where e occurs inside the periodic part of the interpretation. In this case, the element i such that φ2 holds may occur before e. Then φ1Uφ2 also holds if φ1 holds from e to the end of the loop, i.e. n, and then holds again when we “get back” at the beginning of the loop, i.e. from k to some i − 1, with φ2 holding at i ≤ e. Since i ∈ {0, . . . , e}, this can be easily stated as an iterated disjunction. The fact that i ≥ k is encoded by stating that loopi must hold (i.e. i must be inside the periodic part of the interpretation).\nRemark 48. This transformation might remind the reader of some formulae encountered when dealing with the path model checking problem for UP interpretations [VG09]. This resemblance can be explained by observing that every model of s pfx ≤ is a UP path, and ⌈φ⌉e is the operation of model checking the specified path. Then, as s pfx ≤ specifies all UP paths, we actually model check all possible models, hence the fact that we can conclude about the satisfiability.\nThis transformation is sound and complete but the resulting schema is not sequential (iterations are nested and their bounds are different from 0 and n−1). Consequently, we present another translation in the next section, which will indeed fall in the class of SPS.\n5.3 A successful translation into SPS\nThe following translation follows more or less the same goal as the previous one: for every model σ of an LTL formula φ, the interpretation VσW shall be a model\nof ⌈φ⌉. Hence it relies again on the UP property. This new transformation uses a structure-preserving approach: for each subformula φ (different from an indexed proposition) of the original formula, we introduce a fresh propositional variable written |φ|. For an indexed proposition p, |p| def\n= p. Each indexed propositional variable |φ|i, 0 ≤ i ≤ n, is then intended to be true iff the subformula φ is true at time i. Formally, we extend V.W as follows:\nDefinition 49. Let σ be a UP interpretation and φ an LTL formula. Then:\n– for every propositional variable of the form |ψ| for some subformula ψ of φ, (|ψ| , t) ∈ VσW iff σ, t |= ψ; – for every other variable, VσW is defined as described early on.\nFurthermore, for each subformula of the form φ1Uφ2, we add another propositional variable called |φ1U\n′φ2| (called this way because its behaviour is very close to the one of U) interpreted as true at t ∈ N iff there is t′ ∈ N s.t. t ≤ t′ ≤ k + l − 1 where φ1 holds between t and t ′ − 1 and φ2 holds at t ′, i.e. the semantics are the same as for U except that the instant when φ2 occurs must happen before the end of the loop (as explained thereafter, this variable is used to ensure that the eventuality indeed happens).\nNote that this semantic transformation now depends on the formula to translate. The inverse operation is defined as in Definition 31 except that the value of any variable |ψ| is “forgotten”.\nThe translation is done by adding axioms to compute the values of the newly introduced propositional variables (relating these values to the ones of the propositional variables originally occurring in the formula). As we shall see, the specification of those new variables is straightforward when the head symbol of the subformula is a boolean connective: the value of the considered variable can be directly related to the values of the variables corresponding to the operands, see definition of Ax¬φ and Axφ1∧φ2 in Definition 50 below.\nWhen the head symbol of the subformula is a temporal connective, we have to distinguish whether the index denotes a time lower or equal to n (since the interpretation is UP, we only have to consider the time interval {0, . . . , n}). In both cases, the value of the considered propositional variable |φ| at time i is related to the one of the variables at the next instant. If i < n then this next instant is easy to compute: it is simply i+ 1. But if i = n, since the value of the variables |φ| are specified only on the interval {0, . . . , n} we cannot refer to the time n+ 1 and we have to take advantage of the fact that the interpretation is periodic: since n necessarily corresponds to the end of the periodic part, the next instant must be the beginning of the loop. This is easily handled in the X case: if we have Xφ at time n then we must have φ at time k where k is the beginning of the loop.\nIn the U case, if we have φ1Uφ2 at time n then we have to deal with the fact that φ2 might hold after n, between time k and n − 1 (by taking the loop into account). In this case we have to check that φ2 holds between k and n− 1, and that φ1 holds in between. This check is triggered by the use of the new connective\nU′, whose specification is thus added to the definition. Intuitively, φ1U ′φ2 may be seen as a connective interpreted as φ1Uφ2, except that the formula φ2 must hold at the latest at time n (one may wonder why not use directly U instead of U′; but this would yield an ill-founded definition: the eventuality could be always delayed and never fulfilled).\nDefinition 50. Let φ be an LTL formula. Then ⌈φ⌉ is the schema defined as ⌈φ⌉ def\n= |φ|0∧Φ φ∧spfx≤ ∧Axi=k where Φ φ stands for ∧ {Axψ | ψ is a subformula of φ}\nand Axψ is defined as follows:\nAx⊤ def =\nn∧\ni=0\n|⊤|i\nAx¬φ def =\nn∧\ni=0\n(|¬φ|i ⇔ ¬|φ|i)\nAxφ1∧φ2 def\n= n∧\ni=0\n(|φ1 ∧ φ2|i ⇔ |φ1|i ∧ |φ2|i)\nAxXφ def =\nn−1∧\ni=0\n(|Xφ|i ⇔ |φ|i+1) ∧ (|Xφ|n ⇔\nn∧\ni=0\n(i = k ⇒ |φ|i))\nAxφ1Uφ2 def =\nn−1∧\ni=0\n(|φ1Uφ2|i ⇔ |φ2|i ∨ (|φ1|i ∧ |φ1Uφ2|i+1))\n∧(|φ1Uφ2|n ⇔ (|φ2|n ∨ (|φ1|n ∧\nn∧\ni=0\n(i = k ⇒ |φ1U ′φ2|i))))\n∧\nn−1∧\ni=0\n(|φ1U ′φ2|i ⇔ |φ2|i ∨ (|φ1|i ∧ |φ1U ′φ2|i+1))\n∧(|φ1U ′φ2|n ⇔ |φ2|n)\nwhere ∧n i=0 s is a shortcut for ∧n−1\ni=0 s ∧ s[n/i] (we need to define this as an abbreviation so that the schema be indeed sequential).\nLemma 51. Let φ be an LTL formula and n ∈ N. The instance of ⌈φ⌉ w.r.t. n contains only variables whose index is comprised between 0 and n.\nProof. By inspection of all cases in Definition 50, all indices of propositional variables in ⌈φ⌉ are n, i or i+1. i is always bound by an iteration whose bounds are 0 and n− 1. Consequently the instance of ⌈φ⌉ w.r.t. n only contain indexed propositional variables whose indices are between 0 and n. ⊓⊔\nTheorem 52. Let φ be an LTL formula. Then V.W is a bijection between the UP models of φ and the models of ⌈φ⌉ (if the latter are restricted to the values of propositional variables occurring in the corresponding instance of ⌈φ⌉). V.W−1 is the inverse bijection.\nProof. We first prove that the codomain of V.W indeed falls into the set of models of ⌈φ⌉, i.e., for every UP model σ of a formula φ, VσW |= ⌈φ⌉. Let k, l be the prefix index and period of σ. Note that, by Definition 28, VσW gives the value k+ l− 1 to the parameter. Then we actually prove the more general result that for any t ∈ N, if σ, t |= φ then VσW |= spfx≤ ∧|φ|t∧Φ φ. First, since VσW is a 2-initial segment w.r.t. pfx, VσW |= spfx≤ . Second, VσW |= |φ|t by definition (Definition 49). Finally we prove VσW |= Φφ by proving that VσW |= Axψ for any subformula ψ of φ, depending on the head symbol of ψ:\n– Assume φ = ⊤. For any t ∈ N, σ, t |= ⊤, by definition of LTL semantics. Thus, by definition of VσW, VσW |= |⊤|t for every t. Hence, VσW |= Ax⊤, and thus VσW |= Φφ. – Assume φ = ¬ψ. For any t ∈ N, σ, t |= φ iff σ, t 6|= ψ, by definition of LTL semantics. Thus, by definition of VσW, VσW |= |φ|t iff VσW 6|= |ψ|t, i.e. iff VσW |= ¬ |ψ|t (this time by definition of schemata semantics). Consequently, VσW |= |φ|t ⇔ ¬|ψ|t for any t ∈ N, and in particular for t between 0 and k + l − 1. Thus VσW |= Axφ. – The conjunction cases are similar. – Assume that φ = φ1Uφ2. Let t ∈ N be s.t. σ, t |= φ. By the semantics of LTL,\nthere exists t′ ≥ t s.t. σ, t′ |= φ2 and, for all t ′′ between t and t′−1, σ, t′′ |= φ1. Thus either σ, t |= φ2 or σ, t |= φ1 and σ, t + 1 |= φ. Hence, by definition of V.W, VσW |= |φ2|t or VσW |= |φ2|t+1 and VσW |= |φ|t+1, which enables us to conclude for the first conjunct of the U case. For the reverse implication, suppose VσW |= |φ2|t ∨ (|φ1|t ∧ |φ1Uφ2|t+1) for some t ∈ N. If VσW |= |φ2|t, then it is clear that VσW |= |φ1Uφ2|t. If VσW |= |φ1|t ∧ |φ1Uφ2|t+1, then by definition σ, t |= φ1 ∧ φ1Uφ2, thus VσW |= |φ1Uφ2|t. For the second conjunct (i.e. the second line; notice that, for the sake of presentation simplicity, there is one conjunct per line), assume t = k+ l− 1. If σ, t |= φ2 then we are done. Otherwise, we have t\n′ > k+ l− 1. This means that σ, k + l |= φ1Uφ2, which, by periodicity, is equivalent to σ, k |= φ1Uφ2, and so to σ, k |= φ1U\n′φ2. For the third and fourth conjuncts the proof is similar, except that we now must ensure that the instant when φ2 occurs must be lower or equal to k+l−1. This is indeed the case of t′ ↓.\n– The case of X is similar (but much simpler).\nWe now focus on the inverse transformation. First, V.W−1 is well defined: since ⌈φ⌉ contains spfx≤ , every model of ⌈φ⌉ is a 2-initial segment. Second, it is easily seen that V(VIW)W−1 = I. Third, V(VI, nW−1)W is well defined since, by definition, VI, nW−1 is UP. Then V(VI, nW−1)W = (I, n), if we restrict to the values of I for indices below n. However they might differ for indices above n, but, by Lemma 51, variables with such indices do not occur in the instance of ⌈φ⌉ by n. Since we consider equality among interpretations only up to the values of propositional variables occurring in the corresponding instance of ⌈φ⌉, we indeed have the intended equality.\nWe finally show that the codomain of V.W−1 indeed falls in the set of models of φ, i.e. that for every model M of ⌈φ⌉, VMW−1 |= φ. We shall prove the more\ngeneral result that, for every t ≤ k + l − 1, where k, l are the prefix index and the period of VMW−1, and every subformula ψ of φ, if M |= spfx≤ ∧ |ψ|t ∧Φ φ then VMW−1, t |= ψ. By induction on the structure of φ:\n– For ⊤ this is trivial. – Assume φ = ¬ψ. Then M |= spfx≤ ∧ |φ|t ∧ Φ φ implies M |= |¬ψ|t and M |=\nAx¬ψ, thus M |= ¬ |ψ|t, so M 6|= |ψ|t. As already shown, M = V(VMW −1)W (as far as we consider t ≤ k + l − 1 which is indeed the case here), hence V(VMW−1)W 6|= |ψ|t. Hence, by contraposition w.r.t. the previous result in this proof, VMW−1, t 6|= ψ. Consequently, VMW−1, t |= φ. – For conjunction the result is routine, using the induction hypothesis. – Assume φ = Xψ. Then we have either t < k + l − 1 or t = k + l − 1. In\nthe first case, one easily gets M |= spfx≤ ∧ |ψ|t+1 ∧Φ ψ by the first conjunct of AxXψ and concludes by induction hypothesis. In the second case, |φ|k+l−1 is equivalent to |φ|n (because, by definition of V.W\n−1, k+ l−1 is the value given to n), so we can use the second conjunct which states that ψ must hold at time k. By the UP property, ψ also holds at time k + l, i.e. t+ 1, hence the result. – Finally assume φ = φ1Uφ2. We have two cases: Either there is some t ′\ncomprised between t and k+ l− 1 s.t. |φ2|t′ holds; assume furthermore that t′ is the smallest time with this property; in this case, |φ1| must hold between t and t′, by the (iterated application of the) first conjunct of Axφ1Uφ2 ; we then just apply the induction hypothesis to conclude. Or there is no such t′, in which case |φ1| must hold from t to k + l − 1, by the same argument. Furthermore, since |φ2|t′ never holds for t\n′ between t and k + l − 1, the iteration\n∧n i=0(i = k ⇒ |φ1U\n′φ2|i) of the second conjunct also holds in M. Hence M |= |φ1U\n′φ2|k. Consequently, by the iterated application of the last two conjuncts, there must be some t′ comprised between k and k+ l− 1 (actually t−1 is sufficient) s.t. |φ2|t′ holds, and |φ1| holds in between: indeed, the last conjunct imposes that |φ2| must hold at worst at instant n (note: this is precisely why U′ is needed). The fact that |φ1| holds in between is due to the similar structure between the two first and the two last conjuncts. Finally, by the UP property, the same holds for t′ + l, which enables us to conclude. ⊓⊔\nFurthermore it is trivial that #⌈φ⌉ is linear w.r.t. #φ.\nCorollary 53. The satisfiability problem for LTL can be reduced in linear space to the satisfiability problem for SPS.\nTheorem 54. The satisfiability problem for SPS is PSPACE-complete if numbers are encoded in unary or bounded by a constant.\nProof. Consequence of the fact that the satisfiability problem for LTL is PSPACEcomplete, of the previous corollary and of Theorem 42. ⊓⊔\nNotice however that this result could be proved in a much simpler way by directly encoding a polynomial space Turing machine with SPS. Such a proof would be very close to the one of Theorem 1 in [Byl91].\nImprovements. For practical efficiency, we can improve over Definition 50. We can translate the purely propositional connectives directly, i.e. without axiomatising them: any occurrence of an atom |⊤|e (resp. |¬φ|e, resp. |φ1 ∧ φ2|e) is directly replaced by ⊤ (resp. ¬|φ|e, resp. |φ1|e ∧ |φ2|e) repeatedly until there is no more such occurrence. The same applies to ∨, ⇒ and ⇔. Those are defined as abbreviations in the present paper in order to simplify definitions and proofs, but it is of course more efficient in practice to translate them directly when available as primitive connectives (obviously, this is also true for Definition 35).\nAnother optimization can be devised by observing that all schemata decision procedures [ACP09,ACP10a] reason by induction on n, i.e. they refute a schema for any value of n by reduction to the case n− 1. In our reduction, n corresponds to the last instant of the UP interpretation. Consequently, a schema procedure applied to a translated LTL formula starts by considering the last instant of the interpretation and then going backward. This is counter natural since we try to refute a formula at time 0. For instance, an inductive proof is achieved for the formula Xp∧X¬p even though this is obviously not needed: one would naturally try to first see what happens at time 0 and then switch to the next state, as is done with LTL procedures. To tackle this problem we just need to change the translation by “inverting the time”: i.e. the index 0 will be interpreted as the last instant of the period and the index n as its first instant. Concretely, in Definition 50, we just rewrite every index i − 1 into i, every index i into i + 1, every index 0 into n, and every index n into 0. Experiments with this translation indeed confirm that conjectures are refuted faster using this new translation.\nRemark 55. The translation given here might remind the reader of bounded model checking (BMC) [BCC+03]. A very important difference however is that our reduction is complete, which is of course not the case of BMC. Indeed, the whole point of schemata is to reason about an infinite family of propositional formulae without having to instantiate the parameter. Our translation could of course be used for BMC, simply by instantiating the parameter with successive natural numbers. However the converse does not hold: not every translation found in BMC could fit instead of Definition 50, since the result must respect the syntactical criteria ensuring decidability of the satisfiability problem. For instance, renaming sub-formulae by propositional variables is just an optimization in the case of BMC whereas in our case, it is needed since, otherwise, the resulting schema would not be sequential (and not even regular). Completeness is an important problem in BMC which is usually tackled with notions like completeness thresholds and recurrence diameter [BCC+03] or induction [SSS00]. Thorough analysis of how schemata procedures handle the above translation could give new ideas in order to get completeness for BMC."
    }, {
      "heading" : "6 Implementation",
      "text" : "The implementations of both translations are available at http://membres-liglab.imag.fr/aravantinos/Site/ Some preliminary experiments have been achieved on a few benchmarks: standard schemata examples provided with RegStab [ACP10c] have been translated\nto LTL (note that the examples have been slightly modified in order to fit the constraints of SPS) and standard LTL pattern formulae [RV07] have been translated to SPS. The performance of RegStab and pltl (http://users.cecs.anu.edu.au/~rpg/software.html) have been compared on both benchmarks. In both cases, pltl clearly outperformed RegStab. We see two reasons to this:\n– RegStab deals with regular schemata, which are more general than SPS. In particular, the decision procedure for such schemata requires the detection and elimination of pure literals (an adaptation of the “Affirmative-negative rule” of [DP60]), which is well-known to be a huge time-consuming task (and this is even more the case for schemata since we have to deal with a symbolic notion of pure literal). This auxiliary procedure is needed for termination, and is mainly a consequence of the “non-local” aspect of schemata.\n– With LTL procedures, given a formula φ, one knows in advance all the formulae that will occur in the deduction process: all of them belong to the closure of φ (merely the set of all subformulae of φ, closed by negation and unfolding of temporal formulae); this permits the use of efficient data structures to represent sets of formulae, e.g. pltl uses bitsets. This is not the case of SPS (and even more regular schemata), e.g. refuting a schema containing\n∧n i=0 pi potentially leads to the introduction of pn, pn−1, pn−2,\netc. By termination for regular schemata [ACP09], this enumeration is finite but one does not know in advance how far it has to go. Hence the data structures used in RegStab are much heavier: e.g. we use balanced trees for sets of formulae. Thus, for big examples, the memory is easily saturated and RegStab spends much of its time in its handling which was absolutely not the case of pltl.\nThe most important reason seems to be the second one. It can actually be tackled in order to improve RegStab performance: we can syntactically extract from the input schema a bound for the above enumeration pn, pn−1, pn−2, . . . by analysis of the termination proof for regular schemata. Implementing this technique is ongoing work.\nYet, there are examples where RegStab did better than pltl. Consider (p1 ⇒ qn+1) ∧ p1 ∧ ¬qn+1 ∧ φ where φ is any formula involving some iterations. This schema is immediately refuted by RegStab, but the bigger φ is, the longer it takes for pltl to refute the corresponding LTL formula. Of course, this example was devised to emphasize one of the strengths of RegStab: contrarily to LTL procedures in general, and to pltl in particular, reasoning about schemata is global, i.e. RegStab may reason simultaneously on propositions containing various symbolic indices. In contrast, pltl will analyse the formula φ and the contradiction will appear only at the end of the construction (i.e. by “discovering” eventually that t = n cannot hold at any state, since it would allow to derive a contradiction)."
    }, {
      "heading" : "7 Discussion",
      "text" : ""
    }, {
      "heading" : "7.1 Pros and cons of each logic",
      "text" : "Since LTL and SPS are equivalent w.r.t. satisfiability, one may wonder which to favour. There are two major differences between LTL and schemata:\n– LTL default interpretations are infinite whereas those of schemata are finite; – LTL refers to states in an anonymous way, whereas schemata name them.\nThese differences provide us with clear criteria for choosing one logic or the other in different situations: to specify an infinite behaviour, one would naturally use LTL, whereas classes of structurally similar finite behaviours are more naturally specified with schemata. Unsurprisingly, the specification of temporal behaviours falls of course in the first category. But, e.g., the specification of a circuit independently of the number of bits of its input falls in the second category. Consider for instance the specification of a ripple-carry adder:\nn∧\ni=0\n((si ⇔ (xi ⊕ yi)⊕ ci) ∧ (ci+1 ⇔ (xi ∧ yi) ∨ (yi ∧ ci) ∨ (xi ∧ ci))) ∧ ¬c0\nwhere x0, . . . , xn and y0, . . . , yn are the input bit vectors of size n; s0, . . . , sn is the output bit vector and c0, . . . , cn is the carry vector. Here the indices indeed correspond to the time in a concrete sequential circuit. However, from a specification point of view, those indices are just an abstract way to represent a generic scheme of circuits. Consequently, the schema syntax seems better suited to this case (notice furthermore that it is very intuitive).\nSimilarly, the choice between a named or an anonymous representation of states depends on the situation. The X connective is well suited to express properties in a local way, since there is no need to explicitly use an index to refer to the current or the next state. The U connective is also far more intuitive than its translation to SPS to refer to some instant satisfying some property in the future. On the other hand, in order to refer to an identified instant of the future, one needs to refer to it by giving it a name, which is easily done with the schema syntax thanks to arithmetic. Consider e.g. the example p0∧ ∧n−1 i=0 (pi ⇒ pi+1)∧¬pn translated as p∧G(t < n ⇒ p⇒ Xp)∧G(t = n ⇒ ¬p) (plus the necessary axioms φt<n< ∧Axt=n) in LTL. One can even specify behaviours after that time (but this goes beyond sequential schemata [ACP11]), e.g. one can write p0∧ ∧n i=0(pi ⇒ pi+1)∧ ∧2n\ni=n(¬pi+1 ⇒ ¬pi)∧¬p2n. It seems improbable that such a property would be useful in a temporal context, but this could be used to specify planning problems with some predefined strategy e.g. if one wants to allow some set of actions in a first phase of a planning problem and then another set in some other phase of this problem."
    }, {
      "heading" : "7.2 Behaviour of ⌊.⌋ w.r.t. LTL decision procedures",
      "text" : "We now analyse informally how the standard multi-pass tableau procedure of [Wol85] (called LTL-tab from now on) behaves on a translated schema. Consider\nthe example p0 ∧ ∧n−1\ni=0 (pi ⇒ pi+1) ∧ ¬pn and its translation p ∧G(t < n ⇒ p ⇒ Xp) ∧ G(t = n ⇒ ¬p) ∧ φt<n< ∧ Axt=n\n4. We do not present a detailed tableau, instead we just sketch its construction by focusing on the most relevant branches (the following requires some knowledge of LTL-tab, see [Wol85] otherwise).\nWhen applying LTL-tab, the rule for the U connective applies on φt<n< (i.e. (t < n)UG(¬t < n)) and generates one branch where G(¬t < n) holds and one branch where t < n and X((t < n)UG(¬t < n)) hold. Intuitively, the first one corresponds to the case n = 0 (since it states that ¬(t < n) always holds from the initial state till ω) while the second one corresponds to n > 0 (since t < n holds at the initial state). In the first case, LTL-tab easily finds a contradiction using mostly propositional reasoning (¬t < n entails t = n thanks to Axt=n, and t = n entails ¬p with G(t = n ⇒ ¬p), thus yielding a contradiction). In the second case, since t < n holds, one easily obtain Xp by propositional reasoning with t < n ⇒ p⇒ Xp. Then the decomposition of Axt=n yieldsG(t < n∧¬X(t < n) ⇔ X(t = n)). By application of the rule for G, one immediately gets the formula t < n ∧ ¬X(t < n) ⇔ X(t = n), and we then get two non-closed branches: one where ¬X(t < n) and X(t = n) hold (call this state “1”), and one where X(t < n) and ¬X(t = n) hold (“2”). At the next state, we thus have two branches: one where ¬t < n and t = n hold, and one where t < n and ¬t = n hold. The first branch means that the instant corresponding to n has been reached and is easily closed similarly to the base case (actually, up to some formulae that only occur in the initial formula, this state is the same as the one corresponding to n = 0). The second branch means that n has still not been reached, thus we can go to the next state without encountering a contradiction. This is easily seen to lead either to state “1” or “2”, hence the construction of the tableau terminates. Since “2” is closed the only non closed branch is the one that indefinitely loops on “1”. But this loop is closed in the second pass because the eventuality (t < n)UG(¬t < n) is never satisfied.\nTo sum up, the construction of this tableau follows quite faithfully a proof by induction on the parameter n. The axioms φt<n< and Axt=n contain the arithmetic content that drive the induction, while ⌊s⌋prop contains the purely propositional content. Since LTL has to deal with infinite interpretations the induction is not well-founded in general (this is of course a wanted feature of LTL in order to deal with coinductive specifications). But the axiom φt<n< introduces the eventuality (t < n)UG(¬t < n) which enforces a well-founded induction. Notice that ⌊.⌋ can be modified so that φt<n< be the only eventuality occurring in the resulting formula. Indeed, in its current state, the translation may introduce eventualities in two ways: either by negating an iteration\n∧n−1 i=0 s, or by negating an atom of the\nform pn+k. In the first case, the negation is equivalent to ∨n−1 i=0 ¬s which can easily be simulated by the proposition qn with the axiom ¬q0 ∧ ∧n−1\ni=0 qi+1 ⇔ (¬s ∨ qi). In the second case the translation of ¬pn+k is ¬G(t = n ⇒ X\nkp). But, as already encountered in Example 36, this is equivalent to G(t = n ⇒ Xk¬p) since\n4 Notice that this translation has been simplified since we use G(t = n ⇒ ¬p) instead of ¬G(t = n ⇒ p).\nt = n holds at only one instant. Consequently one can get rid of those artificial eventualities as follows:\n– put the schema in negation normal form (this introduces ⊥, disjunctions and iterated disjunctions);\n– delete every iterated disjunction by replacing it with a proposition qn axiomatized as above;\n– apply the translation (which is straightforwardly extended to ⊥ and disjunction) by handling the case ¬pn+k as above.\nThis is interesting since it makes the second pass much easier to handle. Furthermore it shows clearly that the overall proof is indeed an inductive proof, obtained from a coinductive proof by discarding the ill-founded branch in the second pass.\nProof procedures for schemata are defined by combining usual propositional procedures and inductive reasoning. This inductive reasoning is performed by a loop detection during the construction of the tableau. For instance Stab [ACP09] is defined by extending semantic tableaux. The reader acquainted with Stab may have noticed that the tableau we just sketched looks quite similar to the one that would be obtained with Stab for the corresponding schema. This is mainly a matter of strategy since we oriented the construction in a way to make it understandable from a “schema point of view”. There are many other tableaux that would have differed from the one obtained with Stab. The main differences between LTL-tab and Stab are the following:\n– Arithmetic is handled natively in Stab;\n– In LTL-tab, termination is ensured by identifying nodes with the same labels, whereas this is not sufficient, in Stab, to ensure termination: a dedicated cycle relation must be defined (e.g. there is a cycle between\n∧n−1 i=0 s and∧n\ni=0 s). This is obviously not an essential difference, which is only related to the way schemata are represented and stored in the nodes;\n– In LTL-tab, an artificial branch corresponding to an ill-founded derivation is discarded in the second phase, whereas in Stab the cycle relation embeds a (strict) ordering which ensures the well-foundedness of the derivation (e.g. ∧n\ni=0 s cannot loop on itself). Consequently Stab does not require a second phase.\n– In LTL-tab, the reasoning is purely local, i.e. only formulae that are true at the current state are derived. In contrast, Stab may reason simultaneously on propositions containing various symbolic indices. This is related to the fact that schemata handles time in a symbolic way and it explains why, as mentioned in Section 6, pltl performed so bad on (p1 ⇒ qn+1)∧p1∧¬qn+1∧φ where φ is a big formula involving some iterations. In contrast LTL-tab (and pltl) analyses the formula φ and the contradiction appears only at the end of the construction (i.e. by “discovering” eventually that t = n cannot hold at any state, since it would allow to derive a contradiction)."
    }, {
      "heading" : "7.3 Behaviour of ⌈.⌉ w.r.t. SPS decision procedures",
      "text" : "Conversely, we can consider an LTL formula φ and apply Stab on ⌈φ⌉. For instance, take the unsatisfiable LTL formula φ def\n= Xp ∧ ¬Xp. The translation is then the conjunction of the following schemata (we use the optimizations mentioned at the end of Section 5):\n|Xp|n ∧ |X¬p|n n−1∧\ni=0\n(|Xp|i+1 ⇔ pi)\n|Xp|0 ⇔ (0 = k ⇒ p0) ∧\nn−1∧\ni=0\n(i+ 1 = k ⇒ pi+1)\nn−1∧\ni=0\n(|X¬p|i+1 ⇔ |X¬p|i)\n|X¬p|0 ⇔ (0 = k ⇒ ¬p0) ∧\nn−1∧\ni=0\n(i+ 1 = k ⇒ ¬pi+1)\n¬pfxn ⇔ n = k\nn−1∧\ni=0\n(pfxi ∧ ¬pfxi ⇔ i = k)\n¬pfx0 n−1∧\ni=0\n(pfxi ⇒ pfxi+1)\nIt is immediately noticed that, even though the transformation is linear, the linear coefficient is very big: a very simple LTL formula is turned into a complicated schema.\nWe just sketch the resulting tableau. As explained in the previous section, the general idea of Stab is to refute a formula by induction on the parameter n. In the context of ⌈.⌉, n represents the length of a UP interpretation. Consequently Stab shows that every UP interpretation falsifies the formula, by induction on n. Such an approach is obviously original, but a priori not natural from an LTL point of view. The general scheme of the proof may be divided into three cases as follows (see Fig. 7): either the interpretation has only one state (looping on itself), or it has more than one state. In the first case, there are finitely many interpretations, so the proof is easily achieved (simply by a tableaux-like enumeration of interpretations). In the second case, we encounter two more cases, depending on the position of the prefix index: it can either coincide with the first state, or with a state farther in the interpretation (formally, this corresponds to a simple case splitting on the propositional variable n = k). The reasoning in each case then depends on the formula itself.\nIt is particularly interesting to understand how we deal with eventualities: how does it happen that we do not need a second phase, similarly to LTL-tab? To answer this question, we can observe (again informally) how Stab behaves on the formula Gp ∧ F¬p. Notice that we can easily define a simplified translation for the connectives G and F with the following axioms:\nAxGφ def = ∧n−1\ni=0 (|Gφ|i ⇔ |φ|i ∧ |Gφ|i+1)\n∧(|Gφ|n ⇔ |φ|n ∧ ∧n i=0(i = k ⇒ |Gφ|i))\nAxFφ def = ∧n−1\ni=0 (|Fφ|i ⇔ |φ|i ∨ |Fφ|i+1)\n∧(|Fφ|n ⇔ |φ|n ∨ ∧n i=0(i = k ⇒ |F ′φ|i)) ∧ ∧n−1\ni=0 (|F ′φ|i ⇔ |φ|i ∨ |F ′φ|i+1)\n∧(|F′φ|n ⇔ |φ|n)\nwhere F′ is a new connective which is to F what U′ is to U. The case with only one state is easily handled. When there are more than one state, it is easily seen that the conjecture Gp ∧ F¬p still holds at the next instant. Thus if the prefix index is above 1, then the induction hypothesis allows to conclude immediately. However when the prefix is empty, the induction hypothesis does not apply: we actually need to make a case splitting on the value of the variable F′¬p: intuitively, this variable holds iff there is some instant before n s.t. p holds. If this variable is assumed true, then we easily obtain a contradiction with Gp (by induction). If it is supposed false, then we get a contradiction with the (second conjunct of the) axiom of U which states that φ1U\n′φ2 must hold at time k (i.e. 0, here), and this concludes the refutation.\nLet us now generalize the way eventualities are handled. At any moment, the procedure “stores” the fact that any eventuality occurring as a subformula of the original formula holds or not. This is stored in the corresponding “primed” subformula (i.e. it is true iff the eventuality holds). Then, if ever an eventuality does not hold at the end of the period, the second conjunct of the U axiom imposes that the eventuality held before that time, inside the period. If this was not the case, then the corresponding primed subformula is false, thus we\nget a contradiction and this interpretation is discarded. On the contrary, if the eventuality held before, then we found a model.\nThe reader acquainted with the one-pass Schwendimann algorithm (“SA”) for LTL [Sch98] might recognize this behaviour. Indeed this algorithm builds a tableau by maintaining in each state a set of unfulfilled eventualities. This can be seen as corresponding to the “primed eventualities” of our translation. The set of unfulfilled eventualities at a state can be retrieved simply as the set of primed eventualites that are false at that state. However, apart from those informal similarities, the procedures are quite different:\n– Stab builds explicitly a UP interpretation (that can be retrieved directly from a non closed branch of the resulting tableau) whereas SA just ensures that such an interpretation exists (which can be retrieved by loop linearization, see [Sch98], proof of Theorem 28). This probably makes the outcome of SA more “understandable”, since it is more compact. – In any branch, Stab considers all eventualities, whereas SA considers only the eventualities needed for the current branch. This makes probably SA more efficient than Stab since many useless situations are trivially discarded. – On the other hand, the fact that Stab considers all eventualities makes it possible to consider a looping in the whole tree. This is not the case of SA which imposes a looping in the current branch. This is precisely why the worst-case complexity of SA is bigger than the one of algorithms à la Wolper. Of course, an implementation of Stab can still impose loopings to occur only in the current branch which thus makes available both possibilities to Stab. Consequently, an advantage of Stab is that it allows for a one-pass algorithm, while preserving an exponential time complexity. – The trade-off is that Stabmakes some redundant computations: for instance, the procedure needs to “decide” in advance if a node is the start of the UP interpretation’s loop, thus leading to two different branches sharing many inferences. With SA, the inferences are just made irrespective of whether the node will be the start of the loop or not, and then the loop detection is handled by the algorithm itself. Similarly the fact that the semantics are encoded in the translation makes Stab consider some cases that would be automatically discarded by SA."
    }, {
      "heading" : "8 Model checking safety properties with schemata: an example",
      "text" : "With the translation given in Section 5, and classical results of reduction from satisfiability to model checking [SC85,RV07], one can of course use schemata to model check LTL formulae. However if we restrict ourselves to n.n.f. LTL formulae whose only temporal operators are X and G, we can obtain a much simpler translation into schemata. Such formulae are of interest since they can in particular model safety properties, i.e. formulae of the form Gψ where ψ is a purely propositional formula. Suppose we have a transition system T and want to check if it is a model of φ. We first recall those notions:\nDefinition 56. A transition system is the triple of a set of states S, a set of actions A, and a transition function δ : S × A → S. A (finite or infinite) path is a sequence of states which respects the transition function.\nAn interpreted transition system is the pair of a transition system and a labelling function l : S → 2P , where P is a finite set of propositional variables. As usual a computation is a sequence of subsets of P corresponding to some path of the transition system. For a given path π, we write l(π) for its corresponding computation.\nAn infinite computation can obviously be seen as an LTL interpretation (in the sense of Definition 1). Then an interpreted transition system (T, l) is a model of an LTL formula φ iff every infinite computation in (T, l) is a model of φ.\nWe now show on an example how we can model check a transition system against a formula using schemata. We do not provide any formalisation since the example can easily be generalized. Consider the interpreted transition system T represented on Figure 8. We can represent the behaviour of T on all finite paths with\na schema.\nFirst we model the sole structure of the system, i.e. the uninterpreted transition system. The indexed proposition state1i (resp. state 2 i , state 3 i ) means we are in state 1 (resp. 2, 3) at time i, and actionai (resp. action b i ) means that the action taken at time i is a (resp. b):\nstate1i ∧ action a i ⇒ state 3 i+1 state1i ∧ action b i ⇒ state 2 i+1 state2i ∧ action a i ⇒ state 2 i+1 state2i ∧ action b i ⇒ state 2 i+1 state3i ∧ action a i ⇒ state 2 i+1 state3i ∧ action b i ⇒ state 1 i+1\nNow the label of each state is easily modelled by the following schema:\nstate1i ⇒ pi ∧ qi ∧ ¬ri state2i ⇒ ¬pi ∧ qi ∧ ri state3i ⇒ pi ∧ ¬qi ∧ ri\nwhere pi (resp. qi, ri) means that p (resp. q, r) holds at time i. Finally we also have to specify the fact that, at each instant i, there is one and only state active, and one and only one action can be taken 5:\nstate1i ⇔ ¬state 2 i ∧ ¬state 3 i state2i ⇔ ¬state 1 i ∧ ¬state 3 i state3i ⇔ ¬state 1 i ∧ ¬state 2 i actionai ⇔ ¬action b i\nWe write sT for the conjunction of all those schemata, all wrapped under a single∧n i=0. s is not precisely an SPS since the upper bound of this iteration is n and not n− 1. But this is easily circumvented (s is regular anyway). Now if we want to check this model against the formula G(p ∨ q), we first translate this formula into a schema: ⌈G(p∨ q)⌉ = ∧n\ni=0(pi ∨ qi). If the transition system is indeed a model of G(p∨q), then s⇒\n∧n i=0(pi∨qi) must be valid (which\nintuitively means that for every n ∈ N and every path of length n, the property p∨ q holds all along the path). Equivalently, it is a model iff s∧\n∨n i=0(¬pi ∧¬qi)\nis unsatisfiable (which means that there exists n ∈ N and a path of length n s.t. the property p ∨ q does not hold at one state of the path). We can thus use any regular schema SAT-solver (like RegStab) to check if this formula is satisfiable or not."
    }, {
      "heading" : "9 Conclusion and future work",
      "text" : "LTL formulae and the so-called sequential propositional schemata have been shown to be reducible to each other in polynomial time (exponential time when numbers are encoded in binary). This entails that the satisfiability of SPS is PSPACE-complete. Both those results are new. The reduction of SPS to LTL is not so surprising, and the converse reduction makes use of the well-known fact that the infinite semantics of LTL can be finitely represented. This remark illustrates one of the two major differences between LTL and schemata: whereas the semantics of LTL are infinite, those of schemata are finite. The other difference is that schemata allow to refer to a time in the future in a symbolic way (using the parameter n) and to use arithmetic operations to construct time expressions. If these operations are sufficiently simple, they can be encoded in LTL formulae as shown in Section 4. On the other hand, LTL allows for a much handier way to deal with time in a purely local way.\n5 It is actually useless to ensure explicitly the unicity of actions since this is entailed by the unicity of states.\nFuture work. Using the above translations to help export procedures from one logic to another is an obvious follow-up of this work (in particular, Dpll inspired procedures for schemata could help defining such a procedure for LTL). Similarly, as explained in Remark 55, investigating how model checking is done by translation to schemata could give ideas to define new completeness criteria for bounded model checking. The extension of the presented results to other classes of schemata could also be considered, e.g. schemata with nested iterations (proved decidable in [ACP10a,ACP11]). Translation algorithms from nested schemata into sequential ones exist [ACP11], however they are of double exponential complexity. Thus we conjecture that no polynomial-time transformation from nested schemata to LTL exists. The extension of this study to other – more expressive – temporal logics could also be of interest. Notably, LTL with past operators [LPZ85] seems to be easily handled with (non sequential) schemata simply by allowing negative numbers in indices. Since implementations for this logic do not have the same support as standard LTL and are generally not as efficient, such a reduction could help in improving those points. One could go even further by making connections between schemata and monadic second order logic (MSO). This would be interesting both in theory and practice, since few implementations are available for MSO (only MONA [HJJ+95] seems to be actively maintained)."
    } ],
    "references" : [ {
      "title" : "A Schemata Calculus for Propositional Logic, TABLEAUX",
      "author" : [ "ACP09. Vincent Aravantinos", "Ricardo Caferra", "Nicolas Peltier" ],
      "venue" : "vol. 5607,",
      "citeRegEx" : "Aravantinos et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Aravantinos et al\\.",
      "year" : 2009
    }, {
      "title" : "A Resolution Calculus for Propositional Schemata",
      "author" : [ "AMEP10. Vincent Aravantinos", "Mnacho Echenim", "Nicolas Peltier" ],
      "venue" : "Tech. report,",
      "citeRegEx" : "Aravantinos et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Aravantinos et al\\.",
      "year" : 2010
    }, {
      "title" : "Bounded model checking",
      "author" : [ "BCC03. Armin Biere", "Alessandro Cimatti", "Edmund M. Clarke", "Ofer Strichman", "Yunshan Zhu" ],
      "venue" : "Advances in Computers",
      "citeRegEx" : "Biere et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Biere et al\\.",
      "year" : 2003
    }, {
      "title" : "LTL Goal Specifications Revisited, ECAI (Amsterdam)",
      "author" : [ "BH10. Andreas Bauer", "Patrik Haslum" ],
      "venue" : null,
      "citeRegEx" : "Bauer and Haslum,? \\Q2010\\E",
      "shortCiteRegEx" : "Bauer and Haslum",
      "year" : 2010
    }, {
      "title" : "The complexity of propositional linear temporal logics",
      "author" : [ "SC85. A.P. Sistla", "E.M. Clarke" ],
      "venue" : "Journal of the ACM",
      "citeRegEx" : "Sistla and Clarke,? \\Q1985\\E",
      "shortCiteRegEx" : "Sistla and Clarke",
      "year" : 1985
    }, {
      "title" : "Star-free regular sets of ω-sequences",
      "author" : [ "Tho79. Wolfgang Thomas" ],
      "venue" : "Information and Control",
      "citeRegEx" : "Thomas,? \\Q1979\\E",
      "shortCiteRegEx" : "Thomas",
      "year" : 1979
    }, {
      "title" : "Temporal Logics for Specification and Verification, Proceedings of the European Summer School in Logic, Language and Information (ESSLI’09)",
      "author" : [ "VG09. Valentin Goranko" ],
      "venue" : null,
      "citeRegEx" : "Goranko,? \\Q2009\\E",
      "shortCiteRegEx" : "Goranko",
      "year" : 2009
    }, {
      "title" : "The tableau method for temporal logic: an overview",
      "author" : [ "Wol85. Pierre Wolper" ],
      "venue" : "Logique et Analyse",
      "citeRegEx" : "Wolper,? \\Q1985\\E",
      "shortCiteRegEx" : "Wolper",
      "year" : 1985
    }, {
      "title" : "Reasoning about infinite computation paths",
      "author" : [ "WVS83. Pierre Wolper", "Moshe Y. Vardi", "A. Prasad Sistla" ],
      "venue" : "Foundations of Computer Science, Annual IEEE Symposium on",
      "citeRegEx" : "Wolper et al\\.,? \\Q1983\\E",
      "shortCiteRegEx" : "Wolper et al\\.",
      "year" : 1983
    } ],
    "referenceMentions" : [ ],
    "year" : 2013,
    "abstractText" : "This paper relates the well-known formalism of Linear Temporal Logic [Pnu77] with the logic of propositional schemata introduced in [ACP09]. We prove that LTL is equivalent to a particular class of schemata in the sense that polynomial-time translation algorithms exist from one logic to the other. Some consequences about complexity are given. We report about first experiments and the consequences about possible improvements in existing implementations are analyzed.",
    "creator" : "LaTeX with hyperref package"
  }
}