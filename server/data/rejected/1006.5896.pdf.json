{
  "name" : "1006.5896.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Counterexample Guided Abstraction Refinement Algorithm for Propositional Circumscription",
    "authors" : [ "Joao Marques-Silva" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n00 6.\n58 96\nv1 [\ncs .A\nI] 3\n0 Ju"
    }, {
      "heading" : "1 Introduction",
      "text" : "Closed world reasoning (CWR) and circumscription (CIRC) are well-known nonmonotonic reasoning techniques, that find a wide range of practical applications. Part of the interest in these techniques is that they bring us closer to how humans reason [15,17,16]. While these techniques have been studied in the context of both first-order and propositional logic, this paper addresses the propositional case. Research directions that have characterized the study of nonmonotonic reasoning techniques include expressiveness, computational complexity, applications and algorithms. The different CWR rules proposed in the late 70s and 80s illustrate the evolution in terms of expressive power in first-order and propositional logics. The computational complexity of propositional CWR rules was studied in the early 90s [1,6] and showed that, with few exceptions, the complexity of CWR deduction problems are in the second level of the polynomial hierarchy, being ΠP2 -complete [6]. Nonmonotonic reasoning finds a wide range of applications in Artificial Intelligence (AI), but also in description logics [7]\nand in interactive configuration [13], among many others. Finally, different algorithms have been proposed over the years, examples of which include minimal model resolution [20], tableau calculus [18], Quantified Boolean Formula (QBF) solvers [5] and Disjunctive Logic Programming (DLP) [14,12,19].\nThe main contribution of this paper is to propose a new algorithm for solving the deduction problem for the propositional version of some CWR rules and for propositional circumscription. The new algorithm is based on iterative calls to a SAT solver, and is motivated by the practical success of modern SAT solvers. However, given the complexity class of entailment for CWR rules, a SAT solver can be expected to be called an exponential number of times in the worst case, or be required to process an exponentially large input. To cope with this issue, we utilize a technique inspired in counterexample guided abstraction refinement (CEGAR), widely used in model checking [3]. One of the key ideas of the new algorithm is that we try to prove a stronger formula, which is weakened if it turns out to be too strong. Based on this idea we develop an algorithm that decides entailment in circumscription. Further, we refine the algorithm to compute the closure of a formula defined by one of the variants of CWR, namely GCWA. As a result, the main contributions of the paper can be summarized as follows: (i) A novel algorithm for propositional circumscription that does not require an enumeration of all minimal models or prime implicates; (ii) Specialization of this algorithm to compute variables that are 0 in all minimal models; and (iii) Computing the closure of GCWA.\nThe paper is organized as follows. The next section introduces the notation and concepts used in the remainder of the paper. Section 3 introduces the computational problems addressed in the paper. The new algorithms are described in Sections 4, 5, and 6. The new algorithms are compared to alternative algorithms in Section 7. The paper concludes with directions for future research work."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "All variables are propositional, and represented by a finite set V . A Conjunctive Normal Form (CNF) formula φ is a conjunction of clauses, which are disjunctions of literals, which are possibly negated variables. A formula φ can also be viewed as a set of sets of literals. The two representations are used interchangeably in this paper. A clause is called positive, if it contains only positive literals. Arbitrary Boolean formulas will also be considered, for which the standard definitions apply. A variable assignment ν is a total function from V to {0, 1}. In the text, a variable assignment is represented as {xv11 , . . . , x vn n } where V = {x1, . . . , xn} and vi ∈ {0, 1}, i ∈ 1..n. For a variable assignment ν and a formula φ we write ν |= φ to denote that ν satisfies φ. In this case, ν is called a model of φ. We write φ |= ψ if the models of φ are also models of ψ. Given a set of variables S ⊆ V and v ∈ {0, 1}, the expression φ[S 7→ v] denotes the formula φ with all variables in S replaced with v."
    }, {
      "heading" : "2.1 Minimal Models",
      "text" : "Minimal models are widely used in nonmonotonic reasoning and AI in general. To introduce minimal models, we consider the bitwise ordering on variable assignments. For variable assignments ν and µ we write ν ≤ µ and say that ν is smaller than µ iff (∀x ∈ V )(ν(x) ≤ µ(x)). We write ν < µ and say that ν is strictly smaller than µ iff ν ≤ µ and ν 6= µ. A model ν of φ is a minimal model iff there is no model of φ strictly smaller than ν. Finally, we write φ |=min ψ if ψ holds in all minimal models of φ.\nProposition 1. The models of formula φ that are strictly smaller than some variable assignment ν are the models of the formula\nφ ∧ ∧\nν(x)=0 ¬x ∧\n∨\nν(x)=1 ¬x (1)"
    }, {
      "heading" : "2.2 Closed World Reasoning",
      "text" : "The intuition behind closed world assumption (CWA) reasoning is that facts are not considered to be true unless they were specifically stated. This is motivated by the type of reasoning humans use on an everyday basis. For instance, if Alice asks Bob to buy eggs, Bob will clearly buy eggs. However, he will not buy bread even though Alice has not specified that the bread should not be bought. Traditional mathematical logic behaves differently in this respect: the fact buy-eggs trivially entails buy-eggs but does not entail the fact ¬buy-bread.\nThis intuition has been realized by several different formalisms. Here we present only a small portion of these formalisms and the interested reader is referred to appropriate publications for further reference [1,6,4].\nThe standard formulation of CWA rules partitions set V into three sets: P , Q and Z, where P denotes the variables to be minimized, Z are the variables that can change when minimizing the variables in P , andQ represents all other (fixed) variables. For any set R, R+ and R− denote, respectively, the sets of positive and negative literals from variables in R. Following [1,6], a closure operation is defined for CWR rules as follows:\nDefinition 1. Let φ be a propositional formula, 〈P ;Q;Z〉 a partition of V , and α a CWR-rule. Then, the closure of φ with respect to α is defined by,\nα(φ;P ;Q;Z) = φ ∪ {¬K | K is free for negation in φ w.r.t. α} (2)\nEach CWR rule considers a different set of formulas that are free for negation. For each CWR rule below, a formula K is free for negation if and only if the corresponding condition holds:\nGCWA (Generalized CWA [17]): K is a positive literal and for every positive clause B such that φ 2 B it holds that φ 2 B ∨K.\nEGCWA (Extended GCWA [24]): K is a conjunction of positive literals and for every positive clause B such that φ 2 B it holds that φ 2 B ∨K.\nECWA (Extended CWA [24]): K is an arbitrary formula not involving literals from Z, and for every positive clause B whose literals belong to P+∪Q+∪Q−, such that φ 2 B, it holds that φ 2 B ∨K.\nWe consider only a subset of existing CWR rules. A detailed characterization for existing CWR rules can be found elsewhere [1,6,4].\nObserve that a single positive literal is free for negation in both GCWA and EGCWA under the same conditions. Since a positive literal corresponds to some variable, we extend the terminology for variables accordingly.\nDefinition 2. A variable x is free for negation in φ iff for every positive clause B such that φ 2 B it holds that φ 2 B ∨ v.\nAnother concept closely related to closed world assumption is circumscription. Originally, McCarthy defined circumscription in the context of first order logic as a closure of the given theory that considers only predicates with minimal extension [15]. In propositional logic, circumscription of a formula yields a formula whose models are the minimal models of the original one.\nDefinition 3. Consider the sets of variables P , Q and Z introduced above. The circumscription of a formula φ is defined as follows:\nCIRC(φ;P ;Q;Z) = φ ∧ (∀P ′,Z′)((φ(P ′;Q;Z ′) ∧ (P ′ ⇒ P )) ⇒ (P ⇒ P ′)) (3)\nWhere P ′, Z ′ are sets of variables s.t. X ′ = {x′ | x ∈ X}; φ(P ′, Q, Z ′) is obtained from φ(P,Q,Z) by replacing the variables in P and Z by the corresponding variables in P ′ and Z ′; finally, P ′ ⇒ P stands for ∧\nx∈P (x ′ ⇒ x).\nIn the remainder of the paper the sets Z and Q are assumed to be empty. The extension to the general case where these sets are not empty is simple, and is outlined in Appendix B.\nIt is well-known that for the propositional case, circumscription is equivalent to ECWA [9]. Another well-known relationship is the one of both CWR rules and circumscription to minimal models (e.g. [17,1,6]). In particular variables free for negation take value 0 in all minimal models. And, both EGCWA and circumscription entail the same set of facts as the set of minimal models. These relations are captured by the following propositions (adapted from [17,1,6]):\nProposition 2. A variable x is free for negation in a formula φ iff x is assigned value 0 in all minimal models of φ.\nProposition 3. Let φ and ψ be formulas. It holds that EGCWA(φ) |= ψ iff φ |=min ψ. And, it holds that CIRC(φ) |= ψ iff φ |=min ψ."
    }, {
      "heading" : "3 Problems",
      "text" : "The CWR rules yield the two following problems. The first problem consists of computing the closure of the theory, as defined by the CWR rule. The second problem is that of computing whether a certain fact is entailed by that closure.\nIf the closure has been computed, standard satisfiability algorithms can be used to solve the entailment problem. However, whereas the closure of GCWA increases the size of the formula by at most a linear number of literals, the closure of both ECWA and EGCWA may increase the size of the formula by an exponential number of conjuncts of literals. The circumscription of a formula can be constructed easily but gives rise to a QBF formula and our objective is to stay within propositional logic with the ultimate goal of developing purely SAT-based solutions. Hence, this paper focuses on the following problems.\nEntails-Min instance: formulas φ and ψ question: Does the formula ψ hold in all minimal models of φ?\nFree-For-Negation instance: formula φ and variable x ∈ V question: Does x take value 0 in all minimal models of ψ?\nFree-For-Negation-All instance: formula φ and a variable v ∈ V question: What is the set of variables with value 0 in all minimal models of φ?\nNote that solving Entails-Min enables answering whether a fact is entailed by ECWA or by circumscription due to Proposition 3. Clearly, the problem Free-For-Negation is a special case of Entails-Min with ψ set to ¬x. Solving Free-For-Negation-All gives us the closure of GCWA.\nInterestingly, in terms of complexity, the problem Free-For-Negation is not easier than the problem Entails-Min. Both Entails-Min and Free-ForNegation are ΠP2 -complete [6, Lemma 3.1].\n4 Computing Entails-Min\nThe algorithm we wish to develop will be using a SAT solver. This gives us two objectives. One objective is to construct a propositional formula that corresponds to the validity of φ |=min ψ. The second objective is to avoid constructing an exponentially large formula. We begin by observing that if φ |=min ψ is to hold, then any model of φ that violates ψ must not be a minimal model.\nProposition 4. ψ holds in all minimal models of φ iff any model ν of φ where ¬ψ holds is not a minimal model of φ.\n[φ |=min ψ] ⇔ [(∀ν) ((ν |= φ ∧ ¬ψ) ⇒ (∃ν ′)(ν′ < ν ∧ ν′ |= φ))]\nProposition 4 tells us that whether φ |=min ψ holds or not can be decided by deciding whether the following formula is valid:\n(∀ν) ((ν |= φ ∧ ¬ψ) ⇒ (∃ν′)(ν′ < ν ∧ ν′ |= φ)) (4)\nSince our first objective is to find a propositional formula, we need to eliminate · |= · and quantifiers from (4). First, let us focus on the subformula (∃ν′)(ν′ < ν ∧ ν′ |= φ), which expresses that ν is not a minimal model.\nProposition 5. A model ν of φ is not minimal iff there exists a set S of variables such that ν is a model of φ[S 7→ 0], and ν(x) = 1 for some x ∈ S.\n(∃ν′)(ν′ < ν ∧ ν′ |= φ) ⇔ (∃S ⊆ V ) (ν |= φ[S 7→ 0] ∧ (∃x ∈ S)(ν(x) = 1)) (5)\nExample 1. Let φ = ¬x ∨ y. The model µ = {x0, y0} is minimal and the righthand side of (5) is invalid since there is no set S satisfying the condition (∃x ∈ S)(ν(x) = 1). Let ν = {x0, y1} and let us choose S = {x, y}, which yields φ[S 7→ 0] = 1. ν is not minimal and the right-hand side of (5) is valid since ν |= 1 and ν(y) = 1.\nReplacing the left-hand side of (5) with the right-hand side of (5) in (4) yields the following formula:\n(∀ν) ((ν |= φ ∧ ¬ψ) ⇒ (∃S ⊆ V ) (ν |= φ[S 7→ 0] ∧ (∃x ∈ S)(ν(x) = 1))) (6)\nRemoving the universal quantifier and replacing existential quantifiers with the Boolean operator ∨ in (6), gives us that (6) holds iff the following formula is a tautology:\n(φ ∧ ¬ψ) ⇒ ∨\nS∈P(V )\n(\nφ[S 7→ 0] ∧ ∨\nx∈S\nx\n)\n(7)\nIntuitively, (7) expresses that if ψ is violated in a model of φ, then a different model of φ is obtained by flipping a set of variables to 0. That this model is indeed different is guaranteed by the condition ∨\nx∈S x. The model obtained by the flipping serves as a witness of that the model violating ψ is not minimal.\nIf (7) is constructed, its validity can be decided by calling a SAT solver on its negation. However, the formula is too large to construct since it requires considering all subsets of V . Therefore, we construct a stronger version of it that considers only some subsets of V . This stronger version is referred to as the abstraction of (7) and always has the following form:\n(φ ∧ ¬ψ) ⇒ ∨\nS∈W\n(\nφ[S 7→ 0] ∧ ∨\nx∈S\nx\n)\nwhere W ⊆ P(V ) (8)\nEach abstraction is determined by a set of sets of variables W . For any W , if the abstraction (8) is shown to be a tautology, then (7) is also a tautology and we are done because we have shown that φ |=min ψ. If the abstraction is not a tautology, it is either because φ |=min ψ does not hold or the abstraction is overly strong—it is too coarse. If the abstraction is shown to be too coarse, a different abstraction must be considered.\ninput : formulas φ and ψ output: true iff φ |=min ψ\n1 ω ← φ ∧ ¬ψ 2 while true do 3 (outc1, ν) ← SAT(ω) 4 if outc1 = false then 5 return true // no counterexample was found\n6 (outc2, ν ′) ← SAT\n(\nφ ∧ ∧ ν(x)=0 ¬x ∧ ∨ ν(x)=1 ¬x )\n// find ν′ < ν\n7 if outc2 = false then // ν is minimal 8 return false // abstraction cannot be refined\n9 S ← {x ∈ V | ν(x) = 1 ∧ ν′(x) = 0} 10 ω ← ω ∧ (¬φ[S 7→ 0] ∨ ∧\nx∈S ¬x) // refine\nAlgorithm 1: Refining\nExample 2. Let us show that ¬x ∨ y |=min ¬y. First, let us try W1 = {{y}}, which yields the abstraction ((¬x ∨ y) ∧ y) ⇒ ¬x. This abstraction is not a tautology. In particular, it is violated by the assignment {x1, y1}, which means that flipping y to value 0 in this assignment does not yield a model. Now, let us try W2 = {{x, y}}, which yields the abstraction ((¬x ∨ y) ∧ y) ⇒ 1. This abstraction is a tautology, which means that any model where y is 1 can be turned into another model by flipping both x and y to 0. Therefore, ¬x ∨ y |=min ¬y.\nExample 3. Let φ = ¬x ∨ ¬y ∨ ¬z and ψ = (¬x ∨ ¬y) ∧ (¬x ∨ ¬z) ∧ (¬z ∨ ¬y) Let us show that φ |=min ψ. Let us choose the abstraction defined by the set W = {{x}, {y}}. The following diagram demonstrates that each model violating ψ has a witness corresponding to one of the sets in W .\n000\n100 010 001\n110 101 011 {y}\n{x} {y}\n111\nφ\nφ∧¬ψ Each triple represents a variable assignment\nwhere the elements represent the values of x,\ny, and z, respectively. Models and their per-\ntaining witnesses are connected by an edge,\nwhich is labeled by the set of variables S whose\nvalues are flipped to 0 to obtain the witness.\nThe approach of searching for the right abstraction follows the CounterExample Guided Abstract Refinement (CEGAR) loop [3]. If the abstraction is a tautology, the search terminates. If the abstraction is not a tautology, it is weakened by adding some set of variables S to the set W . This weakening is referred to as refinement and is done by investigating the counterexample that shows that the current abstraction is not a tautology. If it cannot be refined, (7) is not a tautology and φ |=min ψ does not hold.\nAlgorithm 1 realizes the idea outlined above. The algorithm maintains the negation of the abstraction in variable ω and starts with W being the empty set. Therefore the initial abstraction is (φ ∧ ¬ψ) ⇒ 0 with the negation being φ ∧ ¬ψ (line 1). The test whether the abstraction is a tautology or not is done\nby calling a SAT solver on its negation (line 2). If the negation is unsatisfiable— the abstraction is a tautology—then the algorithm terminates and returns true (line 4). If a model ν is found showing that the abstraction is not a tautology, it means that for any assignment that is obtained from ν by flipping some set of variables in S ∈ W to 0 is not a model of φ. The algorithm looks for a model ν′ that is strictly smaller than ν applying Proposition 1 (line 7). If there is no model strictly smaller than ν then the algorithm terminates and returns false since ν is a minimal model and violates ψ (line 9). If there is a model ν′ that is strictly smaller than ν, there is some set of variables that are 1 in ν but are 0 in ν′. This set of variables is added to the sets determining the abstraction (line 9). Observe that a set S will be used at most once to refine the abstraction since once the set is added to W , an assignment for which flipping 1 to 0 for variables in S yields a model cannot satisfy the negation of the abstraction. Consequently, the algorithm is terminating and will perform at most as many iterations as there are subsets of the set V .\n5 Computing Free-For-Negation\nThis section specializes Algorithm 1 to compute variables free for negation— variables that take value 0 in all minimal models. As mentioned earlier, this problem is a special case of the problem Entails-Min, studied in the previous section: x is free for negation in φ iff φ |=min ¬x. However, focusing on this type of formulas enables a more efficient implementation of the algorithm.\nThe abstractions used in the previous section have to contain the condition that at least one of the variables being flipped to 0 is 1 to guarantee the corresponding witnesses is strictly smaller (see (7)). For variables free for negation these conditions will not be needed thanks to the following proposition.\nProposition 6. Let ν be a model of φ s.t. ν(x) = 1 for a variable x. If x is free for negation, then there exists a model ν′ of φ s.t. ν′ < ν and ν′(x) = 0.\nProposition 6 tells us that if ν(x) = 1 and x is free for negation, there must be a witness ν′ that flips x to 0 (and possibly some other variables). This ensures that ν and ν′ are different. This observation enables us to compute φ |=min ¬x by determining the validity of a stronger and more concise formula than before.\nProposition 7. A variable x is free for negation in φ iff the following formula is a tautology.\n(φ ∧ x) ⇒ ∨\nS⊆V ∧x∈S φ[S 7→ 0] (9)\nThe abstraction of (9) is analogous to the one used in the previous section with the difference that only sets of variables containing x are considered. Hence, the abstraction always has the following form.\n(φ ∧ x) ⇒ ∨\nS∈W φ[S 7→ 0], where W ⊆ P(V ) and (∀S ∈W )(x ∈ S) (10)\ninput : CNF formula φ and a variable x output: true iff φ |=min ¬x\n1 φ0 ← φ[x 7→ 0] 2 φ′0 ← {¬rc ∨ c | c ∈ φ0} ∪ {¬l ∨ rc | c ∈ φ0, l ∈ c} ∪ { ∨\nc∈φ0 ¬rc\n}\n3 ω ← φ ∧ x ∧ φ′0 4 while true do 5 (outc1, ν) ← SAT(ω) 6 if outc1 = false then 7 return true // no counterexample was found\n8 (outc2, ν ′) ← SAT\n(\nφ ∧ ¬x ∧ ∧ ν(z)=0 ¬z )\n// find ν′ < ν and ν′(x) = 0\n9 if outc2 = false then 10 return false // abstraction cannot be refined\n11 S ← {z ∈ V | ν(z) = 1 ∧ ν′(z) = 0} 12 Cp ← {c ∈ φ0 | (c ∩ S) 6= ∅} // clauses with some y ∈ S 13 Cn ← {c ∈ φ0 | (c ∩ ¬S) 6= ∅} // clauses with some ¬y ∈ S 14 C ← {c′ | c ∈ (Cp r Cn) ∧ c\n′ = c[S 7→ 0]} // new clauses 15 ω ← ω ∪ {¬rc ∨ c | c ∈ C} ∪ {¬l ∨ rc | c ∈ C, l ∈ c} // representation 16 ω ← ω ∪ { ∨\nc∈φr(Cn∪Cp) ¬rc ∨\n∨\nc∈C ¬rc\n}\n// negation of clauses\nAlgorithm 2: Deciding whether a variable is free for negation"
    }, {
      "heading" : "5.1 Constructing and Refining Abstraction",
      "text" : "Whenever the abstraction is being refined (weakened) the size of the formula representing the negation of the abstraction increases. Since the abstraction is refined in the worst case exponentially many times, it is warranted to pay attention to the size of the formula representing the negation of the abstraction.\nThe negation of an abstraction is a conjunct of the left-hand side of the implication and formulas capturing the substitutions.\n(φ ∧ x) ∧ ∧\nS∈W ¬φ[S 7→ 0], where W ⊆ P(V ) and (∀S ∈ W )(x ∈ S) (11)\nWhen the abstraction is being refined, a new set of variables S is added to the set W , therefore, the negation of the abstraction is strengthened by conjoining it with ¬φ[S 7→ 0]. We aim to implement this strengthening without duplicating those parts of the formula that are already present.\nAlgorithm 2 outlines this procedure. Since all the sets S must contain x, the algorithm starts with the abstraction determined by W = {{x}}. In the initialization phase, the negation of this abstraction is φ ∧ x ∧ ¬φ[x 7→ 0] and is computed using the Tseitin transformation [23]. Each clause c in φ[x 7→ 0] is represented by a fresh variable rc and a clause is added that expresses that at least one of these variables must be 0 (line 2). As in the previous section, variable ω represents the negation of the abstraction (see (11)).\nWhen the abstraction is being refined, the formula in variable ω is conjoined with ¬φ[S 7→ 0]. Since ω already contains clauses from ¬φ[x 7→ 0], we need to\nconsider only those clauses that contain literals on the variables in S. Clauses containing negative literals on variables from S are skipped, positive literals are removed. Each of the affected clauses is represented by a fresh Tseitin variable. Finally, a clause is added to express that one of the clauses in φ[S 7→ 0] is 0. Note that this clause is referring to the original Tseitin variables for the clauses that are not affected by the substitution besides the freshly created ones. Note that when looking for a model ν′ < ν, the algorithm requires that x has value 0 in ν′ since the set S must contain x (line 8)."
    }, {
      "heading" : "5.2 Finding Models",
      "text" : "An abstraction is refined according to two responses from the underlying SAT solver (ν and ν′). This enables us to devise heuristics that prefer some responses of the solver to another. The motivation for these heuristics is to find abstractions where the set W determining the abstraction contains few sets S. Dually, this means that each of S ∈W yields a witness for many models. The heuristics used in the current implementation are motivated by the two following examples.\nExample 4. Let φ = (x⇒ y) ∧ (w ∨ z). The abstraction defined byW = {{x, y}} shows that φ |=min ¬y since flipping both x and y in any model yields a model (a witness). The abstraction determined by W = {{x, y, z}} is not sufficient. This abstraction provides a witness for models with w having value 1 but not for the others. Intuitively, variable z is irrelevant to the relation x⇒ y and therefore it is better to choose a small S.\nExample 5. Let φ = x ⇒ (y ∨ w1 ∨ . . . wn) and let us prove that φ |=min ¬y. The abstraction determined by W = {{x, y}} is sufficient. However, if ν is not minimal, it may be that ν = x1, y1, w11 , . . . w 1 n which gives us an exponential number of possibilities for ν′ while only one of them is desirable. Intuitively, if ν is not minimal and there is some set S that yields a witness for both ν and some ν1 < ν, then the set S is more likely to be found when ν1 is inspected.\nBased on this last observation, the model ν is required to be minimal. To make the difference between ν and ν′ small, and therefore make this set S small, the solution ν′ is required to be a maximal model.\nTo obtain a minimal, respectively maximal, model from a SAT solver is done by specifying the phase—the value that the solver prefers when making decisions when traversing the search space. Namely, preferring 0 yields a minimal model while preferring 1 yields a maximal model [10,21].\n6 Computing Free-For-Negation-All\nTo calculate the set of variables that are free for negation, we invoke the algorithm described in the previous section for each variable. This procedure is optimized by conjoining the negations of the variables that have already been shown to be free for negation, which is justified by the following proposition.\ninput : CNF formula φ and a set of variables V output: subset of V that are free for negation\n1 F ← ∅ 2 X ← V 3 timeout ← initial-timeout 4 while X 6= ∅ do 5 G ← ∅ 6 foreach x in X do 7 (success, outc) ← Free-For-Negation(φ, x, timeout) 8 if success = true then 9 G ← G ∪ {x}\n10 if outc = true then 11 F = F ∪ {x} 12 φ = φ ∧ ¬x\n13 X ← X rG 14 timeout ← k × timeout 15 return F\nAlgorithm 3: Computing the set of variables that are free for negation\nProposition 8. Let φ and ψ be formulas such that φ |=min ψ. The formula φ∧ψ has the same set of minimal models as φ. In particular, if φ |=min ¬x then (φ ∧ ¬x) |=min ¬y iff φ |=min ¬y.\nThe motivation for conjoining negations of variables free for negation is to give more information to subsequent inferences. The effectiveness of this technique, however, depends on the ordering of the variables. Hence, the approach we use is to set timeouts for testing a single variable and if a test times out, the variable is tested again but with information gained from the other tests.\nAlgorithm 3 summarizes these ideas in pseudocode. The algorithm described in the previous section is represented by the function Free-For-Negation, which returns a pair of values. The first value in the pair indicates whether the algorithm terminated before the given timeout or not. The second value of the pair indicates whether the given variable is free for negation or not. The timeout is gradually multiplied by some constant coefficient k. In the actual implementation there is a maximum timeout for which the algorithm stops and returns an approximation of the set of variables free for negation."
    }, {
      "heading" : "7 Evaluation",
      "text" : "Algorithm 3 was implemented in Java using SAT4j as the underlying SAT solver while availing of its incremental interface [22]. The implementation was evaluated on a benchmark of 260 tests4. A majority of these are valid software configurations (motivated by [13]). A few tests are from the SAT ’09 competition—\n4 Available at http://logos.ucd.ie/confs/jelia10/jelia10-bench.tgz\nrelatively easy instances were chosen as the computed problem is significantly harder than satisfiability. The results appear in Table 1. An instance is considered solved if the answer is given in less than 30 s. The time given in the table is the average for the solved instances.\nThe alternative we tried was based on the tool circ2dlp [19], which transforms circumscription into a disjunctive logic program, and gnt [11], which lists all models of that program. From the list of models it is easy and fast to construct the set of variables that are free for negation. We also tried using a QBF solver along with (3), but that implementation solved none of the 260 tests."
    }, {
      "heading" : "8 Summary and Future Work",
      "text" : "This paper proposes an algorithm for deduction under the set of minimal models of a propositional formula. This algorithm enables us to reason under the propositional versions of close world assumption or circumscription. The algorithm hinges on an application of a SAT solver but more importantly on counterexample guided abstraction refinement (CEGAR). While CEGAR has been amply used in software verification [3,8],we are not aware of its application in nonmonotonic reasoning.\nThe deduction problem under the set of minimal models can be formulated as QBF [5] or as a DLP [14,12]. The experimental results suggest that current QBF solvers are not practical for this problem. The comparison to the DLP-based solution indicates that our dedicated algorithm enables solving more instances. Nevertheless, the DLP-based solution was faster for some instances.\nThe promising experimental results indicate that the ideas behind the presented algorithms have potential for further work. The evaluation was performed for the computation of variables free for negation defining the closure of a theory in GCWA, hence, further evaluations should be performed on other types of problems in this domain. On a more general scale, it is well known that minimal models can be seen as optima with respect to the pertaining ordering [2,21]. This opens possibilities to investigate generalizations of the presented algorithms for different orderings than the one used for minimal models. Last but not least, the comparison with the DLP-based solution indicates that it would be beneficial to investigate approaches tackling the problem with hybrid techniques."
    }, {
      "heading" : "A Proofs",
      "text" : "Proposition 1. The models of formula φ that are strictly smaller than some variable assignment ν are the models of the formula\nφ ∧ ∧\nν(x)=0\n¬x ∧ ∨\nν(x)=1\n¬x (1)\nProof. Let ν′ be a model of (1). The assignment ν′ is a model of φ because (1) is stronger than φ. The model ν′ is smaller than ν because whenever ν(x) = 0 holds, ν′(x) = 0 holds as well due to the condition ∧\nν(x)=0 ¬x. The model ν ′ is\nstrictly smaller than ν because there must be at least one variable x for which ν(x) = 1 and ν′(x) = 0 due to the condition ∨\nν(x)=1 ¬x. ⊓⊔\nProposition 4. A formula ψ holds in all minimal models of the formula φ iff any model ν of φ where ¬ψ holds is not a minimal model of φ.\n[φ |=min ψ] ⇔ [(∀ν) ((ν |= φ ∧ ¬ψ) ⇒ (∃ν ′)(ν′ < ν ∧ ν′ |= φ))]\nProof. In classical logic, for any assignment ν either ν |= ψ or ν |= ¬ψ but not both. Let φ |=min ψ and let ν be a model φ such that ν |= φ∧ ¬ψ. Then ν must not be minimal because ν |= ¬ψ and therefore ν would be a minimal model of φ not satisfying ψ.\nIf any model of φ that satisfies ¬ψ is not minimal, then all the minimal models of φ must satisfy ψ. ⊓⊔\nProposition 5. Let ν be a model of a formula φ. The model ν is not a minimal model of φ iff there exists a set of variables S such that ν is a model of the formula φ[S 7→ 0], and, ν(x) = 1 for some x ∈ S.\n(∃ν′)(ν′ < ν ∧ ν′ |= φ) ⇔ (∃S ⊆ V ) (ν |= φ[S 7→ 0] ∧ (∃x ∈ S)(ν(x) = 1)) (5)\nProof. If ν is not a minimal model of φ, then there exists some model ν′ such that ν′ < ν. By definition, there exists some set of variables S such that ν′(x) = 0 and ν(x) = 1 for x ∈ S, and, ν′(x) = ν(x) for x /∈ S. Then ν is a model of φ[S 7→ 0] because ν′ is a model of φ and ν′ assigns 0 to all variables in S.\nLet S be a a set of variables such that ν |= φ[S 7→ 0] and (∃x ∈ S)(ν(x) = 1). Let us define the assignment ν′ such that ν′(x) = 0 if x ∈ S and ν′(x) = ν(x) otherwise. Then ν′ is a model of φ because φ[S 7→ 0] corresponds to a partial evaluation of φ. The model ν′ is smaller than ν because it differs only on the variables in S, where ν′ is 0. The model ν′ is strictly smaller than ν because at least one of the variables from S are assigned the value 1 by ν due to the condition (∃x ∈ S)(ν(x) = 1). Hence, ν′ < ν and therefore ν is not minimal. ⊓⊔\nProposition 6. Let ν be a model of a formula φ such that ν(x) = 1 for a variable x. If the variable x is free for negation, then there exists a model ν′ of φ such that ν′ < ν an ν′(x) = 0.\nProof. Since the set of considered variables V is finite, there are no infinitely decreasing chains in the ordering < and therefore for the model ν there must be a model ν′ ≤ ν that is minimal. Since x is free for negation, it must have the value 0 in such model ν′. ⊓⊔\nProposition 8. Let φ and ψ be formulas such that φ |=min ψ. The formula φ ∧ ψ has the same set of minimal models as the formula φ. In particular, if φ |=min ¬x then (φ ∧ ¬x) |=min ¬y iff φ |=min ¬y.\nProof. Since the formula ψ holds in all minimal models of φ, all the minimal models of φ are models of φ∧ψ. Since models of the formula φ∧ψ form a subset of the models of the formula ψ, the minimal models of φ are also minimal in φ ∧ ψ. To show that any minimal model of φ ∧ ψ is also a minimal model of φ, consider for contradiction that there is an assignment ν such that ν is a minimal model of φ∧ψ but is not a minimal model of φ. Since ν is not minimal in φ and there are no infinitely decreasing chains in <, there must be a minimal model ν′ of φ such that ν′ < ν. Since ν is minimal in φ∧ψ, ν′ is not a model of φ∧ψ but that is a contradiction because all minimal models of φ are also models of ψ. ⊓⊔"
    }, {
      "heading" : "B Deciding Entailment in Full ECWA",
      "text" : "The article presents an algorithm that enables us to decide whether a formula holds in all minimal models of another formula. This enables us to decide entailment for ECWA and circumscription with Q = Z = ∅ (see section 2). To provide a semantic characterization supporting arbitrary Q and Z, the concept of minimality of models is extended.\nDefinition 4. Let P , Q, and Z be a partitioning of the variables V . For variable assignments ν and µ, we write ν ≤(P,Z) µ if ν(x) = µ(x) for all x ∈ Q, and, ν(x) ≤ µ(x) for all x ∈ P . We write ν <(P,Z) µ if ν ≤(P,Z) µ and not µ ≤(P,Z) ν.\nWe write φ |=(P,Z) ψ iff ψ holds in all models that are minimal with respect to the ordering <(P,Z).\nThe entailment |=(P,Z) corresponds to deduction from the closure defined by ECWA and analogously for circumscription [1]. So we focus on deciding φ |=(P,Z) ψ. Observe that φ |=(P,Z) ψ coincides with φ |=min ψ when Q = Z = ∅. In terms of computational complexity, deciding φ |=(P,Z) ψ is not more difficult than deciding φ |=min ψ since both problems are ΠP2 -complete [6].\nWe show that Algorithm 1 can be easily modified to decide φ |=(P,Z) ψ. The structure of the algorithm remains the same, hence here we focus on the form of the abstraction and how it is refined. Recall that the abstraction captures the statement that any model of φ that violates ψ is not a minimal model. In particular, a smaller model can be found (see (8)). The following formula replicates the same idea for the minimality defined by <(P,Z).\n(φ ∧ ¬ψ) ⇒ ∨\n(S,Z0,Z1)∈W\n(\nφ[S 7→ 0, Z0 7→ 0, Z1 7→ 1] ∧ ∨ x∈S x ) ,\nwhere W ⊆ {(S,Z0, Z1) | S ⊆ P,Z0 ⊆ Z,Z1 ⊆ Z} (12)\nIn this case, the abstraction is defined by a set of triples for each of the triples determines which variables are flipped to 0 and which are flipped to 1. Since variables from P can only be flipped to 0 and variables from Q cannot be flipped at all, the right-hand side of the abstraction is indeed permitting only models smaller in the sense of <(P,Z).\nWhen the algorithm tries to refine the abstraction, it needs to find a model ν′ <(P,Z) ν, where ν is a model of the negation of the abstraction. We observe that ν′ must be a model of the following formula.\nφ ∧ ∧\nν(x)=0∧x∈P\n¬x ∧ ∨\nν(x)=1∧x∈P\n¬x ∧ ∧\nν(x)=0∧x∈Q\n¬x ∧ ∧\nν(x)=1∧x∈Q\nx (13)\nThe abstraction is refined by adding a triple into the set W . The triple is defined by the following elements.\nS = {x | x ∈ P ∧ ν(x) = 1 ∧ ν′(x) = 0} Z0 = {x | x ∈ Z ∧ ν(x) = 1 ∧ ν′(x) = 0} Z1 = {x | x ∈ Z ∧ ν(x) = 0 ∧ ν′(x) = 1}\n(14)"
    } ],
    "references" : [ {
      "title" : "The complexity of closed world reasoning and circumscription",
      "author" : [ "M. Cadoli", "M. Lenzerini" ],
      "venue" : "AAAI Conference on Artificial Intelligence. pp. 550–555",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 1990
    }, {
      "title" : "Using the Davis and Putnam procedure for an efficient computation of preferred models",
      "author" : [ "T. Castell", "C. Cayrol", "M. Cayrol", "D.L. Berre" ],
      "venue" : "European Conference on Artificial Intelligence. pp. 350–354",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "Counterexample-guided abstraction refinement",
      "author" : [ "E.M. Clarke", "O. Grumberg", "S. Jha", "Y. Lu", "H. Veith" ],
      "venue" : "Computer Aided Verification. pp. 154–169",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Nonmonotonic reasoning: Towards efficient calculi and implementations",
      "author" : [ "J. Dix", "U. Furbach", "I. Niemelä" ],
      "venue" : "Voronkov, A., Robinson, A. (eds.) Handbook of Automated Reasoning, chap. 19, pp. 1241–1354. North Holland",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Solving advanced reasoning tasks using quantified boolean formulas",
      "author" : [ "U. Egly", "T. Eiter", "H. Tompits", "S. Woltran" ],
      "venue" : "AAAI Conference on Artificial Intelligence. pp. 417–422",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Propositional circumscription and extended closed-world reasoning are Π  2 -complete",
      "author" : [ "T. Eiter", "G. Gottlob" ],
      "venue" : "Theor. Comput. Sci. 114(2), 231–245",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 1993
    }, {
      "title" : "Combining answer set programming with description logics for the Semantic Web",
      "author" : [ "T. Eiter", "G. Ianni", "T. Lukasiewicz", "R. Schindlauer", "H. Tompits" ],
      "venue" : "Artif. Intell. 172(12-13), 1495–1539",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Predicate abstraction for software verification",
      "author" : [ "C. Flanagan", "S. Qadeer" ],
      "venue" : "Principles of programming languages (POPL). pp. 191–202. ACM",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "On the relationship between circumscription and negation as failure",
      "author" : [ "M. Gelfond", "H. Przymusinska", "T.C. Przymusinski" ],
      "venue" : "Artif. Intell. 38(1), 75–94",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 1989
    }, {
      "title" : "Solving optimization problems with DLL",
      "author" : [ "E. Giunchiglia", "M. Maratea" ],
      "venue" : "European Conference on Artificial Intelligence. pp. 377–381",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Unfolding partiality and disjunctions in stable model semantics",
      "author" : [ "T. Janhunen", "I. Niemelä", "D. Seipel", "P. Simons", "J.H. You" ],
      "venue" : "ACM Trans. Comput. Log. 7(1), 1–37",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Capturing parallel circumscription with disjunctive logic programs",
      "author" : [ "T. Janhunen", "E. Oikarinen" ],
      "venue" : "European Conf. on Logics in Artif. Intell. pp. 134–146",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "How to complete an interactive configuration process? In: Conference on Current Trends in Theory and Practice of Computer Science",
      "author" : [ "M. Janota", "G. Botterweck", "R. Grigore", "J. Marques-Silva" ],
      "venue" : "pp. 528–539",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Foundations of logic programming",
      "author" : [ "V. Lifschitz" ],
      "venue" : "Principles of Knowledge Representation pp. 69–127",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "Circumscription - a form of non-monotonic reasoning",
      "author" : [ "J. McCarthy" ],
      "venue" : "Artif. Intell. 13(1-2), 27–39",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 1980
    }, {
      "title" : "Applications of circumscription to formalizing common-sense knowledge",
      "author" : [ "J. McCarthy" ],
      "venue" : "Artif. Intell. 28(1), 89–116",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 1986
    }, {
      "title" : "On indefinite databases and the closed world assumption",
      "author" : [ "J. Minker" ],
      "venue" : "Conference on Automated Deduction. pp. 292–308",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 1982
    }, {
      "title" : "Implementing circumscription using a tableau method",
      "author" : [ "I. Niemelä" ],
      "venue" : "European Conference on Artificial Intelligence. pp. 80–84",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "circ2dlp - translating circumscription into disjunctive logic programming",
      "author" : [ "E. Oikarinen", "T. Janhunen" ],
      "venue" : "Logic Programming and Nonmonotonic Reasoning. pp. 405–409",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "An algorithm to compute circumscription",
      "author" : [ "T.C. Przymusinski" ],
      "venue" : "Artif. Intell. 38(1), 49–73",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 1989
    }, {
      "title" : "Solving satisfiability problems with preferences",
      "author" : [ "E.D. Rosa", "E. Giunchiglia", "M. Maratea" ],
      "venue" : "Constraints, An International Journal",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2010
    }, {
      "title" : "On the complexity of derivation in propositional calculus",
      "author" : [ "G.S. Tseitin" ],
      "venue" : "Studies in constructive mathematics and mathematical logic 2(115-125), 10–13",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 1968
    }, {
      "title" : "Deduction in non-Horn databases",
      "author" : [ "A.H. Yahya", "L.J. Henschen" ],
      "venue" : "Journal of Automated Reasoning 1(2), 141–160",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 1985
    } ],
    "referenceMentions" : [ {
      "referenceID" : 14,
      "context" : "Part of the interest in these techniques is that they bring us closer to how humans reason [15,17,16].",
      "startOffset" : 91,
      "endOffset" : 101
    }, {
      "referenceID" : 16,
      "context" : "Part of the interest in these techniques is that they bring us closer to how humans reason [15,17,16].",
      "startOffset" : 91,
      "endOffset" : 101
    }, {
      "referenceID" : 15,
      "context" : "Part of the interest in these techniques is that they bring us closer to how humans reason [15,17,16].",
      "startOffset" : 91,
      "endOffset" : 101
    }, {
      "referenceID" : 0,
      "context" : "The computational complexity of propositional CWR rules was studied in the early 90s [1,6] and showed that, with few exceptions, the complexity of CWR deduction problems are in the second level of the polynomial hierarchy, being Π 2 -complete [6].",
      "startOffset" : 85,
      "endOffset" : 90
    }, {
      "referenceID" : 5,
      "context" : "The computational complexity of propositional CWR rules was studied in the early 90s [1,6] and showed that, with few exceptions, the complexity of CWR deduction problems are in the second level of the polynomial hierarchy, being Π 2 -complete [6].",
      "startOffset" : 85,
      "endOffset" : 90
    }, {
      "referenceID" : 5,
      "context" : "The computational complexity of propositional CWR rules was studied in the early 90s [1,6] and showed that, with few exceptions, the complexity of CWR deduction problems are in the second level of the polynomial hierarchy, being Π 2 -complete [6].",
      "startOffset" : 243,
      "endOffset" : 246
    }, {
      "referenceID" : 6,
      "context" : "Nonmonotonic reasoning finds a wide range of applications in Artificial Intelligence (AI), but also in description logics [7]",
      "startOffset" : 122,
      "endOffset" : 125
    }, {
      "referenceID" : 12,
      "context" : "and in interactive configuration [13], among many others.",
      "startOffset" : 33,
      "endOffset" : 37
    }, {
      "referenceID" : 19,
      "context" : "Finally, different algorithms have been proposed over the years, examples of which include minimal model resolution [20], tableau calculus [18], Quantified Boolean Formula (QBF) solvers [5] and Disjunctive Logic Programming (DLP) [14,12,19].",
      "startOffset" : 116,
      "endOffset" : 120
    }, {
      "referenceID" : 17,
      "context" : "Finally, different algorithms have been proposed over the years, examples of which include minimal model resolution [20], tableau calculus [18], Quantified Boolean Formula (QBF) solvers [5] and Disjunctive Logic Programming (DLP) [14,12,19].",
      "startOffset" : 139,
      "endOffset" : 143
    }, {
      "referenceID" : 4,
      "context" : "Finally, different algorithms have been proposed over the years, examples of which include minimal model resolution [20], tableau calculus [18], Quantified Boolean Formula (QBF) solvers [5] and Disjunctive Logic Programming (DLP) [14,12,19].",
      "startOffset" : 186,
      "endOffset" : 189
    }, {
      "referenceID" : 13,
      "context" : "Finally, different algorithms have been proposed over the years, examples of which include minimal model resolution [20], tableau calculus [18], Quantified Boolean Formula (QBF) solvers [5] and Disjunctive Logic Programming (DLP) [14,12,19].",
      "startOffset" : 230,
      "endOffset" : 240
    }, {
      "referenceID" : 11,
      "context" : "Finally, different algorithms have been proposed over the years, examples of which include minimal model resolution [20], tableau calculus [18], Quantified Boolean Formula (QBF) solvers [5] and Disjunctive Logic Programming (DLP) [14,12,19].",
      "startOffset" : 230,
      "endOffset" : 240
    }, {
      "referenceID" : 18,
      "context" : "Finally, different algorithms have been proposed over the years, examples of which include minimal model resolution [20], tableau calculus [18], Quantified Boolean Formula (QBF) solvers [5] and Disjunctive Logic Programming (DLP) [14,12,19].",
      "startOffset" : 230,
      "endOffset" : 240
    }, {
      "referenceID" : 2,
      "context" : "To cope with this issue, we utilize a technique inspired in counterexample guided abstraction refinement (CEGAR), widely used in model checking [3].",
      "startOffset" : 144,
      "endOffset" : 147
    }, {
      "referenceID" : 0,
      "context" : "Here we present only a small portion of these formalisms and the interested reader is referred to appropriate publications for further reference [1,6,4].",
      "startOffset" : 145,
      "endOffset" : 152
    }, {
      "referenceID" : 5,
      "context" : "Here we present only a small portion of these formalisms and the interested reader is referred to appropriate publications for further reference [1,6,4].",
      "startOffset" : 145,
      "endOffset" : 152
    }, {
      "referenceID" : 3,
      "context" : "Here we present only a small portion of these formalisms and the interested reader is referred to appropriate publications for further reference [1,6,4].",
      "startOffset" : 145,
      "endOffset" : 152
    }, {
      "referenceID" : 0,
      "context" : "Following [1,6], a closure operation is defined for CWR rules as follows:",
      "startOffset" : 10,
      "endOffset" : 15
    }, {
      "referenceID" : 5,
      "context" : "Following [1,6], a closure operation is defined for CWR rules as follows:",
      "startOffset" : 10,
      "endOffset" : 15
    }, {
      "referenceID" : 16,
      "context" : "For each CWR rule below, a formula K is free for negation if and only if the corresponding condition holds: GCWA (Generalized CWA [17]): K is a positive literal and for every positive clause B such that φ 2 B it holds that φ 2 B ∨K.",
      "startOffset" : 130,
      "endOffset" : 134
    }, {
      "referenceID" : 22,
      "context" : "EGCWA (Extended GCWA [24]): K is a conjunction of positive literals and for every positive clause B such that φ 2 B it holds that φ 2 B ∨K.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 22,
      "context" : "ECWA (Extended CWA [24]): K is an arbitrary formula not involving literals from Z, and for every positive clause B whose literals belong to P∪Q∪Q, such that φ 2 B, it holds that φ 2 B ∨K.",
      "startOffset" : 19,
      "endOffset" : 23
    }, {
      "referenceID" : 0,
      "context" : "A detailed characterization for existing CWR rules can be found elsewhere [1,6,4].",
      "startOffset" : 74,
      "endOffset" : 81
    }, {
      "referenceID" : 5,
      "context" : "A detailed characterization for existing CWR rules can be found elsewhere [1,6,4].",
      "startOffset" : 74,
      "endOffset" : 81
    }, {
      "referenceID" : 3,
      "context" : "A detailed characterization for existing CWR rules can be found elsewhere [1,6,4].",
      "startOffset" : 74,
      "endOffset" : 81
    }, {
      "referenceID" : 14,
      "context" : "Originally, McCarthy defined circumscription in the context of first order logic as a closure of the given theory that considers only predicates with minimal extension [15].",
      "startOffset" : 168,
      "endOffset" : 172
    }, {
      "referenceID" : 8,
      "context" : "It is well-known that for the propositional case, circumscription is equivalent to ECWA [9].",
      "startOffset" : 88,
      "endOffset" : 91
    }, {
      "referenceID" : 16,
      "context" : "[17,1,6]).",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 0,
      "context" : "[17,1,6]).",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 5,
      "context" : "[17,1,6]).",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 16,
      "context" : "These relations are captured by the following propositions (adapted from [17,1,6]): Proposition 2.",
      "startOffset" : 73,
      "endOffset" : 81
    }, {
      "referenceID" : 0,
      "context" : "These relations are captured by the following propositions (adapted from [17,1,6]): Proposition 2.",
      "startOffset" : 73,
      "endOffset" : 81
    }, {
      "referenceID" : 5,
      "context" : "These relations are captured by the following propositions (adapted from [17,1,6]): Proposition 2.",
      "startOffset" : 73,
      "endOffset" : 81
    }, {
      "referenceID" : 2,
      "context" : "The approach of searching for the right abstraction follows the CounterExample Guided Abstract Refinement (CEGAR) loop [3].",
      "startOffset" : 119,
      "endOffset" : 122
    }, {
      "referenceID" : 21,
      "context" : "In the initialization phase, the negation of this abstraction is φ ∧ x ∧ ¬φ[x 7→ 0] and is computed using the Tseitin transformation [23].",
      "startOffset" : 133,
      "endOffset" : 137
    }, {
      "referenceID" : 9,
      "context" : "Namely, preferring 0 yields a minimal model while preferring 1 yields a maximal model [10,21].",
      "startOffset" : 86,
      "endOffset" : 93
    }, {
      "referenceID" : 20,
      "context" : "Namely, preferring 0 yields a minimal model while preferring 1 yields a maximal model [10,21].",
      "startOffset" : 86,
      "endOffset" : 93
    }, {
      "referenceID" : 12,
      "context" : "A majority of these are valid software configurations (motivated by [13]).",
      "startOffset" : 68,
      "endOffset" : 72
    }, {
      "referenceID" : 18,
      "context" : "The alternative we tried was based on the tool circ2dlp [19], which transforms circumscription into a disjunctive logic program, and gnt [11], which lists all models of that program.",
      "startOffset" : 56,
      "endOffset" : 60
    }, {
      "referenceID" : 10,
      "context" : "The alternative we tried was based on the tool circ2dlp [19], which transforms circumscription into a disjunctive logic program, and gnt [11], which lists all models of that program.",
      "startOffset" : 137,
      "endOffset" : 141
    }, {
      "referenceID" : 2,
      "context" : "While CEGAR has been amply used in software verification [3,8],we are not aware of its application in nonmonotonic reasoning.",
      "startOffset" : 57,
      "endOffset" : 62
    }, {
      "referenceID" : 7,
      "context" : "While CEGAR has been amply used in software verification [3,8],we are not aware of its application in nonmonotonic reasoning.",
      "startOffset" : 57,
      "endOffset" : 62
    }, {
      "referenceID" : 4,
      "context" : "The deduction problem under the set of minimal models can be formulated as QBF [5] or as a DLP [14,12].",
      "startOffset" : 79,
      "endOffset" : 82
    }, {
      "referenceID" : 13,
      "context" : "The deduction problem under the set of minimal models can be formulated as QBF [5] or as a DLP [14,12].",
      "startOffset" : 95,
      "endOffset" : 102
    }, {
      "referenceID" : 11,
      "context" : "The deduction problem under the set of minimal models can be formulated as QBF [5] or as a DLP [14,12].",
      "startOffset" : 95,
      "endOffset" : 102
    }, {
      "referenceID" : 1,
      "context" : "On a more general scale, it is well known that minimal models can be seen as optima with respect to the pertaining ordering [2,21].",
      "startOffset" : 124,
      "endOffset" : 130
    }, {
      "referenceID" : 20,
      "context" : "On a more general scale, it is well known that minimal models can be seen as optima with respect to the pertaining ordering [2,21].",
      "startOffset" : 124,
      "endOffset" : 130
    } ],
    "year" : 2013,
    "abstractText" : "Circumscription is a representative example of a nonmonotonic reasoning inference technique. Circumscription has often been studied for first order theories, but its propositional version has also been the subject of extensive research, having been shown equivalent to extended closed world assumption (ECWA). Moreover, entailment in propositional circumscription is a well-known example of a decision problem in the second level of the polynomial hierarchy. This paper proposes a new Boolean Satisfiability (SAT)-based algorithm for entailment in propositional circumscription that explores the relationship of propositional circumscription to minimal models. The new algorithm is inspired by ideas commonly used in SAT-based model checking, namely counterexample guided abstraction refinement. In addition, the new algorithm is refined to compute the theory closure for generalized close world assumption (GCWA). Experimental results show that the new algorithm can solve problem instances that other solutions are unable to solve.",
    "creator" : "LaTeX with hyperref package"
  }
}