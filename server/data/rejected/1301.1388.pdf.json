{
  "name" : "1301.1388.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Utilizing ASP for Generating and Visualizing Argumentation Frameworks",
    "authors" : [ "Günther Charwat", "Johannes Peter Wallner", "Stefan Woltran" ],
    "emails" : [ "gcharwat@dbai.tuwien.ac.at", "wallner@dbai.tuwien.ac.at", "woltran@dbai.tuwien.ac.at" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Instantiation-based argumentation [7] is a central paradigm in nonmonotonic reasoning since it gives a formal handle to separate the logical and non-classical contents of reasoning in the presence of contradicting information. Hereby, one starts with a knowledge base and constructs arguments from it. Arguments typically consist of two parts, namely a support, which is grounded in the knowledge base and a claim derived from it. In [4] the process is described with an underlying propositional knowledge base using minimal sets of consistent support classically entailing the claim. In a second step, conflicts between these arguments have to be identified. The obtained arguments and the relation between them yield a so-called argumentation framework [9]. This simple, yet expressive formalism is basically a directed graph whereby the arguments are represented via vertices and the conflicts with directed edges. Argumentation frameworks are then evaluated with one of the numerous semantics for abstract argumentation available, resulting in potentially multiple acceptable sets of arguments [3].\nHere we are only interested in the instantiation part, however, which received less attention wrt. realized systems. Notable exceptions are the Carneades system, which can construct arguments using heuristics [16] and the recent TOAST implementation\nar X\niv :1\n30 1.\n13 88\nv1 [\ncs .A\nI] 8\nJ an\n2 01\nfor the ASPIC+ framework [27]. The reason for the lack of implementations is potentially twofold: First, due to the inherent high complexity of the problem; already constructing a single argument is hard for the second level of the polynomial hierarchy [23]. Secondly, standard instantiation schemes for propositional knowledge bases result in infinite argumentation frameworks even for finite knowledge bases [1]. The first obstacle calls for highly expressive languages, making answer-set programming [6, 21, 22] (ASP, for short) a well suited candidate. For the second obstacle, we restrict ourselves here to arguments that have their claims coming from an a priori specified set of formulae.\nTo summarize, we aim here for a system which takes as input a knowledge base as well as a set of potential claims and produces the instantiated argumentation framework, such that the latter can be processed by other argumentation tools, e.g. ASPARTIX [11] or CEGARTIX [10]. More specifically, our contributions are as follows:\n– We provide ASP programs1 to encode the construction of arguments as well as the construction of the conflicts. For the second task, the answer-sets of the first encoding are used as input. Thus we can make use of the high sophistication modern ASP systems have reached [15, 20]. Moreover, since the argument construction and conflict identification are declaratively described via ASP code, the system is easily adaptable to other notions of arguments or conflicts. – We present a system that, on the one hand, takes care of passing the answer-sets from one program to another. On the other hand, the system uses the answer-sets of the two programs for visualization in form of a graph. In our case we obtain an argumentation framework. Finally, this result can be exported and used by other systems for abstract argumentation.\nAs a by-product, we observed that this method is by no means restricted to the argumentation domain. Ultimately, it allows for a user-driven graph representation of the collection of answer-sets of a given input program, thus acting as a tool for ASP visualization in general. The most interesting feature of the tool is that the concrete specification for two answer-sets being in relation is given by an ASP program itself. In recent years, ASP has benefited from the rising number of development and visualization tools, e.g. ASPViz [8], ASPIDE [14], Kara [19] and IDPDraw [29]. These tools so far have focused on presentations of single answer-sets of the given program. However, in certain applications it is not only the single answer-sets which are of interest, but the relation between them.\nWhile visualization is a rather new research branch in ASP, it has gained more attention in the argumentation community, where dedicated visualization tools have been proposed already in the late 90s (e.g. [2, 5, 11, 18, 24–26, 28], including Debategraph2 and Rationale3). Many of these support the argument construction by a user via different means, such as automated reasoning, input masks and database querying. Compared to these systems, our approach combines the computational power of high-sophisticated ASP systems with visualization aspects. Moreover, thanks to the declarative nature of\n1 http://dbai.tuwien.ac.at/proj/argumentation/vispartix/ 2 http://debategraph.org 3 http://rationale.austhink.com/\nthe ASP encodings specifying the instantiation step, we believe that the strength of our approach lies in its flexibility and its expandability to new argumentation formalisms.\nThis paper is structured as follows: We briefly introduce argumentation and ASP in Section 2. Then, in Section 3, we present ASP encodings for constructing an argumentation framework. In Section 4 we outline a novel visualization tool which is used for representing relations between answer-sets. A final discussion is given in Section 5."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "We provide the necessary background from argumentation theory and ASP for this work. In particular we will explain the argumentation process based on argumentation frameworks [9] as well as briefly recall the concepts for disjunctive logic programs."
    }, {
      "heading" : "2.1 Argumentation",
      "text" : "In this section we introduce formal argumentation. We start with the underlying process [7], which we will utilize in our context. The general process consists of three steps. First, given a knowledge base, arguments and their relationships are instantiated. After this instantiation the arguments are treated as abstract entities, without considering their concrete content. Secondly conflicts are resolved using appropriate semantics on the abstract instantiation and finally conclusions are drawn.\nIn this work the knowledge base K is a (potentially inconsistent) set of propositional logic formulae. We construct the formulae with the usual connectives ¬,∨,∧,→, the negation, disjunction, conjunction and implication, respectively. Furthermore entailment and logical equivalence of formulae is denoted by |= and≡, respectively. We write formulae with lowercase Greek letters α, β, γ, ....\nExample 1. Consider the following simple and inconsistent example knowledge base:\nK = {a, a→ b,¬b}\nThe instantiation step now constructs arguments and relations among them based on the information available in K according to [4]. The abstract representation we utilize for this purpose is the widely studied argumentation framework [9]. An argumentation framework (AF) is a directed graph F = (Args,Att), with the vertices (Args) being abstract arguments and the directed edges (Att) denote attacks between them to represent conflicts.\nThe instantiation of an AF now consists of two parts, namely the argument construction and the attack relation construction. An argument A = (S,C) consists of a support for the argument and a claim. The support is a subset of the knowledge base K and the claim is a single logical formula. The support must be a consistent and subset minimal set of formulae, which entails the claim.\nHere the arguments are pairs of support and claim to provide a formal basis for argument construction. When plugged in the argumentation framework we abstract from this “inner” structure and collapse every pair of support and claim into one abstract argument. This is the abstraction procedure of the overall process.\nWe note that argument construction here differs from the usual argument definition in the literature. In particular the claim can be taken only from a pre-defined set C. Using a pre-defined set of claims, we can restrict ourselves to reasonable claims, e.g. not involving tautologies. In this way we prohibit the construction of infinitely many arguments that could otherwise result from infinitely many syntactically different formulae which are semantically equivalent. This restriction comes with a disadvantage however, as the set of pre-defined claims must be chosen with care, since inconsistent conclusions might be drawn otherwise. Indeed, [17] identify conditions for rational and consistent end results, which require the existence of specific arguments, which must be included in C. On the other hand, this restriction is in line with the concept of cores of argumentation frameworks [1], which try to preserve desired properties while using only a subset of all possible arguments.\nExample 2. Continuing Example 1, let the set of claims be C = K ∪ {¬a, b, a ∧ ¬b}. Then we can construct the following arguments:\na1 = ({a}, a) a4 = ({¬b, a→ b},¬a) a2 = ({a→ b}, a→ b) a5 = ({¬b},¬b) a3 = ({a, a→ b}, b) a6 = ({a,¬b}, a ∧ ¬b)\nFor the construction of the attack relation several options were studied in literature. The basic idea for attacks between arguments underlying all of these options is that some sort of inconsistency occurs between them. We take the attack definitions from [17] and illustrate two types, defeat and directed defeat. An argument A = (S,C) attacks an argumentA′ = (S′ = {φ′1, ..., φ′m}, C ′) using defeat ifC |= ¬(φ′1∧...∧φ′m). The former directly defeats the latter if C |= ¬φ′i for one i, 1 ≤ i ≤ m.\nExample 3. Continuing Example 2, the AF in Figure 1 illustrates the result using the direct defeat on the arguments built from K and the claims C. Note that e.g. a3 and a5 are not mutually attacking each other, since the claim of a5 does not entail a negated support formula of a3.\nThis completes the first step of the argumentation process, namely the AF construction out of the knowledge base. For the conflict resolution a plethora of argumentation framework semantics exist. A basic property for semantics is the conflictfree property, which states that a set M of arguments in an AF F is conflict free if there are no attacks between them in F . A set of arguments M is stable in an AF\nF = (Args,Att) if it is conflict free and all arguments outside are attacked from M , i.e. ∀a ∈ (Args \\M) ∃b ∈M with (b, a) ∈ Att .\nExample 4. If we take the argumentation framework from Example 3, then the stable semantics selects { {a1, a5, a6}, {a1, a2, a3}, {a2, a4, a5} } as acceptable subsets of arguments.\nThe last step of the argumentation process deals with drawing conclusions from the sets of acceptable arguments. One can look at the content of the abstract arguments which were accepted, e.g. one can derive the deductive closure of this content.\nIn general every step of this process is intractable. Hence we need sophisticated systems for tackling these steps, which makes ASP a suitable choice for embedding the process in. A more detailed computational complexity analysis can be found in [23]."
    }, {
      "heading" : "2.2 Answer-Set Programming",
      "text" : "In this section we recall the basics of disjunctive logic programs under the answer-sets semantics [6, 22].\nWe fix a countable set U of (domain) elements, also called constants. An atom is an expression p(t1, . . . , tn), where p is a predicate of arity n ≥ 0 and each ti is either a variable or an element from U . An atom is ground if it is free of variables. BU denotes the set of all ground atoms over U .\nA (disjunctive) rule r is of the form\na1 ∨ · · · ∨ an ← b1, . . . , bk, not bk+1, . . . , not bm\nwith n ≥ 0, m ≥ k ≥ 0, n + m > 0, where a1, . . . , an, b1, . . . , bm are atoms, and “not ” stands for default negation. The head of r is the set H(r) = {a1, . . . , an} and the body of r is B(r) = {b1, . . . , bk, not bk+1, . . . , not bm}. Furthermore, B+(r) = {b1, . . . , bk} and B−(r) = {bk+1, . . . , bm}. A rule r is a constraint if n = 0. A rule r is safe if each variable in r occurs in B+(r). A rule r is ground if no variable occurs in r. A fact is a ground rule without disjunction and empty body. A program is a finite set of disjunctive rules.\nFor any program π, let Uπ be the set of all constants appearing in π. Gr(π) is the set of rules rσ obtained by applying, to each rule r ∈ π, all possible substitutions σ from the variables in r to elements of Uπ . An interpretation I ⊆ BU satisfies a ground rule r iff H(r) ∩ I 6= ∅ whenever B+(r) ⊆ I and B−(r) ∩ I = ∅. I satisfies a ground program π, if each r ∈ π is satisfied by I . A non-ground rule r (resp., a program π) is satisfied by an interpretation I iff I satisfies all groundings of r (resp., Gr(π)). I ⊆ BU is an answer-set of π iff it is a subset-minimal set satisfying the Gelfond-Lifschitz reduct πI = {H(r)← B+(r) | I ∩B−(r) = ∅, r ∈ Gr(π)}."
    }, {
      "heading" : "3 Instantiation-based Argumentation",
      "text" : "In this section we provide our ASP encodings for the construction of arguments from a knowledge-base K and a set C of claims. As input, each formula in K and C is given by the unary predicate kb(·) and cl(·), respectively.\nExample 5. The input, as given in Example 1 and 2, is specified by:\n{kb(a). kb(imp(a, b)). kb(neg(b)). cl(a). cl(imp(a, b)). cl(neg(b)). cl(neg(a)). cl(b). cl(and(a,neg(b))).}\nFirst, we introduce the ASP encodings for checking whether a certain variable assignment is a model for a given formula (or not). Model checking plays a crucial role for our instantiation-based approach. Then, we present encodings for the computation of arguments. Finally, we provide ASP code for some types of attack relations. Note that an argumentation framework is obtained by two separate ASP program calls where the first one takes as input K and C and returns a separate answer-set for each resulting argument. The second program receives as input a “flattened” version of all arguments and computes the attacks between arguments based on different attack type encodings."
    }, {
      "heading" : "3.1 Model Checking",
      "text" : "Propositional formulae provide the basis for the construction of arguments and their attack relations. In fact, we can express most of the defining properties of arguments (such as entailment of the support to the claim) and attacks by means of propositional formulae. In this section we provide an ASP encoding that allows us to check whether a formula α is true under a given interpretation I , i.e. I is a model for α. First, the formula is split into sub-formulae until we obtain the contained atoms or constants. Due to brevity, the following encodings only exemplify this for the connectives ∧, ¬ and→. Note that ∨, 6↔ and↔ are supported as well.\nπsubformula = {\nsubformula(F )← subformula(and(F, )); (1) subformula(F )← subformula(and( , F )); (2) subformula(F )← subformula(neg(F )); (3) subformula(F )← subformula(imp(F, )); (4) subformula(F )← subformula(imp( , F )). } (5)\nThe atoms and constants of α are then obtained via the encoding πatom. Consider rule (1) which denotes that a formula is not an atom in case it is of the form and(·, ·) 4.\nπatom = {\nnoatom(F )← subformula(F ;F1;F2), F := and(F1, F2); (1) noatom(F )← subformula(F ;F1), F := neg(F1); (2) noatom(F )← subformula(F ;F1;F2), F := imp(F1, F2); (3) atom(X)← subformula(X),not noatom(X). } (4)\nNow we compute whether the interpretation is a model by first evaluating the atoms and constants. In case an atom gets assigned true (false) we derive that the interpretation for this sub-formula is a model (not a model). Now, the connectives are evaluated bottom-up based on the model information of the sub-formulae. In particular, this allows to check whether I is a model for our original formula α, or not.\nThe encoding πismodel exemplifies this approach for some of the connectives. In the subsequent sections we have to apply model checking several times within a single ASP encoding. In order to avoid side effects of different checks, we introduce an additional\n4 Note that the syntax of our encodings is specific to the grounder gringo [15].\nparameter, K, which serves as a key for identifying the origin of the interpretation that is currently checked. Suppose, for example, that we want to check satisfiability of two different formulae. As the formulae may evaluate to true under different interpretations we have to distinguish between the truth assignments.\nπismodel = { ismodel(K,X)← atom(X), true(K,X); (1)\nismodel(K,F )← subformula(F ;F1), F := neg(F1), nomodel(K,F1);\n(2)\nismodel(K,F )← subformula(F ), F := and(F1, F2), ismodel(K,F1;F2);\n(3)\nismodel(K,F )← subformula(F ), F := imp(F1, F2), ismodel(K,F1;F2). } (4)\nDue to brevity we omit the encoding πnomodel here. Analogous to πismodel it derives the predicate nomodel(K,F ) whenever an atom gets assigned false or a sub-formula is false under the current interpretation. The complete program for checking whether a formula evaluates to true under a given variable assignment consists of\nπmodelcheck = πsubformula ∪ πatom ∪ πismodel ∪ πnomodel\nExample 6. Consider the formula a → b from K of Example 5, i.e. kb(imp(a, b)). In order to check whether there exists a model we can make use of πmodelcheck in the following way: Initially, we have to define an additional rule subformula(X)← kb(X) as πsubformula only considers formulae given by the predicate subformula(·). By adding the program πsubformula ∪ πatom the following answer-set is returned:\n{kb(imp(a, b)). subformula(imp(a, b)). subformula(a). subformula(b). noatom(imp(a, b)). atom(b). atom(a).}\nEach atom now gets assigned true or false, representing an interpretation. We encode this by the rule true(k,X) ∨ false(k,X)← atom(X). Note that the specification of a key (in this case k) is mandatory although πmodelcheck is not applied several times in this example. By adding and running πismodel∪πnomodel four answer-sets are returned. Each contains the predicates from the previously given answer-set as well as the truth assignment for the atoms a and b and either ismodel(k, imp(a, b)) or nomodel(k, imp(a, b)). The answer-set obtained by false(k, a) and true(k, b) contains (amongst others)\n{false(k, a). true(k, b). ismodel(k, b). nomodel(k, a). ismodel(k, imp(a, b)).}\ndenoting that I(a) = false, I(b) = true is a model for a→ b."
    }, {
      "heading" : "3.2 Forming Arguments",
      "text" : "We now derive the arguments from a knowledge baseK and a set C of claims. According to [4], we have to check whether the support entails the claim and if the support is subset minimal as well as consistent. In order to obtain arguments we first guess exactly one claim and a subset of formulae from K. This guess is encoded as follows:\nπarg = { 1{ sclaim(X) : cl(X) }1; (1)\n1{ fs(X) : kb(X) }. }\n(2)\nThe selected claim is denoted by sclaim(·). The predicate fs(·) is derived if the respective formula from K is contained in the support S of an argument A = (S,C).\nEntailment: In order to be a valid argument, the support must entail the claim, i.e. S |= C must hold. As S |= C, |= S → C must hold as well. Hence, ¬(S → C) ≡ ¬(¬S ∨ C) ≡ S ∧ ¬C must be unsatisfiable. Unsatisfiability of the formula S ∧ ¬C can be checked by making use of the saturation technique [12]: We first assign true(entail , x) or false(entail , x) to each atom x in the formula using a disjunctive rule. This allows both true(entail , x) and false(entail , x) to be contained in the resulting answerset. Furthermore, all formulae in S and the negated claim C are conjunctively connected. Hence, in case any of those formulae evaluates to false under a variable assignment (i.e. nomodel(entail , ·) is derived) we know that ¬(S → C) is not satisfied which implies that S |= C evaluates to true under the given interpretation. In this case we saturate, i.e. we derive true(entail , x) and false(entail , x) for any atom x. On the other hand, if no formula in S and C derives entails claim the constraint ← not entails claim removes the answer-set. If this is the case, due to the definition of stable model semantics in answer-set programming, no answer-set is returned. Only in case there exists no model for ¬(S → C) all guesses are saturated and we obtain a single answer-set representing a support S and claim C where S |= C holds.\nIn the following the program πentailment is given. Note that entail is simply used as a key for identifying the variable assignment and model check.\nπentailment = {\ntrue(entail, X) ∨ false(entail, X)← atom(X); (1) entails claim← nomodel(entail, neg(X)), sclaim(X); (2) entails claim← nomodel(entail, X), fs(X); (3) ← not entails claim; (4) true(entail, X)← entails claim, atom(X); (5) false(entail, X)← entails claim, atom(X). } (6)\nSubset minimality: The support S of an argument must be a subset minimal set of formulae, i.e. there must not exist an S′ ⊂ S s.t. S′ |= C. Here, we apply the concept of a loop (see e.g. [13]). For a candidate support S we consider all S′ ⊂ S where there exists exactly one formula α ∈ S but α 6∈ S′. In case any such S′ exists where S′ |= C we know that S is not a support for C. Due to monotonicity of classical logic this is sufficient since if S′ 6|= C then also for all S′′ ⊂ S′ it holds that S′′ 6|= C. First, we define a total ordering over all formulae fs(·) in S:\nπ< = {\nlt(X,Y )← fs(X), fs(Y ), X < Y ; (1) nsucc(X,Z)← lt(X,Y ), lt(Y, Z); (2) succ(X,Y )← lt(X,Y ),not nsucc(X,Y ); (3) ninf(Y )← lt(X,Y ); (4) inf(X)← fs(X),not ninf(X); (5) nsup(X)← lt(X,Y ); (6) sup(X)← fs(X),not nsup(X). } (7)\nFor any S′ we now assign true(m(K), x) or false(m(K), x) to all atoms x. m(K) is used as key for identifying the truth assignment. K is the formula α where α 6∈ S′.\nThe idea is now to “iterate” over the the ordering, beginning at the infimum inf(·). Based on the ordering, we now consider every formula from the support: In case the formula is satisfied or corresponds to the removed formula α (i.e. the key K) we derive model upto(m(α), ·). If we can derive hasmodel(m(α)) we know that the support S′ = S \\ α is satisfiable and can therefore not be a valid support for our claim. On the other hand, if any S′ is a valid support we can not derive hasmodel(m(α)) and the answer-set is removed by the constraint← not hasmodel(m(α)), fs(α).\nπminimize = { true(m(K), X)← not false(m(K), X), atom(X), fs(K); (1) false(m(K), X)← not true(m(K), X), atom(X), fs(K); (2) model upto(m(K), X)← inf(X), ismodel(m(K), X),\nfs(X), X 6= K; (3)\nmodel upto(m(K), K)← inf(K), fs(K); (4) model upto(m(K), X)← succ(Z,X), ismodel(m(K), X),\nfs(X),model upto(m(K), Z), X 6= K; (5)\nmodel upto(m(K), K)← succ(Z,K),model upto(m(K), Z), fs(K);\n(6)\nhasmodel(m(K))← sup(K),model upto(m(K), X), ismodel(m(K), neg(Z)), sclaim(Z);\n(7)\n← not hasmodel(m(K)), fs(K). }\n(8)\nConsistency: The support S must be a consistent set of formulae. In other words, there exists a model for the conjunction of all formulae in S. The program πconsistent simply consists of a guess which assigns truth values to all atoms and a constraint that removes any unsatisfiable support.\nπconsistent = { 1{ true(consistent, X), false(consistent, X) }1← atom(X). (1)\n← nomodel(consistent, X), fs(X). }. }\n(2)\nThe following program then gives all arguments that can be computed from a knowledge base K and a set of claims C:\nπarguments = πmodelcheck ∪ πarg ∪ πentailment ∪ π< ∪ πminimize ∪ πconsistent\nEach answer-set obtained by πarguments contains the predicate sclaim(·) and a set of predicates fs(·), representing claim and support.\nExample 7. Consider the input as given in Example 5. The program πarguments returns the following answer-sets (we restrict ourselves to the relevant predicates):\na1 : {fs(a). sclaim(a).} a∗2 : {fs(imp(a, b)). sclaim(imp(a, b)).} a3 : {fs(a). fs(imp(a, b)). sclaim(b).} a4 : {fs(neg(b)). fs(imp(a, b)). sclaim(neg(a)).} a5 : {fs(neg(b)). sclaim(neg(b)).} a6 : {fs(a). fs(neg(b)). sclaim(and(a,neg(b))).}\nNote that due to the definition of program πminimize and πconsistent several resulting answer-sets may represent the same derived argument: This is the case for a∗2 where actually three models are derived by the program πconsistent. They only differ in the respective truth assignments true(consistent, ·) and false(consistent, ·). We eliminate duplicates in an additional post-processing step in order to remove redundant information."
    }, {
      "heading" : "3.3 Identifying Conflicts between Arguments",
      "text" : "We now want to compute attacks between arguments. Therefore we first specify encodings that are used by every attack type (such as defeat and direct defeat). We then present encodings for the computation of these attack types.\nIn order to reason over all arguments we first have to “flatten” the answer-sets obtained by πarguments. We specify this by the predicates as(A, fs, ·) and as(A, claim, ·). A is a numeric key identifying the argument.\nExample 8. We illustrate this by the answer-sets a1, a2 and a3 from Example 7. This input is given by the following facts:\n{as(1, fs, a). as(1, sclaim, a). as(2, fs, imp(a, b)). as(2, sclaim, imp(a, b)). as(3, fs, a). as(3, fs, imp(a, b)). as(3, sclaim, b).}\nIn order to identify conflicts between arguments we first guess two arguments. selected1(·) and selected2(·) contain the keys of the selected arguments.\nπatt = { 1{selected1(A) : as(A, , )}1. (1)\n1{selected2(A) : as(A, , )}1. }\n(2)\nFurthermore, we construct one single support formula for each argument A by conjunction of all formulae in as(A, fs, ·). As in the previous section we first define an ordering over all formulae that are contained in the support. The only difference is that we add the argument’s keyA to the predicates inf(A, ·), sup(A, ·) and succ(A, ·, ·). Due to brevity, the corresponding program π<key is omitted. We can then construct the support formula by iterating over the ordering and connecting the formulae by conjunction. Note that the last parameter of fs conj(A, ·, ·) is simply used as an identifier for the current position in the iteration. When the supremum is reached we derive support(A, ·) for A containing the support formula.\nπsupport = {\nfs conj(A,X,X)← inf(A,X), sup(A,X); (1) fs conj(A, and(X,Y ), Y )← inf(A,X), succ(A,X, Y ); (2) fs conj(A, and(O,N), N)← succ(A,C,N), fs conj(A,O,C); (3) support(A,X)← fs conj(A,X,C), sup(A,C). } (4)\nFor the computation of attacks we again apply the saturation technique. The program πatt sat is used to saturate all attack computations. First, we derive all attack type keys t from the truth assignments true(t, ·) and false(t, ·) of the applied attack type programs. Note that the corresponding assignments are defined separately in each attack program. In case attack is derived for all truth assignments in some attack program\nwe saturate. Finally, the binary predicate attack(·, ·) is generated. It is used for the representation of the attack relation between the two arguments.\nπatt sat = {\nattacktype(T )← true(T, ); (1) attacktype(T )← false(T, ); (2) true(T,X)← attack, atom(X), attacktype(T ); (3) false(T,X)← attack, atom(X), attacktype(T ); (4) ← not attack; (5) attack(X,Y )← selected1(X), selected2(Y ). } (6)\nWe now consider the attack types defeat and direct defeat. The basic idea is to define a propositional formula that represents the attack condition. We then assign true(t, x) or false(t, x) to any atom x using a disjunctive rule. In case every such interpretation is a model for our attack formula we know that the formula is valid. Otherwise, if any interpretation is not a model (i.e. attack is not derived) the resulting answer-set is strictly smaller than those where the interpretation is a model. Such answer-sets are removed by the constraint← not attack. Note that this also works in case we consider several attack types: If we derive attack for all interpretations of a single attack type we saturate all interpretations of all attack types. As the predicate attack as well as all assignments true(t, x) and false(t, x) are then contained in all answer-sets for the two selected arguments we derive every attack relation.\nThe following program πdefeat exemplifies the above described approach. For two arguments A = (S,C) and A′ = (S′ = {φ′1, ..., φ′m}, C ′) we have that A defeats A′ if C |= ¬(φ′1∧ ...∧φ′m). Here we make use of the support derived by π<key ∪πsupport. As the support is defined as a conjunction of formulae we can directly make use of claim C and the negated support ¬S′.\nπdefeat = { checkDefeat(imp(C, neg(S ′ )))← selected1(X), selected2(Y ),\nas(X, sclaim, C), support(Y, S ′ );\n(1)\nsubformula(X)← checkDefeat(X); (2) true(defeat, X) ∨ false(defeat, X)← atom(X); (3) attack← ismodel(defeat, X), checkDefeat(X). } (4)\nThe second program we consider here is πddefeat. A directly defeats A′ if C |= ¬φ′i for a φ′i ∈ S′. Hence, we have to consider each formula in S′ separately. Therefore we use a combination of attack type and φ′i to identify the truth assignment.\nπddefeat = { checkDirectdefeat(Φ, imp(C, neg(Φ)))← selected1(X), selected2(Y ),\nas(X, sclaim, C), as(Y, fs, Φ); (1)\nsubformula(X)← checkDirectdefeat( , X); (2) true(ddefeat(T ), X) ∨ false(ddefeat(T ), X)← atom(X),\ncheckDirectdefeat(T, ); (3)\nattack← ismodel(ddefeat(T ), X), checkDirectdefeat(T,X). }\n(4)\nThe program πattacks in combination with any attack type programs (such as πdefeat, πddefeat, ...) computes the respective attack relations.\nπattacks = πmodelcheck ∪ πatt ∪ πsupport ∪ π<key ∪ πatt sat\nExample 9. Continuing our running example, we now consider the flattened input as exemplified in Example 8 and the program πattacks ∪ πddefeat. We obtain 9 answer-sets that contain the attack information between arguments:\n{attack(4, 1).}, {attack(6, 2).}, {attack(4, 3).}, {attack(6, 4).}, {attack(3, 5).}, {attack(3, 4).}, {attack(6, 3).}, {attack(4, 6).}, {attack(3, 6).}\nThe first answer-set, for example, represents that argument a4 = ({¬b, a → b},¬a) attacks (directly defeats) a1 = ({a}, a)."
    }, {
      "heading" : "3.4 Overall Approach at a Glance",
      "text" : "To sum it up, the overall process of our instantiation-based approach for generating argumentation frameworks consists of the following steps:\n1. A knowledge-base K and a set C of claims are used as input. 2. The encoding πarguments = πmodelcheck ∪ πarg ∪ πentailment ∪ π< ∪ πminimize ∪ πconsistent defines how arguments are derived from K and C: πmodelcheck is generally used for evaluating formulae under truth assignments. Within πarg, for each argument A = (S,C) a claim C ∈ C and a support S ⊆ K is guessed. The encodings πentailment, π< ∪ πminimize and πconsistent guarantee that the support entails the claim, the support is subset minimal and that S is a consistent set of formulae. 3. The resulting arguments are “flattened” and used as input for πattacks. 4. The encoding πattacks = πmodelcheck∪πatt∪πsupport∪π<key∪πatt sat is shared by\nall attack types. πmodelcheck is again needed for model checking. πatt guesses two arguments at once. πsupport ∪ π<key constructs a single support formula for those arguments by connecting the contained formulae by conjunction. πatt sat saturates all attack computations. 5. Any attack encodings, such as πdefeat and πddefeat can be used in combination with πattacks in order to compute the respective attack relations."
    }, {
      "heading" : "4 Visualization of Argumentation Frameworks",
      "text" : "In order to visualize argumentation frameworks we make use of the purpose-built tool ARVis5. ARVis is intended for the visualization of answer-sets and their relations by means of a directed graph. Each node in the graph represents an answer-set and a directed edge between two arguments represents a relation.\nWe now describe the process of generating and visualizing argumentation frameworks by using the encodings πarguments and πattacks. ARVis provides a wizard that handles the respective steps:\n1. Obtain arguments: The program πarguments and a problem instance must be specified within ARVis. ARVis computes the arguments by invoking an ASP solver. 2. Flatten arguments: The arguments obtained in the previous step are “flattened”, i.e. a single set of facts is generated in order to be able to reason over all obtained arguments when computing the attacks.\n5 http://dbai.tuwien.ac.at/proj/argumentation/vispartix/#ARVis\n3. Obtain attacks: The program πattacks and the attack type programs are now specified. The relations between the arguments are computed. 4. Select attack predicate: In general, ARVis accepts any binary predicate that represents answer-set relations. We define attack/2 here. 5. Argumentation framework: We obtain a graph visualization consisting of arguments (vertices) and attacks (edges). 6. Export: The obtained argumentation framework can be exported for further processing.\nThe argumentation framework resulting from our running example, as represented by ARVis, is given in Figure 2. The attacks correspond to direct defeats between arguments. Each argument in the graph is represented by its id. By selecting an argument its claim and support are shown in the text field on the right side. All encodings, ARVis and detailed configuration information is available at\nhttp://dbai.tuwien.ac.at/proj/argumentation/vispartix\nARVis is a general-purpose tool that may also be used in many other areas of research: Consider, for example, the Traveling Salesperson Problem (TSP) where the first program computes cities and the second program outputs routes where every city is visited exactly once. In fact, ARVis can be used for any problem where one is interested in the relation between answer-sets. It is only necessary to specify two answer-set programs: One for generating answer-sets and a second one for computing relations between those answer-sets.\nOur approach is different from other available ASP visualization tools: ASPViz [8] takes two answer-set programs as input, one for the problem encoding and one for the visualization. The latter is used for visualization for each answer-set of the former\nseparately. It is realized in Java and works with pre-defined predicates to extract the visualization of answer-sets. IDPDraw [29] works in a similar fashion, which augments the presentation by providing also time points to show the result in different evolutionary states. Kara [19] from the SeaLion development environment for ASP also provides visualization of answer-sets using special predicates. ASPIDE [14] gives the user the opportunity to visualize the dependency graph of the input program and thus allows for another type of representation."
    }, {
      "heading" : "5 Conclusion",
      "text" : "In this paper, we have presented a novel ASP-based tool for constructing argumentation frameworks from a given knowledge base. We have provided here the concrete ASP encodings used to obtain such frameworks when logic-based arguments cf. [4] are employed. However, similar encodings for further approaches of argumentation are possible and subject of future work, as well as a performance evaluation of the presented approach to check its scalability with large knowledge bases.\nWhen designing our tool, ARVis, we tried to keep it as flexible as possible such that the concrete construction of the framework can be specified in the logic programs. As it has turned out, ARVis is thus not only a tool for generating and visualizing argumentation frameworks but also for graphically representing relations between answer-sets in a user-specified manner. Ongoing work thus focuses on application areas where it is the relation between the answer-sets (rather than the single answer-sets) that can support the designer of logic programs or where this relation is the relevant output of an ASP encoding.\nAcknowledgments We would like to thank Thomas Ambroz and Andreas Jusits for implementing and adapting ARVis according to our requirements as well as Torsten Schaub for providing hints how to process arbitrary formulae via ASP.\nThis work has been funded by the Vienna Science and Technology Fund (WWTF) through project ICT08-028, and by the Vienna University of Technology program “Innovative Projects”."
    } ],
    "references" : [ {
      "title" : "Identifying the Core of Logic-Based Argumentation Systems",
      "author" : [ "L. Amgoud", "P. Besnard", "S. Vesic" ],
      "venue" : "In ICTAI’11,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2011
    }, {
      "title" : "Learning by diagramming Supreme Court oral arguments",
      "author" : [ "K. Ashley", "N. Pinkwart", "C. Lynch", "V. Aleven" ],
      "venue" : "In ICAIL’07,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2007
    }, {
      "title" : "Semantics of Abstract Argument Systems",
      "author" : [ "P. Baroni", "M. Giacomin" ],
      "venue" : "Argumentation in Artificial Intelligence,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2009
    }, {
      "title" : "A logic-based theory of deductive arguments",
      "author" : [ "P. Besnard", "A. Hunter" ],
      "venue" : "Artif. Intell.,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2001
    }, {
      "title" : "DUNESDialogic and Argumentative Negotiation Educational Software-Technical Realization",
      "author" : [ "J. Börding", "A. Voss", "J. Walther", "V. Wolff", "A. Ocakli", "R. Groot", "B. Baurens" ],
      "venue" : "In ICTE’02,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2002
    }, {
      "title" : "Answer set programming at a glance",
      "author" : [ "G. Brewka", "T. Eiter", "M. Truszczyński" ],
      "venue" : "Commun. ACM,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2011
    }, {
      "title" : "On the evaluation of argumentation formalisms",
      "author" : [ "M. Caminada", "L. Amgoud" ],
      "venue" : "Artif. Intell.,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2007
    }, {
      "title" : "ASPVIZ: Declarative Visualisation and Animation Using Answer Set Programming",
      "author" : [ "O. Cliffe", "M.D. Vos", "M. Brain", "J.A. Padget" ],
      "venue" : "In ICLP’08,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2008
    }, {
      "title" : "On the Acceptability of Arguments and its Fundamental Role in Nonmonotonic Reasoning, Logic Programming and n-Person Games",
      "author" : [ "P.M. Dung" ],
      "venue" : "Artif. Intell.,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1995
    }, {
      "title" : "Complexity-Sensitive Decision Procedures for Abstract Argumentation",
      "author" : [ "W. Dvořák", "M. Järvisalo", "J.P. Wallner", "S. Woltran" ],
      "venue" : "In KR’12,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2012
    }, {
      "title" : "Answer-set programming encodings for argumentation frameworks",
      "author" : [ "U. Egly", "S.A. Gaggl", "S. Woltran" ],
      "venue" : "Argument and Computation,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2010
    }, {
      "title" : "On the Computational Cost of Disjunctive Logic Programming: Propositional Case",
      "author" : [ "T. Eiter", "G. Gottlob" ],
      "venue" : "Ann. Math. Artif. Intell.,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 1995
    }, {
      "title" : "Answer Set Programming: A Primer",
      "author" : [ "T. Eiter", "G. Ianni", "T. Krennwallner" ],
      "venue" : "In Reasoning Web,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2009
    }, {
      "title" : "ASPIDE: Integrated Development Environment for Answer Set Programming",
      "author" : [ "O. Febbraro", "K. Reale", "F. Ricca" ],
      "venue" : "In LPNMR,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2011
    }, {
      "title" : "Potassco: The Potsdam Answer Set Solving Collection",
      "author" : [ "M. Gebser", "R. Kaminski", "B. Kaufmann", "M. Ostrowski", "T. Schaub", "M. Schneider" ],
      "venue" : "AI Commun.,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2011
    }, {
      "title" : "An Overview of the Carneades Argumentation Support System",
      "author" : [ "T. Gordon" ],
      "venue" : "Dialogue and Argumentation. An Examination of Douglas Walton’s Theories of Reasoning,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2010
    }, {
      "title" : "Instantiating abstract argumentation with classical logic arguments: Postulates and properties",
      "author" : [ "N. Gorogiannis", "A. Hunter" ],
      "venue" : "Artif. Intell.,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2011
    }, {
      "title" : "Computer supported argumentation and collaborative decision making: the HERMES system",
      "author" : [ "N. Karacapilidis", "D. Papadias" ],
      "venue" : "Inf. Syst.,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2001
    }, {
      "title" : "Kara: A System for Visualising and Visual Editing of Interpretations for Answer-Set Programs",
      "author" : [ "C. Kloimüllner", "J. Oetsch", "J. Pührer", "H. Tompits" ],
      "venue" : "In WLP’11,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2011
    }, {
      "title" : "The DLV system for knowledge representation and reasoning",
      "author" : [ "N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello" ],
      "venue" : "ACM Trans. Comput. Log.,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2006
    }, {
      "title" : "Stable Models and an Alternative Logic Programming Paradigm. In The Logic Programming Paradigm – A 25-Year Perspective, pages 375–398",
      "author" : [ "V.W. Marek", "M. Truszczyński" ],
      "venue" : null,
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 1999
    }, {
      "title" : "Logic Programming with Stable Model Semantics as a Constraint Programming Paradigm",
      "author" : [ "I. Niemelä" ],
      "venue" : "Ann. Math. Artif. Intell.,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 1999
    }, {
      "title" : "Properties and Complexity of Some Formal Inter-agent Dialogues",
      "author" : [ "S. Parsons", "M. Wooldridge", "L. Amgoud" ],
      "venue" : "J. Log. Comput.,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2003
    }, {
      "title" : "Araucaria: Software for Argument Analysis, Diagramming and Representation",
      "author" : [ "C. Reed", "G. Rowe" ],
      "venue" : "Int. Journal on Artif. Intel. Tools,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2004
    }, {
      "title" : "ArguNet a software tool for collaborative argumentation analysis and research",
      "author" : [ "D. Schneider", "C. Voigt", "G. Betz" ],
      "venue" : "In CMNA VII,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2007
    }, {
      "title" : "Cohere: Towards Web 2.0 Argumentation",
      "author" : [ "S.B. Shum" ],
      "venue" : "In COMMA’08,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2008
    }, {
      "title" : "ArguMed - A Template-Based Argument Mediation System for Lawyers",
      "author" : [ "B. Verheij" ],
      "venue" : "In JURIX’98,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 1998
    }, {
      "title" : "IDPDraw, a tool used for visualizing answer sets. https://dtai.cs",
      "author" : [ "J. Wittocx" ],
      "venue" : "kuleuven.be/krr/software/visualisation,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2009
    } ],
    "referenceMentions" : [ {
      "referenceID" : 6,
      "context" : "Instantiation-based argumentation [7] is a central paradigm in nonmonotonic reasoning since it gives a formal handle to separate the logical and non-classical contents of reasoning in the presence of contradicting information.",
      "startOffset" : 34,
      "endOffset" : 37
    }, {
      "referenceID" : 3,
      "context" : "In [4] the process is described with an underlying propositional knowledge base using minimal sets of consistent support classically entailing the claim.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 8,
      "context" : "The obtained arguments and the relation between them yield a so-called argumentation framework [9].",
      "startOffset" : 95,
      "endOffset" : 98
    }, {
      "referenceID" : 2,
      "context" : "Argumentation frameworks are then evaluated with one of the numerous semantics for abstract argumentation available, resulting in potentially multiple acceptable sets of arguments [3].",
      "startOffset" : 180,
      "endOffset" : 183
    }, {
      "referenceID" : 15,
      "context" : "Notable exceptions are the Carneades system, which can construct arguments using heuristics [16] and the recent TOAST implementation ar X iv :1 30 1.",
      "startOffset" : 92,
      "endOffset" : 96
    }, {
      "referenceID" : 22,
      "context" : "The reason for the lack of implementations is potentially twofold: First, due to the inherent high complexity of the problem; already constructing a single argument is hard for the second level of the polynomial hierarchy [23].",
      "startOffset" : 222,
      "endOffset" : 226
    }, {
      "referenceID" : 0,
      "context" : "Secondly, standard instantiation schemes for propositional knowledge bases result in infinite argumentation frameworks even for finite knowledge bases [1].",
      "startOffset" : 151,
      "endOffset" : 154
    }, {
      "referenceID" : 5,
      "context" : "The first obstacle calls for highly expressive languages, making answer-set programming [6, 21, 22] (ASP, for short) a well suited candidate.",
      "startOffset" : 88,
      "endOffset" : 99
    }, {
      "referenceID" : 20,
      "context" : "The first obstacle calls for highly expressive languages, making answer-set programming [6, 21, 22] (ASP, for short) a well suited candidate.",
      "startOffset" : 88,
      "endOffset" : 99
    }, {
      "referenceID" : 21,
      "context" : "The first obstacle calls for highly expressive languages, making answer-set programming [6, 21, 22] (ASP, for short) a well suited candidate.",
      "startOffset" : 88,
      "endOffset" : 99
    }, {
      "referenceID" : 10,
      "context" : "ASPARTIX [11] or CEGARTIX [10].",
      "startOffset" : 9,
      "endOffset" : 13
    }, {
      "referenceID" : 9,
      "context" : "ASPARTIX [11] or CEGARTIX [10].",
      "startOffset" : 26,
      "endOffset" : 30
    }, {
      "referenceID" : 14,
      "context" : "Thus we can make use of the high sophistication modern ASP systems have reached [15, 20].",
      "startOffset" : 80,
      "endOffset" : 88
    }, {
      "referenceID" : 19,
      "context" : "Thus we can make use of the high sophistication modern ASP systems have reached [15, 20].",
      "startOffset" : 80,
      "endOffset" : 88
    }, {
      "referenceID" : 7,
      "context" : "ASPViz [8], ASPIDE [14], Kara [19] and IDPDraw [29].",
      "startOffset" : 7,
      "endOffset" : 10
    }, {
      "referenceID" : 13,
      "context" : "ASPViz [8], ASPIDE [14], Kara [19] and IDPDraw [29].",
      "startOffset" : 19,
      "endOffset" : 23
    }, {
      "referenceID" : 18,
      "context" : "ASPViz [8], ASPIDE [14], Kara [19] and IDPDraw [29].",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 27,
      "context" : "ASPViz [8], ASPIDE [14], Kara [19] and IDPDraw [29].",
      "startOffset" : 47,
      "endOffset" : 51
    }, {
      "referenceID" : 1,
      "context" : "[2, 5, 11, 18, 24–26, 28], including Debategraph2 and Rationale3).",
      "startOffset" : 0,
      "endOffset" : 25
    }, {
      "referenceID" : 4,
      "context" : "[2, 5, 11, 18, 24–26, 28], including Debategraph2 and Rationale3).",
      "startOffset" : 0,
      "endOffset" : 25
    }, {
      "referenceID" : 10,
      "context" : "[2, 5, 11, 18, 24–26, 28], including Debategraph2 and Rationale3).",
      "startOffset" : 0,
      "endOffset" : 25
    }, {
      "referenceID" : 17,
      "context" : "[2, 5, 11, 18, 24–26, 28], including Debategraph2 and Rationale3).",
      "startOffset" : 0,
      "endOffset" : 25
    }, {
      "referenceID" : 23,
      "context" : "[2, 5, 11, 18, 24–26, 28], including Debategraph2 and Rationale3).",
      "startOffset" : 0,
      "endOffset" : 25
    }, {
      "referenceID" : 24,
      "context" : "[2, 5, 11, 18, 24–26, 28], including Debategraph2 and Rationale3).",
      "startOffset" : 0,
      "endOffset" : 25
    }, {
      "referenceID" : 25,
      "context" : "[2, 5, 11, 18, 24–26, 28], including Debategraph2 and Rationale3).",
      "startOffset" : 0,
      "endOffset" : 25
    }, {
      "referenceID" : 26,
      "context" : "[2, 5, 11, 18, 24–26, 28], including Debategraph2 and Rationale3).",
      "startOffset" : 0,
      "endOffset" : 25
    }, {
      "referenceID" : 8,
      "context" : "In particular we will explain the argumentation process based on argumentation frameworks [9] as well as briefly recall the concepts for disjunctive logic programs.",
      "startOffset" : 90,
      "endOffset" : 93
    }, {
      "referenceID" : 6,
      "context" : "We start with the underlying process [7], which we will utilize in our context.",
      "startOffset" : 37,
      "endOffset" : 40
    }, {
      "referenceID" : 3,
      "context" : "The instantiation step now constructs arguments and relations among them based on the information available in K according to [4].",
      "startOffset" : 126,
      "endOffset" : 129
    }, {
      "referenceID" : 8,
      "context" : "The abstract representation we utilize for this purpose is the widely studied argumentation framework [9].",
      "startOffset" : 102,
      "endOffset" : 105
    }, {
      "referenceID" : 16,
      "context" : "Indeed, [17] identify conditions for rational and consistent end results, which require the existence of specific arguments, which must be included in C.",
      "startOffset" : 8,
      "endOffset" : 12
    }, {
      "referenceID" : 0,
      "context" : "On the other hand, this restriction is in line with the concept of cores of argumentation frameworks [1], which try to preserve desired properties while using only a subset of all possible arguments.",
      "startOffset" : 101,
      "endOffset" : 104
    }, {
      "referenceID" : 16,
      "context" : "We take the attack definitions from [17] and illustrate two types, defeat and directed defeat.",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 22,
      "context" : "A more detailed computational complexity analysis can be found in [23].",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 5,
      "context" : "In this section we recall the basics of disjunctive logic programs under the answer-sets semantics [6, 22].",
      "startOffset" : 99,
      "endOffset" : 106
    }, {
      "referenceID" : 21,
      "context" : "In this section we recall the basics of disjunctive logic programs under the answer-sets semantics [6, 22].",
      "startOffset" : 99,
      "endOffset" : 106
    }, {
      "referenceID" : 14,
      "context" : "4 Note that the syntax of our encodings is specific to the grounder gringo [15].",
      "startOffset" : 75,
      "endOffset" : 79
    }, {
      "referenceID" : 3,
      "context" : "According to [4], we have to check whether the support entails the claim and if the support is subset minimal as well as consistent.",
      "startOffset" : 13,
      "endOffset" : 16
    }, {
      "referenceID" : 11,
      "context" : "Unsatisfiability of the formula S ∧ ¬C can be checked by making use of the saturation technique [12]: We first assign true(entail , x) or false(entail , x) to each atom x in the formula using a disjunctive rule.",
      "startOffset" : 96,
      "endOffset" : 100
    }, {
      "referenceID" : 12,
      "context" : "[13]).",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 7,
      "context" : "Our approach is different from other available ASP visualization tools: ASPViz [8] takes two answer-set programs as input, one for the problem encoding and one for the visualization.",
      "startOffset" : 79,
      "endOffset" : 82
    }, {
      "referenceID" : 27,
      "context" : "IDPDraw [29] works in a similar fashion, which augments the presentation by providing also time points to show the result in different evolutionary states.",
      "startOffset" : 8,
      "endOffset" : 12
    }, {
      "referenceID" : 18,
      "context" : "Kara [19] from the SeaLion development environment for ASP also provides visualization of answer-sets using special predicates.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 13,
      "context" : "ASPIDE [14] gives the user the opportunity to visualize the dependency graph of the input program and thus allows for another type of representation.",
      "startOffset" : 7,
      "endOffset" : 11
    }, {
      "referenceID" : 3,
      "context" : "[4] are employed.",
      "startOffset" : 0,
      "endOffset" : 3
    } ],
    "year" : 2013,
    "abstractText" : "Within the area of computational models of argumentation, the instantiation-based approach is gaining more and more attention, not at least because meaningful input for Dung’s abstract frameworks is provided in that way. In a nutshell, the aim of instantiation-based argumentation is to form, from a given knowledge base, a set of arguments and to identify the conflicts between them. The resulting network is then evaluated by means of extension-based semantics on an abstract level, i.e. on the resulting graph. While several systems are nowadays available for the latter step, the automation of the instantiation process itself has received less attention. In this work, we provide a novel approach to construct and visualize an argumentation framework from a given knowledge base. The system we propose relies on Answer-Set Programming and follows a two-step approach. A first program yields the logic-based arguments as its answer-sets; a second program is then used to specify the relations between arguments based on the answer-sets of the first program. As it turns out, this approach not only allows for a flexible and extensible tool for instantiation-based argumentation, but also provides a new method for answer-set visualization in general.",
    "creator" : "TeX"
  }
}