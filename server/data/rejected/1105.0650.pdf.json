{
  "name" : "1105.0650.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ ],
    "emails" : [ "yuliya@cs.uky.edu)", "mirek@cs.uky.edu)" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n10 5.\n06 50\nv1 [\ncs .A\nI] 3"
    }, {
      "heading" : "1 Introduction",
      "text" : "A fundamental reasoning task for propositional logic is to compute models of propositional formulas or determine that no models exist. Programs developed for this task are commonly called model generators or satisfiability (SAT) solvers. In the paper we show that transition systems introduced by Nieuwenhuis et al. (2006) to model and analyze SAT solvers can be adapted for the analysis and comparison of solvers developed for other propositional formalisms. The two formalisms we focus on are logic programming with the answer-set semantics and the logic PC(ID).\nDavis-Putnam-Logemann-Loveland (DPLL) procedure is a well-known method that exhaustively explores interpretations to generate models of a propositional formula. Most modern SAT solvers are based on variations of the DPLL procedure. Usually these variations are specified by pseudocode. Nieuwenhuis et al. (2006) proposed an alternative approach based on the notion of a transition system that describes “states of computation” and allowed transitions between them. In this way, it defines a directed graph such that every execution of the DPLL procedure corresponds to a path in the graph. This abstract way of presenting DPLL-based algorithms simplifies the analysis of their correctness and facilitates studies of their properties — instead of reasoning about pseudocode constructs, we reason about properties of a graph. For instance, by proving that the graph corresponding to a DPLL-based algorithm is finite and acyclic we show that the algorithm always terminates.\nAnswer-set programming (ASP) (Marek and Truszczyński 1999; Niemelä 1999) is a declarative programming formalism based on the answer-set semantics of logic programs (Gelfond and Lifschitz 1988). Generating answer sets of propositional programs is the\nkey step in computation with ASP. The logic FO(ID), introduced by Denecker (2000) is another formalism for declarative programming and knowledge representation. As in the case of ASP, most automated reasoning tasks in the logic FO(ID) reduce to reasoning in its propositional core, the logic PC(ID) (Mariën et al. 2008), where generating models is again the key.\nIn this paper, we show that both computing answer sets of programs and computing models of PC(ID) theories can be considered as testing satisfiability modulo theories (SMT), where the objective is to find a model of a set of clauses that is also an answer set of a certain program. We refer to this computational problem as satisfiability modulo answer-set programming and denote it by SM(ASP). We identify the propositional formalism capturing SM(ASP) — we use the same term to refer to it — and show that it is a common generalization of ASP and PC(ID). We define a simple transition system for SM(ASP) and show that it can be used as an abstract representation of the solver SMODELS1 (Niemelä and Simons 2000), an alternative to a similar characterization of SMODELS obtained earlier by Lierler (2011). We then define another more elaborate transition system for SM(ASP) that captures such features of backtracking search as backjumping and learning. We use this transition system to obtain abstract characterizations of the algorithms implemented by the ASP solvers CMODELS2 (Giunchiglia et al. 2004) and CLASP3 (Gebser et al. 2007), and the PC(ID) solver MINISAT(ID)4 (Mariën et al. 2008). Finally, we briefly mention the possibility to regard the introduced transition systems as proof systems. In that setting, transition systems could be used for comparing the solvers they represent in terms of the complexity of the corresponding proof systems.\nOur results provide a uniform correctness proof for a broad class of solvers that can be modeled by the transition system for SM(ASP), clarify essential computational principles behind ASP and PC(ID) solvers, and offer insights into how they relate to each other. In particular, our results yield the first abstract representation of CLASP in terms of transition systems (up to now CLASP has been typically specified in pseudocode), and show that at the abstract level, CLASP and MINISAT(ID) are strikingly closely related.\nThis last point is noteworthy as the two solvers were developed for different propositional formalisms. MINISAT(ID) was developed specifically for the logic PC(ID), where there is no concept of an answer set. The semantics is a natural extension of the notion of a model of a propositional theory to the setting when a theory consists of propositional clauses and definitions. Definitions are written as logic programs but they are interpreted by the well-founded semantics and not by the answer-set semantics. There is no indication in the literature that CLASP or MINISAT(ID) were influenced by each other. The two solvers were developed independently and for differently motivated formalisms. It is then of substantial interest that at the level of solving they are closely related.\n1 http://www.tcs.hut.fi/Software/smodels/ . 2 http://www.cs.utexas.edu/users/tag/cmodels . 3 http://www.cs.uni-potsdam.de/clasp/ . 4 http://dtai.cs.kuleuven.be/krr/software/minisatid ."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "We now review the abstract transition system framework proposed for the DPLL procedure by Nieuwenhuis et al. (2006), and introduce some necessary terminology concerning logic programs and the logic PC(ID).\nAbstract DPLL. Most state-of-the-art SAT solvers are based on variations of the DPLL procedure (Davis et al. 1962). Nieuwenhuis et al. (2006) described DPLL by means of a transition system that can be viewed as an abstract representation of the underlying DPLL computation. In this section we review the abstract DPLL in the form convenient for our purposes, following the presentation proposed by Lierler (2011).\nFor a set A of atoms, a record relative to A is an ordered set M of literals over A , some possibly annotated by ∆, which marks them as decision literals. A state relative to A is either a distinguished state FailState or a record relative to A . For instance, the states relative to a singleton set {a} are\nFailState, /0, a, ¬a, a∆, ¬a∆, a¬a, a∆¬a, a¬a∆, a∆¬a∆, ¬aa, ¬a∆ a, ¬aa∆, ¬a∆ a∆.\nFrequently, we consider M as a set of literals, ignoring both the annotations and the order among its elements. If neither a literal l nor its dual, written l, occurs in M, then l is unassigned by M. We say that M is inconsistent if both an atom a and its negation ¬a occur in it. For instance, states b∆¬b and ba¬b are inconsistent.\nIf C is a disjunction (conjunction) of literals then by C we understand the conjunction (disjunction) of the duals of the literals occurring in C. In some situations, we will identify disjunctions and conjunctions of literals with the sets of these literals.\nIn this paper, a clause is a non-empty disjunction of literals and a CNF formula is a conjunction (alternatively, a set) of clauses. Each CNF formula F determines its DPLL graph DPF. The set of nodes of DPF consists of the states relative to the set of atoms occurring in F. The edges of the graph DPF are specified by four transition rules:\nUnit Propagate: M =⇒ Ml if C∨ l ∈ F and C ⊆ M Decide: M =⇒ Ml∆ if l is unassigned by M\nFail: M =⇒ FailState if\n{\nM is inconsistent, and M contains no decision literals\nBacktrack: Pl∆ Q =⇒ Pl if\n{ Pl∆ Q is inconsistent, and Q contains no decision literals.\nA node (state) in the graph is terminal if no edge originates in it. The following proposition gathers key properties of the graph DPF .\nProposition 1\nFor any CNF formula F,\n(a) graph DPF is finite and acyclic, (b) any terminal state of DPF other than FailState is a model of F, (c) FailState is reachable from /0 in DPF if and only if F is unsatisfiable.\nThus, to decide the satisfiability of a CNF formula F it is enough to find a path leading from node /0 to a terminal node M. If M = FailState, F is unsatisfiable. Otherwise, F is satisfiable and M is a model of F.\nFor instance, let F = {a∨ b,¬a∨ c}. Below we show a path in DPF with every edge annotated by the name of the transition rule that gives rise to this edge in the graph:\n/0 Decide =⇒ a∆ Unit Propagate =⇒ a∆ c Decide =⇒ a∆ cb∆.\nThe state a∆ cb∆ is terminal. Thus, Proposition 1(b) asserts that F is satisfiable and {a,c,b} is a model of F.\nLogic Programs. A (propositional) logic program is a finite set of rules of the form\na0 ← a1, . . . ,al,not al+1, . . . ,not am,not not am+1, . . . ,not not an, (1)\nwhere a0 is an atom or ⊥ and each ai, 1≤ i ≤ n, is an atom.5 If a0 is an atom then a rule (1) is weakly normal. If, in addition, n = m then it is normal. Programs consisting of weakly normal (normal, respectively) rules only are called weakly normal (normal, respectively). If Π is a program, by At(Π) we denote the set of atoms that occur in Π.\nThe expression a0 is the head of the rule. If a0 = ⊥ we say that the head of the rule is empty and we often omit ⊥ from the notation. In such case we require that n > 0. We call a rule with the empty head a constraint. We write Head(Π) for the set of nonempty heads of rules in a program Π.\nWe call the expression a1, . . . ,al,not al+1, . . . ,not am, not not am+1, . . . ,not not an in a rule (1) the body of the rule and often view it as the set of all elements that occur in it. If a is an atom, we set s(a) = s(not not a) = a, and s(not a) = ¬a, and we define s(B) = {s(l) | l ∈ B}. More directly,\ns(B) = {a1, . . . ,al,¬al+1, . . . ,¬am,am+1, . . . ,an}.\nWe also frequently identify the body B of (1) with the conjunction of elements in s(B):\na1 ∧·· ·∧al ∧¬al+1 ∧·· ·∧¬am ∧am+1 ∧·· ·∧an.\nBy Bodies(Π,a) we denote the set of the bodies of all rules of Π with the head a (including the empty body). If B is the body of (1), we write Bpos for the positive part of the body, that is, Bpos = {a1, . . .al}.\nWe often interpret a rule (1) as a propositional clause\na0 ∨¬a1 ∨ . . .∨¬al ∨al+1 ∨ . . .∨am ∨¬am+1 ∨ . . .∨¬an (2)\n(in the case when the rule is a constraint, a0 is absent in (2)). Given a program Π, we write Πcl for the set of clauses (2) corresponding to all rules in Π.\nThis version of the language of logic programs is a special case of programs with nested expressions (Lifschitz et al. 1999). It is essential for our approach as it yields an alternative definition of the logic PC(ID), which facilitates connecting it to ASP. We assume that the reader is familiar with the definition of an answer set of a logic program and refer to the paper by Lifschitz et al. (1999) for details.\n5 In the paper, we do not use the term literal for expressions a, not a and not not a. We reserve the term literal exclusively for propositional literals a and ¬a.\nWell-Founded Semantics and the Logic PC(ID). Let M be a set of (propositional) literals. By M we understand the set of the duals of the literals in M. A set U of atoms occurring in a program Π is unfounded on a consistent set M of literals with respect to Π if for every a ∈ U and every B ∈ Bodies(Π,a), M∩ s(B) 6= /0 or U∩Bpos 6= /0. For every program Π and for every consistent set M of literals, the union of sets that are unfounded on M with respect to Π is also unfounded on M with respect to Π. Thus, under the assumptions above, there exists the greatest unfounded set on M with respect to Π. We denote this set by GUS(M,Π).\nFor every weakly normal program Π we define an operator WΠ on a set M of literals as follows\nWΠ(M) =\n{\nM∪{a | a ← B ∈ Π and s(B)⊆ M}∪GUS(M,Π) if M is consistent At(Π)∪At(Π) otherwise.\nBy WfixΠ (M) we denote a fixpoint of the operator WΠ over a set M of literals. One can show that it always exists since WΠ is not only monotone but also increasing (for any set M of literals, M ⊆ WΠ(M)). The least fixpoint of WΠ, W fix Π ( /0), is consistent and yields the wellfounded model of Π, which in general is three-valued. It is also written as lfp(WΠ). These definitions and properties were initially introduced for normal programs only (Van Gelder et al. 1991). They extend to programs in our syntax in a straightforward way, no changes in statements or arguments are needed (Lee 2005).\nLet Π be a program and A a set of atoms. An atom a is open with respect to Π and A if a ∈ A\\Head(Π). We denote the set of atoms that are open with respect to Π and A by OΠA . By ΠA we denote the logic program Π extended with the rules a ← not not a for each atom a ∈ OΠA . For instance, let Π be a program\na ← b, not c b.\n(3)\nThen, Π{c} is\nc ← not not c a ← b, not c b.\nWe are ready to introduce the logic PC(ID) (Denecker 2000). A PC(ID) theory is a pair (F,Π), where F is a set of clauses and Π is a weakly normal logic program. For a PC(ID) theory (F,Π), by Πo we denote ΠAt(F∪Π) and by OΠ we denote OΠAt(F∪Π) (where At(F ∪Π) stands for the set of atoms that occur in F and Π). Moreover, for a set M of literals and a set A of atoms, by MA we denote the set of those literals in M whose atoms occur in A. A set M of literals is complete over the set At of atoms if every atom in At occurs (possibly negated) in M and no other atoms occur in M.\nDefinition 1 Let (F,Π) be a PC(ID) theory. A consistent and complete (over At(F∪Π)) set M of literals is called a model of (F,Π) if\n(i) M is a model of F, and (ii) M = WfixΠo(M OΠ).\nFor instance, let F be a clause b∨¬c and Π be program (3). The PC(ID) theory (F,Π) has two models {b,¬c,a} and {b,c, ¬a}. We note that although sets {¬b,¬c,a} and {¬b,¬c,¬a} satisfy the condition (i), that is, are models of F, they do not satisfy the condition (ii) and therefore are not models of (F,Π).\nThe introduced definition of a PC(ID) theory differs from the original one (Denecker 2000). Specifically, for us the second component of a PC(ID) theory is a weakly normal program rather than a set of normal programs (definitions). Still, the two formalisms are closely related.\nProposition 2 For a PC(ID) theory (F,Π) such that Π is a normal program, M is a model of (F,Π) if and only if M is a model of (F,{Π}) according to the definition in (Denecker 2000).\nAs the restriction to a single program in PC(ID) theories is not essential (Mariën et al. 2008), Proposition 2 shows that our definition of the logic PC(ID) can be regarded as a slight generalization of the original one (more general programs can appear as definitions in PC(ID) theories)."
    }, {
      "heading" : "3 Satisfiability Modulo ASP: a unifying framework for ASP and PC(ID) solvers",
      "text" : "For a theory T the satisfiability modulo theory (SMT) problem is: given a formula F, determine whether F is T-satisfiable, that is, whether there exists a model of F that is also a model of T. We refer the reader to (Nieuwenhuis et al. 2006) for an introduction to SMT. Typically, a theory T that defines a specific SMT problem is a first-order formula. The SMT problem that we consider here is different. The theory T is a logic program under the (slightly modified) answer-set semantics. We show that the resulting version of the SMT problem can be regarded as a joint extension of ASP and PC(ID).\nWe start by describing the modification of the answer-set semantics that we have in mind.\nDefinition 2 Given a logic program Π, a set X of atoms is an input answer set of Π if X is an answer set of Π∪ (X \\Head(Π)).\nInformally, the atoms of X that cannot possibly be defined by Π as they do not belong to Head(Π) serve as “input” to Π. A set X is an input answer set of Π if it is an answer set of the program Π extended with these “input” atoms from X. Input answer sets are related to stable models of a propositional logic program module (Oikarinen and Janhunen 2006).\nFor instance, let us consider program (3). Then, sets {b,c}, {a,b} are input answer sets of the program whereas set {a,b,c} is not.\nThere are two important cases when input answer sets of a program are closely related to answer sets of the program.\nProposition 3 For a logic program Π and a set X of atoms:\n(a) X ⊆ Head(Π) and X is an input answer set of Π if and only if X is an answer set of Π.\n(b) If (X \\Head(Π))∩ At(Π) = /0, then X is an input answer set of Π if and only if X∩Head(Π) is an answer set of Π.\nWe now introduce a propositional formalism that we call satisfiability modulo ASP and denote by SM(ASP). Later in the paper we show that SM(ASP) can be viewed as a common generalization of both ASP and PC(ID). Theories of SM(ASP) are pairs [F,Π], where F is a set of clauses and Π is a program. In the definition below and in the remainder of the paper, for a set M of literals we write M+ to denote the set of atoms (non-negated literals) in M. For instance, {a,¬b}+ = {a}.\nDefinition 3 For an SM(ASP) theory [F,Π], a consistent and complete (over At(F∪Π)) set M of literals is a model of [F,Π] if M is a model of F and M+ is an input answer set of Π.\nFor instance, let F be a clause b∨¬c and Π be program (3). The SM(ASP) theory [F,Π] has two models {b,¬c,a} and {b,c,¬a}.\nThe problem of finding models of pairs [F,Π] can be regarded as an SMT problem in which, given a formula F and a program Π, the goal is to find a model of F that is (its representation by the set of its true atoms, to be precise) an input answer set of Π. This observation motivated our choice of the name for the formalism.\nAs for PC(ID) theories, also for an SM(ASP) theory [F,Π] we write Πo for the program ΠAt(Π∪F). We have the following simple observation.\nProposition 4 A set M of literals is a model of an SM(ASP) theory [F,Π] if and only if M is a model of an SM(ASP) theory [F,Πo].\nIt is evident that a set M of literals is a model of F if and only if M is a model of [F, /0]. Thus, SM(ASP) allows us to express the propositional satisfiability problem. We now show that the SM(ASP) formalism captures ASP. Let Π be a program. We say that a set F of clauses is Π-safe if\n1. F |= ¬a, for every a ∈ OΠAt(Π), and 2. for every answer set X of Π there is a model M of F such that X = M+∩Head(Π).\nProposition 5 Let Π be a program. For every Π-safe set F of clauses, a set X of atoms is an answer set of Π if and only if X = M+∩At(Π), for some model M of [F,Π].\nThis result shows that for an appropriately chosen theory F, answer sets of a program Π can be derived in a direct way from models of an SM(ASP) theory [F,Π]. There are several possible choices for F that satisfy the requirement of Π-safety. One of them is the Clark’s completion of Π (Clark 1978). We recall that the completion of a program Π consists of clauses in Πcl and of the formulas that can be written as\n¬a∨ ∨\nB∈Bodies(Π,a) B (4)\nfor every atom a in Π that is not a fact (that is, the set Bodies(Π,a) contains no empty body). Formulas (4) can be clausified in a straightforward way by applying distributivity.\nThe set of all the resulting clauses and of those in Πcl forms the clausified completion of Π, which we will denote by Comp(Π).\nThe theory Comp(Π) does not involve any new atoms but it can be exponentially larger than the completion formula before clausification. We can avoid the exponential blowup by introducing new atoms. Namely, for each body B of a rule in Π with |B| > 1, we introduce a fresh atom fB. If |B|= 1, then we define fB = s(l), where l is the only element of B. By ED-Comp(Π), we denote the set of the following clauses:\n1. all clauses in Πcl 2. all clauses ¬a∨ ∨\nB∈Bodies(Π,a) fB, for every a ∈ At(Π) such that a is not a fact in Π and |Bodies(Π,a)|> 1 3. all clauses ¬a∨ s(l), where a ∈ At(Π), Bodies(Π,a) = {B} and l ∈ B, 4. all clauses ¬a, where |Bodies(Π,a)|= 0 5. all clauses obtained by clausifying in the obvious way formulas fB ↔ B, where B ∈\nBodies(Π,a), for some atom a that is not a fact in Π and |Bodies(Π,a)|> 1.\nClearly, the restrictions of models of the theory ED-Comp(Π) to the original set of atoms are precisely the models of Comp(Π) (and of the completion of Π). However, the size of ED-Comp(Π) is linear in the size of Π. The theory ED-Comp(Π) has long been used in answer-set computation. Answer set solvers such as CMODELS (Giunchiglia et al. 2004) and CLASP (Gebser et al. 2007) start their computation by transforming the given program Π into ED-Comp(Π).\nFor instance, let Π be program (3). The completion of Π is the formula\n(a∨¬b∨ c)∧b∧¬c∧ (¬a∨ (b∧¬c)),\nits clausified completion Comp(Π) is the formula\n(a∨¬b∨ c)∧ (¬a∨b)∧ (¬a∨¬c)∧b∧¬c,\nand, finally, ED-Comp(Π) is the formula\n(a∨¬b∨ c)∧ (¬a∨ fb∧¬c)∧ (fb∧¬c ∨¬b∨ c)∧ (¬fb∧¬c ∨b)∧ (¬fb∧¬c ∨¬c)∧b∧¬c.\nWe now have the following corollary from Proposition 5.\nCorollary 1 For a logic program Π and a set X of atoms, the following conditions are equivalent:\n(a) X is an answer set of Π, (b) X = M+ for some model M of the SM(ASP) theory [{¬a | a ∈ OΠAt(Π)},Π], (c) X = M+ for some model M of the SM(ASP) theory [Comp(Π),Π], (d) X = M+∩At(Π) for some model M of the SM(ASP) theory [ED-Comp(Π),Π].\nIt is in this sense that ASP can be regarded as a fragment of SM(ASP). Answer sets of a program Π can be described in terms of models of SM(ASP) theories. Moreover, answerset computation can be reduced in a straightforward way to the task of computing models of SM(ASP) theories.\nRemark 1 Corollary 1 specifies three ways to describe answer sets of a program in terms of models of SM(ASP) theories. This offers an interesting view into answer-set generation. The CNF formulas appearing in the SM(ASP) theories in the conditions (b) - (d) make explicit some of the “propositional satisfiability inferences” that may be used when computing answer sets. The condition (b) shows that when computing answer sets of a program, atoms not occurring as heads can be inferred as false. The theory in (c) makes it clear that a much broader class of inferences can be used, namely those that are based on the clauses of the completion. The theory in (d) describes still additional inferences, as now, thanks to new atoms, we can explicitly infer whether bodies of rules must evaluate to true or false. In each case, some inferences needed for generating answer sets are still not captured by the respective CNF theory and require a reference to the program Π. We note that it is possible to express these “answer-set specific” inferences in terms of clauses corresponding to loop formulas (Lin and Zhao 2004; Lee 2005). We do not consider this possibility in this paper.\nNext, we show that SM(ASP) encompasses the logic PC(ID). The well-founded model M of a program Π is total if it assigns all atoms occurring in Π. For a PC(ID) theory (F,Π), a program Π is total on a model M of F if WfixΠo(M\nOΠ) is total. A program Π is total if Π is total on every model M of F. The PC(ID) theories (F,Π) where Π is total form an important class of total PC(ID) theories.\nThere is a tight relation between models of a total PC(ID) theory (F,Π) and models of an SM(ASP) theory [F,Π].\nProposition 6 For a total PC(ID) theory (F,Π) and a set M of literals over the set At(F∪Π) of atoms, the following conditions are equivalent:\n(a) M is a model of (F,Π), (b) M is a model of the SM(ASP) theory [F,Π], (c) M is a model of the SM(ASP) theory [Comp(ΠAt(Π))∪F,Π], (d) for some model M′ of the SM(ASP) theory [ED-Comp(ΠAt(Π))∪F,Π], M = M′ ∩\nAt(F∩Π).\nThe conditions (b), (c), (d) state that the logic PC(ID) restricted to total theories can be regarded as a fragment of the SM(ASP) formalism. The comments made in Remark 1 pertain also to generation of models in the logic PC(ID).\nWe now characterize models of SM(ASP) theories, and computations that lead to them, in terms of transition systems. Later we discuss implications this characterization has for ASP and PC(ID) solvers.\nWe define the transition graph SM(ASP)F,Π for an SM(ASP) theory [F,Π] as follows. The set of nodes of the graph SM(ASP)F,Π consists of the states relative to At(F ∪ Π). There are five transition rules that characterize the edges of SM(ASP)F,Π. The transition rules Unit Propagate, Decide, Fail, Backtrack of the graph DPF∪Πcl , and the transition rule\nUnfounded: M =⇒ M¬a if a ∈ U for a set U unfounded on M w.r.t. Πo.\nThe graph SM(ASP)F,Π can be used for deciding whether an SM(ASP) theory [F,Π] has a model.\nProposition 7 For any SM(ASP) theory [F,Π],\n(a) graph SM(ASP)F,Π is finite and acyclic, (b) for any terminal state M of SM(ASP)F,Π other than FailState, M is a model of [F,Π], (c) FailState is reachable from /0 in SM(ASP)F,Π if and only if [F,Π] has no models.\nProposition 7 shows that algorithms that correctly find a path in the graph SM(ASP)F,Π from /0 to a terminal node can be regarded as SM(ASP) solvers. It also provides a proof of correctness for every SM(ASP) solver that can be shown to work in this way.\nOne of the ways in which SM(ASP) encompasses ASP (specifically, Corollary 1(c)) is closely related to the way the answer-set solver SMODELS works. We recall that to represent SMODELS Lierler (2011) proposed a graph SMΠ. We note that the rule Unfounded above is closely related to the transition rule with the same name used in the definition of SMΠ (Lierler 2011). In fact, if Π = Πo then these rules are identical.\nLierler (2011) observed that SMODELS as it is implemented never follows certain edges in the graph SMΠ, and called such edges singular. Lierler (2011) denoted by SM−Π the graph obtained by removing from SMΠ all its singular edges and showed that SM − Π is still sufficient to serve as an abstract model of a class of ASP solvers including SMODELS. The concept of a singular edge extends literally to the case of the graph SM(ASP)F,Π. An edge M =⇒ M′ in the graph SM(ASP)F,Π is singular if:\n1. the only transition rule justifying this edge is Unfounded, and 2. some edge M =⇒ M′′ can be justified by a transition rule other than Unfounded or\nDecide.\nWe define SM(ASP)−F,Π as the graph obtained by removing all singular edges from SM(ASP)F,Π. Proposition 8 below can be seen as an extension of Proposition 4 in (Lierler 2011) to nontight programs.\nProposition 8 For every program Π, the graphs SM−Π and SM(ASP) − Comp(Π),Π are equal.\nIt follows that the graph SM(ASP)−Comp(Π),Π provides an abstract model of SMODELS. We recall though that Comp(Π) can be exponentially larger than the completion formula before clausification. Using ASP specific propagation rules such as Backchain True and All Rules Cancelled (Lierler 2011) allows SMODELS to avoid explicit representation of the clausified completion and infer all the necessary transitions directly on the basis of the program Π.\nA similar relationship, in terms of pseudocode representations of SMODELS and DPLL, is established in (Giunchiglia and Maratea 2005) for tight programs.\nThe answer-set solvers CMODELS, CLASP and the PC(ID) solver MINISAT(ID) cannot be described in terms of the graph SM(ASP) nor its subgraphs. These solvers implement such advanced features of SAT and SMT solvers as learning (forgetting), backjumping and restarts (Nieuwenhuis et al. (2006) give a good overview of these techniques). In the next section we extend the graph SM(ASP)F,Π with propagation rules that capture these techniques. In the subsequent section, we discus how this new graph models solvers CMODELS, CLASP, and MINISAT(ID). Then we provide insights into how they are related."
    }, {
      "heading" : "4 Backjumping and Learning for SM(ASP)",
      "text" : "Nieuwenhuis et al. (2006, Section 2.4) defined the DPLL System with Learning graph that can be used to describe most of the modern SAT solvers, which typically implement such sophisticated techniques as learning and backjumping. We demonstrate how to extend these findings to capture SM(ASP) framework with learning and backjumping.\nLet [F,Π] be an SM(ASP) theory and let G be a formula over At(F ∪Π). We say that [F,Π] entails G, written F,Π |= G, if for every model M of [F,Π], M |= G.\nFor an SM(ASP) theory [F,Π], an augmented state relative to F and Π is either a distinguished state FailState or a pair M||Γ where M is a record relative to the set of atoms occurring in F and Π, and Γ is a set of clauses over At(F∪Π) such that F,Πo |= Γ.\nWe now define a graph SML(ASP)F,Π for an SM(ASP) theory [F,Π]. Its nodes are the augmented states relative to F and Π. The rules Decide, Unfounded, and Fail of SM(ASP)F,Π are extended to SML(ASP)F,Π as follows: M||Γ =⇒ M′||Γ (M||Γ =⇒ FailState, respectively) is an edge in SML(ASP)F,Π justified by Decide or Unfounded (Fail, respectively) if and only if M =⇒ M′ (M =⇒ FailState) is an edge in SM(ASP)F,Π justified by Decide or Unfounded (Fail, respectively). The other transition rules of SML(ASP)F,Π follow:\nUnit Propagate Learn: M||Γ =⇒ Ml||Γ if { C∨ l ∈ F∪Πcl ∪Γ and C ⊆ M\nBackjump: Pl∆ Q||Γ =⇒ Pl′||Γ if { Pl∆Q is inconsistent and F,Πo |= l′∨P\nLearn: M||Γ =⇒ M||C,Γ if { every atom in C occurs in F and F,Πo |= C.\nWe refer to the transition rules Unit Propagate Learn, Unfounded, Backjump, Decide, and Fail of the graph SML(ASP)F,Π as basic. We say that a node in the graph is semi-terminal if no rule other than Learn is applicable to it. We omit the word “augmented” before “state” when this is clear from a context.\nThe graph SML(ASP)F,Π can be used for deciding whether an SM(ASP) theory [F,Π] has a model.\nProposition 9 For any SM(ASP) theory [F,Π],\n(a) every path in SML(ASP)F,Π contains only finitely many edges justified by basic transition rules, (b) for any semi-terminal state M||Γ of SML(ASP)F,Π reachable from /0|| /0, M is a model of [F,Π], (c) FailState is reachable from /0|| /0 in SML(ASP)F,Π if and only if [F,Π] has no models.\nOn the one hand, Proposition 9 (a) asserts that if we construct a path from /0|| /0 so that basic transition rules periodically appear in it then some semi-terminal state is eventually reached. On the other hand, parts (b) and (c) of Proposition 9 assert that as soon as a semiterminal state is reached the problem of deciding whether [F,Π] has a model is solved. In other words, Proposition 9 shows that the graph SML(ASP)F,Π gives rise to a class of correct algorithms for computing models of an SM(ASP) theory [F,Π]. It gives a proof\nof correctness to every SM(ASP) solver in this class and a proof of termination under the assumption that basic transition rules periodically appear in a path constructed from /0|| /0.\nNieuwenhuis et al. (2006) proposed the transition rules to model such techniques as forgetting and restarts. The graph SML(ASP)F,Π can easily be extended with such rules.\n5 Abstract CMODELS, CLASP and MINISAT(ID)\nWe can view a path in the graph SML(ASP)F,Π as a description of a process of search for a model of an SM(ASP) theory [F,Π] by applying transition rules. Therefore, we can characterize the algorithm of a solver that utilizes the transition rules of SML(ASP)F,Π by describing a strategy for choosing a path in this graph. A strategy can be based, in particular, on assigning priorities to transition rules of SML(ASP)F,Π, so that a solver never applies a rule in a state if a rule with higher priority is applicable to the same state.\nWe use this approach to describe and compare the algorithms implemented in the solvers CMODELS, CLASP and MINISAT(ID). We stress that we talk here about characterizing and comparing algorithms and not their specific implementations in the solvers. We refer to these algorithms as abstract CMODELS, CLASP and MINISAT(ID), respectively. Furthermore, we only discuss the abstract MINISAT(ID) for the case of the total PC(ID) theories whereas the MINISAT(ID) system implements additional totality check propagation rule to deal with the non-total theories. Given a program Π, abstract CMODELS and abstract CLASP construct first ED-Comp(Π). Afterwards, they search the graph SML(ASP)ED-Comp(Π),Π for a path to a semi-terminal state. In other words, both algorithms, while in a node of the graph SML(ASP)ED-Comp(Π),Π, progress by selecting one of the outgoing edges. By Proposition 9 and Corollary 1, each algorithm is indeed a method to compute answer sets of programs.\nHowever, abstract CMODELS selects edges according to the priorities on the transition rules of the graph that are set as follows:\nBackjump,Fail ≫ Unit Propagate ≫ Decide ≫ Unfounded,\nwhile abstract CLASP uses a different prioritization:\nBackjump,Fail ≫ Unit Propagate ≫ Unfounded≫ Decide.\nThe difference between the algorithms boils down to when the rule Unfounded is used. We now describe the algorithm behind the PC(ID) solver MINISAT(ID) (Mariën et al. 2008) for total PC(ID) theories — the abstract MINISAT(ID). Speaking precisely, MINISAT(ID) assumes that the program Π of the input PC(ID) theory (F,Π) is in the definitional normal form (Mariën 2009). Therefore, in practice MINISAT(ID) is always used with a simple preprocessor that converts programs into the definitional normal form. We will assume here that this preprocessor is a part of MINISAT(ID). Under this assumption, given a PC(ID) theory (F,Π), MINISAT(ID) can be described as constructing the completion ED-Comp(Πo) (the new atoms are introduced by the preprocessor when it converts Π into the definitional normal form, the completion part is performed by the MINISAT(ID) proper), and then uses the transitions of the graph SML(ASP)ED-Comp(Πo)∪F,Πo to search for a path to a semi-terminal state. In other words, the graph SML(ASP)ED-Comp(Πo)∪F,Πo represents the abstract MINISAT(ID). The strategy used by the algorithm follows the prioritization:\nBackjump,Fail ≫ Unit Propagate ≫ Unfounded≫ Decide.\nBy Propositions 4 and 6, the algorithm indeed computes models of total PC(ID) theories. Systems CMODELS, CLASP, and MINISAT(ID) implement conflict-driven backjumping and learning. They apply the transition rule Learn only when in a non-semi-terminal state reached by an application of Backjump. Thus, the rule Learn does not differentiate the algorithms and so we have not taken it into account when describing these algorithms."
    }, {
      "heading" : "6 PC(ID) Theories as Logic Programs with Constraints",
      "text" : "For a clause C = ¬a1 ∨ . . .∨¬al ∨al+1 ∨ . . .∨am we write Cr to denote the corresponding rule constraint\n← a1, . . . ,al,not al+1, . . . ,not am.\nFor a set F of clauses, we define Fr = {Cr | C ∈ F}. Finally, for a PC(ID) theory (F,Π) we define a logic program π(F,Π) by setting\nπ(F,Π) = Πo ∪Fr.\nThe representation of a PC(ID) theory (F,Π) as π(F,Π) is similar to the translation of FO(ID) theories into logic programs with variables given by Mariën et al. (2004). The difference is in the way atoms are “opened.” We do it by means of rules of the form a ← not not a, while Mariën et al. use pairs of rules a ← not a∗ and a∗ ← not a.\nThere is a close relation between models of a PC(ID) theory (F,Π) and answer sets of a program π(F,Π).\nProposition 10 For a total PC(ID) theory (F,Π) and a consistent and complete (over At(F∪Π)) set M of literals, M is a model of (F,Π) if and only if M+ is an answer set of π(F,Π).\nA choice rule construct {a} (Niemelä and Simons 2000) of the LPARSE6 and GRINGO7 languages can be seen as an abbreviation for a rule a ← not not a (Ferraris and Lifschitz 2005). Thus, in view of Proposition 10, any answer set solver implementing language of LPARSE or GRINGO is also a PC(ID) solver (an input total PC(ID) theory (F,Π) needs to be translated into π(F,Π)).\nThe reduction implied by Proposition 10 by itself does not show how to relate particular solvers. However, we recall that abstract MINISAT(ID) is captured by the graph SML(ASP)ED-Comp(Πo)∪F,Πo . Moreover, we have the following property.\nProposition 11 For a PC(ID) theory (F,Π), we have\nSML(ASP)ED-Comp(π(F,Π)),π(F,Π) = SML(ASP)ED-Comp(Πo)∪F,Πo .\nThe graph SML(ASP)ED-Comp(π(F,Π)),π(F,Π) captures the way CLASP works on the program π(F,Π). In addition, the MINISAT(ID) and CLASP algorithms use the same prioritization. Thus, Proposition 11 implies that the abstract CLASP used as a PC(ID) solver coincides with the abstract MINISAT(ID).\n6 http://www.tcs.hut.fi/Software/smodels/ . 7 http://potassco.sourceforge.net/ ."
    }, {
      "heading" : "7 Related Work and Discussion",
      "text" : "Lierler (2011) introduced the graphs SML and GTL that extended the graphs SM and GT (Lierler 2011), respectively, with transition rules Backjump and Learn. The graph SML was used to characterize the computation of such answer set solvers implementing learning as SMODELScc\n8 (Ward and Schlipf 2004) and SUP9 (Lierler 2011) whereas the graph GTL was used to characterize CMODELS. These graphs are strongly related to our graph SML(ASP) but they are not appropriate for describing the computation behind answer set solver CLASP or PC(ID) solver MINISAT(ID). The graph SML reflects only propagation steps based on a program whereas CLASP and MINISAT(ID) proceed by considering both the program and a propositional theory. The graph GTL, on the other hand, does not seem to provide a way to imitate the behavior of the Unfounded rule in the SML(ASP) graph.\nGiunchiglia and Maratea (2005) studied the relation between the answer set solver SMODELS and the DPLL procedure for the case of tight programs by means of pseudocode analysis. Giunchiglia et al (2008) continued this work by comparing answer set solvers SMODELS, DLV10 (Eiter et al. 1997), and CMODELS via pseudocode. In this paper we use a different approach to relate solvers that was proposed by Lierler (2011). That is, we use graphs to represent the algorithms implemented by solvers, and study the structure of these graphs to find how the corresponding solvers are related. We use this method to state the relation between the answer set solvers CMODELS, CLASP, and the PC(ID) solver MINISAT(ID) designed for different knowledge representation formalisms.\nGebser and Schaub (2006) introduced a deductive system for describing inferences involved in computing answer sets by tableaux methods. The abstract framework presented in this paper can be viewed as a deductive system also, but a very different one. For instance, we describe backtracking and backjumping by inference rule, while the GebserSchaub system does not. Also the Gebser-Schaub system does not take learning into account. Accordingly, the derivations considered in this paper describe a search process, while derivations in the Gebser-Schaub system do not. Further, the abstract framework discussed here does not have any inference rule similar to Cut; this is why its derivations are paths rather than trees.\nMariën (2009) (Section 5.7) described a MINISAT(ID) transition system to model a computation behind the PC(ID) solver MINISAT(ID). We recall that we modeled the abstract MINISAT(ID) with the graph SML(ASP). The graphs SML(ASP) and MINISAT(ID) are defined using different sets of nodes and transition rules. For instance, SML(ASP) allows states containing inconsistent sets of literals whereas the MINISAT(ID) graph considers consistent states only. Due to this difference the MINISAT(ID) graph requires multiple versions of “backjump” and “fail” transition rules.\nWe used transition systems to characterize algorithms for computing answer sets of logic programs and models of PC(ID) theories. These transition systems are also suitable for formal comparison of the strength or power of reasoning methods given rules that specify them. An approach to do so was proposed by Mariën (2009) (Section 5.7), who introduced\n8 http://www.nku.edu/∼wardj1/Research/smodels cc.html . 9 http://www.cs.utexas.edu/users/tag/sup .\n10 http://www.dbai.tuwien.ac.at/proj/dlv/ .\nthe concept of decide-efficiency for such analysis. We outline below how standard concepts of proof complexity (Cook et al. 1979) can be adapted to the setting of transition systems.\nLet A be an infinite set of atoms. We define a node over A to be a symbol FailState, or a finite sequence of literals over A with annotations. For a propositional formalism F over A , a proof procedure PF consists of graphs GT , where T ranges over all theories in F , such that for every theory T (i) GT is composed of nodes over A and (ii) T is unsatisfiable if and only if there is a path p in GT from the empty (start) node to the FailState node. We call each such path p a proof. We say that a proof system S is based on a proof procedure PF if (i) S⊆F ×R, where R denotes the set of all finite sequences of nodes over A , and (ii) S(T,p) holds if and only if p is a proof in the graph GT in PF . Predicate S is indeed a proof system in the sense of Cook (1979) because (i) S is polynomial-time computable, and (ii) T is unsatisfiable if and only if there exists a proof p such that S(T,p) holds.\nIn this sense, each of the graphs (transition systems) we introduced in this paper can be regarded as a proof procedure for SM(ASP) (for those involving the rule Learn, under additional assumptions to ensure the rule can be efficiently implemented). Thus, transition systems determine proof systems. Consequently, they can be compared, as well as solvers that they capture, in terms of the complexity of the corresponding proof systems."
    }, {
      "heading" : "8 Conclusions",
      "text" : "In the paper, we proposed a formalism SM(ASP) that can be regarded as a common generalization of (clausal) propositional logic, ASP, and the logic PC(ID). The formalism offers an elegant satisfiability modulo theories perspective on the latter two. We present several characterizations of these formalisms in terms of SM(ASP) theories that differ in the explicitly identified “satisfiability” component. Next, we proposed transition systems for SM(ASP) to provide abstract models of SM(ASP) model generators. The transition systems offer a clear and uniform framework for describing model generation algorithms in SM(ASP). As SM(ASP) subsumes several propositional formalisms, such a uniform approach provides a general proof of correctness and termination that applies to a broad class of model generators designed for these formalisms. It also allows us to describe in precise mathematical terms relations between algorithms designed for reasoning with different logics such as propositional logic, logic programming under answer-set semantics and the logic PC(ID), the latter two studied in detail in the paper. For instance, our results imply that at an abstract level of transition systems, CLASP and MINISAT(ID) are essentially identical. Finally, we note that this work gives the first description of CLASP in the abstract framework rather than in pseudocode. Such high level view on state-of-the-art solvers in different, yet, related propositional formalisms will further their understanding, and help port advances in solver technology from one area to another."
    }, {
      "heading" : "Acknowledgments",
      "text" : "We are grateful to Marc Denecker and Vladimir Lifschitz for useful discussions. We are equally grateful to the reviewers who helped eliminate minor technical problems and improve the presentation. Yuliya Lierler was supported by a CRA/NSF 2010 Computing Innovation Fellowship. Miroslaw Truszczynski was supported by the NSF grant IIS-0913459."
    }, {
      "heading" : "Appendix: Proofs",
      "text" : ""
    }, {
      "heading" : "8.1 Proof of Proposition 2",
      "text" : "We start with some additional notation and several lemmas. Let N be a set of literals. By |N| we denote a set of atoms occurring in N. For instance |{a,¬b, c}| = {a, b, c}. Further, by ch(N) we denote a set of rules of the form a ← not not a, where a ∈ |N|.\nBy a program literal we mean expressions a, not a and not not a, where a is an atom. For a program literal l, we set s(l) = a, if l = a or l = not not a, and s(l) = ¬a, if l = not a. For a set B of body literals, we define s(B) = {s(l) | l ∈ B}. If Π is a program and N is a set of literals, by Π(N) we denote the program obtained from Π by removing each rule whose body contains a program literal l such that s(l) ∈ N, and deleting from the bodies of all rules in Π every program literal l such that s(l) ∈ N.\nLemma 1 Let Π be a logic program and N a consistent set of literals such that |N| ∩Head(Π) = /0. For every consistent set M of literals such that |N| ∩ |M|= /0,\n{a | a ← B ∈ Π∪ ch(N) and s(B)⊆ M∪N} \\N = {a | a ← B ∈ Π(N) and s(B)⊆ N}·"
    }, {
      "heading" : "Proof",
      "text" : "Let c ∈ {a | a ← B ∈ Π ∪ ch(N) and s(B) ⊆ M ∪ N} \\N. Let c ∈ |N|. The only rule in Π∪ch(N) with c as the head is c← not not c. It follows that c∈M∪N. Since |N|∩|M|= /0, c ∈ N, a contradiction. Thus, c /∈ |N| and there is a rule c ← B ∈ Π such that s(B)⊆ M∪N. Let B′ be what remains when we remove from B all expressions l such that s(l) ∈ N. The rule c ← B′ ∈ Π(N) and s(B′)⊆ M. It follows that c ∈ {a | a ← B ∈ Π(N) and s(B′)⊆ M}.\nConversely, let c ∈ {a | a ← B ∈ Π(N) and s(B) ⊆ M}. It follows that c /∈ |N| and so, c /∈ N. Moreover, there is a rule c ← B′ ∈ Π(N) such that s(B′) ⊆ M. By the definition of Π(N), there is a rule c ← B ∈ Π such that s(B) ⊆ M ∪ N. Thus, c ∈ {a | a ← B ∈ Π∪ ch(N) and s(B)⊆ M∪N} \\N.\nLet N be a set of literals. We define N− = {a | ¬a ∈ N}.\nLemma 2 For a logic program Π, a consistent set N of literals such that |N| ∩Head(Π) = /0, and a consistent set M of literals such that |M| ∩ |N| = /0, GUS(M ∪ N,Π ∪ ch(N)) \\N− = GUS(M,Π(N))."
    }, {
      "heading" : "Proof",
      "text" : "We note that since the sets M and N are consistent and |M| ∩ |N|= /0, M∪N is consistent. Moreover, we note that to prove the claim it suffices to show that U is an unfounded set on M∪N w.r.t. Π∪ ch(N) if and only if U \\N− is an unfounded set on M w.r.t. Π(N). (⇒) Let a ∈ U \\N− and let D ∈ Bodies(Π(N),a). It follows that a /∈ |N|. It also follows that there is a rule a ← B ∈ Π such that for every program literal l ∈ B, s(l) /∈ N, and D is obtained by removing from B every program literal l such that s(l) ∈ N.\nSince U is an unfounded set on M∪N w.r.t. Π∪ch(N), it follows that s(B)∩(M∪N) 6= /0 or U∩B+ 6= /0. In the first case, since for every program literal l ∈ B, s(l) /∈ N, s(B)∩M 6= /0\nfollows. Moreover, D differs from B only in program literals l such that s(l) ∈ N. Since |M|∩|N|= /0, we have s(D)∩M 6= /0. Thus, let us consider the second case. Let a∈U∩B+. Since a /∈ |N|, a /∈ N−. For the same reason, a /∈ N. Thus, a ∈ U \\N− and a ∈ D+. That is, (U \\N−)∩D+ 6= /0. This proves that U \\N− is an unfounded set on M w.r.t. Π(N). (⇐) Let U′ be any unfounded set on M w.r.t. Π(N). By the definition of an unfounded set, U′ contains no atoms from |N| since they do not appear in Π(N). We show that U′∪N− is an unfounded set on M∪N w.r.t. Π∪ ch(N). Let a be any atom in U′∪N−. Case 1. a ∈ N−. It follows that a occurs in the head of only one rule in Π∪ ch(N) namely, a ← not not a. Since ¬a ∈ N, s(not not a) ∈ N and, consequently, s(not not a) ∈ M∪N.\nCase 2. a ∈ U′. It follows that a 6∈ N and so, Bodies(Π∪ ch(N),a) = Bodies(Π,a). To complete the argument it suffices to show that for every body B ∈ Bodies(Π,a), s(B)∩ (M∪N) 6= /0 or (U′∪N−)∩B+ 6= /0 holds.\nLet B be any body in Bodies(Π,a). It follows that Π contains the rule a ← B. If there is a program literal l in B such that s(l) ∈ N, then the first condition above holds. Thus, let us assume that for every program literal l∈B, s(l) /∈N. Let D be obtained from B by removing from it every program literal l such that s(l) ∈ N. It follows that a ← D ∈ Π(N). Since U′ is unfounded on M w.r.t. Π(N), there is l in D such that s(l) ∈ M or U′∩D+ 6= /0. In the first case, we have s(B)∩ (M ∪N) 6= /0. In the second case, we have (U′∪N−)∩B+ 6= /0.\nBy W iΠ(M) we will denote the i-fold application of the WΠ operator on the set M of literals. By convention, we assume that W0Π(M) = M.\nLemma 3 For a normal logic program Π and a consistent set N of literals such that |N|∩Head(Π)= /0,\nW iΠ∪ch(N)(N) = W i Π(N)( /0)∪N·"
    }, {
      "heading" : "Proof",
      "text" : "We proceed by induction on i. For i = 0, since N is consistent, we have\nW0Π∪ch(N)(N) = N = /0∪N = W 0 Π(N)( /0)∪N·\nLet us assume that the identity holds for some i ≥ 0. We show that it holds for i+ 1. Let M denote W iΠ(N)( /0). We recall that W fix Π(N)( /0) is the well-founded model of the normal program Π(N). Consequently, the sets WfixΠ(N)( /0) and W j Π(N)( /0), j ≥ 0, are consistent (Van Gelder et al. 1991). In particular, M is consistent. Moreover, since |N|∩ |WfixΠ(N)( /0)|= /0, the sets W jΠ(N)( /0)∪N, j ≥ 0, are consistent, too. Thus, we have\nW i+1Π(N)( /0)∪N = N ∪WΠ(N)(W i Π(N)( /0)) = N ∪WΠ(N)(M)\n= N ∪M∪{a | a ← B ∈ Π(N) and B ⊆ M}∪GUS ( M,Π(N) ) ·\nSince |N|∩ |WfixΠ(N)( /0)|= /0, |M|∩ |N|= /0. We also observed that M is consistent. By Lemmas 1 and 2 and the fact that {¬a | a ∈ N−} ⊆ N, we have\nW i+1Π(N)( /0)∪N = N ∪ (M∪{a | a ← B ∈ Π∪ ch(N) and B ⊆ M∪N} \\N)\n∪ GUS ( M∪N,Π∪ ch(N) ) \\N−\n= N ∪ (M∪{a | a ← B ∈ Π∪ ch(N) and B ⊆ M∪N} \\N) ∪ (GUS ( M∪N,Π∪ ch(N) ) \\ {¬a | a ∈ N−})\n= N ∪M∪{a | a ← B ∈ Π∪ ch(N) and B ⊆ M∪N} ∪ GUS ( M∪N,Π∪ ch(N) ) ·\nSince this last set is consistent, it is equal to WΠ∪ch(N)(M∪N) = WΠ∪ch(N)(W i Π(N)( /0)∪N). Applying the induction hypothesis, the inductive step follows.\nProposition 2 For a PC(ID) theory (F,Π) such that Π is a normal program, M is a model of (F,Π) if and only if M is a model of (F,Π) according to the definition in (Denecker 2000)."
    }, {
      "heading" : "Proof",
      "text" : "Let (F,Π) be a PC(ID) theory. In (Denecker 2000), the authors state that a consistent and complete (over At(F∪Π)) set M of literals is a model of (F,Π) if\n(i) M is a model of F, and (ii) M = Wfix\nΠ(MOΠ ) ( /0)∪MO\nΠ .\nTo prove the assertion it is sufficient to show that for any model M of F such that |M|= At(Π∪F), M = WfixΠo(M OΠ ) if and only if M = Wfix Π(MOΠ ) ( /0)∪MO Π . Let N = MO Π . The definitions of OΠ and Πo directly imply that |N|∩Head(Π) = /0 and that Πo = Π∪ch(N). Thus, the property follows from Lemma 3."
    }, {
      "heading" : "8.2 Proofs of Results from Section 3",
      "text" : "Proposition 3 For a logic program Π and a set X of atoms,\n(a) X ⊆ Head(Π) and X is an input answer set of Π if and only if X is an answer set of Π. (b) if (X \\Head(Π))∩ At(Π) = /0, then X is an input answer set of Π if and only if X∩Head(Π) is an answer set of Π."
    }, {
      "heading" : "Proof",
      "text" : "The proof of part (a) is straightforward and follows directly from the definition of an input answer set. To prove (b), let us assume first that X is an input answer set of Π. By the definition, X is an answer set of Π∪(X\\Head(Π)). Thus, X is the least model of the reduct [Π∪(X\\Head(Π))]X. Clearly, we have [Π∪(X\\Head(Π))]X =ΠX∪(X\\Head(Π)). Since (X \\ Head(Π))∩ At(Π) = /0, ΠX = ΠX∩Head(Π). It follows that X is the least model of ΠX∩Head(Π)∪ (X \\Head(Π)). Using again the assumption (X \\Head(Π))∩At(Π) = /0, one can show that X ∩Head(Π) is the least model of ΠX∩Head(Π). Thus, X ∩Head(Π) is an answer set of Π\nThe proof in the other direction is similar. Let us assume that X ∩Head(Π) is an answer set of Π. It follows that X ∩Head(Π) is the least model of ΠX∩Head(Π). Since (X \\ Head(Π))∩At(Π) = /0, X is the least model of ΠX∩Head(Π) ∪ (X \\Head(Π)). Moreover, since ΠX∩Head(Π)=ΠX , X is the least model of ΠX∪(X\\Head(Π))= [Π∪(X\\Head(Π))]X. Thus, X is an input answer set of Π.\nProposition 4 A set of literals M is a model of an SM(ASP) theory [F,Π] if and only if M is a model of an SM(ASP) theory [F,Πo]."
    }, {
      "heading" : "Proof",
      "text" : "Proceeding in each direction, we can assume that M is a complete (over At(F ∪Π)) and consistent set of literals such that |M| = |At(F∪Π)|. It follows that to prove the assertion it suffices to show that for every such set M, M+ is an input answer set of Π if and only if M+ is an input answer set of Πo.\nWe note that Πo =Π∪{a← not not a | a∈At(F∪Π)\\Head(Π)}. Thus, M+ ⊆Head(Π) and so, by Proposition 3, M+ is an input answer set of Πo if and only if M+ is an answer set of Πo. It follows that to complete the argument, it suffices to show that under our assumptions about M, M+ is an answer set of Π∪ (M+ \\Head(Π)) if and only if M+ is an answer set of Πo. This statement is evident once we observe that the reducts of Π∪ (M+ \\Head(Π)) and Πo with respect to M+ are equal (they are both equal to ΠM+ ∪ (M+ \\Head(Π))).\nProposition 5 For any SM(ASP) theory [F,Π] that is Π-safe, a set X of atoms is an answer set of Π if and only if X = M+∩At(Π), for some model M of [F,Π]."
    }, {
      "heading" : "Proof",
      "text" : "(⇒) Let X be an answer set of Π. Since [F,Π] is Π-safe, there is a model M of F such that X = M+ ∩Head(Π). Moreover, again by the Π-safety of [F,Π], {¬a | a ∈ OΠ} ⊆ M. It follows that X = M+∩At(Π) and (M+ \\Head(Π))∩At(Π) = /0. By Proposition 3(b), M+ is an input answer set of Π.\n(⇐) Let X = M+ ∩At(Π), where M is a model of [F,Π]. It follows that M is a model of F. By the Π-safety of [F,Π], we have {¬a | a ∈ OΠ} ⊆ M. As above, it follows that (M+ \\ Head(Π))∩At(Π) = /0. Since M+ is an input answer set of Π, Proposition 3(b) implies that M+∩Head(Π) is an answer set of Π. From the identity (M+ \\Head(Π))∩At(Π) = /0, it follows that M+∩Head(Π) = M+∩At(Π). Thus, X is an answer set of Π.\nCorollary 1 follows immediately from Proposition 5. We omit its proof and move on to Proposition 6. We start by proving two simple auxiliary results.\nLemma 4 For a logic program Π, and a consistent and complete set M of literals over At(Π), if M = WΠ(M), then M is a model of Π."
    }, {
      "heading" : "Proof",
      "text" : "It is sufficient to show that for every rule a ← B ∈ Π if s(B)⊆ M then a ∈ M. This follows from the definition of the operator WΠ and the fact that M = WΠ(M).\nLemma 5 For a logic program Π and a consistent and complete set M of literals over At(Π), if M = WΠ(M) then M+ does not have any non-empty subset that is unfounded on M with respect to Π."
    }, {
      "heading" : "Proof",
      "text" : "Let us assume that U is a non-empty subset of M+ that is unfounded on M with respect to Π. It follows that U ⊆ M. Since U 6= /0, M is inconsistent, a contradiction.\nNext, we recall the following generalization of a well-known characterization of answer sets in terms of unfounded sets due to Leone et al. (1997). The generalization extended the characterization to the case of programs with double negation.\nTheorem on Unfounded Sets(Lee 2005) For a set M of literals, M+ is an answer set of a program Π if and only if M is a model of Π and M+ does not have any non-empty subset that is unfounded on M with respect to Π.\nProposition 6 For a total PC(ID) theory (F,Π) and a set M of literals over the set At(F∪ Π) of atoms, the following conditions are equivalent:\n(a) M is a model of (F,Π) (b) M is a model of an SM(ASP) theory [F,Π] (c) M is a model of an SM(ASP) theory [Comp(ΠAt(Π))∪F,Π] (d) for some model M′ of an SM(ASP) theory [ED-Comp(ΠAt(Π))∪F,Π], M = M′ ∩\nAt(F∩Π)."
    }, {
      "heading" : "Proof",
      "text" : "(a)⇒(b) It is sufficient to show that M+ is an input answer set of Π, that is, an answer set of Π∪ (M+ \\Head(Π)). Since M is a model of the PC(ID) theory (F,Π), M is a complete and consistent set of literals over At(F ∪Π) and M = WfixΠo(M\nOΠ). It follows that M = WΠo(M). Since At(Πo) = At(F ∪Π), by Lemma 4 it follows that M is a model of Πo. Consequently, M is a model of Π∪ (M+ \\Head(Π)). By Theorem on Unfounded Sets, it is sufficient to show that M+ does not have any non-empty subset that is unfounded on M with respect to Π∪ (M+ \\Head(Π)). For a contradiction, let us assume that there is a nonempty set U ⊆ M+ that is unfounded on M with respect to Π∪ (M+ \\Head(Π)). Let a ∈ U. It follows that a ∈ M+. If a /∈ Head(Π), then a is a fact in Π∪ (M+ \\Head(Π)). This is a contradiction with the unfoundedness of U. Thus, a ∈ Head(Π). By the definition of Πo, Bodies(Πo,a) = Bodies(Π,a). It follows that for every B ∈ Bodies(Πo,a), s(B)∩M 6= /0 or U ∩B+ 6= /0. This shows that U is unfounded on M with respect to Πo. This contradicts Lemma 5.\n(a)⇐(b) Since M is a model of [F,Π], M is a complete and consistent set of literals over At(F ∪Π). By the assumption, M+ is an answer set of Π′ = Π∪ (M+ \\Head(Π)). Since Π′ and Π have the same reducts with respect to M+, M+ is an answer set of Πo.\nSince MO Π ⊆ M, WΠo(MO Π )⊆ WoΠ(M). Let l ∈ W o Π(M). If l = a, where a is an atom in Πo, then there is a rule a ← B in Πo such that s(B)⊆ M. Since M is a model of Πo (it is so since M+ is an answer set of Πo), a ∈ M. If l = ¬a, then a ∈ GUS(M,Πo).\nLet us assume that a ∈ M+ and let us define U = M+∩GUS(M,Πo). Clearly, U 6= /0 and U ⊆ GUS(M,Πo). Let b ∈ U and let B ∈ Bodies(Πo,b). Let us assume that s(B)M = /0. By the completeness of M, s(B) ⊆ M. Since b ∈ GUS(M,Πo), there is an element GUS(M,Πo)∩B+ 6= /0. Let us assume that c ∈ GUS(M,Πo)∩B+. It follows that c ∈ M+ and so, c ∈ U. Thus, U is a nonempty set contained in M+ and unfounded on M with respect to Πo. By Theorem on Unfounded Sets, this contradicts the fact that M+ is an answer\nset of Πo. it follows that a /∈ M+. By the completeness of M, ¬a ∈ M. Thus, WoΠ(M) ⊆ M and, consequently, WΠo(MO Π ) ⊆ M. By iterating, we obtain that WfixΠo(M OΠ ) ⊆ M. Since (F,Π) is total, WfixΠo(M OΠ ) = M. Thus, (a) follows. (b)⇔(c) It is sufficient to show that M is a model of F if and only if M is a model of Comp(Πo)∪ F given that M+ is an input answer set of Π or, equivalently, that M+ is an answer set of Π∪M+ \\Head(Π). The “if” part is obvious. For the “only if” part, we proceed as follows. First, reasoning as above we observe that M+ is an answer set of Πo. Thus, M is the model of the completion Comp(Πo) and so, M is a model of Comp(Πo)∪F, which we needed to show.\n(b)⇔(d) The equivalence follows from the fact that ED-Comp(ΠAt(Π)) is a conservative extension of Comp(ΠAt(Π)).\nWe now proceed to the proof of Proposition 7. We first recall a result proved by Lierler (2011) (using a slightly modified notation)..\nLemma 6 (Lemma 4 (Lierler 2011)) For any unfounded set U on a consistent set M of literals with respect to a program Π, and any assignment N, if N |= M and N ∩U 6= /0, then N+ is not an answer set for Π.\nIt is well known that for any consistent and complete set M of literals over At(Π) (assignment on At(Π)), if M+ is an answer set for a program Π, then M is a model of Πcl. The property has a counterpart for SM(ASP) theories. The proof is straightforward and we omit it.\nLemma 7 For every SM(ASP) theory [F,Π], if M is a model of [F,Π], then M is a model of F∪Πcl.\nNext, we prove the following auxiliary result.\nLemma 8 For every SM(ASP) theory [F,Π], every state M other than FailState reachable from /0 in SM(ASP)F,Π, and every model N of [F,Π], if N satisfies all decision literals in M, then N satisfies M."
    }, {
      "heading" : "Proof",
      "text" : "We proceed by induction on n = |M|. The property trivially holds for n = 0. Let us assume that the property holds for all states with k′ ≤ k elements that are reachable from /0. For the inductive step, let us consider a state M = l1 . . . lk such that every model N of [F,Π] that satisfies all decision literals lj with j ≤ j satisfies M. We need to prove that applying any transition rule of SM(ASP)F,Π in the state l1 . . . lk, leads to a state M\n′ = l1 . . . lk, lk+1 such that if N is a model of [F,Π] and N satisfies every decision literal lj with j ≤ k+ 1, then N satisfies M′.\nUnit Propagate: By the definition of Unit Propagate, there is a clause C∨ l ∈ F∪Πcl such that C ⊆ M and M′ = Ml. Let N be any model of [F,Π] that satisfies all decision literals lj ∈ Ml. It follows that N satisfies all decision literals in M. By the induction hypothesis, N |= M. Since N |= C∨ l and C ⊆ M, Lemma 7 implies that N |= l.\nDecide: In this case, M′ = Mld (l is a decision literal). If N is a model of the theory [F,Π]\nand it satisfies all decision literals in M′, then N satisfies l (by the assumption) and N satisfies every decision literal in M. By the induction hypothesis, the latter implies that N |= M. Thus, N |= M′.\nFail: If this rule is applicable, M has no decision literals and is inconsistent. If [F,Π] has a model N, then by the induction hypothesis, N |= M, a contradiction. It follows that [F,Π] has no models and the assertion is trivially true.\nBacktrack: If this rule is applied, it follows that M has the form Pldi Q, where Q contains no decision literals, and M′ = Pli. Let N be a model of [F,Π] such that N satisfies all decision literals in Pli. It follows that N satisfies all decision literals in P and so, by the induction hypothesis, N |= P. Let us assume that N |=li. Then, N satisfies all decision literals in M and, consequently, N |= M, a contradiction as M is inconsistent. Thus, N |= li and so, N |= M′.\nUnfounded: If M′ is obtained from M by an application of the Unfounded rule, then M is consistent and M′ = M¬a, for some a ∈ U, where U is an unfounded set on M with respect to Πo. Let N be any model N of [F,Π] such that N satisfies all decision literals in M′. It follows that N satisfies all decision literals in M and so, by the inductive hypothesis, N |= M. By the definition of a model of [F,Π], N+ is an input answer set of Π. Consequently, N+ is an answer set of Π∪ (N+ \\Head(Π)). Arguing as as before, we obtain that N+ is an answer set of Πo. By Lemma 6, a /∈ N+, that is, N |= ¬a.\nProposition 7 For any SM(ASP) theory [F,Π],\n(a) graph SM(ASP)F,Π is finite and acyclic, (b) for any terminal state M of SM(ASP)F,Π other than FailState, M is a model of [F,Π] (c) FailState is reachable from /0 in SM(ASP)F,Π if and only if [F,Π] has no models."
    }, {
      "heading" : "Proof",
      "text" : "Parts (a) and (c) are proved as in the proof of Proposition 1 (Lierler 2011, Proposition 1) using Lemma 8. (b) Let M be a terminal state. It follows that none of the rules are applicable. From the fact that Decide is not applicable, we derive that M assigns all literals. Since neither Backtrack nor Fail are applicable, M is consistent. Since Unit Propagate is not applicable, it follows that for every clause C∨ a ∈ F∪Πcl if C ⊆ M then a ∈ M. Consequently, if M |= C then M |= a. Thus, M is a model of F∪Πcl. Consequently, M is a model of F.\nNext, we show that M+ is an input answer set of Π, that is, that M+ is an answer set of Π∪ (M+ \\Head(Π)). To this end, it is sufficient to show that M+ is an answer set of Πo (we again exploit here the fact that M+ is an answer set of Π∪(M+ \\Head(Π)) if and only if M+ is an answer set of Πo). Since M is a model of F∪Πcl, M is a model of Πo.\nLet us assume that M+ is not an answer set of Πo. By Theorem on Unfounded Sets, it follows that there is a non-empty unfounded set U on M with respect to Πo such that U ⊆ M+. Then Unfounded can be applied for some a ∈ U. If ¬a /∈ M, M is not terminal, a contradiction. Thus, ¬a ∈ M. Since M is consistent, a /∈ M+, a contradiction (as U ⊆ M+). It follows that M+ is an answer set of Πo, as required.\nFinally, we sketch a proof for Proposition 8 Proposition 8 For every program Π, the graphs SM−Π and SM(ASP) − Comp(Π),Π are equal."
    }, {
      "heading" : "Proof",
      "text" : "Sketch: First we show that the states of the graphs SM−Π and SM(ASP) − Comp(Π),Π coincide. In view of Proposition 3 stated and proved by Lierler (Lierler 2011) it is sufficient to show that there is a non-singular edge M =⇒ M′ in SMΠ justified by the transition Unfounded (defined for SM) if and only if there is a non-singular edge M =⇒ M′ in SM(ASP)Comp(Π),Π justified by Unfounded (defined for SM(ASP)). We conclude by proving the last statement."
    }, {
      "heading" : "8.3 Proof of Proposition 9",
      "text" : "We first extend Lemma 8 to the “learning” version of the graph SM(ASP)F,Π.\nLemma 9 For every SM(ASP) theory [F,Π], every state M||Γ reachable from /0|| /0 in SM(ASP)F,Π, and every model N of [F,Π], if N satisfies all decision literals in M, then N satisfies M."
    }, {
      "heading" : "Proof",
      "text" : "The proof is by induction on n = |M| and proceeds similarly as that of Lemma 8. In particular, the property trivially holds for n = 0. Let us assume that the property holds for all states M||Γ, where |M| ≤ k, that are reachable from /0|| /0. For the inductive step, let us consider a state M||Γ, with M = l1 . . . lk, such that every model N of [F,Π] that satisfies all decision literals lj with j ≤ k satisfies M. We need to prove that applying any transition rule of SM(ASP)F,Π in the state M||Γ, leads to a state M′||Γ′, where M′ = Mlk+1, such that if N is a model of [F,Π] and N satisfies every decision literal lj with j ≤ k+ 1, then N satisfies M′.\nThe rules Decide, Fail and Unfounded can be dealt with as before (with only minor notational adjustments to account for extended states). Thus, we move on to the rules Unit Propagate Learn, Backjump, and Learn.\nUnit Propagate Learn: We recall that Γ is a set of clauses entailed by F and Π. In other words, any model of [F,Π] is also a model of Γ. We now proceed as in the case of the rule Unit Propagate in the proof of Proposition 8 with F∪Πcl replaced by F∪Πcl ∪Γ. Backjump: The argument is similar to that used in the case of the transition rule Backtrack in the proof of Lemma 8.\nLearn: This case is trivially true.\nWe now recall several concepts we will need in the proofs. Given a set A of atoms, we define Bodies(Π,A) = ⋃\na∈A Bodies(Π,a). Let Π be a program and Y a set of atoms. We call the formula\n∨\na∈Y\na → ∨ {B | B ∈ Bodies(Π,Y) and Bpos∩Y = /0} (5)\nthe loop formula for Y (Lin and Zhao 2004). We can rewrite the loop formula (5) as the disjunction\n( ∧\na∈Y\n¬a)∨ ∨ {B | B ∈ Bodies(Π,Y) and Bpos ∩Y = /0}. (6)\nThe Main Theorem in (Lee 2005) implies the following property loop formulas. In its statement we refer to the concept of a program entailing a formula. The notion is defined as follows. A program Π entails a formula F (over the set of atoms in Π) if for every interpretation M (over the set of atoms in Π) such that M+ is an answer set of Π, M is a model of F.\nLemma 10 (Lemma on Loop Formulas) For every program Π and every set Y of atoms, Y ⊆ At(Π), Π entails the loop formula (6) for Y.\nFor an SM(ASP) theory [F,Π] and a list PlQ of literals, we say that a clause C∨ l is a reason for l to be in PlQ with respect to [F,Π] if\n1. P |= ¬C, and 2. F,Πo |= C∨ l.\nLemma 11 Let [F,Π] be an SM(ASP) theory. For every state M||Γ reachable from /0|| /0 in the graph SML(ASP)F,Π, every literal l in M is either a decision literal or has a reason to be in M with respect to [F,Π]."
    }, {
      "heading" : "Proof",
      "text" : "We proceed by induction on the length of a path from /0|| /0 to M||Γ in the graph SML(ASP)F,Π. Since the property trivially holds in the initial state /0|| /0, we only need to prove that every transition rule of SML(ASP)F,Π preserves it.\nLet us consider an edge M||Γ =⇒ M′||Γ′, where M is a sequence l1 . . . lk such that every li, 1 ≤ i ≤ k, is either a decision literal or has a reason to be in M with respect to [F,Π]. It is evident that transition rules Backjump, Decide, Learn, and Fail preserve the property (the last one trivially, as FailState contains no literals).\nUnit Propagate Learn: The edge M||Γ =⇒ M′||Γ′ is justified by the rule Unit Propagate Learn. That is, there is a clause C∨ l ∈ F∪Πcl ∪Γ such that C ⊆ M and M′ = Ml. By the inductive hypothesis, the property holds for every literal in M. We now show that a clause C∨ l is a reason for l to be in Ml. By the applicability conditions of Unit Propagate Learn, C ⊆ M. Consequently, M |= C. It remains to show that F,Πo |= C∨ l. Case 1. C∨ l ∈ F. Then, clearly, F |= C∨ l and, consequently, F,Πo |= C∨ l. Case 2. C ∨ l ∈ Πcl. Since Πcl ⊆ (Πo)cl, C ∨ l ∈ (Πo)cl. Let M be a model of [F,Πo]. It follows that M+ is an answer set of Πo. Thus, M |= (Πo)cl and so, M |= C ∨ l. Thus, F,Πo |= C∨ l. Case 3. C∨ l ∈ Γ. We recall that F,Πo |= Γ by the definition of an augmented state. Consequently, F,Πo |= C∨ l. Unfounded: We have that M is consistent, and that there is an unfounded set U on M with respect to Πo and a ∈ U such that M′ = M¬a. By the inductive hypothesis, the property holds for every literal in M. We need to show that ¬a has a reason to be in M¬a with respect to [F,Π].\nLet B ∈ Bodies(Πo,U) be such that U ∩Bpos = /0. By the definition of an unfounded\nset, it follows that s(B)∩M 6= /0. Consequently, s(B) contains a literal from M. We pick an arbitrary one and call it f (B). The clause\nC = ¬a∨ ∨ {f (B) | B ∈ Bodies(Πo,U) and Bpos∩U = /0}, (7)\nis a reason for ¬a to be in M¬a with respect to [F,Π]. First, by the choice of f (B), for every B ∈ Bodies(Πo,U) and Bpos ∩U = /0, f (B) ∈ M. Consequently,\nM |= ¬ ∨ {f (B) | B ∈ Bodies(Πo,U) and Bpos ∩U = /0}· (8)\nSecond, since f (B) ∈ B, the loop formula\n( ∧\nu∈U\n¬u)∨ ∨ {B | B ∈ Bodies(Π,U) and Bpos ∩U = /0} (9)\nentails C. By Lemma on Loop Formulas, it follows that Πo entails C. Consequently, F,Πo |= C.\nFor a list M of literals, by consistent(M) we denote the longest consistent prefix of M. For example, consistent(abc¬bd) = abc. A clause C is conflicting on a list M of literals with respect to an SM(ASP) theory [F,Π] if consistent(M) |= ¬C and F,Πo |= C.\nFor a state M||Γ reachable from /0|| /0 in SML(ASP)F,Π, by rM we denote a function that maps every non-decision literal in M to its reason to be in M (with respect to [F,Π]). By RM we denote the set consisting of the clauses rM(l), for each non-decision literal l ∈ consistent(M).\nA resolution derivation of a clause C from a sequence of clauses C1, . . . ,Cm is a sequence C1, . . . ,Cm, . . . ,Cn, where C ≡ Cl for some l ≤ n, and each clause Ci in the sequence is either a clause from C1, . . . ,Cm or is derived by applying the resolution rule to clauses Cj and Ck, where j,k < i (we call such clauses derived ). We say that a clause C is derived by a resolution derivation from a sequence of clauses C1, . . . ,Cm if there is a resolution derivation of a clause C from C1, . . . ,Cm.\nLemma 12 Let [F,Π] be an SM(ASP) theory, M||Γ a state in the graph SM(ASP)F,Π such that M is inconsistent, and C1 a clause in RM . If clause C2 is conflicting on M with respect to [F,Π], then every clause C derived from C1 and C2 is also a conflicting clause on M with respect to [F,Π]."
    }, {
      "heading" : "Proof",
      "text" : "Let us assume that C is derived from C1 and C2 by resolving on some literal l ∈ C1. Then, C2 is of the form l∨C′2.\nFrom the fact that C1 ∈ RM, it follows that F,Πo |= C1 and that C1 has the form c1 ∨C′1, where consistent(M) |= ¬C ′ 1. Since C2 is conflicting, consistent(M) |= ¬C2 and F,Πo |= C2. By the consistency of consistent(M), there is no literal in C′1 such that its complement occurs in C2. Therefore l = c1 and, consequently, C = C′1 ∨C ′ 2. It follows that consistent(M) |= ¬C. Moreover, since F,Πo |= C1 and F,Πo |= C2 and C results from C1 and C2 by resolution, F,Πo |= C.\nFor an SM(ASP) theory [F,Π] and a node M||Γ in SM(ASP)F,Π, a resolution derivation C1, . . . ,Cn is trivial on M with respect to [F,Π]11 if\n(1) {C1, . . . ,Ci}= RM (2) Ci+1 is a conflicting clause on M with respect to [F,Π] (3) Cj, j > i+ 1, is derived from Cj−1 and a clause Ck, where k ≤ i (that is, Ck ∈ RM),\nby resolving on some non-decision literal of consistent(M).\nFor a record M0 l1 M1 . . . lk Mk, where li are all the decision literals of the record, we say that the literals of li Mi belong to a decision level i. For a state MlM′ l′M′′, we say that l is older than l′. We say that a state is a backjump state if it is inconsistent, contains a decision literal, and is reachable from /0|| /0 in SML(ASP)F,Π.\nLemma 13 For every SM(ASP) theory [F,Π], the transition rule Backjump is applicable in every backjump state in SM(ASP)F,Π."
    }, {
      "heading" : "Proof",
      "text" : "Let M||Γ be a backjump state in SM(ASP)F,Π. We will show that M has the form Pl∆ Q and that there is a literal l′ that has a reason to be in Pl′ with respect to [F,Π].\nSince M||Γ is a backjump state, it follows that M has the form consistent(M)l N. It is clear that l is not a decision literal (otherwise consistent(M)l would be consistent). By Lemma 11, there is a reason, say R for l to be in M. We denote this reason by R. Since consistent(M)l is inconsistent, l ∈ consistent(M). This observation and the definition of a reason imply that consistent(M) |= ¬R. Moreover, since F,Πo |= R (as R is a reason), R is a conflicting clause.\nLet dec be the largest of the decision levels of the complements of the literals in R (each of them occurs in consistent(M)). Let D be the set of all non-decision literals in consistent(M). By Ddec we denote a subset of D that contains all the literals that belong to decision level dec.\nIt is clear that C1, . . . ,Ci,Ci+1, where {C1, . . .Ci} = RM and Ci+1 = R, is a trivial resolution derivation with respect to M and consistent(M) |= ¬Ci+1. Let us consider a trivial resolution derivation with respect to M of the form C1, . . . ,Ci,Ci+1, . . . ,Cn, where n≥ i+1 and consistent(M) |= ¬Cn. Let us assume that there is a literal l ∈ D such that l in Cn. It follows that Cn = l∨C′n, for some clause C ′ n.\nSince l ∈ D (is a non-decision literal in consistent(M)), the set RM contains the clause rM(l), which is a reason for l to be in M. The clause rM(l) is of the form l∨ l1 ∨ . . .∨ lm, where literals l1, . . . , lm are older than l and consistent(M) |= ¬(l1 ∨ . . .∨ lm). Resolving Cn and rM(l) yields the clause Cn+1 = C′n ∨ l1 ∨ . . .∨ lm. Clearly, C1, . . . ,Cn+1 is a trivial resolution derivation with respect to M and conistent(M) |= ¬Cn+1.\nIf we apply this construction selecting at each step a non-decision literal l ∈ Ddec such that l ∈ R, then at some point we obtain a clause Cn that contains exactly one literal whose complement belongs to decision level dec (the reason is that in each step of the construction, the literal with respect we perform the resolution is replaced by older ones).\n11 This definition is related to the definition of a trivial resolution derivation (Beame et al. 2004).\nBy Lemma 12, the clause C = Cn is conflicting on M with respect to [F,Π], that is, consistent(M) |= ¬C and F,Πo |= C. By the construction, C = l′∨C′, where l′ is the only literal whose complement belongs to the decision level dec and the complements of all literals in C′ belong to lower decision levels.\nCase 1. dec = 0. Since for every literal l ∈ C′, the decision level of l is strictly lower than dec, C′ = ⊥. Since M||Γ is a backjump state, M contains a decision literal. Then M can be written as Pl∆ Q, where P contains no decision literals (in other words P consists of all literals in consistent(M) of decision level dec = 0) and l′ ∈ P. Clearly, P |= ¬C′ (as C′ =⊥). Since F,Πo |= C(= l′∨C′), C is a reason for l′ to be in Pl′.\nCase 2. dec ≥ 1. Let l be the decision literal in M that starts the decision level dec. Then, M can be written as Pl∆ Q. By the construction of the clause C, the complement of every literal in C′ belongs to a decision level smaller than dec, that is, to P. It follows that P |= ¬C′. Thus, as before, we conclude that C is a reason for l′ to be in Pl′.\nProposition 9 For any SM(ASP) theory [F,Π],\n(a) every path in SML(ASP)F,Π contains only finitely many edges justified by basic transition rules,\n(b) for any semi-terminal state M||Γ of SML(ASP)F,Π reachable from /0|| /0, M is a model of [F,Π],\n(c) FailState is reachable from /0|| /0 in SML(ASP)F,Π if and only if [F,Π] has no models."
    }, {
      "heading" : "Proof",
      "text" : "Part (a) is proved as in the proof of Proposition 13↑ (Lierler 2010) (we preserve the notation used in that work).\n(b) Let M||G be a semi-terminal state reachable from /0|| /0 (that is, none of the basic rules are applicable.) Since Decide is not applicable, M assigns all literals. Next, M is consistent. Indeed, if M were inconsistent then, since Fail is not applicable, M would contain a decision literal. Consequently, M||Γ would be a backjump state. By Lemma 13, the transition rule Backjump would be applicable in M||Γ, contradicting our assumption that M||Γ is semi-terminal. We now proceed as in the proof of Proposition 7 (b) to show M is a model of F and M+ is an input answer set of Π.\n(c) If FailState is reachable from /0|| /0 in SML(ASP)F,Π, then there is a state M||Γ reachable from /0|| /0 in SML(ASP)F,Π such that there is an edge between M||Γ and FailState. By the definition of SML(ASP)F,Π, this edge is due to the transition rule Fail. Thus, M is inconsistent and contains no decision literals. By Lemma 9, every model N of [F,Π] satisfies M. Since M is inconsistent, [F,Π] has no models.\nConversely, if [F,Π] has no models, let us consider a maximal path in SML(ASP)F,Π starting in /0|| /0 and consisting of basic transition rules. By (a), it follows that such a path is finite and ends in a semi-terminal state. By (b), this semi-terminal must be FailState, because [F,Π] has no models."
    }, {
      "heading" : "8.4 Proofs of Results from Section 6",
      "text" : "Proposition 10 For a total PC(ID) theory (F,Π) and a consistent and complete (over At(F∪Π)) set M of literals, M is a model of (F,Π) if and only if M+ is an answer set of π(F,Π)."
    }, {
      "heading" : "Proof",
      "text" : "By Proposition 6, it is enough to prove that M is a model of the SM(ASP) theory [F,Π] if and only if M+ is an answer set of π(F,Π). By the definition of π(F,Π), M+ is an answer set of π(F,Π) if and only if M+ is an answer set of Πo and a model of F. Since M+ is a subset of Head(Πo) (since Head(Πo) = At(F ∪Π)), Proposition 3(a) implies that M+ is an answer set of Πo if and only if M+ is an input answer set of Πo. It follows that M+ is an answer set of π(F,Π) if and only if M is a model of the SM(ASP) theory [F,Πo]. The assertion follows now from Proposition 4.\nProposition 11 For a PC(ID) theory (F,Π), we have\nSML(ASP)ED-Comp(Πo)∪F,Πo = SML(ASP)ED-Comp(π(F,Π)),π(F,Π)."
    }, {
      "heading" : "Proof",
      "text" : "We recall that π(F,Π) = Fr ∪Πo. From the construction of ED-Comp, it is easy to see that\nED-Comp(Πo)∪F = ED-Comp(π(F,Π))·\nFurthermore, from the definition of an unfounded set it follows that for any consistent set M of literals and a set U of atoms, U is unfounded on M with respect to Πo if and only if U is unfounded on M with respect to π(F,Π)."
    } ],
    "references" : [ {
      "title" : "Towards understanding and harnessing",
      "author" : [ "P. BEAME", "H. KAUTZ", "A. SABHARWAL" ],
      "venue" : null,
      "citeRegEx" : "BEAME et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "BEAME et al\\.",
      "year" : 2004
    }, {
      "title" : "The relative efficiency of propositional proof systems",
      "author" : [ "S.A. COOK", "ROBERT", "A. RECKHOW" ],
      "venue" : null,
      "citeRegEx" : "COOK et al\\.,? \\Q1979\\E",
      "shortCiteRegEx" : "COOK et al\\.",
      "year" : 1979
    }, {
      "title" : "A machine program for theorem proving",
      "author" : [ "M. DAVIS", "G. LOGEMANN", "D. LOVELAND" ],
      "venue" : "Journal of Symbolic Logic",
      "citeRegEx" : "DAVIS et al\\.,? \\Q1962\\E",
      "shortCiteRegEx" : "DAVIS et al\\.",
      "year" : 1962
    }, {
      "title" : "A deductive system for non-monotonic reasoning",
      "author" : [ "T. EITER", "N. LEONE", "C. MATEIS", "G. PFEIFER", "F. SCARCELLO" ],
      "venue" : "In",
      "citeRegEx" : "EITER et al\\.,? 1997",
      "shortCiteRegEx" : "EITER et al\\.",
      "year" : 1997
    }, {
      "title" : "Weight constraints as nested expressions",
      "author" : [ "P. FERRARIS", "V. LIFSCHITZ" ],
      "venue" : "Theory and Practice of Logic Programming 5, 45–74.",
      "citeRegEx" : "FERRARIS and LIFSCHITZ,? 2005",
      "shortCiteRegEx" : "FERRARIS and LIFSCHITZ",
      "year" : 2005
    }, {
      "title" : "Conflict-driven answer set solving",
      "author" : [ "M. GEBSER", "B. KAUFMANN", "A. NEUMANN", "T. SCHAUB" ],
      "venue" : "Proceedings of 20th International Joint Conference on Artificial Intelligence, IJCAI 2007. 386–392.",
      "citeRegEx" : "GEBSER et al\\.,? 2007",
      "shortCiteRegEx" : "GEBSER et al\\.",
      "year" : 2007
    }, {
      "title" : "Tableau calculi for answer set programming",
      "author" : [ "M. GEBSER", "T. SCHAUB" ],
      "venue" : "Proceedings of the 22nd International Conference on Logic Programming, ICLP 2006. Lecture Notes in Computer Science, vol. 4079. Springer, Berlin, 11–25.",
      "citeRegEx" : "GEBSER and SCHAUB,? 2006",
      "shortCiteRegEx" : "GEBSER and SCHAUB",
      "year" : 2006
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "M. GELFOND", "V. LIFSCHITZ" ],
      "venue" : "Proceedings of the 5th International Logic Programming Conference and Symposium, R. Kowalski and K. Bowen, Eds. MIT Press, Cambridge, MA, 1070–1080.",
      "citeRegEx" : "GELFOND and LIFSCHITZ,? 1988",
      "shortCiteRegEx" : "GELFOND and LIFSCHITZ",
      "year" : 1988
    }, {
      "title" : "On the relation among answer set solvers",
      "author" : [ "E. GIUNCHIGLIA", "N. LEONE", "M. MARATEA" ],
      "venue" : null,
      "citeRegEx" : "GIUNCHIGLIA et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "GIUNCHIGLIA et al\\.",
      "year" : 2008
    }, {
      "title" : "On the relation between answer set and SAT procedures (or, between smodels and cmodels)",
      "author" : [ "E. GIUNCHIGLIA", "M. MARATEA" ],
      "venue" : "Proceedings of the 21st International Conference on Logic Programming, ICLP 2005. Lecture Notes in Computer Science, vol. 3668. Springer, Berlin, 37–51.",
      "citeRegEx" : "GIUNCHIGLIA and MARATEA,? 2005",
      "shortCiteRegEx" : "GIUNCHIGLIA and MARATEA",
      "year" : 2005
    }, {
      "title" : "A model-theoretic counterpart of loop formulas",
      "author" : [ "LEE J." ],
      "venue" : "In",
      "citeRegEx" : "J.,? 2005",
      "shortCiteRegEx" : "J.",
      "year" : 2005
    }, {
      "title" : "Disjunctive stable models: Unfounded sets, fixpoint semantics, and computation",
      "author" : [ "N. LEONE", "P. RULLO", "F. SCARCELLO" ],
      "venue" : "Information and Computation 135(2), 69–112.",
      "citeRegEx" : "LEONE et al\\.,? 1997",
      "shortCiteRegEx" : "LEONE et al\\.",
      "year" : 1997
    }, {
      "title" : "Sat-based answer set programming",
      "author" : [ "Y. LIERLER" ],
      "venue" : "Ph.D. thesis, University of Texas at Austin.",
      "citeRegEx" : "LIERLER,? 2010",
      "shortCiteRegEx" : "LIERLER",
      "year" : 2010
    }, {
      "title" : "Abstract answer set solvers with backjumping and learning",
      "author" : [ "Y. LIERLER" ],
      "venue" : "Theory and Practice of Logic Programming 11, 135–169.",
      "citeRegEx" : "LIERLER,? 2011",
      "shortCiteRegEx" : "LIERLER",
      "year" : 2011
    }, {
      "title" : "Nested expressions in logic programs",
      "author" : [ "V. LIFSCHITZ", "L.R. TANG", "H. TURNER" ],
      "venue" : null,
      "citeRegEx" : "LIFSCHITZ et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "LIFSCHITZ et al\\.",
      "year" : 1999
    }, {
      "title" : "ASSAT: Computing answer sets of a logic program by SAT solvers",
      "author" : [ "F. LIN", "Y. ZHAO" ],
      "venue" : "Artificial Intelligence 157, 115–137.",
      "citeRegEx" : "LIN and ZHAO,? 2004",
      "shortCiteRegEx" : "LIN and ZHAO",
      "year" : 2004
    }, {
      "title" : "Stable models and an alternative logic programming",
      "author" : [ "V. MAREK", "M. TRUSZCZYŃSKI" ],
      "venue" : null,
      "citeRegEx" : "MAREK and TRUSZCZYŃSKI,? \\Q1999\\E",
      "shortCiteRegEx" : "MAREK and TRUSZCZYŃSKI",
      "year" : 1999
    }, {
      "title" : "Model generation for ID-logic",
      "author" : [ "M. MARIËN" ],
      "venue" : "Ph.D. thesis, Katholieke Universiteit Leuven.",
      "citeRegEx" : "MARIËN,? 2009",
      "shortCiteRegEx" : "MARIËN",
      "year" : 2009
    }, {
      "title" : "On the relation between ID-logic and answer set programming",
      "author" : [ "M. MARIËN", "D. GILIS", "M. DENECKER" ],
      "venue" : "Proceedings of the 9th European Conference on Logics in Artificial Intelligence, JELIA 2004. Lecture Notes in Computer Science, vol. 3229. Springer, Berlin, 108–120.",
      "citeRegEx" : "MARIËN et al\\.,? 2004",
      "shortCiteRegEx" : "MARIËN et al\\.",
      "year" : 2004
    }, {
      "title" : "SAT(ID): Satisfiability of propositional logic extended with inductive definitions",
      "author" : [ "M. MARIËN", "J. WITTOCX", "M. DENECKER", "M. BRUYNOOGHE" ],
      "venue" : "Proceedings of the 11th International Conference on Theory and Applications of Satisfiability Testing, SAT 2008. Lecture Notes in Computer Science, vol. 4996. Springer, Berlin, 211–224.",
      "citeRegEx" : "MARIËN et al\\.,? 2008",
      "shortCiteRegEx" : "MARIËN et al\\.",
      "year" : 2008
    }, {
      "title" : "Logic programs with stable model semantics as a constraint programming paradigm",
      "author" : [ "I. NIEMELÄ" ],
      "venue" : null,
      "citeRegEx" : "NIEMELÄ,? \\Q1999\\E",
      "shortCiteRegEx" : "NIEMELÄ",
      "year" : 1999
    }, {
      "title" : "Extending the Smodels system with cardinality and weight constraints",
      "author" : [ "I. NIEMELÄ", "P. SIMONS" ],
      "venue" : "Logic-Based Artificial Intelligence, J. Minker, Ed. Kluwer, Dordrecht, 491–521.",
      "citeRegEx" : "NIEMELÄ and SIMONS,? 2000",
      "shortCiteRegEx" : "NIEMELÄ and SIMONS",
      "year" : 2000
    }, {
      "title" : "Solving SAT and SAT modulo theories: From an abstract Davis-Putnam-Logemann-Loveland procedure to DPLL(T)",
      "author" : [ "R. NIEUWENHUIS", "A. OLIVERAS", "C. TINELLI" ],
      "venue" : "Journal of the ACM 53(6), 937–977.",
      "citeRegEx" : "NIEUWENHUIS et al\\.,? 2006",
      "shortCiteRegEx" : "NIEUWENHUIS et al\\.",
      "year" : 2006
    }, {
      "title" : "Modular equivalence for normal logic programs",
      "author" : [ "E. OIKARINEN", "T. JANHUNEN" ],
      "venue" : "Proceedings of the 17th European Conference on Artificial Intelligence, ECAI 2006. IOS Press, Amsterdam, 412–416.",
      "citeRegEx" : "OIKARINEN and JANHUNEN,? 2006",
      "shortCiteRegEx" : "OIKARINEN and JANHUNEN",
      "year" : 2006
    }, {
      "title" : "The well-founded semantics for general logic programs",
      "author" : [ "A. VAN GELDER", "K. ROSS", "J. SCHLIPF" ],
      "venue" : null,
      "citeRegEx" : "GELDER et al\\.,? \\Q1991\\E",
      "shortCiteRegEx" : "GELDER et al\\.",
      "year" : 1991
    } ],
    "referenceMentions" : [ {
      "referenceID" : 7,
      "context" : "Answer-set programming (ASP) (Marek and Truszczyński 1999; Niemelä 1999) is a declarative programming formalism based on the answer-set semantics of logic programs (Gelfond and Lifschitz 1988).",
      "startOffset" : 164,
      "endOffset" : 192
    }, {
      "referenceID" : 21,
      "context" : "In the paper we show that transition systems introduced by Nieuwenhuis et al. (2006) to model and analyze SAT solvers can be adapted for the analysis and comparison of solvers developed for other propositional formalisms.",
      "startOffset" : 59,
      "endOffset" : 85
    }, {
      "referenceID" : 21,
      "context" : "In the paper we show that transition systems introduced by Nieuwenhuis et al. (2006) to model and analyze SAT solvers can be adapted for the analysis and comparison of solvers developed for other propositional formalisms. The two formalisms we focus on are logic programming with the answer-set semantics and the logic PC(ID). Davis-Putnam-Logemann-Loveland (DPLL) procedure is a well-known method that exhaustively explores interpretations to generate models of a propositional formula. Most modern SAT solvers are based on variations of the DPLL procedure. Usually these variations are specified by pseudocode. Nieuwenhuis et al. (2006) proposed an alternative approach based on the notion of a transition system that describes “states of computation” and allowed transitions between them.",
      "startOffset" : 59,
      "endOffset" : 639
    }, {
      "referenceID" : 5,
      "context" : "2004) and CLASP3 (Gebser et al. 2007), and the PC(ID) solver MINISAT(ID)4 (Mariën et al.",
      "startOffset" : 17,
      "endOffset" : 37
    }, {
      "referenceID" : 9,
      "context" : "In this paper, we show that both computing answer sets of programs and computing models of PC(ID) theories can be considered as testing satisfiability modulo theories (SMT), where the objective is to find a model of a set of clauses that is also an answer set of a certain program. We refer to this computational problem as satisfiability modulo answer-set programming and denote it by SM(ASP). We identify the propositional formalism capturing SM(ASP) — we use the same term to refer to it — and show that it is a common generalization of ASP and PC(ID). We define a simple transition system for SM(ASP) and show that it can be used as an abstract representation of the solver SMODELS1 (Niemelä and Simons 2000), an alternative to a similar characterization of SMODELS obtained earlier by Lierler (2011). We then define another more elaborate transition system for SM(ASP) that captures such features of backtracking search as backjumping and learning.",
      "startOffset" : 186,
      "endOffset" : 805
    }, {
      "referenceID" : 22,
      "context" : "We now review the abstract transition system framework proposed for the DPLL procedure by Nieuwenhuis et al. (2006), and introduce some necessary terminology concerning logic programs and the logic PC(ID).",
      "startOffset" : 90,
      "endOffset" : 116
    }, {
      "referenceID" : 20,
      "context" : "Nieuwenhuis et al. (2006) described DPLL by means of a transition system that can be viewed as an abstract representation of the underlying DPLL computation.",
      "startOffset" : 0,
      "endOffset" : 26
    }, {
      "referenceID" : 12,
      "context" : "In this section we review the abstract DPLL in the form convenient for our purposes, following the presentation proposed by Lierler (2011). For a set A of atoms, a record relative to A is an ordered set M of literals over A , some possibly annotated by ∆, which marks them as decision literals.",
      "startOffset" : 124,
      "endOffset" : 139
    }, {
      "referenceID" : 22,
      "context" : "We refer the reader to (Nieuwenhuis et al. 2006) for an introduction to SMT.",
      "startOffset" : 23,
      "endOffset" : 48
    }, {
      "referenceID" : 23,
      "context" : "Input answer sets are related to stable models of a propositional logic program module (Oikarinen and Janhunen 2006).",
      "startOffset" : 87,
      "endOffset" : 116
    }, {
      "referenceID" : 5,
      "context" : "2004) and CLASP (Gebser et al. 2007) start their computation by transforming the given program Π into ED-Comp(Π).",
      "startOffset" : 16,
      "endOffset" : 36
    }, {
      "referenceID" : 15,
      "context" : "We note that it is possible to express these “answer-set specific” inferences in terms of clauses corresponding to loop formulas (Lin and Zhao 2004; Lee 2005).",
      "startOffset" : 129,
      "endOffset" : 158
    }, {
      "referenceID" : 13,
      "context" : "We note that the rule Unfounded above is closely related to the transition rule with the same name used in the definition of SMΠ (Lierler 2011).",
      "startOffset" : 129,
      "endOffset" : 143
    }, {
      "referenceID" : 12,
      "context" : "We recall that to represent SMODELS Lierler (2011) proposed a graph SMΠ.",
      "startOffset" : 36,
      "endOffset" : 51
    }, {
      "referenceID" : 12,
      "context" : "We recall that to represent SMODELS Lierler (2011) proposed a graph SMΠ. We note that the rule Unfounded above is closely related to the transition rule with the same name used in the definition of SMΠ (Lierler 2011). In fact, if Π = Πo then these rules are identical. Lierler (2011) observed that SMODELS as it is implemented never follows certain edges in the graph SMΠ, and called such edges singular.",
      "startOffset" : 36,
      "endOffset" : 284
    }, {
      "referenceID" : 12,
      "context" : "We recall that to represent SMODELS Lierler (2011) proposed a graph SMΠ. We note that the rule Unfounded above is closely related to the transition rule with the same name used in the definition of SMΠ (Lierler 2011). In fact, if Π = Πo then these rules are identical. Lierler (2011) observed that SMODELS as it is implemented never follows certain edges in the graph SMΠ, and called such edges singular. Lierler (2011) denoted by SMΠ the graph obtained by removing from SMΠ all its singular edges and showed that SM − Π is still sufficient to serve as an abstract model of a class of ASP solvers including SMODELS.",
      "startOffset" : 36,
      "endOffset" : 420
    }, {
      "referenceID" : 13,
      "context" : "Proposition 8 below can be seen as an extension of Proposition 4 in (Lierler 2011) to nontight programs.",
      "startOffset" : 68,
      "endOffset" : 82
    }, {
      "referenceID" : 13,
      "context" : "Using ASP specific propagation rules such as Backchain True and All Rules Cancelled (Lierler 2011) allows SMODELS to avoid explicit representation of the clausified completion and infer all the necessary transitions directly on the basis of the program Π.",
      "startOffset" : 84,
      "endOffset" : 98
    }, {
      "referenceID" : 9,
      "context" : "A similar relationship, in terms of pseudocode representations of SMODELS and DPLL, is established in (Giunchiglia and Maratea 2005) for tight programs.",
      "startOffset" : 102,
      "endOffset" : 132
    }, {
      "referenceID" : 9,
      "context" : "A similar relationship, in terms of pseudocode representations of SMODELS and DPLL, is established in (Giunchiglia and Maratea 2005) for tight programs. The answer-set solvers CMODELS, CLASP and the PC(ID) solver MINISAT(ID) cannot be described in terms of the graph SM(ASP) nor its subgraphs. These solvers implement such advanced features of SAT and SMT solvers as learning (forgetting), backjumping and restarts (Nieuwenhuis et al. (2006) give a good overview of these techniques).",
      "startOffset" : 103,
      "endOffset" : 442
    }, {
      "referenceID" : 22,
      "context" : "Nieuwenhuis et al. (2006) proposed the transition rules to model such techniques as forgetting and restarts.",
      "startOffset" : 0,
      "endOffset" : 26
    }, {
      "referenceID" : 4,
      "context" : "A choice rule construct {a} (Niemelä and Simons 2000) of the LPARSE6 and GRINGO7 languages can be seen as an abbreviation for a rule a ← not not a (Ferraris and Lifschitz 2005).",
      "startOffset" : 147,
      "endOffset" : 176
    }, {
      "referenceID" : 13,
      "context" : "Lierler (2011) introduced the graphs SML and GTL that extended the graphs SM and GT (Lierler 2011), respectively, with transition rules Backjump and Learn.",
      "startOffset" : 84,
      "endOffset" : 98
    }, {
      "referenceID" : 13,
      "context" : "The graph SML was used to characterize the computation of such answer set solvers implementing learning as SMODELScc 8 (Ward and Schlipf 2004) and SUP9 (Lierler 2011) whereas the graph GTL was used to characterize CMODELS.",
      "startOffset" : 152,
      "endOffset" : 166
    }, {
      "referenceID" : 3,
      "context" : "Giunchiglia et al (2008) continued this work by comparing answer set solvers SMODELS, DLV10 (Eiter et al. 1997), and CMODELS via pseudocode.",
      "startOffset" : 92,
      "endOffset" : 111
    }, {
      "referenceID" : 7,
      "context" : "Giunchiglia and Maratea (2005) studied the relation between the answer set solver SMODELS and the DPLL procedure for the case of tight programs by means of pseudocode analysis.",
      "startOffset" : 0,
      "endOffset" : 31
    }, {
      "referenceID" : 7,
      "context" : "Giunchiglia and Maratea (2005) studied the relation between the answer set solver SMODELS and the DPLL procedure for the case of tight programs by means of pseudocode analysis. Giunchiglia et al (2008) continued this work by comparing answer set solvers SMODELS, DLV10 (Eiter et al.",
      "startOffset" : 0,
      "endOffset" : 202
    }, {
      "referenceID" : 3,
      "context" : "Giunchiglia et al (2008) continued this work by comparing answer set solvers SMODELS, DLV10 (Eiter et al. 1997), and CMODELS via pseudocode. In this paper we use a different approach to relate solvers that was proposed by Lierler (2011). That is, we use graphs to represent the algorithms implemented by solvers, and study the structure of these graphs to find how the corresponding solvers are related.",
      "startOffset" : 93,
      "endOffset" : 237
    }, {
      "referenceID" : 3,
      "context" : "Giunchiglia et al (2008) continued this work by comparing answer set solvers SMODELS, DLV10 (Eiter et al. 1997), and CMODELS via pseudocode. In this paper we use a different approach to relate solvers that was proposed by Lierler (2011). That is, we use graphs to represent the algorithms implemented by solvers, and study the structure of these graphs to find how the corresponding solvers are related. We use this method to state the relation between the answer set solvers CMODELS, CLASP, and the PC(ID) solver MINISAT(ID) designed for different knowledge representation formalisms. Gebser and Schaub (2006) introduced a deductive system for describing inferences involved in computing answer sets by tableaux methods.",
      "startOffset" : 93,
      "endOffset" : 611
    }, {
      "referenceID" : 3,
      "context" : "Giunchiglia et al (2008) continued this work by comparing answer set solvers SMODELS, DLV10 (Eiter et al. 1997), and CMODELS via pseudocode. In this paper we use a different approach to relate solvers that was proposed by Lierler (2011). That is, we use graphs to represent the algorithms implemented by solvers, and study the structure of these graphs to find how the corresponding solvers are related. We use this method to state the relation between the answer set solvers CMODELS, CLASP, and the PC(ID) solver MINISAT(ID) designed for different knowledge representation formalisms. Gebser and Schaub (2006) introduced a deductive system for describing inferences involved in computing answer sets by tableaux methods. The abstract framework presented in this paper can be viewed as a deductive system also, but a very different one. For instance, we describe backtracking and backjumping by inference rule, while the GebserSchaub system does not. Also the Gebser-Schaub system does not take learning into account. Accordingly, the derivations considered in this paper describe a search process, while derivations in the Gebser-Schaub system do not. Further, the abstract framework discussed here does not have any inference rule similar to Cut; this is why its derivations are paths rather than trees. Mariën (2009) (Section 5.",
      "startOffset" : 93,
      "endOffset" : 1320
    }, {
      "referenceID" : 3,
      "context" : "Giunchiglia et al (2008) continued this work by comparing answer set solvers SMODELS, DLV10 (Eiter et al. 1997), and CMODELS via pseudocode. In this paper we use a different approach to relate solvers that was proposed by Lierler (2011). That is, we use graphs to represent the algorithms implemented by solvers, and study the structure of these graphs to find how the corresponding solvers are related. We use this method to state the relation between the answer set solvers CMODELS, CLASP, and the PC(ID) solver MINISAT(ID) designed for different knowledge representation formalisms. Gebser and Schaub (2006) introduced a deductive system for describing inferences involved in computing answer sets by tableaux methods. The abstract framework presented in this paper can be viewed as a deductive system also, but a very different one. For instance, we describe backtracking and backjumping by inference rule, while the GebserSchaub system does not. Also the Gebser-Schaub system does not take learning into account. Accordingly, the derivations considered in this paper describe a search process, while derivations in the Gebser-Schaub system do not. Further, the abstract framework discussed here does not have any inference rule similar to Cut; this is why its derivations are paths rather than trees. Mariën (2009) (Section 5.7) described a MINISAT(ID) transition system to model a computation behind the PC(ID) solver MINISAT(ID). We recall that we modeled the abstract MINISAT(ID) with the graph SML(ASP). The graphs SML(ASP) and MINISAT(ID) are defined using different sets of nodes and transition rules. For instance, SML(ASP) allows states containing inconsistent sets of literals whereas the MINISAT(ID) graph considers consistent states only. Due to this difference the MINISAT(ID) graph requires multiple versions of “backjump” and “fail” transition rules. We used transition systems to characterize algorithms for computing answer sets of logic programs and models of PC(ID) theories. These transition systems are also suitable for formal comparison of the strength or power of reasoning methods given rules that specify them. An approach to do so was proposed by Mariën (2009) (Section 5.",
      "startOffset" : 93,
      "endOffset" : 2192
    } ],
    "year" : 2011,
    "abstractText" : "A fundamental task for propositional logic is to compute models of propositional formulas. Programs developed for this task are called satisfiability solvers. We show that transition systems introduced by Nieuwenhuis, Oliveras, and Tinelli to model and analyze satisfiability solvers can be adapted for solvers developed for two other propositional formalisms: logic programming under the answerset semantics, and the logic PC(ID). We show that in each case the task of computing models can be seen as “satisfiability modulo answer-set programming,” where the goal is to find a model of a theory that also is an answer set of a certain program. The unifying perspective we develop shows, in particular, that solvers CLASP and MINISAT(ID) are closely related despite being developed for different formalisms, one for answer-set programming and the latter for the logic PC(ID).",
    "creator" : "dvips(k) 5.98 Copyright 2009 Radical Eye Software"
  }
}