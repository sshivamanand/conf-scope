{
  "name" : "1106.0776.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "JUAN CARLOS NIEVES" ],
    "emails" : [ "jcnieves@lsi.upc.edu)", "osoriomauri@gmail.com)", "ia@lsi.upc.edu)" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n10 6.\n07 76\nBy considering a possibilistic logic program as a possibilistic logic theory, a construction of a possibilistic logic programming semantic based on answer sets and the proof theory of possibilistic logic is defined. It shows that this possibilistic semantics for disjunctive logic programs can be characterized by a fixed-point operator. It is also shown that the suggested possibilistic semantics can be computed by a resolution algorithm and the consideration of optimal refutations from a possibilistic logic theory.\nIn order to manage inconsistent possibilistic logic programs, a preference criterion between inconsistent possibilistic models is defined; in addition, the approach of cuts for restoring consistency of an inconsistent possibilistic knowledge base is adopted. The approach is illustrated in a medical scenario.\nKEYWORDS: Answer Set Programming, Uncertain Information, Possibilistic Reasoning.\n∗ This is a revised and improved version of the papers Semantics for Possibilistic Disjunctive Programs appeared in C. Baral, G. Brewka and J. Schipf (Eds), Ninth International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR-07), LNAI 4483. Semantics for Possibilistic Disjunctive Logic programs which appears in S. Constantini and W. Watson (Eds), Answer Set Programming: Advantage in Theory and Implementation."
    }, {
      "heading" : "1 Introduction",
      "text" : "Answer Set Programming (ASP) is one of the most successful logic programming approaches in Non-monotonic Reasoning and Artificial Intelligence applications (Baral 2003; Gelfond 2008). In (Nicolas et al. 2006), a possibilistic framework for reasoning under uncertainty was proposed. This framework is a combination between ASP and possibilistic logic (Dubois et al. 1994).\nPossibilistic Logic is based on possibilistic theory in which, at the mathematical level, degrees of possibility and necessity are closely related to fuzzy sets (Dubois et al. 1994). Due to the natural properties of possibilistic logic and ASP, Nicolas et al.’s approach allows us to deal with reasoning that is at the same time non-monotonic and uncertain. Nicolas et al.’s approach is based on the concept of possibilistic stable model which defines a semantics for possibilistic normal logic programs.\nAn important property of possibilistic logic is that it is axiomatizable in the necessityvalued case (Dubois et al. 1994). This means that there is a formal system (a set of axioms and inferences rules) such that from any set of possibilistic fomulæ F and for any possibilistic formula Φ, Φ is a logical consequence of F if and only if Φ is derivable from F in this formal system. A result of this property is that the inference in possibilistic logic can be managed by both a syntactic approach (axioms and inference rules) and a possibilistic model theory approach (interpretations and possibilistic distributions).\nEqually important to consider is that the answer set semantics inference can also be characterized as a logic inference in terms of the proof theory of intuitionistic logic and intermediate logics (Pearce 1999; Osorio et al. 2004). This property suggests that one can explore extensions of the answer set semantics by considering the inference of different logics.\nSince in (Dubois et al. 1994) an axiomatization of possibilistic logic has been defined, in this paper we explore the characterization of a possibilistic semantics for capturing possibilistic logic programs in terms of the proof theory of possibilistic logic and the standard answer set semantics. A nice feature of this characterization is that it is applicable to disjunctive as well as normal possibilistic logic programs, and, with minor modification, to possibilistic logic programs containing a strong negation operator.\nThe use of possibilistic disjunctive logic programs allow us to capture incomplete information and incomplete states of a knowledge base at the same time. In order to illustrate the use of possibilistic disjunctive logic programs, let us consider a scenario in which uncertain and incomplete information is always present. This scenario can be observed in the process of human organ transplanting. There are several factors that make this process sophisticated and complex. For instance:\n• the transplant acceptance criteria vary ostensibly among transplant teams from the same geographical area and substantially between more distant transplant teams (López-Navidad et al. 1997). This means that the acceptance criteria applied in one hospital could be invalid or at least questionable in another hospital. • there are lots of factors that make the diagnosis of an organ donor’s disease in the organ recipient unpredictable. For instance, if an organ donor D has hepatitis, then an organ recipient R could be infected by an organ of D. According to (López-Navidad and Caballero 2003), there are cases in which the infection can oc-\ncur; however, the recipient can spontaneously clear the infection, for example hepatitis. This means that an organ donor’s infection can be present or non-present in the organ recipient. Of course there are infections which can be prevented by treating the organ recipient post-transplant.\n• the clinical state of an organ recipient can be affected by several factors, for example malfunctions of the graft. This means that the clinical state of an organ recipient can be stable or unstable after the graft because the graft can have good graft functions, delayed graft functions and terminal insufficient functions1.\nIt is important to point out that the transplant acceptance criteria rely on the kind of organ (kidney, heart, liver, etc.) considered for transplant and the clinical situation of the potential organ recipients.\nLet us consider the particular case of a kind of kidney transplant with organ donors who have a kind of infection, for example: endocarditis, hepatitis. As already stated, the clinical situation of the potential organ recipients is relevant in the organ transplant process. Hence the clinical situation of an organ recipient is denoted by the predicate cs(t, T ), such that t can be stable, unstable, 0-urgency and T denotes a moment in time. Another important factor, that is considered, is the state of the organ’s functions. This factor is denoted by the predicate o(t, T ) such that t can be terminal-insufficient functions, good-graft functions, delayed-graft functions, normal-graft functions and T denotes a moment in time. Also, the state of an infection in both the organ recipient and the organ donor are considered, these states are denoted by the predicates r_inf(present, T ) and d_inf(present, T ) respectively so that T denotes a moment in time. The last predicate that is presented is action(t, T ) such that t can be transplant, wait, post-transplant treatment and T denotes a moment in time. This predicate denotes the possible actions of a doctor. In Figure 12, a finite state automata is presented. In this automata, each node represents a possible situation where an organ recipient can be found and the arrows represent the doctor’s possible actions. Observe that we are assuming that in the initial state the organ recipient is clinically stable and he does not have an infection; however, he has a kidney whose functions are terminally insufficient. From the initial state, the doctor’s actions would be either to perform a kidney transplantat or just wait3.\nAccording to Figure 1, an organ recipient could be found in different situations after a graft. The organ recipient may require another graft and the state of the infection could be unpredictable. This situation makes the automata of Figure 1 nondeterministic. Let us consider a couple of extended disjunctive clauses which describe some situations presented in Figure 1.\n1 Usually, when a doctor says that an organ has terminally insufficient functions, it means that there are no clinical treatments for improving the organ’s functions. 2 This finite state automata was developed under the supervision of Francisco Caballero M. D. Ph. D. from the Hospital de la Santa Creu I Sant Pau, Barcelona, Spain. 3 In the automata of Figure 1, we are not considering the possibility that there is a waiting list for organs. This waiting list has different policies for assigning an organ to an organ recipient.\nr_inf(present, T 2)∨ ¬r_inf(present, T 2)← action(transplant, T ), d_inf(present, T ), T 2 = T + 1.\no(good_graft_funct, T 2)∨ o(delayed_graft_funct, T 2)∨ o(terminal_insufficient_funct, T 2) ← action(transplant, T ), T 2 = T + 1.\nAs syntactic clarification, we want to point out that ¬ is regarded as a strong negation which is not exactly the negation in classical logic. In fact, any atom negated by strong negation will be replaced by a new atom as it is done in ASP. This means that a ∨ ¬a cannot be regarded as a logic tautology.\nContinuing with our medical scenario, we can see that the intended meaning of the first clause is that if the organ donor has an infection, then the infection can be present or nonpresent in the organ recipient after the graft, and the intended meaning of the second one is that the graft’s functions can be: good, delayed and terminal after the graft. Observe that these clauses are not capturing the uncertainty that is involved in each statement. For instance, w.r.t. the first clause, one can wish to attach an degree of uncertainty in order to capture the uncertainty that is involved in this statement — keeping in mind that the organ recipient can be infected by the infection of the donor’s organ; however, the infection can be spontaneously cleared by the organ recipient as it is the case of hepatitis (López-Navidad and Caballero 2003).\nIn logic programming literature, one can find different approaches for representing un-\ncertain information (Kifer and Subrahmanian 1992; Ng and Subrahmanian 1992; Lukasiewicz 1998; Kern-Isberner and Lukasiewicz 2004; van Emden 1986; Rodríguez-Artalejo and Romero-Díaz 2008; Van-Nieuwenborgh et al. 2007; Fitting 1991; Lakshmanan 1994; Baldwin 1987; Dubois et al. 1991; Alsinet and Godo 2002; Alsinet and Godo 2000; Alsinet et al. 2008; Nicolas et al. 2006). Basically, these approaches differ in the underlying notion of uncertainty and how uncertainty values, associated with clauses and facts, are managed. Usually the selection of an approach for representing uncertain information relies on the kind of information which has to be represented. In psychology literature, one can find significant observations related to the presentation of uncertain information. For instance, Tversky and Kahneman have observed in (Tversky and Kahneman 1982) that people commonly use statements such as “I think that . . . ”, “chances are . . . ”, “it is probable that . . . ”, “it is plausible that . . . ”, etc., for supporting their decisions. In fact, many times, experts in a domain, such as medicine, appeal to their intuition by using these kinds of statements (Fox and Das 2000; Fox and Modgil 2006). One can observe that these statements have adjectives which quantify the information as a common denominator. These adjectives are for example: probable, plausible, etc. This suggests that the consideration of labels for the syntactic representation of uncertain values could help represent uncertain information pervaded by ambiguity.\nSince possibilistic logic defines a proof theory in which the strength of a conclusion is the strength of the weakest argument in its proof, the consideration of an ordered set of labels for capturing incomplete states of a knowledge base is feasible. The only formal requirement is that this set of adjectives/labels must be a finite set. For instance, for the given medical scenario, a transplant coordinator4 can suggest a set of labels in order to quantify a medical knowledge base and, of course, to define an order between those labels. By considering those labels, we can have possibilistic clauses as:\nprobable: r_inf(present, T 2)∨ ¬r_inf(present, T 2)← action(transplant, T ), d_inf(present, T ), T 2 = T + 1.\nInformally speaking, the reading of this clause is: it is probable that if the organ donor has an infection, then the organ recipient can be infected or not after a graft.\nAs we can see, possibilistic programs with negation as failure represent a rich class of logic programs which are especially adapted to automated reasoning when the available information is pervaded by ambiguity.\nIn this paper, we extend the work of two earlier papers (Nieves et al. 2007a; Nieves et al. 2007b) in order to obtain a simple logic characterization of a possibilistic logic programming semantics for capturing possibilistic programs; this semantics is applicable to disjunctive as well as normal logic programs. As we have already mentioned, the construction of the possibilistic semantics is based on the proof theory of possibilistic logic. Following this approach:\n• We define the inference PL. This inference takes as references the standard definition of the answer set semantics and the inference ⊢PL which corresponds to the inference of possibilistic logic.\n4 A transplant coordinator is an expert in all of the processes of transplants (López-Navidad et al. 1997).\n• The possibilistic semantics is defined in terms of a syntactic reduction, PL and the concept of i-greatest set. • Since the inference of possibilistic logic is computable by a generalization of the classical resolution rule, it is shown that the defined possibilistic semantics is computable by inferring optimal refutations. • By considering the principle of partial evaluation, it is shown that the given possibilistic semantics can be characterized by a possibilistic partial evaluation operator. • Finally, since the possibilistic logic uses α-cuts to manage inconsistent possibilistic knowledge bases, an approach of cuts for restoring consistency of an inconsistent possibilistic knowledge base is adopted.\nThe rest of the paper is divided as follows: In §2 we give all the background and necessary notation. In §3, the syntax of our possibilistic framework is presented. In §4, the semantics for capturing the possibilistic logic programs is defined. Also it is shown that this semantics is computable by considering a possibilistic resolution rule and partial evaluation. In §5, some criteria for managing inconsistent possibilistic logic programs are defined. In §6, we present a small discussion w.r.t. related approaches to our work. Finally, in the last section, we present our conclusions and future work."
    }, {
      "heading" : "2 Background",
      "text" : "In this section we introduce the necessary terminology and relevant definitions in order to have a self-contained document. We assume that the reader is familiar with basic concepts of classic logic, logic programming and lattices."
    }, {
      "heading" : "2.1 Lattices and order",
      "text" : "We start by defining some fundamental definitions of lattice theory (see (Davey and Priestly 2002) for more details).\nDefinition 1 Let Q be a set. An order (or partial order) on Q is a binary relation ≤ on Q such that, for all x, y, z ∈ Q,\n(i) x ≤ x (ii) x ≤ y and y ≤ x imply x = y (iii) x ≤ y and y ≤ z imply x ≤ z\nThese conditions are referred to, respectively, as reflexivity, antisymmetry and transitivity.\nA set Q equipped with an order relation ≤ is said to be an ordered set (or partial ordered set). It will be denoted by (Q,≤).\nDefinition 2 Let (Q,≤) be an ordered set and let S ⊆ Q. An element x ∈ Q is an upper bound of S if s ≤ x for all s ∈ S. A lower bound is defined dually. The set of all upper bounds of S is denoted by Su (read as ‘S upper’) and the set of all lower bounds by Sl (read as ‘S lower’).\nIf Su has a minimum element x, then x is called the least upper bound (LUB) of S. Equivalently, x is the least upper bound of S if\n(i) x is an upper bound of S, and (ii) x ≤ y for all upper bound y of S.\nThe least upper bound of S exists if and only if there exists x ∈ Q such that\n(∀y ∈ Q)[((∀s ∈ S)s ≤ y) ⇐⇒ x ≤ y],\nand this characterizes the LUB of S. Dually, if Sl has a greatest element, x, then x is called the greatest lower bound (GLB) of S. Since the least element and the greatest element are unique, LUB and GLB are unique when they exist.\nThe least upper bound of S is called the supremum of S and it is denoted by sup S; the greatest lower bound of S is called the infimum of S and it is denoted by inf S.\nDefinition 3\nLet (Q,≤) be a non-empty ordered set.\n(i) If sup{x, y} and inf{x, y} exist for all x, y ∈ Q, then Q is called lattice. (ii) If sup S and inf S exist for all S ⊆ Q, then Q is called a complete lattice.\nExample 1\nLet us consider the set of labels Q := {Certain, Confirmed, Probable, P lausible, Supported, Open}5 and let be a partial order such that the following set of relations holds: {Open Supported, Supported Plausible, Supported Probable, Probable Confirmed, Plausible Confirmed, Confirmed Certain}. A graphic representation of S according to is showed in Figure 2. It is not difficult to see that (Q, ) is a lattice and further it is a complete lattice."
    }, {
      "heading" : "2.2 Logic programs: Syntax",
      "text" : "The language of a propositional logic has an alphabet consisting of\n(i) proposition symbols: ⊥, p0, p1, ... (ii) connectives : ∨,∧,←,¬, not (iii) auxiliary symbols : ( , )\nin which ∨,∧,← are binary-place connectives, ¬, not are unary-place connective and ⊥ is zero-ary connective. The proposition symbols and ⊥ stand for the indecomposable propositions, which we call atoms, or atomic propositions. Atoms negated by ¬ will be called extended atoms.\n5 This set of labels was taken from (Fox and Modgil 2006). In that paper, the authors argue that we can construct a set of labels (they call those: modalities) in a way that this set provides a simple scale for ordering the claims of our beliefs. We will use this kind of labels for quantifying the degree of uncertainty of a statement.\nRemark 1\nWe will use the concept of atom without paying attention to whether it is an extended atom or not.\nThe negation sign ¬ is regarded as the so called strong negation by the ASP’s literature and the negation not as the negation as failure. A literal is an atom, a, or the negation of an atom not a. Given a set of atoms {a1, ..., an}, we write not {a1, ..., an} to denote the set of literals {not a1, ..., not an}. An extended disjunctive clause, C, is denoted:\na1 ∨ . . . ∨ am ← am+1, . . . , aj , not aj+1, . . . , not an\nin which m ≥ 0, n ≥ 0, m + n > 0, each ai is an atom6. When n = 0 and m > 0 the clause is an abbreviation of a1∨ . . .∨am ←; clauses of these forms are some times written just as a1 ∨ . . . ∨ am. When m = 0 the clause is an abbreviation of:\n← a1, . . . , aj, not aj+1, . . . , not an\nClauses of this form are called constraints (the rest, non-constraint clauses). An extended disjunctive program P is a finite set of extended disjunctive clauses. By LP , we denote the set of atoms in the language of P .\nSometimes we denote an extended disjunctive clause C by A ← B+, not B−, A contains all the head literals, B+ contains all the positive body literals and B− contains all the negative body literals. When B− = ∅, the clause is called positive disjunctive clause. A set of positive disjunctive clauses is called a positive disjunctive logic program. When A is a singleton set, the clause can be regarded as a normal clause. A normal logic program is a finite set of normal clauses. Finally, when A is a singleton set and B− = ∅, the clause can\n6 Notice that these atoms can be extended atoms.\nalso be regarded as a definite clause. A finite set of definite clauses is called a definite logic program.\nWe will manage the strong negation (¬), in our logic programs, as it is done in ASP (Baral 2003). Basically, each extended atom¬a is replaced by a new atom symbol a′ which does not appear in the language of the program. For instance, let P be the normal program:\na← q. q. ¬q ← r. r.\nThen replacing each extended atom by a new atom symbol, we will have:\na← q. q. q′ ← r. r.\nIn order not to allow models with complementary atoms, that is q and ¬q, a constraint of the form ← q, q′ is usually added to the logic program. In our approach, this constraint can be omitted in order to allow models with complementary atoms. In fact, the user could add/omit this constraint without losing generality.\nFormulæ are constructed as usual in classic logic by the connectives: ∨,∧,←,∼,⊥. A theory T is a finite set of formulæ. By LT , we denote the set of atoms that occur in T. When we treat a logic program as a theory,\n• each negative literal not a is replaced by ∼ a such that ∼ is regarded as the negation in classic logic. • each constraint ← a1, . . . , aj, not aj+1, . . . , not an is rewritten according to the formula a1 ∧ · · · ∧ aj∧ ∼ aj+1 ∧ · · · ∧ ∼ an → ⊥.\nGiven a set of proposition symbols S and a theory Γ in a logicX . If Γ ⊢X S if and only if ∀s ∈ S Γ ⊢X s."
    }, {
      "heading" : "2.3 Interpretations and models",
      "text" : "In this section, we define some relevant concepts w.r.t. semantics. The first basic concept that we introduce is interpretation.\nDefinition 4 Let T be a theory, an interpretation I is a mapping from LT to {0, 1} meeting the conditions:\n1. I(a ∧ b) = min{I(a), I(b)}, 2. I(a ∨ b) = max{I(a), I(b)}, 3. I(a← b) = 0 if and only if I(b) = 1 and I(a) = 0, 4. I(∼ a) = 1− I(a), 5. I(⊥) = 0.\nIt is standard to provide interpretations only in terms of a mapping from LT to {0, 1}. Moreover, it is easy to prove that this mapping is unique by virtue of the definition by recursion (van Dalen 1994). Also, it is standard to use sets of atoms to represent interpretations. The set corresponds exactly to those atoms that evaluate to 1.\nAn interpretation I is called a (2-valued) model of the logic program P if and only if for each clause c ∈ P , I(c) = 1. A theory is consistent if it admits a model, otherwise it is called inconsistent. Given a theory T and a formula ϕ, we say that ϕ is a logical consequence of T , denoted by T |= ϕ, if every model I of T holds that I(ϕ) = 1. It is a well known result that T |= ϕ if and only if T ∪ {∼ ϕ} is inconsistent (van Dalen 1994).\nWe say that a model I of a theory T is a minimal model if a model I ′ of T different from I such that I ′ ⊂ I does not exist. Maximal models are defined in the analogous form."
    }, {
      "heading" : "2.4 Logic programming semantics",
      "text" : "In this section, the answer set semantics is presented. This semantics represents a twovalued semantics approach."
    }, {
      "heading" : "2.4.1 Answer set semantics",
      "text" : "By using ASP, it is possible to describe a computational problem as a logic program whose answer sets correspond to the solutions of the given problem. It represents one of the most successful approaches of non-monotonic reasoning of the last two decades (Baral 2003). The number of applications of this approach have increased due to the efficient implementations of the answer set solvers that exist.\nThe answer set semantics was first defined in terms of the so called Gelfond-Lifschitz reduction (Gelfond and Lifschitz 1988) and it is usually studied in the context of syntax dependent transformations on programs. The following definition of an answer set for extended disjunctive logic programs generalizes the definition presented in (Gelfond and Lifschitz 1988) and it was presented in (Gelfond and Lifschitz 1991): Let P be any extended disjunctive logic program. For any set S ⊆ LP , let PS be the positive program obtained from P by deleting\n(i) each rule that has a formula not a in its body with a ∈ S, and then (ii) all formulæ of the form not a in the bodies of the remaining rules.\nClearly PS does not contain not (this means that PS is either a positive disjunctive logic program or a definite logic program), hence S is called an answer set of P if and only if S is a minimal model of PS . In order to illustrate this definition, let us consider the following example:\nExample 2 Let us consider the set of atoms S := {b} and the following normal logic program P :\nb← not a. b. c← not b. c← a.\nWe can see that PS is: b. c← a. Notice that this program has three models: {b}, {b, c} and {a, b, c}. Since the minimal model among these models is {b}, we can say that S is an answer set of P .\nIn the answer set definition, we will normally omit the restriction that if S has a pair of complementary literals then S := LP . This means that we allow for the possibility that\nan answer set could have a pair of complementary atoms. For instance, let us consider the program P : a. ¬a. b. then, the only answer set of this program is : {a,¬a, b}. In Section 5, the inconsistency in possibilistic programs is discussed.\nIt is worth mentioning that in literature there are several forms for handling an inconsistency program (Baral 2003). For instance, by applying the original definition (Gelfond and Lifschitz 1991) the only answer set of P is: {a,¬a, b,¬b}. On the other hand, the DLV system (DLV 1996) returns no models if the program is inconsistent."
    }, {
      "heading" : "2.5 Possibilistic Logic",
      "text" : "Since in our approach is based on the proof theory of possibilistic logic, in this section, we present an axiomation of possibilistic logic for the case of necessity-valued formulæ.\nPossibilistic logic is a weighted logic introduced and developed in the mid-1980s, in the setting of artificial intelligence, with the goal of developing a simple yet rigorous approach to automated reasoning from uncertain or prioritized incomplete information. Possibilistic logic is especially adapted to automated reasoning when the available information is pervaded by ambiguities. In fact, possibilistic logic is a natural extension of classical logic in which the notion of total order/partial order is embedded in the logic.\nPossibilistic Logic is based on possibility theory. Possibilistic theory, as its name implies, deals with the possible rather than probable values of a variable with possibility being a matter of degree. One merit of possibilistic theory is at one and the same time to represent imprecision (in the form of fuzzy sets) and quantity uncertainty (through the pair of numbers that measure possibility and necessity).\nOur study in possibilistic logic is devoted to a fragment of possibilistic logic, in which knowledge bases are only necessity-quantified statements. A necessity-valued formula is a pair (ϕ α) in which ϕ is a classical logic formula and α ∈ (0, 1] is a positive number. The pair (ϕ α) expresses that the formula ϕ is certain at least to the level α, that is N(ϕ) ≥ α, in which N is a necessity measure modeling our possibly incomplete state knowledge (Dubois et al. 1994). α is not a probability (like it is in probability theory), but it induces a certainty (or confidence) scale. This value is determined by the expert providing the knowledge base. A necessity-valued knowledge base is then defined as a finite set (that is to say a conjunction) of necessity-valued formulæ.\nThe following properties hold w.r.t. necessity-valued formulæ:\nN(ϕ ∧ ψ) = min({N(ϕ), N(ψ)}) (1)\nN(ϕ ∨ ψ) ≥ max({N(ϕ), N(ψ)}) (2)\nif ϕ ⊢ ψ then N(ψ) ≥ N(ϕ) (3)\nDubois et al., in (Dubois et al. 1994) introduced a formal system for necessity-valued logic which is based on the following axioms schemata (propositional case):\n(A1) (ϕ→ (ψ → ϕ) 1) (A2) ((ϕ→ (ψ → ξ)) → ((ϕ→ ψ) → (ϕ→ ξ)) 1) (A3) ((¬ϕ→ ¬ψ) → ((¬ϕ→ ψ) → ϕ) 1)\nInference rules:\n(GMP) (ϕ α), (ϕ→ ψ β) ⊢ (ψ min{α, β}) (S) (ϕ α) ⊢ (ϕ β) if β ≤ α\nAccording to Dubois et al., in (Dubois et al. 1994), basically we need a complete lattice to express the levels of uncertainty in Possibilistic Logic. Dubois et al. extended the axioms schemata and the inference rules for considering partially ordered sets. We shall denote by ⊢PL the inference under Possibilistic Logic without paying attention to whether the necessity-valued formulæ are using a totally ordered set or a partially ordered set for expressing the levels of uncertainty.\nThe problem of inferring automatically the necessity-value of a classical formula from a possibilistic base was solved by an extended version of resolution for possibilistic logic (see (Dubois et al. 1994) for details).\nOne of the main principles of possibilistic logic is that:\nRemark 2 The strength of a conclusion is the strength of the weakest argument used in its proof.\nAccording to Dubois and Prade (Dubois and Prade 2004), the contribution of possibilistic logic setting is to relate this principle (measuring the validity of an inference chain by its weakest link) to fuzzy set-based necessity measures in the framework of Zadeh’s possibilistic theory, since the following pattern then holds:\nN(∼ p ∨ q) ≥ α and N(p) ≥ β imply N(q) ≥ min(α, β)\nThis interpretive setting provides a semantic justification to the claim that the weight attached to a conclusion should be the weakest among the weights attached to the formulæ involved in the derivation."
    }, {
      "heading" : "3 Syntax",
      "text" : "In this section, the general syntax for possibilistic disjunctive logic programs will be presented. This syntax is based on the standard syntax of extended disjunctive logic programs (see Section 2.2).\nWe start by defining some concepts for managing the possibilistic values of a possibilistic knowledge base7. We want to point out that in the whole document only finite lattices are considered. This assumption was made based on the recognition that in real applications we will rarely have an infinite set of labels for expressing the incomplete state of a knowledge base.\nA possibilistic atom is a pair p = (a, q) ∈ A×Q, in which A is a finite set of atoms and\n7 Some concepts presented in this section extend some terms presented in (Nicolas et al. 2006).\n(Q,≤) is a lattice. The projection ∗ to a possibilistic atom p is defined as follows: p∗ = a. Also given a set of possibilistic atoms S, ∗ over S is defined as follows: S∗ = {p∗|p ∈ S}.\nLet (Q,≤) be a lattice. A possibilistic disjunctive clause R is of the form:\nα : A ← B+, not B−\nin which α ∈ Q and A ← B+, not B− is an extended disjunctive clause as defined in Section 2.2. The projection ∗ for a possibilistic clause is R∗ = A ← B+, not B−. On the other hand, the projection n for a possibilistic clause is n(R) = α. This projection denotes the degree of necessity captured by the certainty level of the information described by R. A possibilistic constraint C is of the form:\n⊤Q : ← B +, not B−\nin which ⊤Q is the top of the lattice (Q,≤) and ← B+, not B− is a constraint as defined in Section 2.2. The projection ∗ for a possibilistic constraint C is: C∗ = ← B+, not B−. Observe that the possibilistic constraints have the top of the lattice (Q,≤) as an uncertain value, this assumption is due to the fact that similar a constraint in standard ASP, the purpose of a possibilistic constraint is to eliminate possibilistic models. Hence, it can be assumed that there is no doubt about the veracity of the information captured by a possibilistic constraint. However, as in standard ASP, one can define possibilistic constraints of the form: α : x ← B+, not B−, not x such that x is an atom which is not used in any other possibilistic clause and α ∈ Q. This means that the user can define possibilistic constraints with different levels of certainty.\nA possibilistic disjunctive logic program P is a tuple of the form 〈(Q,≤), N〉, in which N is a finite set of possibilistic disjunctive clauses and possibilistic constraints. The generalization of ∗ over P is as follows: P ∗ = {r∗|r ∈ N}. Notice that P ∗ is an extended disjunctive program. When P ∗ is a normal program, P is called a possibilistic normal program. Also, when P ∗ is a positive disjunctive program, P is called a possibilistic positive logic program and so on. A given set of possibilistic disjunctive clauses {γ, . . . , γ} is also represented as {γ; . . . ; γ} to avoid ambiguities with the use of the comma in the body of the clauses.\nGiven a possibilistic disjunctive logic program P = 〈(Q,≤), N〉, we define the α-cut and the strict α-cut of P , denoted respectively by Pα and Pα, by\nPα = 〈(Q,≤), Nα〉 such that Nα = {c|c ∈ N and n(c) ≥ α} Pα = 〈(Q,≤), Nα〉 such that Nα = {c|c ∈ N and n(c) > α}\nExample 3 In order to illustrate a possibilistic program, let us go back to our scenario described in Section 1. Let (Q, ) be the lattice of Figure 2 such that the relation A B means that A is less possible than B. The possibilistic program P := 〈(Q, ), N〉 will be the following set of possibilistic clauses: It is probable that if the organ donor has an infection, then the organ recipient can be infected or not after a graft:\nprobable: r_inf(present, T 2)∨ ¬r_inf(present, T 2)← action(transplant, T ),\nd_inf(present, T ), T 2 = T + 1.\nIt is confirmed that the organ’s functions can be: good, delayed and terminal after a graft.\nconfirmed: o(good_graft_funct, T 2)∨ o(delayed_graft_funct, T 2)∨ o(terminal_insufficient_funct, T 2)← action(transplant, T ), T 2 = T + 1.\nIt is confirmed that if the organ’s functions are terminally insufficient then a transplanting is necessary.\nconfirmed: action(transplant, T ) ← o(terminal_insufficient_funct, T ).\nIt is plausible that the clinical situation of the organ recipient can be stable if the functions of the graft are good.\nplausible: cs(stable, T ) ← o(good_graft_funct, T ).\nIt is plausible that the clinical situation of the organ recipient can be unstable if the functions of the graft are delayed.\nplausible: cs(unstable, T )← o(delayed_graft_funct, T ).\nIt is plausible that the clinical situation of the organ recipient can be of 0-urgency if the functions of the graft are terminally insufficient after the graft.\nplausible: cs(0-urgency, T 2)← o(terminal_insufficient_funct, T 2), action(transplant, T ), T 2 = T + 1.\nIt is certain that the doctor cannot do two actions at the same time.\ncertain: ← action(transplant, T ), action(wait, T ).\nIt is certain that a transplant cannot be done if the organ recipient is dead.\ncertain: ← action(transplant, T ), cs(dead, T ).\nThe initial state of the automata of Figure 1 is captured by the following possibilistic clauses:\ncertain: d_inf(present, 0). certain: ¬r_inf(present, 0). certain: o(terminal_insufficient_funct, 0). certain: cs(stable, 0)."
    }, {
      "heading" : "4 Semantics",
      "text" : "In §3, the syntax for any possibilistic disjunctive program was introduced, Now, in this section, a semantics for capturing these programs is studied. This semantics will be defined in terms of the standard definition of the answer set semantics (§2.4.1) and the proof theory of possibilistic logic (§2.5).\nAs sets of atoms are considered as interpretations, two basic operations between sets of possibilistic atoms are defined; also a relation of order between them is defined: Given a finite set of atoms A and a lattice (Q,≤), PS ′ = 2A×Q and\nPS = PS ′ \\ {A|A ∈ PS such that x ∈ A and Cardinality({(x, α)|(x, α) ∈ A}) ≥ 2}8\nObserve that PS ′ is the finite set of all the possibilistic atom sets induced by A and Q. Informally speaking, PS is the subset of PS ′ such that each set of PS has no atoms with different uncertain value.\nDefinition 5 Let A be a finite set of atoms and (Q,≤) be a lattice. ∀A,B ∈ PS, we define.\nA ⊓B = {(x,GLB({α, β})|(x, α) ∈ A ∧ (x, β) ∈ B} A ⊔B = {(x, α)|(x, α) ∈ A and x /∈ B∗} ∪\n{(x, α)|x /∈ A∗ and (x, α) ∈ B} ∪\n{(x,LUB({α, β})|(x, α) ∈ A and (x, β) ∈ B}. A ⊑ B ⇐⇒ A∗ ⊆ B∗, and ∀x, α, β, (x, α) ∈ A ∧ (x, β) ∈ B\nthen α ≤ β.\nThis definition is almost the same as Definition 7 presented in (Nicolas et al. 2006). The main difference is that in Definition 7 from (Nicolas et al. 2006) the operations ⊓ and ⊔ are defined in terms of the operators min and max instead of the operators GLB and LUB. Hence, the following proposition is a direct result of Proposition 6 of (Nicolas et al. 2006).\nProposition 1 (PS,⊑) is a complete lattice.\nBefore moving on, let us define the concept of i-greatest set w.r.t. PS as follows: Given M ∈ PS,M is an i-greatest set in PS iff ∄M ′ ∈ PS such that M ⊑M ′. For instance, let PS = {{(a, 1)}, {(a, 2)}, {(a, 2), (b, 1)}, {(a, 2), (b, 2)}}. One can see that PS has two i-greatest sets: {(a, 2)} and {(a, 2), (b, 2)}. The concept of i-greatest set will play a key role in the definition of possibilistic answer sets in order to infer possibilistic answer sets with optimal certainty values."
    }, {
      "heading" : "4.1 Possibilistic answer set semantics",
      "text" : "Similar to the definition of answer set semantics, the possibilistic answer set semantics is defined in terms of a syntactic reduction. This reduction is inspired by the GelfondLifschitz reduction.\n8 Cardinality is a function which returns the cardinality of a set.\nDefinition 6 (Reduction PM ) Let P = 〈(Q,≤), N〉 be a possibilistic disjunctive logic program, M be a set of atoms. P reduced by M is the positive possibilistic disjunctive logic program:\nPM := {(n(r) : A∩M ← B +)|r ∈ N,A∩M 6= ∅, B− ∩M = ∅,B+ ⊆M}\nin which r∗ is of the form A ← B+, not B−.\nNotice that (P ∗)M is not exactly equal to the Gelfond-Lifschitz reduction. For instance, let us consider the following programs:\nP : P{c,b} : (P ∗){c,b} :\nα1 : a ∨ b. α1 : b. a ∨ b. α2 : c← not a. α2 : c. c. α3 : c← not b.\nThe program P{c,b} is obtained from P and {c, b} by applying Definition 6 and the program (P ∗){c,b} is obtained from P ∗ and {c, b} by applying the Gelfond-Lifschitz reduction. Observe that the reduction of Definition 6 removes from the head of the possibilistic disjunctive clauses any atom which does not belong to M . As we will see in Section 4.2, this property will be helpful for characterizing the possibilistic answer set in terms of a fixed-point operator. It is worth mentioning that the reduction (P ∗)M also has a different effect from the Gelfond-Lifschitz reduction in the class of normal programs. This difference is illustrated in the following programs:\nP : P{a} : (P ∗){a} :\nα1 : a← not b. α1 : a. a. α2 : a← b. a← b. α3 : b← c. b← c.\nExample 4 Continuing with our medical scenario described in the introduction, let P be a ground instance of the possibilistic program presented in Example 3:\nprobable: r_inf(present, 1) ∨ no_r_inf(present, 1)← action(transplant, 0),\nd_inf(present, 0).\nconfirmed: o(good_graft_funct, 1) ∨ o(delayed_graft_funct, 1)∨ o(terminal_insufficient_funct, 1)← action(transplant, 0). confirmed: action(transplant, 0)← o(terminal_insufficient_funct, 0). plausible: cs(stable, 1)← o(good_graft_funct, 1). plausible: cs(unstable, 1)← o(delayed_graft_funct, 1). plausible: cs(0-urgency, 1)← o(terminal_insufficient_funct, 1),\naction(transplant, 0).\ncertain: ← action(transplant, 0), action(wait, 0). certain: ← action(transplant, 0), cs(dead, 0). certain: d_inf(present, 0). certain: no_r_inf(present, 0).\ncertain: o(terminal_insufficient_funct, 0). certain: cs(stable, 0).\nObserve that the variables of time T and T 2 were instantiated with the values 0 and 1 respectively; moreover, observe that the atoms¬r_inf(present, 0) and¬r_inf(present, 1) were replaced byno_r_inf(present, 0) andno_r_inf(present, 1) respectively. This change was applied in order to manage the strong negation, ¬ .\nNow, let S be the following possibilistic set:\nS = {(d_inf(present, 0), certain), (no_r_inf(present, 0), certain), (o(terminal_insufficient_funct, 0), certain), (cs(stable, 0), certain), (action(transplant, 0), confirmed), (o(good_graft_funct, 1), confirmed), (cs(stable, 1), plausible), (no_r_inf(present, 1), probable)}.\nOne can see that PS∗ is:\nprobable: no_r_inf(present, 1)← action(transplant, 0), d_inf(present, 0). confirmed: o(good_graft_funct, 1)← action(transplant, 0). confirmed: action(transplant, 0)← o(terminal_insufficient_funct, 0). plausible: cs(stable, 1)← o(good_graft_funct, 1). plausible: cs(unstable, 1)← o(delayed_graft_funct, 1). plausible: cs(0-urgency, 1)← o(terminal_insufficient_funct, 1),\naction(transplant, 0).\ncertain: ← action(transplant, 0), action(wait, 0). certain: ← action(transplant, 0), cs(dead, 0). certain: d_inf(present, 0). certain: no_r_inf(present, 0). certain: o(terminal_insufficient_funct, 0). certain: cs(stable, 0).\nOnce a possibilistic logic programP has been reduced by a set of possibilistic atomsM , it is possible to test whetherM is a possibilistic answer set of the program P . For this end, we consider a syntactic approach; meaning that it is based on the proof theory of possibilistic logic. Let us remember that the possibilistic logic is axiomatizable (Dubois et al. 1994); hence, the inference in possibilistic logic can be managed by both a syntactic approach (axioms and inference rules) and a possibilistic model theory approach (interpretations and possibilistic distributions).\nSince the certainty value of a possibilistic disjunctive clause can belong to a partially ordered set, the inference rules of possibilistic logic introduced in Section 2.5 have to be generalized in terms of bounds. The generalization of GMP and S is defined as follows:\n(GMP*) (ϕ α), (ϕ → ψ β) ⊢ (ψ GLB{α, β}) (S*) (ϕ α), (ϕ β) ⊢ (ϕ γ), where γ ≤ GLB{α, β}\nObserve that these inference rules are essentially the same as the inference rules introduced in Section 2.5; however, they are defined in terms of GLB to lead with certainty values which are not comparable (in Example 6 these inference rules are illustrated).\nOnce we have defined GMP ∗ and S∗, the inference PL is defined as follows:\nDefinition 7 Let P = 〈(Q,≤), N〉 be a possibilistic disjunctive logic program and M ∈ PS.\n• We write P PL M when M∗ is an answer set of P ∗ and PM∗ ⊢PL M .\nOne can see that PL is defining a joint inference between the answer set semantics and the proof theory of possibilistic logic. Let us consider the following example.\nExample 5 Let P = 〈(Q,≤), N〉 be a possibilistic disjunctive logic program such that Q = {0.1, . . . , 0.9}, ≤ denotes the standard relation in real numbers and N is the following set of possibilistic clauses:\n0.6 : a ∨ b. 0.4 : a← not b. 0.8 : b← not a.\nIt is easy to see that P ∗ has two answer sets: {a} and {b}. On the other hand, one can see that P{a} ⊢PL {(a, 0.6)}, P{a} ⊢PL {(a, 0.4)}, P{b} ⊢PL {(b, 0.6)} and P{b} ⊢PL {(b, 0.8)}. This means that P PL {(a, 0.6)}, P PL {(a, 0.4)}, P PL {(b, 0.6)} and P PL {(b, 0.8)}.\nThe basic idea of PL is to identify candidate sets of possibilistic atoms in order to consider them as possibilistic answer sets. The following proposition formalizes an important property of PL.\nProposition 2 Let P = 〈(Q,≤), N〉 be a possibilistic disjunctive logic program and M1,M2 ∈ PS such that M∗1 =M ∗ 2 . If P PL M1 and P PL M2, then P PL M1 ⊔M2.\nIn this proposition, since M1 andM2 are two sets of possibilistic atoms, LUB is instantiated in terms of ⊑. By considering PL and the concept of i-greatest set, a possibilistic answer set is defined as follows:\nDefinition 8 (A possibilistic answer set) Let P = 〈(Q,≤), N〉 be a possibilistic disjunctive logic program and M be a set of possibilistic atoms such that M∗ is an answer set of P ∗. M is a possibilistic answer set of P iff M is an i-greatest set in PS such that P PL M .\nEssentially, a possibilistic answer set is an i-greatest set which is inferred by PL. In other words, a possibilistic answer set is an answer set with optimal certainty values. For instance, in Example 5, we saw that P PL {(a, 0.6)}, P PL {(a, 0.4)}, P PL {(b, 0.6)} andP PL {(b, 0.8)}; however, {(a, 0.4)} and {(b, 0.6)} are not i-greatest sets. This means that the possibilistic answer sets of the possibilistic program P of Example 5 are: {(a, 0.6)} and {(b, 0.8)}.\nExample 6 Let P be again the possibilistic program of Example 3 and S be the possibilistic set of atoms introduced in Example 4.\nOne can see that S∗ is an answer set of the extended disjunctive program P ∗. Hence, in order to prove that P PL S, we have to verify that PS∗ ⊢PL S. This means that for each\npossibilistic atom p ∈ S, PS∗ ⊢PL p. It is clear that\nPS∗ ⊢PL {(d_inf(present, 0), certain), (no_r_inf(present, 0), certain), (o(terminal_insufficient_funct, 0), certain), (cs(stable, 0), certain)}\nNow let us prove (cs(stable, 1), plausible) from PS∗ .\nPremises from PS∗ 1. o(terminal_insufficient_funct, 0) certain 2. o(terminal_insufficient_funct, 0)→ action(transplant, 0) confirmed 3. action(transplant, 0)→ o(good_graft_funct, 1) confirmed 4. o(good_graft_funct, 1)→ cs(stable, 1) plausible From 1 and 2 by GMP* 5. action(transplant, 0) confirmed From 3 and 5 by GMP* 6. o(good_graft_funct, 1) confirmed From 4 and 6 by GMP* 7. cs(stable, 1). plausible\nIn this proof, we can also see the inference of the possibilistic atom (action(transplant, 0), confirmed). The proof of the possibilistic atom (no_r_inf(present, 1), probable) is similar to the proof of the possibilistic atom (cs(stable, 1), plausible). Therefore,PS∗ ⊢PL S is true. Notice that a possibilistic set S′ such that S′ 6= S, P(S′)∗ ⊢PL S′ and S ⊑ S′ does not exists; hence, S is an i-greatest set. Then, S is a possibilistic answer set of P . By considering the possibilistic answer set S, what can we conclude about our medical scenario from S? We can conclude that if it is confirmed that a transplant is performed on a donor with an infection, it is probable that the recipient will not be infected after the transplant; moreover it is plausible that he will be stable. It is worth mentioning that this optimistic conclusion is just one of the possible scenarios that we can infer from the program P . In fact, the program P has six possibilistic answer sets in which we can find pessimistic scenarios such as it is probable that the recipient will be infected by the organ donor’s infection and; moreover, it is confirmed that the recipient needs another transplant.\nNow, let us identify some properties of the possibilistic answer set semantics. First, observe that there is an important condition w.r.t. the definition of a possibilistic answer set which is introduced by PL: a possibilistic set S cannot be a possibilistic answer set of a possibilistic logic program P if S∗ is not an answer set of the extended logic program P ∗. This condition guarantees that any clause of P ∗ is satisfied by S∗. For instance, let us consider the possibilistic logic program P :\n0.4 : a. 0.6 : b.\nand the possibilistic set S = {(a, 0.4)}. We can see that PS∗ ⊢PL S; however,S∗ is not an answer set of P ∗. Therefore, P PL S is false. Then S could not be a possibilistic answer set of P . This suggests, a direct relationship between the possibilistic answer semantics and the answer set semantics.\nProposition 3\nLet P be a possibilistic disjunctive logic program. If M is a possibilistic answer set of P then M∗ is an answer set of P ∗.\nWhen all the possibilistic clauses of a possibilistic program P have the same certainly level, the answer sets of P ∗ can be directly generalized to the possibilistic answer sets of P .\nProposition 4 Let P = 〈(Q,≤), N〉 be a possibilistic disjunctive logic program and α be a fixed element of Q. If ∀r ∈ P , n(r) = α and M ′ is an answer set of P ∗, then M := {(a, α)|a ∈M ′} is a possibilistic answer set of P .\nFor the class of possibilistic normal logic programs which are defined with a totally ordered set, our definition of possibilistic answer set is closely related to the definition of a possibilistic stable model presented in (Nicolas et al. 2006). In fact, both semantics coincide.\nProposition 5 Let P := 〈(Q,≤), N〉 be a possibilistic normal program such that (Q,≤) is a totally ordered set and LP has no extended atoms. M is a possibilistic answer set of P if and only if M is a possibilistic stable model of P .\nTo prove that the possibilistic answer set semantics is computable, we will present an algorithm for computing possibilistic answer sets. With this in mind, let us remember that a classical resolvent is defined as follows: Assume that C and D are two clauses in their disjunctive form such that C = a∨ l1 ∨ · · · ∨ ln and D =∼ a∨ ll1 ∨ · · · ∨ llm. The clause l1 ∨ · · · ∨ ln ∨ ll1 ∨ · · · ∨ llm is called a resolvent of C and D w.r.t. a. Thus clauses C and D have a resolvent in case a literal a exists such that a appears in C and ∼ a appears in D (or conversely).\nNow, let us consider a straightforward generalization of the possibilistic resolution rule introduced in (Dubois et al. 1994):\n(R) (c1 α1)(c2 α2) ⊢ (R(c1, c2) GLB({α1, α2}))\nin whichR(c1, c2) is any classical resolvent of c1 and c2 such that c1 and c2 are disjunctions of literals. It is worth mentioning that it is easy to transform any possibilistic disjunctive logic program P into a set of possibilistic disjunctions C. Indeed, C can be obtained as follows:\nC := ⋃\n{(a1 ∨ . . . ∨ am∨ ∼ am+1 ∨ · · · ∨ ∼ aj ∨ aj+1 ∨ . . . , an α)|\n(α : a1 ∨ . . . ∨ am ← am+1, . . . , aj , not aj+1, . . . , not an) ∈ P}\nLet us remember that whenever a possibilistic program is considered as a possibilistic theory, each negative literal not a is replaced by∼ a such that ∼ is regarded as the negation in classic logic — in Example 7, the transformation of a possibilistic program into a set of possibilistic disjunctions is shown.\nThe following proposition shows that the resolution rule (R) is sound.\nProposition 6\nLet C be a set of possibilistic disjunctions, andC = (c α) be a possibilistic clause obtained by a finite number of successive application of (R) to C; then C ⊢PL C.\nLike the possibilistic rule introduced in (Dubois et al. 1994), (R) is complete for refutation. We will say that a possibilistic disjunctive program P is consistent if P has at least a possibilistic answer set. Otherwise P is said to be inconsistent. The degree of inconsistency of a possibilistic logic program P is Inc(P ) = GLB({α|Pα is consistent }).\nProposition 7\nLet P be a set of possibilistic clauses and C be the set of possibilistic disjunctions obtained fromP ; then the valuation of the optimal refutation by resolution from C is the inconsistent degree of P .\nThe main implication of Proposition 6 and Proposition 7 is that (R) suggests a method for inferring a possibilistic formula from a possibilistic knowledge base.\nCorollary 1\nLet P := 〈(Q,≤), N〉 be a possibilistic disjunctive logic program, ϕ be a literal and C be a set of possibilistic disjunctions obtained from N ∪ {(∼ ϕ ⊤Q)}; then the valuation of the optimal refutation from C is n(ϕ), that is P ⊢PL (ϕ n(ϕ)).\nBased on the fact that the resolution rule (R) suggests a method for inferring the necessity value of a possibilistic formula, we can define the following function for computing the possibilistic answer sets of a possibilistic program P . In this function, denotes an empty clause.\nFunction Poss_Answer_Sets(P ) Let ASP (P ∗) be a function that computes the answer set models of the standard logic program P ∗, for example DLV (DLV 1996).\nPoss-ASP := ∅ For all S ∈ ASP (P ∗)\nLet C be the set of possibilistic disjunctions obtained from PS . S′ := ∅ for all a ∈ S C′ := C ∪ {(∼ a ⊤Q)}\nSearch for a deduction of (R( ) α) by applying repeatedly the resolution rule (R) from C′, with α maximal. S′ := S′ ∪ {(a α)}\nendfor Poss-ASP := Poss-ASP ∪ S′\nendfor return(Poss-ASP).\nThe following proposition proves that the function Poss_Answer_Sets computes all the possibilistic answer sets of a possibilistic logic program.\nProposition 8\nLet P := 〈(Q,≤), N〉 be a possibilistic logic program. The set Poss-ASP returned by Poss_Answer_Sets(P ) is the set of all the possibilistic answer sets of P .\nIn order to illustrate this algorithm, let us consider the following example:\nExample 7\nLet P := 〈(Q,≤), N〉 be a possibilistic program such that Q := {0, 0.1, . . . , 0.9, 1}, ≤ is the standard relation between rational numbers and N the following set of possibilistic clauses:\n0.7 : a ∨ b ← not c. 0.6 : c ← not a, not b. 0.8 : a ← b. 0.9 : e ← b. 0.6 : b ← a. 0.5 : b ← a.\nFirst of all, we can see that P ∗ has two answer sets: S1 := {a, b, e} and S2 := {c}. This means that P has two possibilistic answer set models. Let us consider S1 for our example. Then, one can see that PS1 is:\n0.7 : a ∨ b. 0.8 : a ← b. 0.9 : e ← b. 0.6 : b ← a. 0.5 : b ← a.\nThen C := {(a∨b 0.7), (a∨ ∼ b 0.8), (e∨ ∼ b 0.9), (b∨ ∼ a 0.6), (b∨ ∼ a 0.5)}. In order to infer the necessity value of the atom a, we add (∼ a 1) to C and a search for finding an optimal refutation is applied. As we can see in Figure 3, there are three refutations, however the optimal refutation is ( 0.7). This means that the best necessity value for the atom a is 0.7.\nIn Figure 4, we can see the optimal refutation search for the atom b. As we can see the optimal refutation is ( 0.6); hence the best necessity value for the atom b is 0.6.\nIn Figure 5, we can see that the best necessity value for the atom e is 0.6.\nThought the search, we can infer that a possibilistic answer set of the program P is : {(a, 0.7), (b, 0.6), (e, 0.6)}."
    }, {
      "heading" : "4.2 Possibilistic answer sets based on partial evaluation",
      "text" : "We have defined a possibilistic answer set semantics by considering the formal proof theory of possibilistic logic. However, in standard logic programming there are several frameworks for analyzing, defining and computing logic programming semantics (Dix 1995a; Dix 1995b). One of these approaches is based on program transformations, in fact there are many studies on this approach, for example (Brass and Dix 1999; Brass and Dix 1997; Brass and Dix 1998; Dix et al. 2001). For the case of disjunctive logic program, one important transformation is partial evaluation (also called unfolding) (Brass and Dix 1999).\nThis section shows that it is also possible to define a possibilistic disjunctive semantics based on an operator which is a combination between partial evaluation for disjunctive logic programs and the infer rule GMP ∗ of possibilistic logic. This semantics has the same behavior as the semantics based on the proof theory of possibilistic logic.\nThis section starts by defining a version of the general principle of partial evaluation (GPPE) for possibilistic positive disjunctive clauses.\nDefinition 9 (Grade-GPPE (G-GPPE)) Let r1 be a possibilistic clause of the form α : A ← B+∪{B} and r2 a possibilistic clause of the form α1 : A1 such that B ∈ A1 and B /∈ B+, then\nG-GPPE(r1, r2) = (GLB({α, α1}) : A ∪ (A1 \\ {B}) ← B+)\nObserve that one of the possibilistic clauses which is considered by G-GPPE has an empty body. For instance, let us consider the following two possibilistic clauses:\nr1 = 0.7 : a ∨ b. r2 = 0.9 : e← b.\nThen G-GPPE(r1, r2) = (0.7 : e ∨ a). Now, by considering G-GPPE, we will define the operator T .\nDefinition 10 Let P be a possibilistic positive logic program. The operator T is defined as follows:\nT (P ) := P ∪ {G-GPPE(r1, r2)|r1, r2 ∈ P}\nIn order to illustrate the operator T , let us consider the program PS1 of Example 7.\n0.7 : a ∨ b. 0.8 : a ← b. 0.9 : e ← b. 0.6 : b ← a. 0.5 : b ← a.\nHence, T (PS1) is:\n0.7 : a ∨ b. 0.7 : a. 0.8 : a← b. 0.7 : e ∨ a. 0.9 : e← b. 0.6 : b. 0.6 : b← a. 0.5 : b. 0.5 : b← a.\nNotice that by considering the possibilistic clauses that were added to PS1 by T , one can reapply G-GPPE. For instance, if we consider 0.6 : b and 0.9 : e ← b from T (PS1), G-GPPE infers 0.6 : e. Indeed, T (T (PS1)) is:\n0.7 : a ∨ b. 0.7 : a. 0.6 : a. 0.8 : a← b. 0.7 : e ∨ a. 0.5 : a. 0.9 : e← b. 0.6 : b. 0.6 : e. 0.6 : b← a. 0.5 : b. 0.5 : e. 0.5 : b← a. 0.6 : b ∨ e.\n0.5 : b ∨ e.\nAn important property of the operator T is that it always reaches a fixed-point.\nProposition 9 Let P be a possibilistic disjunctive logic program. If Γ0 := T (P ) and Γi := T (Γi−1) such that i ∈ N , then ∃ n ∈ N such that Γn = Γn−1. We denote Γn by Π(P ).\nLet us consider again the possibilistic program PS1 . We can see that Π(PS1) is:\n0.7 : a ∨ b. 0.7 : a. 0.6 : a. 0.6 a ∨ e. 0.8 : a← b. 0.7 : e ∨ a. 0.5 : a. 0.5 a ∨ e. 0.9 : e← b. 0.6 : b. 0.6 : e. 0.6 : b← a. 0.5 : b. 0.5 : e. 0.5 : b← a. 0.6 : b ∨ e.\n0.5 : b ∨ e.\nObserve that in Π(PS1) there are possibilistic facts (possibilistic clauses with empty bodies and one atom in their heads) with different necessity value. In order to infer the optimal necessity value of each possibilistic fact, one can consider the least upper bound of these values. For instance, the optimal necessity value for the possibilistic atom a is LUB({0.7, 0.6, 0.5}) = 0.7. Based on this idea, Semmin is defined as follows.\nDefinition 11 Let P be a possibilistic logic program and Facts(P, a) := {(α : a)|(α : a) ∈ P}. Semmin(P ) := {(x, α)|Facts(P, x) 6= ∅ and α := LUB({n(r)|r ∈ Facts(P, x)})} in which x ∈ LP .\nIt is easy to see that Semmin(Π(PS1)) is {(a, 0.7), (b, 0.6), (e, 0.6)}. Now by considering the operator T and Semmin, we can define a semantics for possibilistic disjunctive logic programs that will be called possibilistic-T answer set semantics.\nDefinition 12 Let P be a possibilistic disjunctive logic program and M be a set of possibilistic atoms such that M∗ is an answer set of P ∗. M is a possibilistic-T answer set of P if and only if M = Semmin(Π(PM∗)).\nIn order to illustrate this definition, let us consider again the programP of Example 7 and S = {(a, 0.7), (b, 0.6), (e, 0.6)}. As commented in Example 7, S∗ is an answer set of P ∗. We have already seen that Semmin(Π(PS1 )) is {(a, 0.7), (b, 0.6), (e, 0.6)}, therefore we can say that S is a possibilistic-T answer set of P . Observe that the possibilistic-T answer set semantics and the possibilistic answer set semantics coincide. In fact, the following proposition guarantees that both semantics are the same.\nProposition 10 Let P be a possibilistic disjunctive logic program and M a set of possibilistic atoms. M is a possibilistic answer set of P if and only if M is a possibilistic-T answer set of P ."
    }, {
      "heading" : "5 Inconsistency in possibilistic logic programs",
      "text" : "In the first part of this section, the relevance of considering inconsistent possibilistic knowledge bases is introduced, and in the second part, some criteria for managing inconsistent possibilistic logic programs are introduced."
    }, {
      "heading" : "5.1 Relevance of inconsistent possibilistic logic programs",
      "text" : "Inconsistent knowledge bases are usually regarded as an epistemic hell that have to be avoided at all costs. However, many times it is difficult or impossible to stay away from managing inconsistent knowledge bases. There are authors such as Octávio Bueno (Bueno 2006) who argues that the consideration of inconsistent systems is a useful device for a number of reasons: (1) it is often the only way to explore inconsistent information without arbitrarily rejecting precious data. (2) inconsistent systems are sometimes the only way to obtain new information (particularly information that conflicts with deeply entrenched theories). As a result, (3) inconsistent belief systems allow us to make better informed decisions regarding which bits of information to accept or reject in the end.\nIn order to give a small example, in which exploring inconsistent information can be important for making a better informed decision, we will continue with the medical scenario described in Section 1. In Example 4, we have already presented the grounded program Pinfections of our medical scenario:\nprobable: r_inf(present, 1) ∨ no_r_inf(present, 1)← action(transplant, 0),\nd_inf(present, 0).\nconfirmed: o(good_graft_funct, 1) ∨ o(delayed_graft_funct, 1)∨\no(terminal_insufficient_funct, 1)← action(transplant, 0).\nconfirmed: action(transplant, 0)← o(terminal_insufficient_funct, 0). plausible: cs(stable, 1)← o(good_graft_funct, 1). plausible: cs(unstable, 1)← o(delayed_graft_funct, 1). plausible: cs(0-urgency, 1)← o(terminal_insufficient_funct, 1),\naction(transplant, 0).\ncertain: ← action(transplant, 0), action(wait, 0). certain: ← action(transplant, 0), cs(dead, 0). certain: d_inf(present, 0). certain: no_r_inf(present, 0). certain: o(terminal_insufficient_funct, 0). certain: cs(stable, 0).\nAs mentioned in Example 4, in this program the atoms ¬r_inf(present, 0) and ¬r_inf(present, 1) were replaced by no_r_inf(present, 0) and no_r_inf(present, 1) respectively. Usually in standard answer set programming, the constraints\n← no_r_inf(present, 0), r_inf(present, 0). ← no_r_inf(present, 1), no_r_inf(present, 1).\nmust be added to the program to avoid inconsistent answer sets. In order to illustrate the role of these kinds of constraints, let C1 be the following possibilistic constraints:\ncertain: ← no_r_inf(present, 0), r_inf(present, 0). certain: ← no_r_inf(present, 1), no_r_inf(present, 1).\nAlso let us consider three new possibilistic clauses (denoted by Pv):\nconfirmed: v(kidney, 0) ← cs(stable, 1), action(transplant, 0). probable: no_v(kidney, 0) ← r_inf(present, 1), action(transplant, 0). certain: ← not cs(stable, 1).\nThe intended meaning of the predicate v(t, T ) is that the organ t is viable for a transplant and T denotes a moment in time. Observe that we replaced the atom ¬v(kidney, 0) with no_v(kidney, 0). The reading of the first clause is that if the clinical situation of the organ recipient is stable after the graft, then it is confirmed that the kidney is viable for transplant. The reading of the second one is that if the organ recipient is infected after the graft, then it is plausible that the kidney is not viable for transplant. The aim of the possibilistic constraint is to discard scenarios in which the clinical situation of the organ recipient is not stable. Let us consider the respective possibilistic constraint w.r.t. the atoms no_v(kidney, 0) and v(kidney, 0) (denoted by C2):\ncertain: ← no_v(kidney, 0), v(kidney, 0).\nTwo programs are defined:\nP := Pinfections ∪ Pv and Pc := Pinfections ∪ Pv ∪ C1 ∪ C2\nBasically, the difference between P and Pc is that P allows inconsistent possibilistic models and Pc does not allow inconsistent possibilistic models.\nNow let us consider the possibilistic answer sets of the programs P and Pc. One can see that the program Pc has just one possibilistic answer set:\n{(d_inf(present, 0), certain), (no_r_inf(present, 0), certain), (o(terminal_insufficient_funct, 0), certain), (cs(stable, 0), certain), (action(transplant, 0), confirmed), (o(good_graft_funct, 1), confirmed), (cs(stable,1), plausible), (no_r_inf(present,1), probable), (v(kidney,0), plausible)}\nThis possibilistic answer set suggests that since it is plausible that the recipient’s clinical situation will be stable after the graft, it is plausible that the kidney is viable for transplanting. Observe that the possibilistic answer sets of P do not show the possibility that the organ recipient could be infected after the graft.\nLet us consider the possibilistic answer set of the program P :\nS1 := {(d_inf(present, 0), certain), (no_r_inf(present, 0), certain), (o(terminal_insufficient_funct, 0), certain), (cs(stable, 0), certain), (action(transplant, 0), confirmed), (o(good_graft_funct, 1), confirmed), (cs(stable,1), plausible), (no_r_inf(present,1), probable), (v(kidney,0), plausible)}\nS2 := {(d_inf(present, 0), certain), (no_r_inf(present, 0), certain),\n(o(terminal_insufficient_funct, 0), certain), (cs(stable, 0), certain), (action(transplant, 0), confirmed), (o(good_graft_funct, 1), confirmed), (cs(stable,1), plausible), (r_inf(present,1), probable), (v(kidney,0), plausible), (no_v(kidney,0), probable)}\nP has two possibilistic answer sets: S1 and S2. S1 corresponds to the possibilistic answer set of the program Pc and S2 is an inconsistent possibilistic answer set — because the atoms (v(kidney,0), plausible) and (no_v(kidney,0), probable) appear in S2. Observe that although S2 is an inconsistent possibilistic answer set, it contains important information w.r.t. the considerations of our scenario. S2 suggests that even though it is plausible that the clinical situation of the organ recipient will be stable after the graft, it is also probable that the organ recipient will be infected by the infection of the donor’s organ.\nObserve that Pc is unable to infer the possibilistic answer set S2; because, it contains the following possibilistic constraint:\ncertain: ← no_v(kidney, 0), v(kidney, 0).\nBy defining these kinds of constraints, we can guarantee that any possibilistic answer set inferred from Pc will be consistent; however, one can omit important considerations w.r.t. a decision-making problem. In fact, we agree with Bueno (Bueno 2006) that considering inconsistent systems as inconsistent possibilistic answer sets is some times the only way to explore inconsistent information without arbitrarily rejecting precious data."
    }, {
      "heading" : "5.2 Inconsistency degrees of possibilistic sets",
      "text" : "To manage inconsistent possibilistic answer sets, it is necessary to define a criterion of preference between possibilistic answer sets. In order to define a criterion between possibilistic answer sets, the concept of inconsistency degree of a possibilistic set is defined. We say that a set of possibilistic atoms S is inconsistent (resp. consistent) if and only if S∗ is inconsistent (resp. consistent), that is to say there is an atom a such that a,¬a ∈ S∗.\nDefinition 13 Let A ∈ SP . The inconsistent degree of S is defined as follows:\nInconsDegre(S) :=\n{\n⊥Q if S∗ is consistent GLB({α|Sα is consistent}) otherwise\nin which ⊥Q is the bottom of the lattice (Q,≤) and Sα := {(a, α1) ∈ S|α1 ≥ α}.\nFor instance, the possibilistic answer set S2 of our example above has a degree of inconsistency of confirmed. Based on the degree of inconsistency of possibilistic sets, we can define a criterion of preference between possibilistic answer sets.\nDefinition 14 Let P = 〈(Q,≤), N〉 be a possibilistic program and M1, M2 two possibilistic answer sets of P . We say that M1 is more-consistent than M2 if and only if InconsDegre(M1) < InconsDegre(M2).\nIn our example above, it is obvious that S1 is more-consistent than S2. In general terms, a possibilistic answer set M1 is preferred to M2 if and only if M1 is more-consistent than M2. This means that any consistent possibilistic answer set will be preferred to any inconsistent possibilistic answer set.\nSo far we have commented only on the case of inconsistent possibilistic answer sets. However, there are possibilistic programs that are inconsistent because they have no possibilistic answer sets. For instance, let us consider the following possibilistic program Pinc (we are assuming the lattice of Example 7):\n0.3 : a← not b. 0.5 : b← not c. 0.6 : c← not a.\nObserve that P ∗inc has no answer sets; hence, Pinc has no possibilistic answer sets."
    }, {
      "heading" : "5.3 Restoring inconsistent possibilistic knowledge bases",
      "text" : "In order to restore consistency of an inconsistent possibilistic knowledge base, possibilistic logic eliminates the set of possibilistic formulæ which are lower than the inconsistent degree of the inconsistent knowledge base. Considering this idea, the authors of (Nicolas et al. 2006) defined the concept of α-cut for possibilistic logic programs. Based on Definition 14 of (Nicolas et al. 2006), we define its respective generalization for our approach.\nDefinition 15 Let P be a possibilistic logic program\n- the strict α-cut is the subprogram P>α = {r ∈ P |n(r) > α} - the consistency cut degree of P :\nConsCutDeg(P ) :=\n{\n⊥Q if P ∗ is consistent GLB({α|Pα is consistent}) otherwise\nwhere ⊥Q is the bottom of the lattice (Q,≤).\nNotice that the consistency cut degree of a possibilistic logic program identifies the minimum level of certainty for which a strict α-cut of P is consistent. As Nicolas et al., remarked in (Nicolas et al. 2006), by the non-monotonicity of the framework, it is not certain that a higher cut is necessarily consistent.\nIn order to illustrate these ideas, let us reconsider the program Pinc. First, one can see that ConsCutDeg(Pinc) = 0.3; hence, the subprogram PConsCutDeg(Pinc) is:\n0.5 : b← not c. 0.6 : c← not a.\nObserve that this program has a possibilistic answer set which is {(c, 0.6)}. Hence due to the strict α-cut of P , one is able to infer information from Pinc\nTo resume, one can identify two kinds of inconsistencies in our approach,\n• one which arises from the presence of complementary atoms in a possibilistic answer set and • one which arises from the non-existence of a possibilistic answer set of a possibilistic logic program.\nTo manage the inconsistency of possibilistic answer sets, a criterion of preference between possibilistic answer sets was defined. On the other hand, to manage the non-existence of a possibilistic answer set of a possibilistic logic program P , the approach suggested by Nicolas et al. in (Nicolas et al. 2006), was adopted. This approach is based on α-cuts in order to get consistent subprograms of a given program P ."
    }, {
      "heading" : "6 Related Work",
      "text" : "Research on logic programming with uncertainty has dealt with various approaches of logic programming semantics, as well as different applications. Most of the approaches in the literature employ one of the following formalisms:\n• annotated logic programming, e.g. (Kifer and Subrahmanian 1992). • probabilistic logic, e.g. (Ng and Subrahmanian 1992; Lukasiewicz 1998; Kern-Isberner and Lukasiewicz 2004;\nBaral et al. 2009). • fuzzy set theory, e.g. (van Emden 1986; Rodríguez-Artalejo and Romero-Díaz 2008;\nVan-Nieuwenborgh et al. 2007). • multi-valued logic, e.g. (Fitting 1991; Lakshmanan 1994). • evidence theoretic logic programming, e.g. (Baldwin 1987). • possibilistic logic, e.g. (Dubois et al. 1991; Alsinet and Godo 2002; Alsinet and Godo 2000;\nAlsinet et al. 2008; Nicolas et al. 2006).\nBasically, these approaches differ in the underlying notion of uncertainty and how uncertainty values, associated with clauses and facts, are managed. Among these approaches, the formalisms based on possibilistic logic are closely related to the approach presented in this paper. A clear distinction betweem them and the formalism of this paper is that none of them capture disjunctive clauses. On the other hand, excepting the work of Nicolas, et al., (Nicolas et al. 2006), none of these approaches describe a formalism for dealing with uncertainty in a logic program with default negation by means of possibilistic logic. Let us recall that the work of (Nicolas et al. 2006) is totally captured by the formalism presented in this paper (Proposition 5), but not directly vice versa. For instance, let us consider the possibilistic logic programs P = 〈({0.1, . . . , 0.9},≤), N〉 such that ≤ is the standard relation between rational number and N the following set of possibilistic clauses:\n0.5 : a ∨ b. 0.5 : a← b.\n0.5 : b← a.\nBy considering a standard transformation from disjunctive clauses to normal clauses (Baral 2003), this program can be transformed to the possibilistic normal logic programs P ′:\n0.5 : a← not b. 0.5 : a← b. 0.5 : b← not a. 0.5 : b← a.\nOne can see that P has a possibilistic answer set: {(a, 0.5), (b, 0.5)}; however, P ′ has no possibilistic answer sets.\nEven though, one can find a wide range of formalisms for dealing with uncertainty by using normal logic programs, there are few proposals for dealing with uncertainty by using disjunctive logic programs (Lukasiewicz 2001; Gergatsoulis et al. 2001; Mateis 2000; Baral et al. 2009):\n• In (Lukasiewicz 2001), Many-Valued Disjunctive Logic Programs with probabilistic semantics are introduced. In this approach, probabilistic values are associated with each clause. Like our approach, Lukasiewicz considers partial evaluation for characterizing different semantics by means of probabilistic theory. • In (Gergatsoulis et al. 2001), the logic programming language Disjunctive Chronolog is introduced. This approach combines temporal and disjunctive logic programming. Disjunctive Chronolog is capable of expressing dynamic behaviour as well as uncertainty. In this approach, like our semantics, it is shown that logic semantics of these programs can be characterized by a fixed- point semantics. • In (Mateis 2000), the Quantitative Disjunctive Logic Programs (QDLP) are introduced. These programs associate an reliability interval with each clause. Different triangular norms (T-norms) are employed to define calculi for propagating uncertainty information from the premises to the conclusion of a quantitative rule; hence, the semantics of these programs is parameterized. This means that each choice of a T-norm induces different QDLP languages. • In (Baral et al. 2009), intensive research is done in order to achieve a complete integration between ASP and probability theory. This approach is similar to the approach presented in this paper; but it is in the context of probabilistic theory.\nWe want to point out that the syntactic approach of this paper is motivated by the fact that the possibilistic logic is axiomatizable; therefore, a proof theory approach (axioms and inference rules) leads to constructions of a possibilistic semantics such as a logic inference. This kind of possibilistic framework allows us to explore extensions of the possibilistic answer set semantics by considering the inference of different logics. In fact, by considering a syntactic approach, one can explore properties such as strong equivalence and free-syntax programs. This means that the exploration of a syntactic approach leads to important implications such as the implications of an approach based on interpretations and possibilistic distributions.\nThe consideration of axiomatizations of given logics has shown to be a generic approach for characterizing logic programming semantics. For instance, the answer set semantics inference can be characterized as a logic inference in terms of the proof theory of intuitionistic logic and intermediate logics (Pearce 1999; Osorio et al. 2004)."
    }, {
      "heading" : "7 Conclusions and future work",
      "text" : "At the beginning of this research, two main goals were expected to be achieved: 1.- a possibilistic extension of the answer set programming paradigm for leading with uncertain, inconsistent and incomplete information; and, 2.- exploring the axiomatization of possibilistic logic in order to define a computable possibilistic disjunctive semantics.\nIn order to achieve the first goal, the work presented in (Nicolas et al. 2006) was taken as a reference point. Unlike the approach of (Nicolas et al. 2006), which is restricted to possibilistic normal programs, we define a possibilistic logic programming framework based on possibilistic disjunctive logic programs. Our approach introduces the use of possibilistic disjunctive clauses which are able to capture incomplete information and incomplete states of a knowledge base at the same time.\nFor capturing the semantics of possibilistic disjunctive logic programs, the axiomatization of possibilistic logic and the standard definition of the answer set semantics are taken as a base. Given that the inference of possibilistic logic is characterized by a possibilistic resolution rule (Proposition 6), it is shown that:\n1. The optimal certainty value of an atom which belongs to a possibilistic answer set corresponds to the optimal refutation by possibilistic resolution (Proposition 7); hence, 2. There exists an algorithm for computing the possibilistic answer sets of a possibilistic disjunctive logic program (Proposition 8).\nAs an alternative approach for inferring the possibilistic answer set semantics, it is shown that this semantics can be characterized by a simplified version of the principle of partial evaluation. This means that the possibilistic answer set semantics is characterized by a possibilistic fixed-point operator (Proposition 10). This result gives two points of view for constructing the possibilistic answer set semantics in terms of two syntactic processes (i.e., the possibilistic proof theory and the principle of partial evaluation).\nBased on the flexibility of possibilistic logic for defining degrees of uncertainty, it is shown that non-numerical degrees for capturing uncertain information can be captured by the defined possibilistic answer set semantics. This is illustrated in a medical scenario.\nTo manage the inconsistency of possibilistic models, we have defined a criterion of preference between possibilistic answer sets. Also, to manage the non-existence of possibilistic answer set of a possibilistic logic program P , we have adopted the approach suggested by Nicolas et al. in (Nicolas et al. 2006) of cuts for achieving consistent subprograms of P .\nIn future work, there are several topics which will be explored. One of the main topics to explore is to show that the possibilistic answer set semantics can be characterized as a logic inference in terms of a possibilistic version of the intuitionistic logic. This issue is motivated by the fact that the answer set semantic inference can be characterized as a logic inference in terms of intuitionistic logic (Pearce 1999; Osorio et al. 2004). On the other hand, we have been exploring to define a possibilistic action language. In (Nieves et al. 2007), we have already defined our first ideas in the context of the action languageA. Finally, we have started to explore the definition of a possibilistic framework in order to define preference between rules and preferences between atoms. With this objective in mind, possibilistic ordered disjunction programs have been explored (Confalonieri et al. 2010)."
    }, {
      "heading" : "NIEVES, J. C., OSORIO, M., CORTÉS, U., CABALLERO, F., AND LÓPEZ-NAVIDAD, A. 2007.",
      "text" : "Reasoning about actions under uncertainty: A possibilistic approach. In In proceedings of CCIA, C. Angulo and L. Godo, Eds.\nOSORIO, M., NAVARRO, J. A., AND ARRAZOLA, J. 2004. Applications of Intuitionistic Logic in Answer Set Programming. Theory and Practice of Logic Programming (TPLP) 4, 3 (May), 225–354.\nPEARCE, D. 1999. Stable Inference as Intuitionistic Validity. Logic Programming 38, 79–91.\nRODRÍGUEZ-ARTALEJO, M. AND ROMERO-DÍAZ, C. A. 2008. Quantitative Logic Programming revisited. In 9th International Symposium, FLOPS, J. Garrigue and M. Hermenegildo, Eds. LNCS, vol. 4989. Springer-Verlag Berlin Heidelberg, 272–288.\nTARSKI, A. 1955. A lattice-theoretical fixpoint theorem and its applications. Pacific Journal of Mathematics 5, 2, 285–309.\nTVERSKY, A. AND KAHNEMAN, D. 1982. Judgment under uncertainty:Heuristics and biases. Cambridge University Press, Chapter Judgment under uncertainty:Heuristics and biases, 3–20.\nVAN DALEN, D. 1994. Logic and structure, 3rd., aumented edition ed. Springer-Verlag, Berlin. VAN EMDEN, M. H. 1986. Quantitative deduction and its fixpoint theory. Journal of Logic Programming 3, 1, 37–53. VAN-NIEUWENBORGH, D., COCK, M. D., AND VERMEIR, D. 2007. An introduction to fuzzy answer set programming. Ann. Math. Artif. Intell. 50, 3-4, 363–388."
    }, {
      "heading" : "Appendix: Proofs",
      "text" : "In this appendix, we give the proofs of some results presented in this paper.\nProposition 2 Let P = 〈(Q,≤), N〉 be a possibilistic disjunctive logic program and M1,M2 ∈ PS such that M∗1 = M ∗ 2 . If P PL M1 and P PL M2, then P PL M1 ⊔M2."
    }, {
      "heading" : "Proof",
      "text" : "The proof is straightforward.\nProposition 3 Let P be a possibilistic disjunctive logic program. If M is a possibilistic answer set of P then M∗ is an answer set of P ∗."
    }, {
      "heading" : "Proof",
      "text" : "The proof is straightforward by the possibilistic answer set’s definition.\nProposition 4 Let P = 〈(Q,≤), N〉 be a possibilistic disjunctive logic program and α be a fixed element of Q. If ∀r ∈ P , n(r) = α and M ′ is an answer set of P ∗, then M := {(a, α)|a ∈M ′} is a possibilistic answer set of P ."
    }, {
      "heading" : "Proof",
      "text" : "Let us introduce two observations:\n1. We known that ∀r ∈ P , n(r) = α; hence, if P ⊢PL (a, α′), then α′ = α. This statement can be proved by contradiction. 2. Given a set of atoms S, if ∀r ∈ P , n(r) = α then ∀r ∈ PS , n(r) = α. This statement follows by fact that the reduction PS (Definition 6) does not affect n(r) of clause rule r in P .\nAs premises we know that ∀r ∈ P , n(r) = α and M ′ is an answer set of P ∗; hence, let M := {(a, α)|a ∈M ′}. Hence, we will prove that M is a possibilistic answer set of P .\nIf M ′ is an answer set of P ∗, then ∀a ∈ M ′, ∃α′ ∈ Q such that PM ′ ⊢PL (a, α′). Therefore, by observations 1 and 2, ∀a ∈ M ′, PM ′ ⊢PL (a, α). Then, P PL M . Observe that M is a greatest set in PS, hence, since P PL M and M is a greatest set, M is a possibilistic answer set of P .\nProposition 5 Let P := 〈(Q,≤), N〉 be a possibilistic normal program such that (Q,≤) is a totally ordered set and LP has no extended atoms. M is a possibilistic answer set of P if and only if M is a possibilistic stable model of P ."
    }, {
      "heading" : "Proof",
      "text" : "(Sketch) It is not difficult to see that when P is a possibilistic normal program, then the syntactic reduction of Definition 6 and the syntactic reduction of Definition 10 from (Nicolas et al. 2006) coincide. Then the proof is reduced to possibilistic definite programs. But, this case is straightforward, since essentially GMP is applied for inferring the possibilistic models of the program in both approaches.\nProposition 6 Let C be a set of possibilistic disjunctions, and C = (c α) be a possibilistic clause obtained by a finite number of successive application of (R) to C; then C ⊢PL C."
    }, {
      "heading" : "Proof",
      "text" : "(The proof is similar to the proof of Proposition 3.8.2 of (Dubois et al. 1994)) Let us consider two possibilistic clauses: C1 = (c1 α1) and C2 = (c2 α2), the application of R yields C′ = (R(c1, c2) GLB({α1, α2})). By classic logic, we known that R(c1, c2) is sound; hence the key point of the proof is to show that n(R(c1, c2)) ≥ GLB({α1, α2}).\nBy definition of necessity-valued clause, n(c1) ≥ α1 and n(c2) ≥ α2, then n(c1∧c2) = GLB({n(c1), n(c2)}) ≥ GLB({α1, α2}). Since c1∧c2 ⊢C R(c1, c2), then n(R(c1, c2)) ≥ n(c1∧c2) (because ifϕ ⊢PL ψ thenN(ψ) ≥ N(ϕ)). Thusn(R(c1, c2)) ≥ GLB({α1, α2}); therefore (R) is sound. Then by induction any possibilistic formula inferred by a finite number of successive applications of (R) to C is a logical consequence of C.\nProposition 7 Let P be a set of possibilistic clauses and C be the set of possibilistic disjunctions obtained from P ; then the valuation of the optimal refutation by resolution from C is the inconsistent degree of P ."
    }, {
      "heading" : "Proof",
      "text" : "(The proof is similar to the proof of Proposition 3.8.3 of (Dubois et al. 1994)) By possibilistic logic, we know that C ⊢PL (⊥ α) if and only if (Cα)∗ is inconsistent in the sense of classic logic. Since (R) is complete in classic logic, then there exists a refutation R( ) from (Cα)∗. Thus considering the valuation of the refutation R( ), we obtain a refutation from Cα such that n(R( )) ≥ α. Then n(R( )) ≥ Inc(C). Since (R) is sound then n(R( )) cannot be strictly greater than Inc(C). Thus n(R( )) is equal to Inc(C). According to Proposition 3.8.1 of (Dubois et al. 1994), Inc(C) = Inc(P ), thus n(R( )) is also equal to Inc(P ).\nProposition 8 Let P := 〈(Q,≤), N〉 be a possibilistic logic program. The set Poss-ASP returned by Poss_Answer_Sets(P ) is the set of all the possibilistic answer sets of P ."
    }, {
      "heading" : "Proof",
      "text" : "The result follows from the following facts:\n1. The function ASP computes all the answer set of P ∗. 2. If M is a possibilistic answer set of P iff M∗ is an answer set of P ∗ (Proposition 3). 3. By Corollary 1, we know that the possibilistic resolution rule R is sound and complete for\ncomputing optimal possibilistic degrees.\nProposition 9 Let P be a possibilistic disjunctive logic program. If Γ0 := T (P ) and Γi := T (Γi−1) such that i ∈ N , then ∃ n ∈ N such that Γn = Γn−1. We denote Γn by Π(P )."
    }, {
      "heading" : "Proof",
      "text" : "It is not difficult to see that the operator T is monotonic, then the proof is direct by Tarski’s Lattice-Theoretical Fixpoint Theorem (Tarski 1955).\nProposition 10 Let P be a possibilistic disjunctive logic program and M a set of possibilistic atoms. M is a possibilistic answer set of P if and only if M is a possibilistic-T answer set of P ."
    }, {
      "heading" : "Proof",
      "text" : "Two observations:\n1. By definition, it is straightforward that if M1 is a possibilistic answer set of P , then there exists a possibilistic-T answer set M2 of P such that M∗1 =M ∗ 2 and viceversa. 2. Since G-GPPE can be regarded as a macro of the possibilistic rule (R), we can conclude by Proposition 6 that G-GPPE is sound.\nLet M1 be a possibilistic answer set of P and M2 be a possibilistic-T answer set of P . By Observation 1, the central point of the proof is to prove that if (a, α1) ∈ M1 and (a, α2) ∈M2 such that M∗1 =M ∗ 2 , then α1 = α2.\nThe proof is by contradiction. Let us suppose that (a, α1) ∈M1 and (a, α2) ∈M2 such that M∗1 =M ∗ 2 and α1 6= α2. Then there are two cases α1 < α2 or α1 > α2\nα1 < α2 : Since G-GPPE is sound (Observation 2), then α1 is not the optimal necessityvalue for the atom a, but this is false by Corollary 1. α1 > α2 : If α1 > α2 then there exists a possibilistic claus α1 : A ← B+ ∈ P (M1) ∗\nthat belongs to the optimal refutation of the atom a and it was not reduced by G-GPPE. But this is false because G-GPPE is a macro of the resolution rule (R)."
    } ],
    "references" : [ {
      "title" : "A logic programming framework for possibilistic argumentation: Formalization and logical properties",
      "author" : [ "T. ALSINET", "C.I. CHESÑEVAR", "L. GODO", "G.R. SIMARI" ],
      "venue" : "Fuzzy Sets and Systems 159, 10, 1208–1228.",
      "citeRegEx" : "ALSINET et al\\.,? 2008",
      "shortCiteRegEx" : "ALSINET et al\\.",
      "year" : 2008
    }, {
      "title" : "A Complete Calculus for Possibilistic Logic Programming with Fuzzy Propositional Variables",
      "author" : [ "T. ALSINET", "L. GODO" ],
      "venue" : "Proceedings of the Sixteen Conference on Uncertainty in Artificial Intelligence. ACM Press, 1-10.",
      "citeRegEx" : "ALSINET and GODO,? 2000",
      "shortCiteRegEx" : "ALSINET and GODO",
      "year" : 2000
    }, {
      "title" : "Towards an automated deduction system for first-order possibilistic logic programming with fuzzy constants",
      "author" : [ "T. ALSINET", "L. GODO" ],
      "venue" : "Int. J. Intell. Syst. 17, 9, 887–924.",
      "citeRegEx" : "ALSINET and GODO,? 2002",
      "shortCiteRegEx" : "ALSINET and GODO",
      "year" : 2002
    }, {
      "title" : "Evidential support logic programming",
      "author" : [ "J.F. BALDWIN" ],
      "venue" : "Fuzzy Sets and Systems 24, 1 (October), 1–26.",
      "citeRegEx" : "BALDWIN,? 1987",
      "shortCiteRegEx" : "BALDWIN",
      "year" : 1987
    }, {
      "title" : "Knowledge Representation, Reasoning and Declarative Problem Solving",
      "author" : [ "C. BARAL" ],
      "venue" : "Cambridge University Press, Cambridge.",
      "citeRegEx" : "BARAL,? 2003",
      "shortCiteRegEx" : "BARAL",
      "year" : 2003
    }, {
      "title" : "Probabilistic reasoning with answer sets",
      "author" : [ "C. BARAL", "M. GELFOND", "J.N. RUSHTON" ],
      "venue" : "TPLP 9, 1, 57–144.",
      "citeRegEx" : "BARAL et al\\.,? 2009",
      "shortCiteRegEx" : "BARAL et al\\.",
      "year" : 2009
    }, {
      "title" : "Characterizations of the disjunctive stable semantics by partial evaluation",
      "author" : [ "S. BRASS", "J. DIX" ],
      "venue" : "J. Log. Program. 32, 3, 207–228.",
      "citeRegEx" : "BRASS and DIX,? 1997",
      "shortCiteRegEx" : "BRASS and DIX",
      "year" : 1997
    }, {
      "title" : "Characterizations of the disjunctive well-founded semantics: Confluent calculi and iterated gcwa",
      "author" : [ "S. BRASS", "J. DIX" ],
      "venue" : "J. Autom. Reasoning 20, 1, 143–165.",
      "citeRegEx" : "BRASS and DIX,? 1998",
      "shortCiteRegEx" : "BRASS and DIX",
      "year" : 1998
    }, {
      "title" : "Semantics of (Disjunctive) Logic Programs Based on Partial Evaluation",
      "author" : [ "S. BRASS", "J. DIX" ],
      "venue" : "Journal of Logic Programming 38(3), 167–213.",
      "citeRegEx" : "BRASS and DIX,? 1999",
      "shortCiteRegEx" : "BRASS and DIX",
      "year" : 1999
    }, {
      "title" : "Knowledge and Inquiry : Essays on the Pragmatism of Isaac Levi",
      "author" : [ "O. BUENO" ],
      "venue" : "Cambridge Studies in Probability, Induction and Decision Theory. Cambridge University Press, Chapter Why Inconsistency Is Not Hell: Making Room for Inconsistency in Science, 70–86.",
      "citeRegEx" : "BUENO,? 2006",
      "shortCiteRegEx" : "BUENO",
      "year" : 2006
    }, {
      "title" : "Possibilistic semantics for logic programs with ordered disjunction",
      "author" : [ "R. CONFALONIERI", "J.C. NIEVES", "M. OSORIO", "J. VÁZQUEZ-SALCEDA" ],
      "venue" : "FoIKS. Lecture Notes in Computer Science, vol. 5956. Springer, 133–152.",
      "citeRegEx" : "CONFALONIERI et al\\.,? 2010",
      "shortCiteRegEx" : "CONFALONIERI et al\\.",
      "year" : 2010
    }, {
      "title" : "Introduction to Lattices and Order, Second ed",
      "author" : [ "B.A. DAVEY", "H.A. PRIESTLY" ],
      "venue" : "Cambridge University Press.",
      "citeRegEx" : "DAVEY and PRIESTLY,? 2002",
      "shortCiteRegEx" : "DAVEY and PRIESTLY",
      "year" : 2002
    }, {
      "title" : "A classification theory of semantics of normal logic programs: I",
      "author" : [ "DIX J." ],
      "venue" : "strong properties. Fundam. Inform. 22, 3, 227–255.",
      "citeRegEx" : "J.,? 1995a",
      "shortCiteRegEx" : "J.",
      "year" : 1995
    }, {
      "title" : "A classification theory of semantics of normal logic programs: II",
      "author" : [ "DIX J." ],
      "venue" : "weak properties. Fundam. Inform. 22, 3, 257–288.",
      "citeRegEx" : "J.,? 1995b",
      "shortCiteRegEx" : "J.",
      "year" : 1995
    }, {
      "title" : "A general theory of confluent rewriting systems for logic programming and its applications",
      "author" : [ "J. DIX", "M. OSORIO", "C. ZEPEDA" ],
      "venue" : "Ann. Pure Appl. Logic 108, 1-3, 153–188.",
      "citeRegEx" : "DIX et al\\.,? 2001",
      "shortCiteRegEx" : "DIX et al\\.",
      "year" : 2001
    }, {
      "title" : "Vienna University of Technology",
      "author" : [ "DLV S." ],
      "venue" : "http://www.dbai.tuwien.ac.at/proj/dlv/.",
      "citeRegEx" : "S.,? 1996",
      "shortCiteRegEx" : "S.",
      "year" : 1996
    }, {
      "title" : "Towards possibilistic logic programming",
      "author" : [ "D. DUBOIS", "J. LANG", "H. PRADE" ],
      "venue" : "ICLP, K. Furukawa, Ed. The MIT Press, 581–595.",
      "citeRegEx" : "DUBOIS et al\\.,? 1991",
      "shortCiteRegEx" : "DUBOIS et al\\.",
      "year" : 1991
    }, {
      "title" : "Possibilistic logic",
      "author" : [ "D. DUBOIS", "J. LANG", "H. PRADE" ],
      "venue" : "Handbook of Logic in Artificial Intelligence and Logic Programming, Volume 3: Nonmonotonic Reasoning and Uncertain Reasoning, D. Gabbay, C. J. Hogger, and J. A. Robinson, Eds. Oxford University Press, Oxford, 439–513.",
      "citeRegEx" : "DUBOIS et al\\.,? 1994",
      "shortCiteRegEx" : "DUBOIS et al\\.",
      "year" : 1994
    }, {
      "title" : "Possibilistic logic: a retrospective and prospective view",
      "author" : [ "D. DUBOIS", "H. PRADE" ],
      "venue" : "Fuzzy Sets and Systems 144, 1, 3–23.",
      "citeRegEx" : "DUBOIS and PRADE,? 2004",
      "shortCiteRegEx" : "DUBOIS and PRADE",
      "year" : 2004
    }, {
      "title" : "Bilattices and the semantics of logic programming",
      "author" : [ "M. FITTING" ],
      "venue" : "Journal of Logic Programming 11, 1&2, 91–116.",
      "citeRegEx" : "FITTING,? 1991",
      "shortCiteRegEx" : "FITTING",
      "year" : 1991
    }, {
      "title" : "Safe and Sound: Artificial Intelligence in Hazardous Applications",
      "author" : [ "FOX J.", "DAS S." ],
      "venue" : "AAAI Press/ The MIT Press.",
      "citeRegEx" : "J. and S.,? 2000",
      "shortCiteRegEx" : "J. and S.",
      "year" : 2000
    }, {
      "title" : "From arguments to decisions: Extending the Toulmin view",
      "author" : [ "J. FOX", "S. MODGIL" ],
      "venue" : "Arguing on the Toulmin model: New essays on argument analysis and evaluation, D. Hitchcock and B. Verheij, Eds. Springer Netherlands, 273–287.",
      "citeRegEx" : "FOX and MODGIL,? 2006",
      "shortCiteRegEx" : "FOX and MODGIL",
      "year" : 2006
    }, {
      "title" : "Handbook of Knowledge Representation",
      "author" : [ "M. GELFOND" ],
      "venue" : "Elsevier, Chapter Answer Sets, 285–316.",
      "citeRegEx" : "GELFOND,? 2008",
      "shortCiteRegEx" : "GELFOND",
      "year" : 2008
    }, {
      "title" : "The Stable Model Semantics for Logic Programming",
      "author" : [ "M. GELFOND", "V. LIFSCHITZ" ],
      "venue" : "5th Conference on Logic Programming, R. Kowalski and K. Bowen, Eds. MIT Press, 1070–1080.",
      "citeRegEx" : "GELFOND and LIFSCHITZ,? 1988",
      "shortCiteRegEx" : "GELFOND and LIFSCHITZ",
      "year" : 1988
    }, {
      "title" : "Classical Negation in Logic Programs and Disjunctive Databases",
      "author" : [ "M. GELFOND", "V. LIFSCHITZ" ],
      "venue" : "New Generation Computing 9, 365–385.",
      "citeRegEx" : "GELFOND and LIFSCHITZ,? 1991",
      "shortCiteRegEx" : "GELFOND and LIFSCHITZ",
      "year" : 1991
    }, {
      "title" : "Temporal disjunctive logic programming",
      "author" : [ "M. GERGATSOULIS", "P. RONDOGIANNIS", "T. PANAYIOTOPOULOS" ],
      "venue" : "New Generation Computing 19, 1, 87–100.",
      "citeRegEx" : "GERGATSOULIS et al\\.,? 2001",
      "shortCiteRegEx" : "GERGATSOULIS et al\\.",
      "year" : 2001
    }, {
      "title" : "Combining probabilistic logic programming with the power of maximum entropy",
      "author" : [ "G. KERN-ISBERNER", "T. LUKASIEWICZ" ],
      "venue" : "Artificial Intelligence 157, 1-2, 139–202.",
      "citeRegEx" : "KERN.ISBERNER and LUKASIEWICZ,? 2004",
      "shortCiteRegEx" : "KERN.ISBERNER and LUKASIEWICZ",
      "year" : 2004
    }, {
      "title" : "Theory of generalized annotated logic programming and its applications",
      "author" : [ "M. KIFER", "V.S. SUBRAHMANIAN" ],
      "venue" : "J. Log. Program. 12, 3&4, 335–367.",
      "citeRegEx" : "KIFER and SUBRAHMANIAN,? 1992",
      "shortCiteRegEx" : "KIFER and SUBRAHMANIAN",
      "year" : 1992
    }, {
      "title" : "An epistemic foundation for logic programming with uncertainty",
      "author" : [ "L.V.S. LAKSHMANAN" ],
      "venue" : "FSTTCS. 89–100.",
      "citeRegEx" : "LAKSHMANAN,? 1994",
      "shortCiteRegEx" : "LAKSHMANAN",
      "year" : 1994
    }, {
      "title" : "Extended criteria for organ acceptance: Strategies for achieving organ safety and for increasing organ pool",
      "author" : [ "A. LÓPEZ-NAVIDAD", "F. CABALLERO" ],
      "venue" : "Clinical Transplantation, Blackwell Munksgaard 17, 308–324.",
      "citeRegEx" : "LÓPEZ.NAVIDAD and CABALLERO,? 2003",
      "shortCiteRegEx" : "LÓPEZ.NAVIDAD and CABALLERO",
      "year" : 2003
    }, {
      "title" : "Professional characteristics of the transplant coordinator",
      "author" : [ "A. LÓPEZ-NAVIDAD", "P. DOMINGO", "M.A. VIEDMA" ],
      "venue" : "XVI International Congress of the Transplantation Society. Transplantation Proceedings, vol. 29. Elsevier Science Inc, 1607–1613.",
      "citeRegEx" : "LÓPEZ.NAVIDAD et al\\.,? 1997",
      "shortCiteRegEx" : "LÓPEZ.NAVIDAD et al\\.",
      "year" : 1997
    }, {
      "title" : "Probabilistic logic programming",
      "author" : [ "T. LUKASIEWICZ" ],
      "venue" : "ECAI. 388–392.",
      "citeRegEx" : "LUKASIEWICZ,? 1998",
      "shortCiteRegEx" : "LUKASIEWICZ",
      "year" : 1998
    }, {
      "title" : "Fixpoint characterizations for many-valued disjunctive logic programs with probabilistic semantics",
      "author" : [ "T. LUKASIEWICZ" ],
      "venue" : "LPNMR. 336–350.",
      "citeRegEx" : "LUKASIEWICZ,? 2001",
      "shortCiteRegEx" : "LUKASIEWICZ",
      "year" : 2001
    }, {
      "title" : "Quantitative disjunctive logic programming: Semantics and computation",
      "author" : [ "C. MATEIS" ],
      "venue" : "AI Commun. 13, 4, 225–248.",
      "citeRegEx" : "MATEIS,? 2000",
      "shortCiteRegEx" : "MATEIS",
      "year" : 2000
    }, {
      "title" : "Probabilistic logic programming",
      "author" : [ "R.T. NG", "V.S. SUBRAHMANIAN" ],
      "venue" : "Inf. Comput. 101, 2, 150–201.",
      "citeRegEx" : "NG and SUBRAHMANIAN,? 1992",
      "shortCiteRegEx" : "NG and SUBRAHMANIAN",
      "year" : 1992
    }, {
      "title" : "Possibilistic Uncertainty Handling for Answer Set Programming",
      "author" : [ "P. NICOLAS", "L. GARCIA", "I. STÉPHAN", "C. LEFÈVRE" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 47, 1-2 (June), 139–181.",
      "citeRegEx" : "NICOLAS et al\\.,? 2006",
      "shortCiteRegEx" : "NICOLAS et al\\.",
      "year" : 2006
    }, {
      "title" : "Semantics for possibilistic disjunctive programs",
      "author" : [ "J.C. NIEVES", "M. OSORIO", "U. CORTÉS" ],
      "venue" : "Ninth International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR-07), C. Baral, G. Brewka, and J. Schlipf, Eds. Number 4483 in LNAI. Springer-Verlag, 315–320.",
      "citeRegEx" : "NIEVES et al\\.,? 2007a",
      "shortCiteRegEx" : "NIEVES et al\\.",
      "year" : 2007
    }, {
      "title" : "Semantics for possibilistic disjunctive programs",
      "author" : [ "J.C. NIEVES", "M. OSORIO", "U. CORTÉS" ],
      "venue" : "Answer Set Programming: Advances in Theory and Implementation, S. Costantini and R. Watson, Eds. 271–284.",
      "citeRegEx" : "NIEVES et al\\.,? 2007b",
      "shortCiteRegEx" : "NIEVES et al\\.",
      "year" : 2007
    }, {
      "title" : "Reasoning about actions under uncertainty: A possibilistic approach",
      "author" : [ "J.C. NIEVES", "M. OSORIO", "U. CORTÉS", "F. CABALLERO", "A. LÓPEZ-NAVIDAD" ],
      "venue" : "In proceedings of CCIA, C. Angulo and L. Godo, Eds.",
      "citeRegEx" : "NIEVES et al\\.,? 2007",
      "shortCiteRegEx" : "NIEVES et al\\.",
      "year" : 2007
    }, {
      "title" : "Applications of Intuitionistic Logic in Answer Set Programming",
      "author" : [ "M. OSORIO", "J.A. NAVARRO", "J. ARRAZOLA" ],
      "venue" : "Theory and Practice of Logic Programming (TPLP) 4, 3 (May), 225–354.",
      "citeRegEx" : "OSORIO et al\\.,? 2004",
      "shortCiteRegEx" : "OSORIO et al\\.",
      "year" : 2004
    }, {
      "title" : "Stable Inference as Intuitionistic Validity",
      "author" : [ "D. PEARCE" ],
      "venue" : "Logic Programming 38, 79–91.",
      "citeRegEx" : "PEARCE,? 1999",
      "shortCiteRegEx" : "PEARCE",
      "year" : 1999
    }, {
      "title" : "Quantitative Logic Programming revisited",
      "author" : [ "M. RODRÍGUEZ-ARTALEJO", "C.A. ROMERO-DÍAZ" ],
      "venue" : "9th International Symposium, FLOPS, J. Garrigue and M. Hermenegildo, Eds. LNCS, vol. 4989. Springer-Verlag Berlin Heidelberg, 272–288.",
      "citeRegEx" : "RODRÍGUEZ.ARTALEJO and ROMERO.DÍAZ,? 2008",
      "shortCiteRegEx" : "RODRÍGUEZ.ARTALEJO and ROMERO.DÍAZ",
      "year" : 2008
    }, {
      "title" : "A lattice-theoretical fixpoint theorem and its applications",
      "author" : [ "A. TARSKI" ],
      "venue" : "Pacific Journal of Mathematics 5, 2, 285–309.",
      "citeRegEx" : "TARSKI,? 1955",
      "shortCiteRegEx" : "TARSKI",
      "year" : 1955
    }, {
      "title" : "Judgment under uncertainty:Heuristics and biases",
      "author" : [ "A. TVERSKY", "D. KAHNEMAN" ],
      "venue" : "Cambridge University Press, Chapter Judgment under uncertainty:Heuristics and biases, 3–20.",
      "citeRegEx" : "TVERSKY and KAHNEMAN,? 1982",
      "shortCiteRegEx" : "TVERSKY and KAHNEMAN",
      "year" : 1982
    }, {
      "title" : "Logic and structure, 3rd., aumented edition ed",
      "author" : [ "D. VAN DALEN" ],
      "venue" : null,
      "citeRegEx" : "DALEN,? \\Q1994\\E",
      "shortCiteRegEx" : "DALEN",
      "year" : 1994
    }, {
      "title" : "Quantitative deduction and its fixpoint theory",
      "author" : [ "M.H. VAN EMDEN" ],
      "venue" : "Journal of Logic Programming 3, 1, 37–53.",
      "citeRegEx" : "EMDEN,? 1986",
      "shortCiteRegEx" : "EMDEN",
      "year" : 1986
    }, {
      "title" : "An introduction to fuzzy answer set programming",
      "author" : [ "D. VAN-NIEUWENBORGH", "M.D. COCK", "D. VERMEIR" ],
      "venue" : "Ann. Math. Artif. Intell. 50, 3-4, 363–388.",
      "citeRegEx" : "VAN.NIEUWENBORGH et al\\.,? 2007",
      "shortCiteRegEx" : "VAN.NIEUWENBORGH et al\\.",
      "year" : 2007
    }, {
      "title" : "coincide. Then the proof is reduced to possibilistic definite programs",
      "author" : [ "Nicolas" ],
      "venue" : null,
      "citeRegEx" : "Nicolas,? \\Q2006\\E",
      "shortCiteRegEx" : "Nicolas",
      "year" : 2006
    } ],
    "referenceMentions" : [ {
      "referenceID" : 4,
      "context" : "Answer Set Programming (ASP) is one of the most successful logic programming approaches in Non-monotonic Reasoning and Artificial Intelligence applications (Baral 2003; Gelfond 2008).",
      "startOffset" : 156,
      "endOffset" : 182
    }, {
      "referenceID" : 22,
      "context" : "Answer Set Programming (ASP) is one of the most successful logic programming approaches in Non-monotonic Reasoning and Artificial Intelligence applications (Baral 2003; Gelfond 2008).",
      "startOffset" : 156,
      "endOffset" : 182
    }, {
      "referenceID" : 35,
      "context" : "In (Nicolas et al. 2006), a possibilistic framework for reasoning under uncertainty was proposed.",
      "startOffset" : 3,
      "endOffset" : 24
    }, {
      "referenceID" : 17,
      "context" : "This framework is a combination between ASP and possibilistic logic (Dubois et al. 1994).",
      "startOffset" : 68,
      "endOffset" : 88
    }, {
      "referenceID" : 17,
      "context" : "Possibilistic Logic is based on possibilistic theory in which, at the mathematical level, degrees of possibility and necessity are closely related to fuzzy sets (Dubois et al. 1994).",
      "startOffset" : 161,
      "endOffset" : 181
    }, {
      "referenceID" : 17,
      "context" : "An important property of possibilistic logic is that it is axiomatizable in the necessityvalued case (Dubois et al. 1994).",
      "startOffset" : 101,
      "endOffset" : 121
    }, {
      "referenceID" : 40,
      "context" : "Equally important to consider is that the answer set semantics inference can also be characterized as a logic inference in terms of the proof theory of intuitionistic logic and intermediate logics (Pearce 1999; Osorio et al. 2004).",
      "startOffset" : 197,
      "endOffset" : 230
    }, {
      "referenceID" : 39,
      "context" : "Equally important to consider is that the answer set semantics inference can also be characterized as a logic inference in terms of the proof theory of intuitionistic logic and intermediate logics (Pearce 1999; Osorio et al. 2004).",
      "startOffset" : 197,
      "endOffset" : 230
    }, {
      "referenceID" : 17,
      "context" : "Since in (Dubois et al. 1994) an axiomatization of possibilistic logic has been defined, in this paper we explore the characterization of a possibilistic semantics for capturing possibilistic logic programs in terms of the proof theory of possibilistic logic and the standard answer set semantics.",
      "startOffset" : 9,
      "endOffset" : 29
    }, {
      "referenceID" : 27,
      "context" : "certain information (Kifer and Subrahmanian 1992; Ng and Subrahmanian 1992; Lukasiewicz 1998; Kern-Isberner and Lukasiewicz 2004; van Emden 1986; Rodríguez-Artalejo and Romero-Díaz 2008; Van-Nieuwenborgh et al. 2007; Fitting 1991; Lakshmanan 1994; Baldwin 1987; Dubois et al. 1991; Alsinet and Godo 2002; Alsinet and Godo 2000; Alsinet et al. 2008; Nicolas et al. 2006).",
      "startOffset" : 20,
      "endOffset" : 369
    }, {
      "referenceID" : 34,
      "context" : "certain information (Kifer and Subrahmanian 1992; Ng and Subrahmanian 1992; Lukasiewicz 1998; Kern-Isberner and Lukasiewicz 2004; van Emden 1986; Rodríguez-Artalejo and Romero-Díaz 2008; Van-Nieuwenborgh et al. 2007; Fitting 1991; Lakshmanan 1994; Baldwin 1987; Dubois et al. 1991; Alsinet and Godo 2002; Alsinet and Godo 2000; Alsinet et al. 2008; Nicolas et al. 2006).",
      "startOffset" : 20,
      "endOffset" : 369
    }, {
      "referenceID" : 31,
      "context" : "certain information (Kifer and Subrahmanian 1992; Ng and Subrahmanian 1992; Lukasiewicz 1998; Kern-Isberner and Lukasiewicz 2004; van Emden 1986; Rodríguez-Artalejo and Romero-Díaz 2008; Van-Nieuwenborgh et al. 2007; Fitting 1991; Lakshmanan 1994; Baldwin 1987; Dubois et al. 1991; Alsinet and Godo 2002; Alsinet and Godo 2000; Alsinet et al. 2008; Nicolas et al. 2006).",
      "startOffset" : 20,
      "endOffset" : 369
    }, {
      "referenceID" : 26,
      "context" : "certain information (Kifer and Subrahmanian 1992; Ng and Subrahmanian 1992; Lukasiewicz 1998; Kern-Isberner and Lukasiewicz 2004; van Emden 1986; Rodríguez-Artalejo and Romero-Díaz 2008; Van-Nieuwenborgh et al. 2007; Fitting 1991; Lakshmanan 1994; Baldwin 1987; Dubois et al. 1991; Alsinet and Godo 2002; Alsinet and Godo 2000; Alsinet et al. 2008; Nicolas et al. 2006).",
      "startOffset" : 20,
      "endOffset" : 369
    }, {
      "referenceID" : 46,
      "context" : "certain information (Kifer and Subrahmanian 1992; Ng and Subrahmanian 1992; Lukasiewicz 1998; Kern-Isberner and Lukasiewicz 2004; van Emden 1986; Rodríguez-Artalejo and Romero-Díaz 2008; Van-Nieuwenborgh et al. 2007; Fitting 1991; Lakshmanan 1994; Baldwin 1987; Dubois et al. 1991; Alsinet and Godo 2002; Alsinet and Godo 2000; Alsinet et al. 2008; Nicolas et al. 2006).",
      "startOffset" : 20,
      "endOffset" : 369
    }, {
      "referenceID" : 19,
      "context" : "certain information (Kifer and Subrahmanian 1992; Ng and Subrahmanian 1992; Lukasiewicz 1998; Kern-Isberner and Lukasiewicz 2004; van Emden 1986; Rodríguez-Artalejo and Romero-Díaz 2008; Van-Nieuwenborgh et al. 2007; Fitting 1991; Lakshmanan 1994; Baldwin 1987; Dubois et al. 1991; Alsinet and Godo 2002; Alsinet and Godo 2000; Alsinet et al. 2008; Nicolas et al. 2006).",
      "startOffset" : 20,
      "endOffset" : 369
    }, {
      "referenceID" : 28,
      "context" : "certain information (Kifer and Subrahmanian 1992; Ng and Subrahmanian 1992; Lukasiewicz 1998; Kern-Isberner and Lukasiewicz 2004; van Emden 1986; Rodríguez-Artalejo and Romero-Díaz 2008; Van-Nieuwenborgh et al. 2007; Fitting 1991; Lakshmanan 1994; Baldwin 1987; Dubois et al. 1991; Alsinet and Godo 2002; Alsinet and Godo 2000; Alsinet et al. 2008; Nicolas et al. 2006).",
      "startOffset" : 20,
      "endOffset" : 369
    }, {
      "referenceID" : 3,
      "context" : "certain information (Kifer and Subrahmanian 1992; Ng and Subrahmanian 1992; Lukasiewicz 1998; Kern-Isberner and Lukasiewicz 2004; van Emden 1986; Rodríguez-Artalejo and Romero-Díaz 2008; Van-Nieuwenborgh et al. 2007; Fitting 1991; Lakshmanan 1994; Baldwin 1987; Dubois et al. 1991; Alsinet and Godo 2002; Alsinet and Godo 2000; Alsinet et al. 2008; Nicolas et al. 2006).",
      "startOffset" : 20,
      "endOffset" : 369
    }, {
      "referenceID" : 16,
      "context" : "certain information (Kifer and Subrahmanian 1992; Ng and Subrahmanian 1992; Lukasiewicz 1998; Kern-Isberner and Lukasiewicz 2004; van Emden 1986; Rodríguez-Artalejo and Romero-Díaz 2008; Van-Nieuwenborgh et al. 2007; Fitting 1991; Lakshmanan 1994; Baldwin 1987; Dubois et al. 1991; Alsinet and Godo 2002; Alsinet and Godo 2000; Alsinet et al. 2008; Nicolas et al. 2006).",
      "startOffset" : 20,
      "endOffset" : 369
    }, {
      "referenceID" : 2,
      "context" : "certain information (Kifer and Subrahmanian 1992; Ng and Subrahmanian 1992; Lukasiewicz 1998; Kern-Isberner and Lukasiewicz 2004; van Emden 1986; Rodríguez-Artalejo and Romero-Díaz 2008; Van-Nieuwenborgh et al. 2007; Fitting 1991; Lakshmanan 1994; Baldwin 1987; Dubois et al. 1991; Alsinet and Godo 2002; Alsinet and Godo 2000; Alsinet et al. 2008; Nicolas et al. 2006).",
      "startOffset" : 20,
      "endOffset" : 369
    }, {
      "referenceID" : 1,
      "context" : "certain information (Kifer and Subrahmanian 1992; Ng and Subrahmanian 1992; Lukasiewicz 1998; Kern-Isberner and Lukasiewicz 2004; van Emden 1986; Rodríguez-Artalejo and Romero-Díaz 2008; Van-Nieuwenborgh et al. 2007; Fitting 1991; Lakshmanan 1994; Baldwin 1987; Dubois et al. 1991; Alsinet and Godo 2002; Alsinet and Godo 2000; Alsinet et al. 2008; Nicolas et al. 2006).",
      "startOffset" : 20,
      "endOffset" : 369
    }, {
      "referenceID" : 0,
      "context" : "certain information (Kifer and Subrahmanian 1992; Ng and Subrahmanian 1992; Lukasiewicz 1998; Kern-Isberner and Lukasiewicz 2004; van Emden 1986; Rodríguez-Artalejo and Romero-Díaz 2008; Van-Nieuwenborgh et al. 2007; Fitting 1991; Lakshmanan 1994; Baldwin 1987; Dubois et al. 1991; Alsinet and Godo 2002; Alsinet and Godo 2000; Alsinet et al. 2008; Nicolas et al. 2006).",
      "startOffset" : 20,
      "endOffset" : 369
    }, {
      "referenceID" : 35,
      "context" : "certain information (Kifer and Subrahmanian 1992; Ng and Subrahmanian 1992; Lukasiewicz 1998; Kern-Isberner and Lukasiewicz 2004; van Emden 1986; Rodríguez-Artalejo and Romero-Díaz 2008; Van-Nieuwenborgh et al. 2007; Fitting 1991; Lakshmanan 1994; Baldwin 1987; Dubois et al. 1991; Alsinet and Godo 2002; Alsinet and Godo 2000; Alsinet et al. 2008; Nicolas et al. 2006).",
      "startOffset" : 20,
      "endOffset" : 369
    }, {
      "referenceID" : 43,
      "context" : "For instance, Tversky and Kahneman have observed in (Tversky and Kahneman 1982) that people commonly use statements such as “I think that .",
      "startOffset" : 52,
      "endOffset" : 79
    }, {
      "referenceID" : 21,
      "context" : "In fact, many times, experts in a domain, such as medicine, appeal to their intuition by using these kinds of statements (Fox and Das 2000; Fox and Modgil 2006).",
      "startOffset" : 121,
      "endOffset" : 160
    }, {
      "referenceID" : 36,
      "context" : "In this paper, we extend the work of two earlier papers (Nieves et al. 2007a; Nieves et al. 2007b) in order to obtain a simple logic characterization of a possibilistic logic programming semantics for capturing possibilistic programs; this semantics is applicable to disjunctive as well as normal logic programs.",
      "startOffset" : 56,
      "endOffset" : 98
    }, {
      "referenceID" : 37,
      "context" : "In this paper, we extend the work of two earlier papers (Nieves et al. 2007a; Nieves et al. 2007b) in order to obtain a simple logic characterization of a possibilistic logic programming semantics for capturing possibilistic programs; this semantics is applicable to disjunctive as well as normal logic programs.",
      "startOffset" : 56,
      "endOffset" : 98
    }, {
      "referenceID" : 11,
      "context" : "We start by defining some fundamental definitions of lattice theory (see (Davey and Priestly 2002) for more details).",
      "startOffset" : 73,
      "endOffset" : 98
    }, {
      "referenceID" : 21,
      "context" : "5 This set of labels was taken from (Fox and Modgil 2006).",
      "startOffset" : 36,
      "endOffset" : 57
    }, {
      "referenceID" : 4,
      "context" : "We will manage the strong negation (¬), in our logic programs, as it is done in ASP (Baral 2003).",
      "startOffset" : 84,
      "endOffset" : 96
    }, {
      "referenceID" : 4,
      "context" : "It represents one of the most successful approaches of non-monotonic reasoning of the last two decades (Baral 2003).",
      "startOffset" : 103,
      "endOffset" : 115
    }, {
      "referenceID" : 23,
      "context" : "The answer set semantics was first defined in terms of the so called Gelfond-Lifschitz reduction (Gelfond and Lifschitz 1988) and it is usually studied in the context of syntax dependent transformations on programs.",
      "startOffset" : 97,
      "endOffset" : 125
    }, {
      "referenceID" : 23,
      "context" : "The following definition of an answer set for extended disjunctive logic programs generalizes the definition presented in (Gelfond and Lifschitz 1988) and it was presented in (Gelfond and Lifschitz 1991): Let P be any extended disjunctive logic program.",
      "startOffset" : 122,
      "endOffset" : 150
    }, {
      "referenceID" : 24,
      "context" : "The following definition of an answer set for extended disjunctive logic programs generalizes the definition presented in (Gelfond and Lifschitz 1988) and it was presented in (Gelfond and Lifschitz 1991): Let P be any extended disjunctive logic program.",
      "startOffset" : 175,
      "endOffset" : 203
    }, {
      "referenceID" : 4,
      "context" : "It is worth mentioning that in literature there are several forms for handling an inconsistency program (Baral 2003).",
      "startOffset" : 104,
      "endOffset" : 116
    }, {
      "referenceID" : 24,
      "context" : "For instance, by applying the original definition (Gelfond and Lifschitz 1991) the only answer set of P is: {a,¬a, b,¬b}.",
      "startOffset" : 50,
      "endOffset" : 78
    }, {
      "referenceID" : 17,
      "context" : "The pair (φ α) expresses that the formula φ is certain at least to the level α, that is N(φ) ≥ α, in which N is a necessity measure modeling our possibly incomplete state knowledge (Dubois et al. 1994).",
      "startOffset" : 181,
      "endOffset" : 201
    }, {
      "referenceID" : 17,
      "context" : ", in (Dubois et al. 1994) introduced a formal system for necessity-valued logic which is based on the following axioms schemata (propositional case):",
      "startOffset" : 5,
      "endOffset" : 25
    }, {
      "referenceID" : 17,
      "context" : ", in (Dubois et al. 1994), basically we need a complete lattice to express the levels of uncertainty in Possibilistic Logic.",
      "startOffset" : 5,
      "endOffset" : 25
    }, {
      "referenceID" : 17,
      "context" : "The problem of inferring automatically the necessity-value of a classical formula from a possibilistic base was solved by an extended version of resolution for possibilistic logic (see (Dubois et al. 1994) for details).",
      "startOffset" : 185,
      "endOffset" : 205
    }, {
      "referenceID" : 18,
      "context" : "According to Dubois and Prade (Dubois and Prade 2004), the contribution of possibilistic logic setting is to relate this principle (measuring the validity of an inference chain by its weakest link) to fuzzy set-based necessity measures in the framework of Zadeh’s possibilistic theory, since the following pattern then holds:",
      "startOffset" : 30,
      "endOffset" : 53
    }, {
      "referenceID" : 35,
      "context" : "7 Some concepts presented in this section extend some terms presented in (Nicolas et al. 2006).",
      "startOffset" : 73,
      "endOffset" : 94
    }, {
      "referenceID" : 35,
      "context" : "This definition is almost the same as Definition 7 presented in (Nicolas et al. 2006).",
      "startOffset" : 64,
      "endOffset" : 85
    }, {
      "referenceID" : 35,
      "context" : "The main difference is that in Definition 7 from (Nicolas et al. 2006) the operations ⊓ and ⊔ are defined in terms of the operators min and max instead of the operators GLB and LUB.",
      "startOffset" : 49,
      "endOffset" : 70
    }, {
      "referenceID" : 35,
      "context" : "Hence, the following proposition is a direct result of Proposition 6 of (Nicolas et al. 2006).",
      "startOffset" : 72,
      "endOffset" : 93
    }, {
      "referenceID" : 17,
      "context" : "Let us remember that the possibilistic logic is axiomatizable (Dubois et al. 1994); hence, the inference in possibilistic logic can be managed by both a syntactic approach (axioms and inference rules) and a possibilistic model theory approach (interpretations and possibilistic distributions).",
      "startOffset" : 62,
      "endOffset" : 82
    }, {
      "referenceID" : 35,
      "context" : "For the class of possibilistic normal logic programs which are defined with a totally ordered set, our definition of possibilistic answer set is closely related to the definition of a possibilistic stable model presented in (Nicolas et al. 2006).",
      "startOffset" : 224,
      "endOffset" : 245
    }, {
      "referenceID" : 17,
      "context" : "Now, let us consider a straightforward generalization of the possibilistic resolution rule introduced in (Dubois et al. 1994):",
      "startOffset" : 105,
      "endOffset" : 125
    }, {
      "referenceID" : 17,
      "context" : "Like the possibilistic rule introduced in (Dubois et al. 1994), (R) is complete for refutation.",
      "startOffset" : 42,
      "endOffset" : 62
    }, {
      "referenceID" : 8,
      "context" : "One of these approaches is based on program transformations, in fact there are many studies on this approach, for example (Brass and Dix 1999; Brass and Dix 1997; Brass and Dix 1998; Dix et al. 2001).",
      "startOffset" : 122,
      "endOffset" : 199
    }, {
      "referenceID" : 6,
      "context" : "One of these approaches is based on program transformations, in fact there are many studies on this approach, for example (Brass and Dix 1999; Brass and Dix 1997; Brass and Dix 1998; Dix et al. 2001).",
      "startOffset" : 122,
      "endOffset" : 199
    }, {
      "referenceID" : 7,
      "context" : "One of these approaches is based on program transformations, in fact there are many studies on this approach, for example (Brass and Dix 1999; Brass and Dix 1997; Brass and Dix 1998; Dix et al. 2001).",
      "startOffset" : 122,
      "endOffset" : 199
    }, {
      "referenceID" : 14,
      "context" : "One of these approaches is based on program transformations, in fact there are many studies on this approach, for example (Brass and Dix 1999; Brass and Dix 1997; Brass and Dix 1998; Dix et al. 2001).",
      "startOffset" : 122,
      "endOffset" : 199
    }, {
      "referenceID" : 8,
      "context" : "For the case of disjunctive logic program, one important transformation is partial evaluation (also called unfolding) (Brass and Dix 1999).",
      "startOffset" : 118,
      "endOffset" : 138
    }, {
      "referenceID" : 9,
      "context" : "There are authors such as Octávio Bueno (Bueno 2006) who argues that the consideration of inconsistent systems is a useful device for a number of reasons: (1) it is often the only way to explore inconsistent information without arbitrarily rejecting precious data.",
      "startOffset" : 40,
      "endOffset" : 52
    }, {
      "referenceID" : 9,
      "context" : "In fact, we agree with Bueno (Bueno 2006) that considering inconsistent systems as inconsistent possibilistic answer sets is some times the only way to explore inconsistent information without arbitrarily rejecting precious data.",
      "startOffset" : 29,
      "endOffset" : 41
    }, {
      "referenceID" : 35,
      "context" : "Considering this idea, the authors of (Nicolas et al. 2006) defined the concept of α-cut for possibilistic logic programs.",
      "startOffset" : 38,
      "endOffset" : 59
    }, {
      "referenceID" : 35,
      "context" : "Based on Definition 14 of (Nicolas et al. 2006), we define its respective generalization for our approach.",
      "startOffset" : 26,
      "endOffset" : 47
    }, {
      "referenceID" : 35,
      "context" : ", remarked in (Nicolas et al. 2006), by the non-monotonicity of the framework, it is not certain that a higher cut is necessarily consistent.",
      "startOffset" : 14,
      "endOffset" : 35
    }, {
      "referenceID" : 35,
      "context" : "in (Nicolas et al. 2006), was adopted.",
      "startOffset" : 3,
      "endOffset" : 24
    }, {
      "referenceID" : 27,
      "context" : "(Kifer and Subrahmanian 1992).",
      "startOffset" : 0,
      "endOffset" : 29
    }, {
      "referenceID" : 34,
      "context" : "(Ng and Subrahmanian 1992; Lukasiewicz 1998; Kern-Isberner and Lukasiewicz 2004; Baral et al. 2009).",
      "startOffset" : 0,
      "endOffset" : 99
    }, {
      "referenceID" : 31,
      "context" : "(Ng and Subrahmanian 1992; Lukasiewicz 1998; Kern-Isberner and Lukasiewicz 2004; Baral et al. 2009).",
      "startOffset" : 0,
      "endOffset" : 99
    }, {
      "referenceID" : 26,
      "context" : "(Ng and Subrahmanian 1992; Lukasiewicz 1998; Kern-Isberner and Lukasiewicz 2004; Baral et al. 2009).",
      "startOffset" : 0,
      "endOffset" : 99
    }, {
      "referenceID" : 5,
      "context" : "(Ng and Subrahmanian 1992; Lukasiewicz 1998; Kern-Isberner and Lukasiewicz 2004; Baral et al. 2009).",
      "startOffset" : 0,
      "endOffset" : 99
    }, {
      "referenceID" : 46,
      "context" : "(van Emden 1986; Rodríguez-Artalejo and Romero-Díaz 2008; Van-Nieuwenborgh et al. 2007).",
      "startOffset" : 0,
      "endOffset" : 87
    }, {
      "referenceID" : 19,
      "context" : "(Fitting 1991; Lakshmanan 1994).",
      "startOffset" : 0,
      "endOffset" : 31
    }, {
      "referenceID" : 28,
      "context" : "(Fitting 1991; Lakshmanan 1994).",
      "startOffset" : 0,
      "endOffset" : 31
    }, {
      "referenceID" : 3,
      "context" : "(Baldwin 1987).",
      "startOffset" : 0,
      "endOffset" : 14
    }, {
      "referenceID" : 16,
      "context" : "(Dubois et al. 1991; Alsinet and Godo 2002; Alsinet and Godo 2000; Alsinet et al. 2008; Nicolas et al. 2006).",
      "startOffset" : 0,
      "endOffset" : 108
    }, {
      "referenceID" : 2,
      "context" : "(Dubois et al. 1991; Alsinet and Godo 2002; Alsinet and Godo 2000; Alsinet et al. 2008; Nicolas et al. 2006).",
      "startOffset" : 0,
      "endOffset" : 108
    }, {
      "referenceID" : 1,
      "context" : "(Dubois et al. 1991; Alsinet and Godo 2002; Alsinet and Godo 2000; Alsinet et al. 2008; Nicolas et al. 2006).",
      "startOffset" : 0,
      "endOffset" : 108
    }, {
      "referenceID" : 0,
      "context" : "(Dubois et al. 1991; Alsinet and Godo 2002; Alsinet and Godo 2000; Alsinet et al. 2008; Nicolas et al. 2006).",
      "startOffset" : 0,
      "endOffset" : 108
    }, {
      "referenceID" : 35,
      "context" : "(Dubois et al. 1991; Alsinet and Godo 2002; Alsinet and Godo 2000; Alsinet et al. 2008; Nicolas et al. 2006).",
      "startOffset" : 0,
      "endOffset" : 108
    }, {
      "referenceID" : 35,
      "context" : ", (Nicolas et al. 2006), none of these approaches describe a formalism for dealing with uncertainty in a logic program with default negation by means of possibilistic logic.",
      "startOffset" : 2,
      "endOffset" : 23
    }, {
      "referenceID" : 35,
      "context" : "Let us recall that the work of (Nicolas et al. 2006) is totally captured by the formalism presented in this paper (Proposition 5), but not directly vice versa.",
      "startOffset" : 31,
      "endOffset" : 52
    }, {
      "referenceID" : 4,
      "context" : "By considering a standard transformation from disjunctive clauses to normal clauses (Baral 2003), this program can be transformed to the possibilistic normal logic programs P :",
      "startOffset" : 84,
      "endOffset" : 96
    }, {
      "referenceID" : 32,
      "context" : "Even though, one can find a wide range of formalisms for dealing with uncertainty by using normal logic programs, there are few proposals for dealing with uncertainty by using disjunctive logic programs (Lukasiewicz 2001; Gergatsoulis et al. 2001; Mateis 2000; Baral et al. 2009):",
      "startOffset" : 203,
      "endOffset" : 279
    }, {
      "referenceID" : 25,
      "context" : "Even though, one can find a wide range of formalisms for dealing with uncertainty by using normal logic programs, there are few proposals for dealing with uncertainty by using disjunctive logic programs (Lukasiewicz 2001; Gergatsoulis et al. 2001; Mateis 2000; Baral et al. 2009):",
      "startOffset" : 203,
      "endOffset" : 279
    }, {
      "referenceID" : 33,
      "context" : "Even though, one can find a wide range of formalisms for dealing with uncertainty by using normal logic programs, there are few proposals for dealing with uncertainty by using disjunctive logic programs (Lukasiewicz 2001; Gergatsoulis et al. 2001; Mateis 2000; Baral et al. 2009):",
      "startOffset" : 203,
      "endOffset" : 279
    }, {
      "referenceID" : 5,
      "context" : "Even though, one can find a wide range of formalisms for dealing with uncertainty by using normal logic programs, there are few proposals for dealing with uncertainty by using disjunctive logic programs (Lukasiewicz 2001; Gergatsoulis et al. 2001; Mateis 2000; Baral et al. 2009):",
      "startOffset" : 203,
      "endOffset" : 279
    }, {
      "referenceID" : 32,
      "context" : "• In (Lukasiewicz 2001), Many-Valued Disjunctive Logic Programs with probabilistic semantics are introduced.",
      "startOffset" : 5,
      "endOffset" : 23
    }, {
      "referenceID" : 25,
      "context" : "• In (Gergatsoulis et al. 2001), the logic programming language Disjunctive Chronolog is introduced.",
      "startOffset" : 5,
      "endOffset" : 31
    }, {
      "referenceID" : 33,
      "context" : "• In (Mateis 2000), the Quantitative Disjunctive Logic Programs (QDLP) are introduced.",
      "startOffset" : 5,
      "endOffset" : 18
    }, {
      "referenceID" : 5,
      "context" : "• In (Baral et al. 2009), intensive research is done in order to achieve a complete integration between ASP and probability theory.",
      "startOffset" : 5,
      "endOffset" : 24
    }, {
      "referenceID" : 40,
      "context" : "For instance, the answer set semantics inference can be characterized as a logic inference in terms of the proof theory of intuitionistic logic and intermediate logics (Pearce 1999; Osorio et al. 2004).",
      "startOffset" : 168,
      "endOffset" : 201
    }, {
      "referenceID" : 39,
      "context" : "For instance, the answer set semantics inference can be characterized as a logic inference in terms of the proof theory of intuitionistic logic and intermediate logics (Pearce 1999; Osorio et al. 2004).",
      "startOffset" : 168,
      "endOffset" : 201
    }, {
      "referenceID" : 35,
      "context" : "In order to achieve the first goal, the work presented in (Nicolas et al. 2006) was taken as a reference point.",
      "startOffset" : 58,
      "endOffset" : 79
    }, {
      "referenceID" : 35,
      "context" : "Unlike the approach of (Nicolas et al. 2006), which is restricted to possibilistic normal programs, we define a possibilistic logic programming framework based on possibilistic disjunctive logic programs.",
      "startOffset" : 23,
      "endOffset" : 44
    }, {
      "referenceID" : 35,
      "context" : "in (Nicolas et al. 2006) of cuts for achieving consistent subprograms of P .",
      "startOffset" : 3,
      "endOffset" : 24
    }, {
      "referenceID" : 40,
      "context" : "This issue is motivated by the fact that the answer set semantic inference can be characterized as a logic inference in terms of intuitionistic logic (Pearce 1999; Osorio et al. 2004).",
      "startOffset" : 150,
      "endOffset" : 183
    }, {
      "referenceID" : 39,
      "context" : "This issue is motivated by the fact that the answer set semantic inference can be characterized as a logic inference in terms of intuitionistic logic (Pearce 1999; Osorio et al. 2004).",
      "startOffset" : 150,
      "endOffset" : 183
    }, {
      "referenceID" : 38,
      "context" : "In (Nieves et al. 2007), we have already defined our first ideas in the context of the action languageA.",
      "startOffset" : 3,
      "endOffset" : 23
    }, {
      "referenceID" : 10,
      "context" : "With this objective in mind, possibilistic ordered disjunction programs have been explored (Confalonieri et al. 2010).",
      "startOffset" : 91,
      "endOffset" : 117
    } ],
    "year" : 2011,
    "abstractText" : "In this paper, a possibilistic disjunctive logic programming approach for modeling uncertain, incomplete and inconsistent information is defined. This approach introduces the use of possibilistic disjunctive clauses which are able to capture incomplete information and incomplete states of a knowledge base at the same time. By considering a possibilistic logic program as a possibilistic logic theory, a construction of a possibilistic logic programming semantic based on answer sets and the proof theory of possibilistic logic is defined. It shows that this possibilistic semantics for disjunctive logic programs can be characterized by a fixed-point operator. It is also shown that the suggested possibilistic semantics can be computed by a resolution algorithm and the consideration of optimal refutations from a possibilistic logic theory. In order to manage inconsistent possibilistic logic programs, a preference criterion between inconsistent possibilistic models is defined; in addition, the approach of cuts for restoring consistency of an inconsistent possibilistic knowledge base is adopted. The approach is illustrated in a medical scenario.",
    "creator" : "LaTeX with hyperref package"
  }
}