{
  "name" : "1005.1475.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Luca Saiu", "Jean-Vincent Loddo" ],
    "emails" : [ "loddo@lipn.univ-paris13.fr", "saiu@lipn.univ-paris13.fr" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n00 5.\n14 75\nv2 [\ncs .A\nI] 1\n1 M\nay 2\n01 0\nKey words: combinatorial game, search, alpha-beta pruning, rational game, tropical algebra, tropical game, term, rewriting, logic, parsing"
    }, {
      "heading" : "1 Introduction",
      "text" : "We are all familiar with games such as Chess or Checkers. Such games are purely rational as they do not involve any element of chance; they are also zero-sum, as the players’ interests are dual: what one “wins”, the other “loses” — which is the origin of the min-max evaluation mechanism. The two fundamental questions to be asked in a rational game are “Who will win?” and “How much will she win?”. Answering such questions involves searching for a strategy trough a (typically large) game tree. Some optimized search techniques were developed, which in the case of combinatorial two-player games include the α-β pruning technique [1,2]. α-β is not an approximated algorithm: its correctness relies on the mutual distributive properties of min and max. In this work we explore the implications of assuming only one player to be rational, breaking the symmetry of the traditional “double-sided” rationality. Quite unsurprisingly our tropical α-pruning depends on just one distributive property, a requirement satisfied by tropical algebras (Section 3).\nFollowing the style introduced by [3] and [4], we will distinguish two aspects of two-player combinatorial games: a first one that we call syntactic, consisting\nThis work is partially financed by Marie Curie action n. 29849 Websicola and ANR06-JCJC-0122. The final publication of this paper is available at www.springerlink.com.\nin a description of the possible game positions and the valid moves leading from a position to another; the game syntax is the formal equivalent of the intuitive notion of the “game rules”. By contrast the semantic aspect is concerned about the interpretation of the game according to the interests of the players, and ultimately about the answer to the two fundamental questions above. Our semantics will be based on tropical algebras, and as a consequence our technique is widely applicable, relying as it does only on their comparatively weak hypotheses.\nWe formally define tropical α-pruning and prove its soundness, as our main contribution (Section 4). A further contribution consists in our formalization of game evaluation and tropical (and α-β) cuts as a small-step semantics, so that proofs can reuse the results of term-rewriting theory.\nActually, our soundness result subsumes other works proving α-β’s soundness over distributive lattices such as [4] and (later) [5], since distributive lattices are bi-tropical structures (Definition 8).\nWe conclude by proposing the algorithm design style Choose-How-To-Divide and Conquer meant for attacking even apparently unrelated search problems as tropical games; we develop approximated parsing as one such problem by showing how it profits from α-pruning (Section 5)."
    }, {
      "heading" : "2 Combinatorial game syntax and semantics",
      "text" : ""
    }, {
      "heading" : "2.1 Syntax",
      "text" : "We speak about “syntax”, hinting at formal grammars, in that some initial game positions are given, together with some “rule” allowing to derive successive positions from those: in this way a game can be seen as the tree of all the possibilities of playing it — the tree of all the possible matches.\nDefinition 1 (Syntax). A game syntax or arena is a triple S = (P, λ, succ), where:\n– P is the set of all game positions. – the turn function λ : P → {P ,O}, says whose turn it is: P for “player” or\nO for “opponent”. – the successor function succ, taking a game position and returning all the\npositions reachable with valid moves from there; succ : P → P∗.\nGiven S = (P, λ, succ), we define:\n– the set of terminal positions PT = {π ∈ P | succ(π) = 〈〉}. – the dual arena S⊥ = (P, λ⊥, succ), of course with λ⊥ : P → {P ,O}, where\nfor any π ∈ P we have λ⊥(π) 6= λ(π). – the move relation is the binary version of the succ relation: for all π, π′ ∈ P,\nmove(π, π′) iff π′ = πi for some i, where succ(π) = 〈π1...πn〉.\nThe arena is called alternate-turn iff move(π, π′) implies λ(π) 6= λ(π′). If move is Nötherian we speak about Nötherian or finite arena.\nRemark 1 (Alternate-turn arenas). It is possible to systematically make a game alternate-turn by “collapsing” all the sequences of consecutive moves of the same player into single moves.\nOne of the most important ideas in Game Theory is the strategy, containing a plan to win the game — a player saying to herself “if this happens I should do that, but if this other thing happens I should do that, and so on”. It should be noticed that a strategy is only related to the syntactic part of a game, being independent, per se, from the game evaluation. In particular, a strategy may very well not be winning.\nDefinition 2 (Strategy). Let S = (P, λ, succ) be an arena, and π ∈ P be a position. We define:\n– the reachable positions from π as the right elements of the reflexive-transitive closure of the relation succ: π↓ = succ∗(π); – a global strategy σ, as a subset of the relation succ which is: • deterministic in P positions: for all π ∈ P where λ(π) = P, if succ(π) = 〈π1...πn〉 then σ(π) = 〈πi〉, for some i such that 1 ≤ i ≤ n.\n• complete in O positions: for all π ∈ P where λ(π) = O, σ(π) = succ(π).\n– a strategy for the initial position π is a global strategy for the restricted arena Sπ = (π↓, λ|π↓, succ|π↓), where we indicate with f |D the restriction of a function f to the set D."
    }, {
      "heading" : "2.2 Semantics",
      "text" : "Let us assume a finite game with syntax S = (P, λ, succ). Traditionally the two players have exactly opposed interests and we assume, by convention, that the player P will try to minimize the payoff of the final position while the opponent O will try to maximize it.\nThe ordinary way of evaluating such a finite game consists in labeling nonterminal nodes with the functions min and max (according to the turn), and terminal nodes with the payoff of the terminal position p(π). Such values are then “propagated” back, applying the function at each node to its children’s values. The final value at the root is called the game value: it says who wins and how much, supposing both players to be rational.\nHence, assuming p : PT → Z in accord to the tradition, the game value vp : P → Z could be simply defined as a function of the initial position:\nvp(π) =\n\n \n \np(π), π ∈ PT minni=1 vp(πi), succ(π) = 〈π1...πn〉, λ(π) = P maxni=1 vp(πi), succ(π) = 〈π1...πn〉, λ(π) = O\nThis classical definition has the obvious defect of only supporting the function min and max; often for resolving actual games the preferred structure is Z, Q (possibly extended with −∞ and +∞), floating point numbers, or some sort\nof tuples containing such structures on which a topological order is defined. Hence, in order to be more general, let us define U to be any set closed over two associative binary operations ⊕ and ⊙, where ⊕ will be associated to the player and ⊙ to the opponent. Assuming p : P → U, the definition above would become:\nvp(π) =\n\n      \n     \np(π), π ∈ PT n ⊕\ni=1\nvp(πi), succ(π) = 〈π1...πn〉, λ(π) = P\nn ⊙\ni=1\nvp(πi), succ(π) = 〈π1...πn〉, λ(π) = O\nThe extended vp above is a step forward, but it still has the problem of only being well-defined on finite games. We solve this problem by abandoning the functional definition of vp altogether, and giving a small-step semantics instead. Actually, this style will also be useful in Section 4.1 to prove the soundness of our pruning technique.\nRemark 2 (Invariance under alternate-turn transformation). It is easy to see that the transformation hinted at in Remark 1 does not alter semantics, because of the two associative properties.\nDefinition 3 (Game). A game is the triple G = (S,A, p), where S = (P, λ, succ) is the syntax, A = (U,⊕,⊙) is an algebra with associative operations ⊕ and ⊙, and where p : PT → U is the payoff function.\nSometimes we informally refer to syntactic or semantic properties as if they belonged to a game, for example by speaking about “Nötherian game” instead of “Game with Nötherian syntax”.\nSmall-step operational semantics In the following, we assume a game G = (S,A, p), where S = (P, λ, succ) and A = (U,⊕,⊙). The configurations of our system consist of (ground) terms of G, recursively defined as: Ter(G) = P ⊎ U ⊎ ({ ∑ , ∏ } × Ter(G)+):\n– positions in P indicate game positions still to be expanded (if not terminal) and evaluated (otherwise).\n– values in U denote the value, already fully computed, of some sub-terms. – a complex term such as ∑ 〈t1...tn〉 or ∏\n〈t1...tn〉 indicates a position at some state of its evaluation; ∑ or ∏\nholding the turn information, and t1...tn representing the game subterms from that state on.\nIt is crucial not to mistake terms of G, which represent partially expanded game trees, for game positions, which in practice will also tend to be structured symbolic terms, but can be considered atomic at a high level: the rewrite rules shown in the following work on Ter(G), not on P.\nSyntactic conventions We use (possibly with subscripts or primes) π to indicate positions in P, s and t for generic terms, v for values in U, t and z for of terms in Ter(G). Sequences are allowed to be empty, if not specified otherwise in a side condition. Just to make the notation more compact we will write ∑\nt instead of ( ∑ , t) and ∏ t for ( ∏ , t). We write Λ instead of either ∑ or ∏\n, just to avoid duplicating otherwise identical rules. Sequences are written with no commas, and parentheses or brackets are used to group when needed.\nπ ∈ PT p(π) = v [Payoff] π → v\nsucc(π) = t λ(π) = P [P-expand] #t ≥ 1\nπ → ∑ t\nsucc(π) = t λ(π) = O [O-expand] #t ≥ 1\nπ → ∏ t\nhack[P-reduce] v1 ⊕ v2 = v∑ t〈v1 v2〉z → ∑ t〈v〉z\nhack[O-reduce] v1 ⊙ v2 = v∏ t〈v1 v2〉z → ∏ t〈v〉z\nhack[Return] Λ〈v〉 → v\nt → t′[Context] for all contexts C C[t] →c C[t ′]\n[Payoff] simply replaces a terminal position with its value in U, by means of the payoff function. [P-expand] and [O-expand] expand a position, generating its successors and keeping track of the turn, which will be important at reduction time. [P-reduce] and [O-reduce] combine two values into one, using ⊕ for the player and ⊙ for the opponent. Notice that these two rules are sources of non-determinism. [Return] unwraps a completely evaluated term containing a single value. [Context] allows to use the other rules within nested terms (also introducing non-determinism).\nNotice that keeping the relation →c distinct from → allows us, when needed, to see our semantics as a term rewriting system (TRS) [6].\nProposition 1. →c is strongly confluent.\nProof. For the purposes of this proof, we consider the small-step semantics as a pure term-rewriting system, expressed in a slightly sugared notation. The system does not need to be conditional (CTRS), since all the rule premises can in fact be seen as structural constraints on syntactic constructors. ⊕ and ⊙ should also be read as syntactic constructors, with their associative properties written as rewrite rules. What is a variable in the rules becomes a (syntactic) variable in the TRS; however, we will not exploit the full power of the formal system: reductions will only be applied to ground terms1.\n1 We do not need the full power of unification: from a programming point of view, pattern matching as used in ML or Haskell is enough for our purposes.\nOur TRS is trivially left- and right-linear, as no variable occurs more than once in each side of a rule. By showing that our system is also strongly closed, strong confluence follows by Huet’s Lemma 3.2 in [7]: “If R is a left- and rightlinear strongly closed term rewriting system, →R is strongly confluent”.\nIn order to show that the system is strongly-closed, we have to show that for every critical pair s, t there exist s′, t′ such that s →∗ t′ ←≡ t and t →∗ s′ ←≡ s (as in [7] and [6]), where ←≡ is the reflexive closure of ←.\nThe left-hand side of [P-reduce] is ∑\nt〈v1 v2〉z. When this rule is used to generate a critical pair with any other rule, only a variable in t or in z can match, with the whole left-hand side of the other rule. The resulting critical pair s, t reaches confluence (to s′ = t′) in one step because redexes are non-overlapping. The same holds for [O-reduce].\nThe only rule pairs candidate for overlapping are [P-reduce] with itself, and [O-reduce] with itself; we only show the first one. The only interesting case of overlapping is the term family ∑\nt〈v1 v2 v3〉z, generating the critical pair s, t. Notice that s′ → t′ and vice-versa because of the associativity of ⊕:\n∑\nt〈v1 v2 v3〉z ւ ց\ns = ∑ t〈(v1 ⊕ v2)v3〉z ∑\nt〈v1(v2 ⊕ v3)〉z = t ↓ ↓\ns′ = ∑ t〈(v1 ⊕ v2)⊕ v3〉z ⇆ ∑ t〈v1 ⊕ (v2 ⊕ v3)〉z = t ′ ⊓⊔\nDefinition 4 (Game tree). Let _ be the sub-rewrite system of →c, made only by the rules [P-expand], [O-expand] and [Context]: given an initial position π0 ∈ P, the set of game tree prefixes from π0 is the set Tπ0 = {t | π0 _\n∗ t}. The game tree, if it exists, is the tree tπ0 ∈ Tπ0 whose positions are all terminal.\nThe game tree tπ0 is well-defined: when it exists it is unique. Actually, the TRS defining _∗ is non-ambiguous (there is no overlap among any reduction rules) and left-linear: such a TRS is called orthogonal, and any orthogonal TRS is confluent [8].\nProposition 2. →c is normalizing for any Nötherian game.\nProof. Let a game G = (S,A, p) where S = (P, λ, succ) and A = (U,⊕,⊙) be given. We prove normalization by exhibiting a reduction order < compatible with our rules [6].\nLet us define a weight function w : P → N to be a particular instance of the higher-order function vp̄ : P → U, where p̄(π) = 2 for any π ∈ PT and ⊕n\ni=1 xi = ⊙n i=1 xi = 2+ ∑n i=1 xi for any x ∈ N ∗. Intuitively, w returns 2 times\nthe number of nodes in the game tree for Nötherian games. Let f : Ter(G) → N be:\nf(π) = w(π), π ∈ P f(v) = 1, v ∈ U f(Λ〈t1...tn〉) = 1 + ∑n i=1 f(ti)\nIn the formula above and in the rest of this proof ∑\nrepresents the sum operation over N. We define our order on terms by using the interpretation f on >N: by definition, let t0 > t1 iff f(t0) >N f(t1). The order > is trivially stable, as\nour terms do not contain variables. > is also monotonic (f is increasing because + : N × N → N is increasing), strict (>N is strict) and well-founded (>N is well-founded). Hence, > is a reduction order.\nIn order to prove compatibility we show that for every rule l → r we have l > r, which by definition is equivalent to f(l) >N f(r). All equalities follow from definitions or trivial algebraic manipulations:\n– [Payoff]: f(π) = w(π) = p̄(π) = 2 >N 1 = f(v). – [P-expand], [O-expand]: f(π) = w(π) = 2+ ∑n\ni=1 w(πi) >N 1+ ∑n\ni=1 w(πi) = 1 + ∑n\ni=1 f(ti) = f(Λ t).\n– [P-reduce], [O-reduce]: f(Λ t〈v1v2〉z) = ∑#t i=1 f(ti)+f(v1)+f(v2)+ ∑#z\ni=1 f(zi) = ∑#t\ni=1 f(ti)+1+1+ ∑#z i=1 f(zi) >N ∑#t i=1 f(ti)+1+ ∑#z i=1 f(zi) = f(Λ t〈v〉z).\n– [Return]: f(Λ〈v〉) = 1 + 1 >N 1 = f(v). ⊓⊔\nIntuitively, if a term converges then its sub-terms also converge; said otherwise if a term converges in a context, then it must also converge in the trivial (empty) context. This is true because of the non-erasing nature of our system, different from, for example, the λ-calculus having actual reduction steps [8]. More formally:\nLemma 1 (Sub-term normalization). Given a game G = (S,A, p) where A = (U,⊕,⊙), for any term t ∈ Ter(G) and any context C, if there exists v ∈ U such that C[t] →∗c v then there exists v ′ ∈ U such that t →∗c v ′.\nProof. By induction over the derivation length n of C[t] →∗c v. We look at the possible shape of the premise of the [Context] rule, s → s′.\n– Base case, n = 1: C[t] →c v. The only applicable rules are [Payoff] and [Return]: in the case of [Payoff], C[t] = t; in the case of [Return], t = v. In either case, t →∗c v = v\n′. – Recursive case n ⇒ n+ 1: t0 = C[t] →c t1 → ∗ c v. The inductive hypothesis\nis that for any term t′ and context C′ if C′[t′] →∗c v in n or fewer steps, then t′ →∗c v\n′. Three cases: • s and t are disjoint sub-terms within C. Since the system is non-erasing t has not been erased, i.e. t1 = C ′[t]; for inductive hypothesis t →∗c v ′. • s contains t. s → s′ may have as its premise [Return], in which case s = Λ〈v〉 and t = v. Otherwise the premise may be [P-Reduce] or [OReduce]: either t is one of the values, or it matches one of the variables, in which case there exists a context C′ such that t1 = C\n′[t]; then the inductive hypothesis applies. • t contains s. t = C′[s], hence by definition of →c we have that t can turn into C′[s′] = t′. There exists a context C′′ where C[s] = C′′[C′[s]], hence t1 = C ′′[C′[s′]]. By induction hypothesis t′ = C′[s′] →∗c v ′. ⊓⊔\nNormalization and confluence justify our re-definition of the game value vp as the transitive closure of the transition relation →c:\nDefinition 5 (Game Value). Let a game, an initial position π and a value v be given; we say that the game value from π is v (and we write vp(π) = v) if and only if π →∗c v."
    }, {
      "heading" : "3 α-β pruning",
      "text" : "The α-β algorithm [1,2] is a method for computing the exact value of a min-max combinatorial game without exhaustively visiting all game positions.\nThe α-β algorithm is traditionally presented as a recursive function written in imperative style (see Figure 1): the function alpha_beta analyzes a game position π ∈ P with two additional parameters, α and β, each one denoting a sort of threshold not to be overstepped during the incremental computation of the value of P. Whenever the threshold is past the evaluation of an entire subtree is aborted, as it can be proven that it will not contribute to the result.\nThe correctness of α-β relies on the algebraic properties of the min and max functions, notably their mutual distributive laws — something we can not count on under our weaker hypotheses on ⊕ and ⊙ [4,5,3].\nGoing back to our game semantics presentation we can model the α-β’s behavior by adding four more rules — two per player:\nhack[P-will] ∑ 〈α [ ∏ 〈β ( ∑ t1)〉 t2]〉 t3 → ∑ 〈α [ ∏ 〈β ( ∑ 〈α〉t1)〉 t2]〉 t3\nhack[O-will] ∏ 〈β [ ∑ 〈α ( ∏ t1)〉 t2]〉 t3 → ∏ 〈β [ ∑ 〈α ( ∏ 〈β〉t1)〉 t2]〉 t3\nα⊕ β = α [P-cut] ∑\n〈α ( ∏ 〈β〉t1)〉 t2 → ∑ 〈α〉t2\nβ ⊙ α = β [O-cut] ∏\n〈β ( ∑ 〈α〉t1)〉 t2 → ∏ 〈β〉t2\nThe initialization of v at line 6 should be read as a first “virtual” move of the player, whose evaluation is the value α inherited from an ancestor (the grandparent in an alternate-turn game). This explains the rationale of [P-will]2: whenever subtrees are nested with turns P-O-P , a grandparent may cross two levels and “give” its grandchild its current accumulator as an initialization value. Of course line 10 is the dual version for the opponent and [O-will].\n[P-cut] and [O-cut] are a simple reformulation of the cut conditions at lines 7 and 11, where the explicit order <Z disappears\n3 from the condition, now expressed as an equality constraint in the rule premise: α ⊕ β = α represents the fact that the player would prefer α over β. Dually, β ⊙ α = β means that the opponent would prefer β over α.\nRemark 3 (Non-alternate turn games). Notice that the cut rules can just fire in alternate-turn contexts: this choice simplifies our exposition, but does not limit generality: see Remarks 1 and 2.\nThe presence of two exactly symmetrical behaviors is quite evident in either presentation; yet what we are interested in showing now is the fact that such duality is quite incidental: it occurs in a natural way in actual two-player games, yet many more search problems lend themselves to be modeled as games despite lacking an intrinsic symmetry.\nWe can see α-β as the union of two separate techniques applied at the same time, breaking the algebraic symmetry of the player/opponent operations: in the following we are going to eliminate the rules [O-will] and [O-cut], or equivalently to turn alpha_beta into tropical (see Figure 1), exploiting the weaker properties of tropical algebras which only allow one threshold α."
    }, {
      "heading" : "4 Tropical games",
      "text" : "As we are dealing with a relatively young research topic, it is not surprising that the formalization of tropical algebras has not yet crystallized into a standard form. And since several details differ among the various presentations, we have to provide our own definition:\nDefinition 6 (Tropical Algebra). An algebra (U,⊕,⊙) is called a tropical algebra if it satisfies the following properties for any a, b and c in U:\n(i) Associativity of ⊕: a⊕ (b⊕ c) = (a⊕ b)⊕ c (ii) Associativity of ⊙: a⊙ (b⊙ c) = (a⊙ b)⊙ c (iii) Left-distributivity of ⊙ with respect to ⊕: a⊙ (b⊕ c) = (a⊙ b)⊕ (a⊙ c) (iv) Right-distributivity of ⊙ with respect to ⊕: (a⊕ b)⊙ c = (a⊙ c)⊕ (b⊙ c)\n2 “Will” should be interpreted as “bequeath”, in the sense of leaving something as inheritance to a descendent. 3 This is customary with lattices, when an order is derived from a least-upper-bound or greatest-lower-bound operation.\nSome particular choices of U, ⊕ and ⊙ are widely used: the min-plus algebra is obtained by defining U , R ∪ {+∞}, a⊕ b , min{a, b} and, a little counterintuitively4, a⊙ b , a+ b.\nSince U and ⊙ can also be usefully instantiated in other ways, we will not simply adopt a min-plus algebra; anyway in practice we will also choose ⊕ to be a minimum on U, which in practice will have a total order. This seems to be the only reasonable choice for the applications5 and helps to understand the idea, yet nothing in the theory depends on the existence of the order. Again, in practice, ⊕ will return one of its parameters, so if needed we will always be able to trivially define a total order as x ≤ y iff x ⊕ y = x, for any x and y in U. ⊕ and ⊙ will also tend to be commutative in practice, making one of the two distributive properties trivial.\nWe will not make any of the supplementary hypotheses above; on the other hand, we will require the following rationality hypothesis6:\nDefinition 7 (Rationality). Let (U,⊕,⊙) be a tropical algebra such that 0 ∈ U is a neutral element for ⊕ and 1 ∈ U is a neutral element for ⊙7. We call the algebra rational if, for any x, y, z ∈ U we have x⊕ (y ⊙ x⊙ z) = x.\nIntuitively, the opponent accumulates costs with ⊙, “worsening” the game value for the player: the player will always choose just x over x “worsened” by something else. Notice that the notion of rationality for two-player games in Game Theory also includes the dual condition x⊙(y⊕x⊕z) = x; such condition does not hold in general for tropical games.\nDefinition 8 (Tropical Game, Tropical Trees). A tropical game G = (S,A, p) is simply a game based on a rational tropical algebra A. We call tropical trees all the game trees of a tropical game, and tropical pruning the α-pruning of a tropical tree. A bi-tropical game is a tropical game whose dual G⊥ = (S⊥,A⊥, p) is also tropical, where A⊥ = (U,⊙,⊕) if A = (U,⊕,⊙)."
    }, {
      "heading" : "4.1 Soundness of tropical pruning",
      "text" : "Proposition 3 (Insertion property). Let (U,⊕,⊙) be a rational tropical algebra. Then for any x, y, α, β ∈ U we have α⊕(β⊙x⊙y) = α⊕(β⊙(α⊕x)⊙y).\nProof (Using associativity implicitly). α⊕(β⊙(α⊕x)⊙y) = {right-distributivity} α⊕(β⊙((α⊙y)⊕(x⊙y))) = {left-distributivity} (α⊕(β⊙α⊙y)⊕(β⊙x⊙y) = {rationality} α⊕ (β ⊙ x⊙ y) ⊓⊔\n4 The particular symbols used for indicating ⊕ and ⊙ are justified by the analogy with + and · in how the distributive law works. 5 Logic programming is an example of an interesting problem lending itself to be interpreted as a combinatorial game on a universe with no total order [3,4]. Anyway the underlying game is a symmetrical inf-sup rather than simply tropical. 6 In lattice theory, the rationality hypothesis is one of the absorption identities. 7 The existence of neutral elements is not strictly necessary, but it simplifies many statements and proofs; without them several results should be given in both “left” and “right” forms.\nThe insertion property is the semantic counterpart of the rule [P-will]: it explains why we can “transfer” α down in the tree (or more operationally, why we can “start” from the same α when choosing with ⊕ two plies below), without affecting the game value.\nDefinition 9 (P-irrelevance). Let (U,⊕,⊙) be a rational tropical algebra, and let α, β ∈ U. Then we call x ∈ U P-irrelevant with respect to α and β if α ⊕ (β ⊙ x) = α.\nIntuitively, as the value of an opponent-level tree, x can’t affect the value of the game because the player will not give the opponent the opportunity to be in that situation: in other word, the current optimal move for the player doesn’t change because of x.\nLemma 2 (P-irrelevance). Let (U,⊕,⊙) be a rational tropical algebra, and α, β ∈ U. If α⊕ β = α then any x ∈ U is P-irrelevant with respect to α and β.\nProof. α⊕ (β ⊙ x) = {hypothesis} (α⊕ β)⊕ (β ⊙ x) = {associativity} α⊕ (β ⊕ (β ⊙ x)) = {rationality} α⊕ β = {hypothesis} α ⊓⊔\nDefinition 10 (Simulation). Given a tropical game, we say that a term t′ simulates a term t, and we write t ≤ t′, if t →∗c v ⇒ t ′ →∗c v.\nLemma 3 (Tropical P-will simulation). Given a tropical game G = (S,A, p) where A = (U,⊕,⊙), for any term sequence α, β ∈ U, t0, t1, t2 ∈ Ter(G) ∗\n∑ 〈α [ ∏ 〈β ( ∑ t0)〉 t1]〉 t2 ≤ ∑ 〈α [ ∏ 〈β ( ∑ 〈α〉 t0)〉 t1]〉 t2\nProof. By the Sub-term normalization Lemma, if t converges there will exist some value sequences v0,v1,v2 ∈ U such that t0 → ∗ v0, t1 → ∗ v1, t2 →\n∗ v2; let us call v0 the result of ⊕ v0, v1 the result of ⊙ v1 and v2 the result of ⊕\nv2. Then,\n∑ 〈α [ ∏ 〈β ( ∑ t0)〉 t1]〉 t2 ∑ 〈α [ ∏ 〈β ( ∑\n〈α〉 t0)〉 t1]〉 t2 ↓∗ ↓∗\n∑ 〈α [ ∏ 〈β v0 v1〉] v2〉 ∑ 〈α [ ∏\n〈β (α⊕ v0) v1〉] v2〉 ↓∗ {Insertion} ↓∗\nα⊕ [β ⊙ v0 ⊙ v1]⊕ v2 = α⊕ [β ⊙ (α⊕ v0)⊙ v1]⊕ v2\nIn the reductions above we implicitly assume that some sequences are non-empty; the proof trivially generalizes to empty t1 and t2 by using neutral elements. ⊓⊔\nLemma 4 (Tropical cut simulation). Given a tropical game G = (S,A, p) where A = (U,⊕,⊙), for any term sequence α, β ∈ U, t0, t1 ∈ Ter(G)\n∗ we have that if α⊕ β = α, then ∑ 〈α ( ∏ 〈β〉 t0)〉 t1 ≤ ∑ 〈α〉 t1.\nProof. Just like Lemma 3, with P-irrelevance at the end. ⊓⊔\nTheorem 1 (Tropical rule soundness). Adding the rules [P-will] and [Pcut] “does not alter semantics”, i.e. if a term t converges to a value v in a system without the two new rules, it is guaranteed to have a reduction sequence converging to v also in the extended system. ⊓⊔"
    }, {
      "heading" : "5 Choose-How-To-Divide and Conquer",
      "text" : "According to the classical Divide and Conquer technique a problem can be divided into subproblems, each of which will be solved recursively until a minimalsize instance is found; sub-solutions will then be recomposed.\nIn the traditional Divide and Conquer style, each division choice is final: it is considered taken once and for all, and cannot be undone. By contrast we present an alternative model based on tropical games. In the Choose-How-To-Divide and Conquer style we work with non-deterministic choices in a solution space, using a quality criterion to be optimized and some way of “combining” sub-solutions.\nOf course many nondeterministic algorithms can be expressed this way: the challenge is finding a suitable mapping to the tropical game concepts, in term of both syntax and semantics (with the required properties). The problem must have both a suitable syntactic structure, and a semantic structure with the required properties.\nThe action of choosing a division corresponds to a player node where the ⊕ function (typically a minimization) returns the “best” option; the points where sub-solutions have their cost accumulated (often something similar to a sum, intuitively “opposed” to ⊕) become opponent nodes where ⊙ combines the values of a subtree sequence into a single result.\nTropical trees have the desirable property of supporting α-pruning, with the potential of significantly cutting down the search space. The more [P-will] and [P-cut] can fire, the more pruning is profitable: hence the problem should be represented as a tropical game having alternate turns and branching factor greater than 2 for O at least “often enough”. Search problems abound in Artificial Intelligence, and in particular we suspect that more symbolic computation problems than one might expect can be modeled this way. We now proceed to show an unusual application of Choose-HowTo-Divide and Conquer."
    }, {
      "heading" : "5.1 Parsing as a tropical game",
      "text" : "Let G be a given context-free grammar, defined over an alphabet of terminals A ∋ a and nonterminals N ∋ X . For simplicity8 let it have no ǫ-production, nor any productions with two consecutive nonterminals or a single nonterminal alone in the right-hand side. Right-hand sides will hence be of the form [a1]X1a2X2...anXn[an+1], with n ≥ 0 and at least one ai. Given a string of terminals s ∈ A+ our problem is finding the “best” parse tree of s in G ; when s contains some errors our “best” solution just ends up being the least wrong, according to some metric; just to keep things simple in this example out metric to minimize will be the total size of the substrings which cannot be matched, in terminals. Sometimes we may wish to have the set of all best parses, instead of being content with just one optimal solution.\n8 Such restrictions can be lifted at the cost of some complexity, but supporting a larger class of grammars would be quite inessential for our demonstrative purposes.\nSyntax. The set of game positions is defined as P = (A∗×N)⊎ (A∗ ×N)∗, and the turn function is λ(s,X) = P , λ((s1, X1)...(sk, Xk)) = O. These definitions become easy to understand once the successor function succ is examined.\nA player position has the form πP = (s,X), since the player has to parse a string s with a nonterminalX . It has to choose a productionX ::= [a1]X1a2X2... anXn[an+1], and match the terminals ai with the terminals in s, in the right order. Each possible match of all terminals, for each production of X , is a valid player move generating strictly smaller subproblems for the opponent: the nonterminals Xi “in between” the matched terminals will have to be matched to substrings of s in the opponent position πO = (s1, X1)...(s1, Xn), for some n ≥ 0. If no match exists with any production then πP is terminal.\nIn an opponent position πO = (s1, X1)...(s1, Xn) the opponent has always exactly n moves: the opponent will give the player each pair (si, Xi) to solve “one at the time”. For this reason the successor of an opponent position is equal to the position itself: it is the sequence of the elements of πO, itself a sequence. An opponent position πO is terminal when it is empty.\nFigure 2 contains a practical example."
    }, {
      "heading" : "E ::= n",
      "text" : ""
    }, {
      "heading" : "E ::= v",
      "text" : ""
    }, {
      "heading" : "E ::= ( E )",
      "text" : "Semantics. We use a min-plus algebra for A = (U,⊕,⊙): we simply define U , N; we take ⊕ , min, since we want as few errors as possible; and finally ⊙ , +: the number of total errors in the parse tree is equal to the sum of the number of errors in all subtrees.\nThe payoff p(π) is defined as the length in characters of the input string for player positions (notice that the payoff is only defined on terminal positions, so such a length is actually the number of unmatched characters), and zero for opponent positions (if πO = 〈〉 then there are no errors to accumulate: at the level above, the player matched the whole string): p(s,X) , #s, p(〈〉) , 0.\nExperiments We implemented a prototype system9 in ML supporting the grammar of Figure 2, which can be configured to do a simple exhaustive search or perform tropical α-pruning. The prototype supports two policies: first-minimal (henceforth FM) searches for only one optimal strategy at P ’s levels, and allminimals (henceforth AM) generates a sequence of strategies with non-increasing cost. Just as illustrative examples, we proceed to show our system behavior on some input strings belonging to different categories.\nNon-ambiguous input: the input string \"let x = 42 in x + if 84=42 then 55 else 77\" is parsable in a unique way, so the FM policy is clearly the right choice. Compared to an exhaustive search the α-pruning FM version avoids 98% of the recursive calls (460 vs 28473) and its completion time is 4%. By setting the policy to AM the number of recursive call grows a little, from 460 to 671 (still avoiding 97% of the calls).\nAmbiguous input: with the input string \"let x = 84 = 42 = 21 in 1 + 2 * 3\", which is parsable in several ways, the the α-pruning FM version avoids 99% of the recursive calls (260 vs 61980), and the run time is 1% of the exhaustivesearch version time. The α-pruning AM version still avoids 96% of the recursive calls (2148 vs 61980), and its run time is 3%.\n“Wrong” input:with the input string \"if if if true then true else false then 10 else (1+(2+)+3)\", containing errors, the α-pruning FM version avoids 98% of the recursive calls (9640 vs 494344) and its run time is 3%, while the AM version avoids 97% of the recursive calls (13820 vs 494344); the AM version’s run time is reduced to 3%. The best strategy has value 6, corresponding to the size of the substring \"if true\" (blanks are not counted) added to the size (0) of the empty substring delimited by the tokens \"+\" and \")\". The α-pruning algorithm has localized errors, guessing that the user should fix her string by replacing \"if true\" with something correct and writing something correct between \"+\" and \")\" — having the size of the unmatched substrings as the payoff function yields this “smallest-incorrect-string” heuristic. Of course other more elaborate criteria are also possible, such as “minimum number of errors”.\nMemoization: on a completely orthogonal axis, the implementation may be configured to perform memoization: when memoization is turned on all the already solved positions are cached, so that they are not computed more than once. We have compared a memoizing version of our tropical-α-pruning parser with a memoizing version performing exhaustive search. In the first case above, the string \"let x = 42 in x + if 84=42 then 55 else 77\" is now parsed with 131 calls instead of 460, again saving 98% of the calls (131 vs 7295) and cutting the run time to 1%. \"let x = 84 = 42 = 21 in 1 + 2 * 3\" is now parsed with 72 calls instead of 260, avoiding 99% of the calls (72 vs 14443) and reducing the run time to 7%. The string \"if if if true then true else false then 10 else (1+(2+)+3)\" is parsed with 1206 calls instead of 9640, avoiding 96% of calls (1206 vs 36575) and cutting the completion time to 10%.\n9 The prototype is freely available under the GNU GPL license at the address http://www-lipn.univ-paris13.fr/~loddo/aisc-2010.\nAt least in our small test cases, tropical α-pruning and memoization work well together: enabling either one does not significantly lessen the efficacy of the other."
    }, {
      "heading" : "6 Conclusions and future work",
      "text" : "We have introduced and formally proved correct tropical α-pruning, a variant of α-β-pruning applicable to the tropical games underlying Choose-How-To-Divide and Conquer problems. As a practical example of the technique we have shown how the problem of approximated parsing and error localization can be modeled as a game, and how our pruning technique can dramatically improve its efficiency; yet an asymptotic measure of the visited node reduction would be a worthy development.\nWe suspect that many more problems can be formalized as tropical games, and the problem of parsing itself can also definitely be attacked in a more general way, lifting our restrictions on the grammar; tropical parsing might prove to be particularly suitable for natural language problems, with their inherent ambiguity.\nThe correctness and efficiency of parallel tropical α-pruning implementations would be particularly interesting to study.\nAcknowledgments Christophe Fouqueré first recognized tropical algebras in the properties required by our formalization."
    } ],
    "references" : [ {
      "title" : "The tree prune (TP) algorithm",
      "author" : [ "T.P. Hart", "D.J. Edwards" ],
      "venue" : "Artificial Intelligence Project Memo 30, Massachusetts Institute of Technology, Cambridge, Massachusetts",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 1961
    }, {
      "title" : "An analysis of alpha-beta pruning",
      "author" : [ "D.E. Knuth", "R.W. Moore" ],
      "venue" : "Artificial Intelligence 6",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1975
    }, {
      "title" : "Généralisation des Jeux Combinatoires et Applications aux Langages Logiques",
      "author" : [ "J.V. Loddo" ],
      "venue" : "PhD thesis, Université Paris VII",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Playing logic programs with the alpha-beta algorithm",
      "author" : [ "J.V. Loddo", "R.D. Cosmo" ],
      "venue" : "Logic for Programming and Automated Reasoning (LPAR). Number 1955 in LNCS, Springer",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Alpha-beta pruning under partial orders",
      "author" : [ "M.L. Ginsberg", "A. Jaffray" ],
      "venue" : "In Games of No Chance II.",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "First-order term rewriting systems",
      "author" : [ "J.W. Klop", "R. de Vrijer" ],
      "venue" : "In Terese, ed.: Term Rewriting Systems. Cambridge Universisty Press",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Confluent reductions: Abstract properties and applications to term rewriting systems: Abstract properties and applications to term rewriting systems",
      "author" : [ "G. Huet" ],
      "venue" : "J. ACM 27(4)",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 1980
    }, {
      "title" : "Orthogonality",
      "author" : [ "J.W. Klop", "V.V. Oostrom", "R. de Vrijer" ],
      "venue" : "In Terese, ed.: Term Rewriting Systems. Cambridge Universisty Press",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2003
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Some optimized search techniques were developed, which in the case of combinatorial two-player games include the α-β pruning technique [1,2].",
      "startOffset" : 135,
      "endOffset" : 140
    }, {
      "referenceID" : 1,
      "context" : "Some optimized search techniques were developed, which in the case of combinatorial two-player games include the α-β pruning technique [1,2].",
      "startOffset" : 135,
      "endOffset" : 140
    }, {
      "referenceID" : 2,
      "context" : "Following the style introduced by [3] and [4], we will distinguish two aspects of two-player combinatorial games: a first one that we call syntactic, consisting This work is partially financed by Marie Curie action n.",
      "startOffset" : 34,
      "endOffset" : 37
    }, {
      "referenceID" : 3,
      "context" : "Following the style introduced by [3] and [4], we will distinguish two aspects of two-player combinatorial games: a first one that we call syntactic, consisting This work is partially financed by Marie Curie action n.",
      "startOffset" : 42,
      "endOffset" : 45
    }, {
      "referenceID" : 3,
      "context" : "Actually, our soundness result subsumes other works proving α-β’s soundness over distributive lattices such as [4] and (later) [5], since distributive lattices are bi-tropical structures (Definition 8).",
      "startOffset" : 111,
      "endOffset" : 114
    }, {
      "referenceID" : 4,
      "context" : "Actually, our soundness result subsumes other works proving α-β’s soundness over distributive lattices such as [4] and (later) [5], since distributive lattices are bi-tropical structures (Definition 8).",
      "startOffset" : 127,
      "endOffset" : 130
    }, {
      "referenceID" : 5,
      "context" : "Notice that keeping the relation →c distinct from → allows us, when needed, to see our semantics as a term rewriting system (TRS) [6].",
      "startOffset" : 130,
      "endOffset" : 133
    }, {
      "referenceID" : 6,
      "context" : "2 in [7]: “If R is a left- and rightlinear strongly closed term rewriting system, →R is strongly confluent”.",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 6,
      "context" : "In order to show that the system is strongly-closed, we have to show that for every critical pair s, t there exist s, t such that s → t ← t and t → s ← s (as in [7] and [6]), where ← is the reflexive closure of ←.",
      "startOffset" : 161,
      "endOffset" : 164
    }, {
      "referenceID" : 5,
      "context" : "In order to show that the system is strongly-closed, we have to show that for every critical pair s, t there exist s, t such that s → t ← t and t → s ← s (as in [7] and [6]), where ← is the reflexive closure of ←.",
      "startOffset" : 169,
      "endOffset" : 172
    }, {
      "referenceID" : 7,
      "context" : "Actually, the TRS defining _ is non-ambiguous (there is no overlap among any reduction rules) and left-linear: such a TRS is called orthogonal, and any orthogonal TRS is confluent [8].",
      "startOffset" : 180,
      "endOffset" : 183
    }, {
      "referenceID" : 5,
      "context" : "We prove normalization by exhibiting a reduction order < compatible with our rules [6].",
      "startOffset" : 83,
      "endOffset" : 86
    }, {
      "referenceID" : 7,
      "context" : "This is true because of the non-erasing nature of our system, different from, for example, the λ-calculus having actual reduction steps [8].",
      "startOffset" : 136,
      "endOffset" : 139
    }, {
      "referenceID" : 0,
      "context" : "The α-β algorithm [1,2] is a method for computing the exact value of a min-max combinatorial game without exhaustively visiting all game positions.",
      "startOffset" : 18,
      "endOffset" : 23
    }, {
      "referenceID" : 1,
      "context" : "The α-β algorithm [1,2] is a method for computing the exact value of a min-max combinatorial game without exhaustively visiting all game positions.",
      "startOffset" : 18,
      "endOffset" : 23
    }, {
      "referenceID" : 3,
      "context" : "The correctness of α-β relies on the algebraic properties of the min and max functions, notably their mutual distributive laws — something we can not count on under our weaker hypotheses on ⊕ and ⊙ [4,5,3].",
      "startOffset" : 198,
      "endOffset" : 205
    }, {
      "referenceID" : 4,
      "context" : "The correctness of α-β relies on the algebraic properties of the min and max functions, notably their mutual distributive laws — something we can not count on under our weaker hypotheses on ⊕ and ⊙ [4,5,3].",
      "startOffset" : 198,
      "endOffset" : 205
    }, {
      "referenceID" : 2,
      "context" : "The correctness of α-β relies on the algebraic properties of the min and max functions, notably their mutual distributive laws — something we can not count on under our weaker hypotheses on ⊕ and ⊙ [4,5,3].",
      "startOffset" : 198,
      "endOffset" : 205
    }, {
      "referenceID" : 2,
      "context" : "5 Logic programming is an example of an interesting problem lending itself to be interpreted as a combinatorial game on a universe with no total order [3,4].",
      "startOffset" : 151,
      "endOffset" : 156
    }, {
      "referenceID" : 3,
      "context" : "5 Logic programming is an example of an interesting problem lending itself to be interpreted as a combinatorial game on a universe with no total order [3,4].",
      "startOffset" : 151,
      "endOffset" : 156
    } ],
    "year" : 2013,
    "abstractText" : "We present tropical games, a generalization of combinatorial min-max games based on tropical algebras. Our model breaks the traditional symmetry of rational zero-sum games where players have exactly opposed goals (min vs. max), is more widely applicable than min-max and also supports a form of pruning, despite it being less effective than α-β. Actually, min-max games may be seen as particular cases where both the game and its dual are tropical: when the dual of a tropical game is also tropical, the power of α-β is completely recovered. We formally develop the model and prove that the tropical pruning strategy is correct, then conclude by showing how the problem of approximated parsing can be modeled as a tropical game, profiting from pruning.",
    "creator" : "LaTeX with hyperref package"
  }
}