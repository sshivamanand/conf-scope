{
  "name" : "0912.0270.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Arturo Barriga Richards", "John Atkinson (UdeC", "Terry Pratchett" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "Universidad Técnica Federico Santa Maŕıa\nDepartamento de Informática\nValparáıso – Chile\nSINGLE-AGENT ON-LINE PATH PLANNING\nIN CONTINUOUS, UNPREDICTABLE AND\nHIGHLY DYNAMIC ENVIRONMENTS\nTesis presentada como requerimiento parcial\npara optar al grado académico de\nMAGÍSTER EN CIENCIAS DE LA INGENIERÍA\nINFORMÁTICA\ny al t́ıtulo profesional de\nINGENIERO CIVIL EN INFORMÁTICA\npor\nNicolás Arturo Barriga Richards\nar X\niv :0\n91 2.\n02 70\nv1 [\ncs .A\nI] 1\nD ec\n2 00\n9\nComisión Evaluadora:\nDr. Mauricio Solar (Gúıa, UTFSM)\nDr. Horst H. von Brand (UTFSM)\nDr. John Atkinson (UdeC)\nNOV 2009\ni\nUniversidad Técnica Federico Santa Maŕıa\nDepartamento de Informática\nValparáıso – Chile\nTITULO DE LA TESIS: SINGLE-AGENT ON-LINE PATH PLANNING IN CONTINUOUS, UNPREDICTABLE AND HIGHLY DYNAMIC ENVIRONMENTS\nAUTOR: NICOLÁS ARTURO BARRIGA RICHARDS\nTesis presentada como requerimiento parcial para optar al grado académico\nde Maǵıster en Ciencias de la Ingenieŕıa Informática y al t́ıtulo profesional de Ingeniero Civil en Informática de la Universidad Técnica Federico Santa Maŕıa.\nDr. Mauricio Solar Profesor Gúıa\nDr. Horst H. von Brand Profesor Correferente\nDr. John Atkinson Profesor Externo\nNov 2009.\nValparáıso, Chile.\nii\nReal stupidity beats artificial intelligence every time.\nTerry Pratchett\niii"
    }, {
      "heading" : "Acknowledgments",
      "text" : "A mis hermanos, por quienes he tratado de ser una mejor persona, para ser un buen ejemplo para ellos. A mis padres, de quienes heredé lo que soy, tanto en cuerpo como en esṕıritu. A mis abuelos y abuelas, especialmente mi Opapa, de quien aprend́ı a disfrutar la vida, y mi Tata, quien me enseñó el valor de la familia.\nQuiero también agradecer a los que hicieron posible esta tesis: Mauricio Araya por ayudarme a escoger el tema y en el desarrollo posterior, a Rodrigo Araya por obligarme a trabajar en medio de las vacaciones de verano, a Nicolás Troncoso, Diego Candel y Roberto Bonvallet, y a mis profesores gúıas y correferentes, Mauricio Solar, Horst H. von Brand y John Atkinson por sus aportes durante el desarrollo de esta tesis.\nQuiero aprovechar la oportunidad para agradecer a los profesores que marcaron mi estad́ıa en la Universidad: Horst H. von Brand, Héctor Allende, Luis Salinas, Hubert Hoffmann, Claudio Dib y Viktor Slüsarenko.\nFinalmente, quiero agradecer en especial a Pamela Saavedra, por estar junto a mı́ durante los más de diez meses que demoró en ser terminada esta tesis, soportándome y apoyándome en los momentos más dif́ıciles.\nValparáıso, Chile Nicolás A. Barriga Noviembre 2009\niv"
    }, {
      "heading" : "Resumen",
      "text" : "Este documento es una tesis en el tema de planificación de caminos uniagente y en ĺınea, para ambientes continuos, impredecibles y altamente dinámicos. El problema es encontrar y recorrer un camino sin colisiones para un robot holonómico, sin restricciones kinodinámicas, moviéndose en un ambiente con varios obstáculos o adversarios moviéndose impredeciblemente. Se asume la disponibilidad de información perfecta del entorno en todo momento.\nVarias variantes estáticas y dinámicas del algoritmo “Rapidly Exploring Random Trees” (RRT) se exploran, aśı como también un algoritmo evolutivo para planificación en ambientes dinámicos llamado “Evolutionary Planner/Navigator.” Se propone una combinación de ambos algoritmos para superar las falencias de ambos y luego una combinación de RRT para planificación inicial y búsqueda local informada para navegación, sumado a una heuŕıstica voraz simple para optimización. Se demuestra que esta combinación de técnicas simples produce mejores respuestas en ambientes altamente dinámicos que las variantes RRT estándar.\nPalabras Claves: Inteligencia artificial. planificación de rutas, RRT, multi-etapa,\nbúsqueda local informada, heuŕıstica voraz, algoritmos evolutivos\nv"
    }, {
      "heading" : "Abstract",
      "text" : "This document is a thesis on the subject of single-agent on-line path planning in continuous,unpredictable and highly dynamic environments. The problem is finding and traversing a collision-free path for a holonomic robot, without kinodynamic restrictions, moving in an environment with several unpredictably moving obstacles or adversaries. The availability of perfect information of the environment at all times is assumed.\nSeveral static and dynamic variants of the Rapidly Exploring Random Trees (RRT) algorithm are explored, as well as an evolutionary algorithm for planning in dynamic environments called the Evolutionary Planner/Navigator. A combination of both kinds of algorithms is proposed to overcome shortcomings in both, and then a combination of a RRT variant for initial planning and informed local search for navigation, plus a simple greedy heuristic for optimization. We show that this combination of simple techniques provides better responses to highly dynamic environments than the RRT extensions.\nKeywords: Artificial intelligence, motion planning, RRT, Multi-stage, informed\nlocal search, greedy heuristics, evolutionary algorithms\nvi"
    }, {
      "heading" : "Index of Contents",
      "text" : ""
    }, {
      "heading" : "Acknowledgments iv",
      "text" : ""
    }, {
      "heading" : "Resumen v",
      "text" : ""
    }, {
      "heading" : "Abstract vi",
      "text" : ""
    }, {
      "heading" : "Index of Contents vii",
      "text" : ""
    }, {
      "heading" : "List of Tables ix",
      "text" : ""
    }, {
      "heading" : "List of Figures x",
      "text" : ""
    }, {
      "heading" : "List of Algorithms xi",
      "text" : ""
    }, {
      "heading" : "1 Introduction 1",
      "text" : "1.1 Problem Formulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 1.2 Document Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3"
    }, {
      "heading" : "2 State of the Art 5",
      "text" : "2.1 Rapidly-Exploring Random Tree . . . . . . . . . . . . . . . . . . . . . . 5 2.2 Retraction-Based RRT Planner . . . . . . . . . . . . . . . . . . . . . . 8 2.3 Execution Extended RRT . . . . . . . . . . . . . . . . . . . . . . . . . 8 2.4 Dynamic RRT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 2.5 Multipartite RRT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 2.6 Rapidly Exploring Evolutionary Tree . . . . . . . . . . . . . . . . . . . 11 2.7 Multidimensional Binary Search Trees . . . . . . . . . . . . . . . . . . 13 2.8 Evolutionary Planner/Navigator . . . . . . . . . . . . . . . . . . . . . . 15"
    }, {
      "heading" : "3 Proposed Techniques 19",
      "text" : "3.1 Combining RRT and EP/N . . . . . . . . . . . . . . . . . . . . . . . . 19\n3.1.1 The Combined Strategy . . . . . . . . . . . . . . . . . . . . . . 19 3.1.2 Algorithm Implementation . . . . . . . . . . . . . . . . . . . . . 20\nvii\n3.2 A Simple Multi-stage Probabilistic Algorithm . . . . . . . . . . . . . . 20\n3.2.1 A Multi-stage Probabilistic Strategy . . . . . . . . . . . . . . . 21 3.2.2 Algorithm Implementation . . . . . . . . . . . . . . . . . . . . . 22"
    }, {
      "heading" : "4 Experimental Setup and Results 27",
      "text" : "4.1 Experimental Setup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n4.1.1 Dynamic Environment . . . . . . . . . . . . . . . . . . . . . . . 27 4.1.2 Partially Known Environment . . . . . . . . . . . . . . . . . . . 27 4.1.3 Unknown Environment . . . . . . . . . . . . . . . . . . . . . . . 28\n4.2 Implementation Details . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 4.3 Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\n4.3.1 Dynamic Environment Results . . . . . . . . . . . . . . . . . . . 32 4.3.2 Partially Known Environment Results . . . . . . . . . . . . . . 34 4.3.3 Unknown Environment Results . . . . . . . . . . . . . . . . . . 34"
    }, {
      "heading" : "5 Conclusions and Future Work 37",
      "text" : "5.1 Future Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38\n5.1.1 Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 5.1.2 Framework . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38\nBibliography 40\nviii"
    }, {
      "heading" : "List of Tables",
      "text" : "4.1 Dynamic Environment Results, map 1. . . . . . . . . . . . . . . . . . . 33 4.2 Dynamic Environment Results, map 2. . . . . . . . . . . . . . . . . . . 33 4.3 Partially Known Environment Results, map 1. . . . . . . . . . . . . . . 35 4.4 Partially Known Environment Results, map 2. . . . . . . . . . . . . . . 36 4.5 Unknown Environment Results . . . . . . . . . . . . . . . . . . . . . . 36\nix"
    }, {
      "heading" : "List of Figures",
      "text" : "2.1 RRT during execution . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 2.2 The roles of the genetic operators . . . . . . . . . . . . . . . . . . . . . 17\n3.1 A Multi-stage Strategy for Dynamic Path Planning . . . . . . . . . . . 25 3.2 The arc operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 3.3 The mutation operator . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n4.1 The dynamic environment, map 1 . . . . . . . . . . . . . . . . . . . . . 28 4.2 The dynamic environment, map 2 . . . . . . . . . . . . . . . . . . . . . 29 4.3 The partially known environment, map 1 . . . . . . . . . . . . . . . . . 30 4.4 The partially known environment, map 2 . . . . . . . . . . . . . . . . . 31 4.5 The unknown environment . . . . . . . . . . . . . . . . . . . . . . . . . 32 4.6 Dynamic environment time . . . . . . . . . . . . . . . . . . . . . . . . . 34 4.7 Dynamic environment success rate . . . . . . . . . . . . . . . . . . . . . 35\nx"
    }, {
      "heading" : "List of Algorithms",
      "text" : "1 BuildRRT(qinit, qgoal) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 2 Extend(T, q) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 3 RRTConnectPlanner(qinit, qgoal) . . . . . . . . . . . . . . . . . . . . . . 7 4 Connect(T, q) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 5 Retraction-based RRT Extension . . . . . . . . . . . . . . . . . . . . . 8 6 ChooseTarget(q, goal) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 7 DRRT() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 8 ReGrowRRT() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 9 TrimRRT() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 10 InvalidateNodes(obstacle) . . . . . . . . . . . . . . . . . . . . . . . . . 11 11 MPRRTSearch(qinit) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 12 PruneAndPrepend(T, F, qinit) . . . . . . . . . . . . . . . . . . . . . . . . 13 13 SelectSample(F ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 14 ExtendToTarget(T ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 15 EP/N . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 16 Main() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 17 processRRTEPN(time) . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 18 Main() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22 19 processMultiStage(time) . . . . . . . . . . . . . . . . . . . . . . . . . . 23 20 arc(path, firstCol) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 21 mut(path, firstCol) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 22 postProcess(path) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\nxi\nChapter 1"
    }, {
      "heading" : "Introduction",
      "text" : "The dynamic path-planning problem consists in finding a suitable plan for each new configuration of the environment by recomputing a collision-free path using the new information available at each time step [HA92]. This kind of problem has to be solved for example by a robot trying to navigate through an area crowded with people, such as a shopping mall or supermarket. The problem has been widely addressed in its several flavors, such as cellular decomposition of the configuration space [Ste95], partial environmental knowledge [Ste94], high-dimensional configuration spaces [KSLO96] or planning with non-holonomic constraints [LKJ99]. However, even simpler variations of this problem are complex enough that they can not be solved with deterministic techniques, and therefore are worthy of study.\nThis thesis is focused on algorithms for finding and traversing a collision-free path in two dimensional space, for a holonomic robot1, without kinodynamic restrictions2, in a highly dynamic environment, but for comparison purposes three different scenarios will be tested:\n• Several unpredictably moving obstacles or adversaries.\n• Partially known environment, where some obstacles become visible when the robot approaches each one of them.\n1A holonomic robot is a robot in which the controllable degrees of freedom is equal to the total degrees of freedom.\n2Kinodynamic planning is a problem in which velocity and acceleration bounds must be satisfied\n1\n• Totally unknown environment, where every obstacle is initially invisible to the planner, and only becomes visible when the robot approaches it.\nBesides the obstacles in the second and third scenario we assume that we have perfect information of the environment at all times.\nWe will focus on continuous space algorithms and will not consider algorithms that use a discretized representation of the configuration space3, such as D* [Ste95], because for high dimensional problems the configuration space becomes intractable in terms of both memory and computation time, and there is the extra difficulty of calculating the discretization size, trading off accuracy versus computational cost. Only single agent algorithms will be considered here. On-line as well as off-line algorithms will be studied. An on-line algorithm is one that is permanently adjusting its solution as the environment changes, while an off-line algorithm computes a solution only once (however, it can be executed many times).\nThe offline Rapidly-Exploring Random Tree (RRT) is efficient at finding solutions, but the results are far from optimal, and must be post-processed for shortening, smoothing or other qualities that might be desirable in each particular problem. Furthermore, replanning RRTs are costly in terms of computation time, as are evolutionary and cell-decomposition approaches. Therefore, the novelty of this work is the mixture of the feasibility benefits of the RRTs, the repairing capabilities of local search, and the computational inexpensiveness of greedy algorithms, into our lightweight multi-stage algorithm. Our working hypothesis will be that a multi-stage algorithm, using different techniques for initial planning and navigation, outperforms current probabilistic sampling techniques in highly dynamic environments"
    }, {
      "heading" : "1.1 Problem Formulation",
      "text" : "At each time-step, the problem could be defined as an optimization problem with satisfiability constraints. Therefore, given a path our objective is to minimize an evaluation function (i.e., distance, time, or path-points), with the Cfree constraint.\n3the space of possible positions that a physical system may attain\n2\nFormally, let the path ρ = p1p2 . . . pn be a sequence of points, where pi ∈ Rn is a ndimensional point (p1 = qinit, pn = qgoal), Ot ∈ O the set of obstacles positions at time t, and eval : Rn ×O 7→ R an evaluation function of the path depending on the object positions. Our ideal objective is to obtain the optimum ρ∗ path that minimizes our eval function within a feasibility restriction in the form\nρ∗ = argmin ρ [eval(ρ,Ot)] with feas(ρ,Ot) = Cfree (1.1)\nwhere feas(·, ·) is a feasibility function that equals Cfree if the path ρ is collision free for the obstacles Ot. For simplicity, we use very naive eval(·, ·) and feas(·, ·) functions, but our approach could be extended easily to more complex evaluation and feasibility functions. The feas(ρ,Ot) function used assumes that the robot is a point object in space, and therefore if no segments −−−→pipi+1 of the path collide with any object oj ∈ Ot, we say that the path is in Cfree. The eval(ρ,Ot) function is the length of the path, i.e., the sum of the distances between consecutive points. This could be easily changed to any other metric such as the time it would take to traverse this path, accounting for smoothness, clearness or several other optimization criteria."
    }, {
      "heading" : "1.2 Document Structure",
      "text" : "In the following sections we present several path planning methods that can be applied to the problem described above. In section 2.1 we review the basic offline, single-query RRT, a probabilistic method that builds a tree along the free configuration space until it reaches the goal state. Afterwards, we introduce the most popular replanning variants of RRT: Execution Extended RRT (ERRT) in section 2.3, Dynamic RRT (DRRT) in section 2.4 and Multipartite RRT (MP-RRT) in section 2.5. The Evolutionary Planner/Navigator (EP/N), along with some variants, is presented in section 2.8. Then, in section 3.1 we present a mixed approach, using a RRT to find an initial solution and the EP/N to navigate, and finally, in section 3.2 we present our new hybrid multi-stage algorithm, that uses RRT for initial planning and informed local search for navigation, plus a simple greedy heuristic for optimization. Experimental results and comparisons that show that this combination of simple techniques provides better responses\n3\nto highly dynamic environments than the standard RRT extensions are presented in section 4.3. The conclusions and further work are discussed in section 5.\n4\nChapter 2"
    }, {
      "heading" : "State of the Art",
      "text" : "In this chapter we present several path planning methods that can be applied to the problem described above. First we will introduce variations of the Rapidly-Exploring Random Tree (RRT), a probabilistic method that builds a tree along the free configuration space until it reaches the goal state. This family of planners is fast at finding solutions, but the solutions are far from optimal, and must be post-processed for shortening, smoothing or other qualities that might be desirable in each particular problem. Furthermore, replanning RRTs are costly in terms of computation time. We then introduce an evolutionary planner with somewhat opposite qualities: It is slow in finding feasible solutions in difficult maps, but efficient at replanning when a feasible solution has already been found. It can also optimize the solution according to any given fitness function without the need for a post-processing step."
    }, {
      "heading" : "2.1 Rapidly-Exploring Random Tree",
      "text" : "One of the most successful probabilistic methods for offline path planning currently in use is the Rapidly-Exploring Random Tree (RRT), a single-query planner for static environments, first introduced in [Lav98]. RRTs works towards finding a continuous path from a state qinit to a state qgoal in the free configuration space Cfree by building a tree rooted at qinit. A new state qrand is uniformly sampled at random from the configuration space C. Then the nearest node, qnear, in the tree is located, and if qrand and the shortest path from qrand to qnear are in Cfree, then qrand is added to the tree\n5\n(algorithm 1). The tree growth is stopped when a node is found near qgoal. To speed up convergence, the search is usually biased to qgoal with a small probability.\nIn [KL00], two new features are added to RRT. First, the EXTEND function (algorithm 2) is introduced, which instead of trying to add qrand directly to the tree, makes a motion towards qrand and tests for collisions.\nAlgorithm 1 BuildRRT(qinit, qgoal)\n1: T ← empty tree 2: T. init(qinit) 3: while Distance(T, qgoal) > threshold do 4: qrand ← RandomConfig() 5: Extend(T, qrand) 6: return T\nAlgorithm 2 Extend(T, q)\n1: qnear ← NearestNeighbor(q, T ) 2: if NewConfig(q, qnear, qnew) then 3: T. add vertex(qnew) 4: T. add edge(qnear, qnew) 5: if qnew = q then 6: return Reached 7: else 8: return Advanced 9: return Trapped\nThen a greedier approach is introduced (the CONNECT function, shown in algorithms 3 and 4), which repeats EXTEND until an obstacle is reached. This ensures that most of the time we will be adding states to the tree, instead of just rejecting new random states. The second extension is the use of two trees, rooted at qinit and qgoal, which are grown towards each other (see figure 2.1). This significantly decreases the time needed to find a path.\n6\nAlgorithm 3 RRTConnectPlanner(qinit, qgoal)\n1: Ta ← tree rooted at qinit 2: Tb ← tree rooted at qgoal 3: Ta. init(qinit) 4: Tb. init(qgoal) 5: for k = 1 to K do 6: qrand ← RandomConfig() 7: if not (Extend(Ta, qrand) = Trapped) then 8: if Connect(Tb, qnew) = Reached then 9: return Path(Ta, Tb)\n10: Swap(Ta, Tb) 11: return Failure\nAlgorithm 4 Connect(T, q)\n1: repeat 2: S ← Extend(T, q) 3: until (S 6= Advanced)\n7"
    }, {
      "heading" : "2.2 Retraction-Based RRT Planner",
      "text" : "The Retraction-based RRT Planner presented in [ZM08] aims at improving the performance of the standard offline RRT in static environments with narrow passages. The basic idea of the Optimize(qr, qn) function in algorithm 5 is to iteratively retract a randomly generated configuration that is in Cobs to the closest boundary point in Cfree. So, instead of using the standard extension that tries to extend in a straight line from qnear to qrand, it extends from qnear to the closest point in Cfree to qrand. This gives more samples in narrow passages. This technique could easily be applied to on-line RRT planners.\nAlgorithm 5 Retraction-based RRT Extension\n1: qr ← a random configuration in Cspace 2: qn ← the nearest neighbor of qr in T 3: if CollisionFree(qn, qr) then 4: T. addVertex(qr) 5: T. addEdge(qn, qr) 6: else 7: S ← Optimize(qr, qn) 8: for all qi ∈ S do 9: Standard RRT Extension(T, qi)\n10: return T"
    }, {
      "heading" : "2.3 Execution Extended RRT",
      "text" : "The Execution Extended RRT presented in [BV02] introduces two extensions to RRT to build an on-line planner, the waypoint cache and adaptive cost penalty search, which improve re-planning efficiency and the quality of generated paths. ERRT uses a kd-tree (see section 2.7) to speed nearest neighbor look-up, and does not use bidirectional search. The waypoint cache is implemented by keeping a constant size array of states, and whenever a plan is found, all the states in the plan are placed in the cache with random replacement. Then, when the tree is no longer valid, a new tree must be\n8\ngrown, and there are three possibilities for choosing a new target state, as shown in algorithm 6, which is used instead of RandomConfig() in previous algorithms. With probability P[goal ], the goal is chosen as the target; with probability P[waypoint ], a random waypoint is chosen, and with the remaining probability a uniform state is chosen as before. In [BV02] the values used are P[goal ]= 0.1 and P[waypoint ]= 0.6.\nAnother extension is adaptive cost penalty search, where the planner adaptively modified a parameter to help it find shorter paths. A value of 1 for beta will always extend from the root node, while a value of 0 is equivalent to the original algorithm. However, the paper [BV02] lacks implementation details and experimental results on this extension.\nAlgorithm 6 ChooseTarget(q, goal)\n1: p← UniformRandom(0.0, 1.0) 2: i← UniformRandom(0.0,NumWayPoints) 3: if 0 < p < GoalProb then 4: return qgoal 5: else if GoalProb < p < GoalProb + WayPointProb then 6: return WayPointCache[i] 7: else if GoalProb + WayPointProb < p < 1 then 8: return RandomConfig()"
    }, {
      "heading" : "2.4 Dynamic RRT",
      "text" : "The Dynamic Rapidly-Exploring Random Tree described in [FKS06] is a probabilistic analog to the widely used D* family of algorithms. It works by growing a tree from qgoal to qinit, as shown in algorithm 7. This has the advantage that the root of the tree does not have to be moved during the lifetime of the planning and execution. In some problem classes the robot has limited range sensors, thus moving or newly appearing obstacles will be near the robot, not near the goal. In general this strategy attempts to trim smaller branches that are farther away from the root. When new information concerning the configuration space is received, the algorithm removes the newly-invalid branches of the tree (algorithms 9 and 10), and grows the remaining tree, focusing,\n9\nwith a certain probability (empirically tuned to 0.4 in [FKS06]) to a vicinity of the recently trimmed branches, by using the waypoint cache of the ERRT (algorithm 6). In experiments presented in [FKS06] DRRT vastly outperforms ERRT.\nAlgorithm 7 DRRT()\n1: qrobot ← the current robot position 2: T ← BuildRRT(qgoal, qrobot) 3: while qrobot 6= qgoal do 4: qnext ← Parent(qrobot) 5: Move from qrobot to qnext 6: for all obstacles that changed O do 7: InvalidateNodes(O) 8: if Solution path contains an invalid node then 9: ReGrowRRT()\nAlgorithm 8 ReGrowRRT()\n1: TrimRRT() 2: GrowRRT()\nAlgorithm 9 TrimRRT()\n1: S ← ∅, i← 1 2: while i < T. size() do 3: qi ← T. node(i) 4: qp ← Parent(qi) 5: if qp.flag = INVALID then 6: qi.flag← INVALID 7: if qi.flag 6= INVALID then 8: S ← S ⋃ {qi}\n9: i← i+ 1 10: T ← CreateTreeFromNodes(S)\n10\nAlgorithm 10 InvalidateNodes(obstacle)\n1: E ← FindAffectedEdges(obstacle) 2: for all e ∈ E do 3: qe ← ChildEndpointNode(e) 4: qe.flag← INVALID"
    }, {
      "heading" : "2.5 Multipartite RRT",
      "text" : "Multipartite RRT presented in [ZKB07] is another RRT variant which supports planning in unknown or dynamic environments. MP-RRT maintains a forest F of disconnected sub-trees which lie in Cfree, but which are not connected to the root node qroot of T , the main tree. At the start of a given planning iteration, any nodes of T and F which are no longer valid are deleted, and any disconnected sub-trees which are created as a result are placed into F (as seen in algorithms 11 and 12). With given probabilities, the algorithm tries to connect T to a new random state, to the goal state, or to the root of a tree in F (algorithm 13). In [ZKB07], a simple greedy smoothing heuristic is used, that tries to shorten paths by skipping intermediate nodes. The MP-RRT is compared to an iterated RRT, ERRT and DRRT, in 2D, 3D and 4D problems, with and without smoothing. For most of the experiments, MP-RRT modestly outperforms the other algorithms, but in the 4D case with smoothing, the performance gap in favor of MP-RRT is much larger. The authors explained this fact due to MP-RRT being able to construct much more robust plans in the face of dynamic obstacle motion. Another algorithm that utilizes the concept of forests is Reconfigurable Random Forests (RRF) presented in [LS02], but without the success of MP-RRT."
    }, {
      "heading" : "2.6 Rapidly Exploring Evolutionary Tree",
      "text" : "The Rapidly Exploring Evolutionary Tree, introduced in [MWS07] uses a bidirectional RRT and a kd-tree (see section 2.7) for efficient nearest neighbor search. The modifications to the Extend() function are shown in algorithm 14. The re-balancing of a kd-tree is costly, and in this paper a simple threshold on the number of nodes added before re-balancing was used. The authors suggest using the method described in [AL02] and\n11\nAlgorithm 11 MPRRTSearch(qinit)\n1: T ← the previous search tree, if any 2: F ← the previous forest of disconnected sub-trees 3: qinit ← the initial state 4: if T = ∅ then 5: qroot ← qinit 6: Insert(qroot, T ) 7: else 8: PruneAndPrepend(T, F, qinit) 9: if TreeHasGoal(T ) then\n10: return true 11: while search time/space remaining do 12: qnew ← SelectSample(F ) 13: qnear ← NearestNeighbor(qnew,T ) 14: if qnew ∈ F then 15: bconnect ← Connect(qnear, qnew) 16: if bconnect and TreeHasGoal(T ) then 17: return true 18: else 19: bextend ← Extend(qnear, qnew) 20: if bextend and IsGoal(qnew) then 21: return true 22: return false\nused in [BV02] to improve the search speed. The novelty in this algorithm comes from the introduction of an evolutionary algorithm [BFM97] that builds a population of biases for the RRTs. The genotype of the evolutionary algorithm consists of a single robot configuration for each tree. This configuration is sampled instead of the uniform distribution. To balance exploration and exploitation, the evolutionary algorithm was designed with 50% elitism. The fitness function is related to the number of left and right branches traversed during the insertion of a new node in the kd-tree. The goal is to introduce a bias to the RRT algorithm which shows preference to nodes created\n12\nAlgorithm 12 PruneAndPrepend(T, F, qinit)\n1: for all q ∈ T, F do 2: if not NodeValid(q) then 3: KillNode(q) 4: else if not ActionValid(q) then 5: SplitEdge(q) 6: if not T = ∅ and qroot 6= qinit then 7: if not ReRoot(T, qinit) then\n8: F ← F ⋃ T 9: T. init(qinit)\nAlgorithm 13 SelectSample(F )\n1: p← Random(0, 1) 2: if p < pgoal then 3: qnew ← qgoal 4: else if p < (pgoal + pforest) and not Empty(F ) then 5: qnew ← q ∈ SubTreeRoots(F ) 6: else 7: qnew ← RandomState() 8: return qnew\naway from the center of the tree. The authors suggest combining RET with DRRT or MP-RRT."
    }, {
      "heading" : "2.7 Multidimensional Binary Search Trees",
      "text" : "The kd-tree, first introduced in [Ben75], is a binary tree in which every node is a k-dimensional point. Every non-leaf node generates a splitting hyperplane that divides the space into two subspaces. In the RRT algorithm, the number of points grows incrementally, unbalancing the tree, thus slowing nearest-neighbor queries. Re-balancing a kd-tree is costly, so in [AL02] the authors present another approach: A vector of trees is constructed, where for n points there is a tree that contains 2i points for each ”1” in\n13\nAlgorithm 14 ExtendToTarget(T )\n1: static p: population, inc← 1 2: p′: temporary population 3: if inc > length(p) then 4: SortByFitness(p) 5: p′ ← null 6: for all i ∈ p do 7: if i is in upper 50% then 8: AddIndividual(i, p′) 9: else\n10: i← RandomState() 11: AddIndividual(i, p′) 12: p← p′ 13: inc← 1 14: qr ← p(inc) 15: qnear ← Nearest(T, qr) 16: qnew ← Extend(T, qnear) 17: if qnew 6= ∅ then 18: AddNode(T, qnew) 19: AssignFitness(p(inc), fitness(qnew) 20: else 21: AssignFitness(p(inc), 0) 22: return qnew\nthe ith place of the binary representation of n. As bits are cleared in the representation due to increasing n, the trees are deleted, and the points are included in a tree that corresponds to the higher-order bit which is changed to ”1”. This general scheme incurs in logarithmic-time overhead, regardless of dimension. Experiments show a substantial performance increase compared to a naive brute-force approach.\n14"
    }, {
      "heading" : "2.8 Evolutionary Planner/Navigator",
      "text" : "An evolutionary algorithm [BFM97] is a generic population-based meta-heuristic optimization algorithm. It is inspired in biological evolution, using methods such as individual selection, reproduction and mutation. The population is composed of candidate solutions and they are evaluated according to a fitness function.\nThe Evolutionary Planner/Navigator presented in [XMZ96], [XMZT97], and [TX97] is an evolutionary algorithm for path finding in dynamic environments. A high level description is shown in algorithm 15. A difference with RRT is that it can optimize the path according to any fitness function defined (length, smoothness, etc), without the need for a post-processing step. Experimental tests have shown it has good performance for sparse maps, but no so much for difficult maps with narrow passages or too crowded with obstacles. However, when a feasible path is found, it is very efficient at optimizing it and adapting to the dynamic obstacles. Every individual in the population is a sequence of nodes, representing nodes in a path consisting of straight-line segments. Each node consists of an (x, y) pair and a state variable b with information about the feasibility of the point and the path segment connecting it to the next point. Individuals have variable length.\nSince a path p can be either feasible or unfeasible, two evaluation functions are used. For feasible paths (equation 2.1), the goal is to minimize distance traveled, maintain a smooth trajectory and satisfy a clearance requirement (the robot should not approach the obstacles too closely). For unfeasible paths, we use equation 2.2, taken from [Xia97], where µ is the number of intersections of a whole path with obstacles and η is the average number of intersections per unfeasible segment.\nevalf (p) = wd · dist(p) + ws · smooth(p) + wc · clear(p) (2.1)\nevalu(p) = µ+ η (2.2)\nEP/N uses eight different operators, as shown in figure 2.2 (description taken\nfrom [XMZ96]):\nCrossover: Recombines two (parent) paths into two new paths. The parent paths\n15\nAlgorithm 15 EP/N\n1: P (t): population at generation t 2: t← 0 3: Initialize(P (t)) 4: Evaluate(P (t)) 5: while (not termination-condition) do 6: t← t+ 1 7: Select operator oj with probability pj 8: Select parent(s) from P (t) 9: Produce offspring applying oj to selected parent(s)\n10: Evaluate offspring 11: Replace worst individual in P (t) by new offspring 12: Select best individual p from P (t) 13: if Feasible(p) then 14: Move along path p 15: Update all individuals in P (t) with current position 16: if changes in environment then 17: Update map 18: Evaluate(P (t)) 19: t← t+ 1\nare divided randomly into two parts respectively and recombined: The first part of the first path with the second part of the second path, and the first part of the second path with the second part of the first path. Note that there can be different numbers of nodes in the two parent paths.\nMutate 1: Used to fine tune node coordinates in a feasible path for shape adjustment.\nThis operator randomly adjusts node coordinates within some local clearance of the path so that the path remains feasible afterwards.\nMutate 2: Used for large random changes of node coordinates in a path, which can\nbe either feasible or unfeasible.\n16\nInsert-Delete: Operates on an unfeasible path by inserting randomly generated new\nnodes into unfeasible path segments and deleting unfeasible nodes (i.e., path nodes that are inside obstacles).\nDelete: Deletes nodes from a path, which can be either feasible or unfeasible. If the\npath is unfeasible, the deletion is done randomly. Otherwise, the operator decides whether a node should definitely be deleted based on some heuristic knowledge, and if a node is not definitely deletable, its deletion will be random.\nSwap: Swaps the coordinates of randomly selected adjacent nodes in a path, which\ncan be either feasible or unfeasible.\nSmooth: Smoothens turns of a feasible path by “cutting corners,” i.e., for a selected\nnode, the operator inserts two new nodes on the two path segments connected to that node respectively and deletes that selected node. The nodes with sharper turns are more likely to be selected.\nRepair: Repairs a randomly selected unfeasible segment in a path by “pulling” the\n17\nsegment around its intersecting obstacle.\nThe probabilities of using each operator is set randomly at the beginning, and then are updated according to the success ratio of each operator, so more successful operators are used more often, and automatically chosen according to the instance of the problem, eliminating the difficult problem of hand tuning the probabilities.\nIn [TX97], the authors include a memory buffer for each individual to store good\npaths from its ancestors, which gave a small performance gain.\nIn [EAA04], the authors propose strategies for improving the stability and controlling population diversity for a simplified version of the EP/N. An improvement proposed by the authors in [XMZT97] is using heuristics for the initial population, instead of random initialization. We will consider this improvement in section 3.1.\nOther evolutionary algorithms have also been proposed for similar problems, in [NG04]\na binary genetic algorithm is used for an offline planner, and [NVTK03] presents an algorithm to generate curved trajectories in 3D space for an unmanned aerial vehicle.\nEP/N has been adapted to an 8-connected grid model in [AR08] (with previous work in [AR05] and [Alf05]). The authors study two different crossover operators and four asexual operators. Experimental results for this new algorithm (EvP) in static unknown environments show that it is faster than EP/N.\n18\nChapter 3"
    }, {
      "heading" : "Proposed Techniques",
      "text" : ""
    }, {
      "heading" : "3.1 Combining RRT and EP/N",
      "text" : "As mentioned in section 2, RRT variants produce suboptimal solutions, which must later be post-processed for shortening, smoothing or other desired characteristics. On the other hand, EP/N, presented in section 2.8, can optimize a solution according to any given fitness function. However, this algorithm is slower at finding a first feasible solution. In this section we propose a combined approach, that uses RRT to find an initial solution to be used as starting point for EP/N, taking advantage of the strong points of both algorithms."
    }, {
      "heading" : "3.1.1 The Combined Strategy",
      "text" : ""
    }, {
      "heading" : "Initial Solution",
      "text" : "EP/N as presented in section 2.8 can not find feasible paths in a reasonable amount of time in any but very sparse maps. For this reason, RRT will be used to generate a first initial solution, ignoring the effects produced by dynamic objects. This solution will be in the initial population of the evolutionary algorithm, along with random solutions."
    }, {
      "heading" : "Feasibility and Optimization",
      "text" : "EP/N is the responsible of regaining feasibility when it is lost due to a moving obstacle or a new obstacle found in a partially known or totally unknown environment. If a\n19\nfeasible solution can not be found in a given amount of time, the algorithm is restarted, keeping its old population, but adding a new individual generated by RRT."
    }, {
      "heading" : "3.1.2 Algorithm Implementation",
      "text" : "Algorithm 16 Main()\n1: qrobot ← is the current robot position 2: qgoal ← is the goal position 3: while qrobot 6= qgoal do 4: updateWorld(time) 5: processRRTEPN(time)\nThe combined RRT-EP/N algorithm proposed here works by alternating environment updates and path planning, as can be seen in algorithm 16. The first stage of the path planning (see algorithm 17) is to find an initial path using a RRT technique, ignoring any cuts that might happen during environment updates. Thus, the RRT ensures that the path found does not collide with static obstacles, but might collide with dynamic obstacles in the future. When a first path is found, the navigation is done by using the standard EP/N as shown in algorithm 15."
    }, {
      "heading" : "3.2 A Simple Multi-stage Probabilistic Algorithm",
      "text" : "In highly dynamic environments, with many (or a few but fast) relatively small moving obstacles, regrowing trees are pruned too fast, cutting away important parts of the trees before they can be replaced. This dramatically reduces the performance of the algorithms, making them unsuitable for these classes of problems. We believe that better performance could be obtained by slightly modifying a RRT solution using simple obstacle-avoidance operations on the new colliding points of the path by informed local search. The path could be greedily optimized if the path has reached the feasibility condition.\n20\nAlgorithm 17 processRRTEPN(time)\n1: qrobot ← the current robot position 2: qstart ← the starting position 3: qgoal ← the goal position 4: Tinit ← the tree rooted at the robot position 5: Tgoal ← the tree rooted at the goal position 6: path← the path extracted from the merged RRTs 7: qrobot ← qstart 8: Tinit. init(qrobot) 9: Tgoal. init(qgoal)\n10: while time elapsed < time do 11: if First path not found then 12: RRT(Tinit, Tgoal) 13: else 14: EP/N()"
    }, {
      "heading" : "3.2.1 A Multi-stage Probabilistic Strategy",
      "text" : "If solving equation 1.1 is not a simple task in static environments, solving dynamic versions turns out to be even more difficult. In dynamic path planning we cannot wait until reaching the optimal solution because we must deliver a “good enough” plan within some time restriction. Thus, a heuristic approach must be developed to tackle the on-line nature of the problem. The heuristic algorithms presented in sections 2.3, 2.4 and 2.5 extend a method developed for static environments, which produces poor response to highly dynamic environments and unwanted complexity of the algorithms.\nWe propose a multi-stage combination of simple heuristic and probabilistic techniques to solve each part of the problem: Feasibility, initial solution and optimization."
    }, {
      "heading" : "Feasibility",
      "text" : "The key point in this problem is the hard constraint in equation 1.1 which must be met before even thinking about optimizing. The problem is that in highly dynamic environments a path turns rapidly from feasible to unfeasible — and the other way\n21\naround — even if our path does not change. We propose a simple informed local search to obtain paths in Cfree. The idea is to randomly search for a Cfree path by modifying the nearest colliding segment of the path. As we include in the search some knowledge of the problem, the informed term is coined to distinguish it from blind local search. The details of the operators used for the modification of the path are described in section 3.2.2. If a feasible solution can not be found in a given amount of time, the algorithm is restarted, with a new starting point generated by a RRT variant."
    }, {
      "heading" : "Initial Solution",
      "text" : "The problem with local search algorithms is that they repair a solution that it is assumed to be near the feasibility condition. Trying to produce feasible paths from scratch with local search (or even with evolutionary algorithms [XMZT97]) is not a good idea due the randomness of the initial solution. Therefore, we propose feeding the informed local search with a standard RRT solution at the start of the planning, as can be seen in figure 3.1."
    }, {
      "heading" : "Optimization",
      "text" : "Without an optimization criterion, the path could grow infinitely large in time or size. Therefore, the eval(·, ·) function must be minimized when a (temporary) feasible path is obtained. A simple greedy technique is used here: We test each point in the solution to check if it can be removed maintaining feasibility; if so, we remove it and check the following point, continuing until reaching the last one."
    }, {
      "heading" : "3.2.2 Algorithm Implementation",
      "text" : "Algorithm 18 Main()\n1: qrobot ← the current robot position 2: qgoal ← the goal position 3: while qrobot 6= qgoal do 4: updateWorld(time) 5: processMultiStage(time)\n22\nThe multi-stage algorithm proposed in this thesis works by alternating environment updates and path planning, as can be seen in algorithm 18. The first stage of the path planning (see algorithm 19) is to find an initial path using a RRT technique, ignoring any cuts that might happen during environment updates. Thus, RRT ensures that the path found does not collide with static obstacles, but might collide with dynamic obstacles in the future. When a first path is found, the navigation is done by alternating a simple informed local search and a simple greedy heuristic as shown in figure 3.1.\nAlgorithm 19 processMultiStage(time)\n1: qrobot ← is the current robot position 2: qstart ← is the starting position 3: qgoal ← is the goal position 4: Tinit ← is the tree rooted at the robot position 5: Tgoal ← is the tree rooted at the goal position 6: path← is the path extracted from the merged RRTs 7: qrobot ← qstart 8: Tinit. init(qrobot) 9: Tgoal. init(qgoal)\n10: while time elapsed < time do 11: if First path not found then 12: RRT(Tinit, Tgoal) 13: else 14: if path is not collision free then 15: firstCol ← collision point closest to robot 16: arc(path, firstCol) 17: mut(path, firstCol) 18: postProcess(path)\nThe second stage is the informed local search, which is a two step function composed by the arc and mutate operators (algorithms 20 and 21). The first one tries to build a square arc around an obstacle, by inserting two new points between two points in the path that form a segment colliding with an obstacle, as shown in figure 3.2. The second step in the function is a mutation operator that moves a point close to an obstacle to\n23\na random point in the vicinity, as explained graphically in figure 3.3. The mutation operator is inspired by the ones used in the Adaptive Evolutionary Planner/Navigator (EP/N) presented in [XMZT97], while the arc operator is derived from the arc operator in the Evolutionary Algorithm presented in [AR05].\nAlgorithm 20 arc(path, firstCol)\n1: vicinity← some vicinity size 2: randDev← random(−vicinity, vicinity) 3: point1← path[firstCol] 4: point2← path[firstCol + 1] 5: if random()%2 then 6: newPoint1← (point1[X] + randDev, point1[Y ]) 7: newPoint2← (point2[X] + randDev, point2[Y ]) 8: else\n9: newPoint1← (point1[X], point1[Y ] + randDev) 10: newPoint2← (point2[X], point2[Y ] + randDev) 11: if path segments point1-newPoint1-newPoint2-point2 are collision free then 12: Add new points between point1 and point2 13: else 14: Drop new points\nAlgorithm 21 mut(path, firstCol)\n1: vicinity ← some vicinity size 2: path[firstCol][X] + = random(−vicinity, vicinity) 3: path[firstCol][Y] + = random(−vicinity, vicinity) 4: if path segments before and after path[firstCol] are collision free then 5: Accept new point 6: else 7: Reject new point\nThe third and last stage is the greedy optimization heuristic, which can be seen as a post-processing for path shortening, that eliminates intermediate nodes if doing so does not create collisions, as is described in the algorithm 22.\n24\nAlgorithm 22 postProcess(path)\n1: i← 0 2: while i < path. size()− 2 do 3: if segment path[i] to path[i+ 2] is collision free then 4: Delete path[i+1] 5: else 6: i← i+ 1\n25\n26\nChapter 4"
    }, {
      "heading" : "Experimental Setup and Results",
      "text" : ""
    }, {
      "heading" : "4.1 Experimental Setup",
      "text" : "Although the algorithms developed in this thesis are aimed at dynamic environments, for the sake of completeness they will also be compared in partially known environments and in totally unknown environments, where some or all of the obstacles become visible to the planner as the robot approaches each one of them, simulating a robot with limited sensor range."
    }, {
      "heading" : "4.1.1 Dynamic Environment",
      "text" : "The first environment for our experiments consists on two maps with 30 moving obstacles the same size of the robot, with a random speed between 10% and 55% the speed of the robot. Good performance in this environment is the main focus of this thesis. This dynamic environments are illustrated in figures 4.1 and 4.2."
    }, {
      "heading" : "4.1.2 Partially Known Environment",
      "text" : "The second environment uses the same maps, but with a few obstacles, three to four times the size of the robot, that become visible when the robot approaches each one of them. This is the kind of environment that most dynamic RRT variants were designed for. The partially known environments are illustrated in figure 4.3 and 4.4.\n27"
    }, {
      "heading" : "4.1.3 Unknown Environment",
      "text" : "For completeness sake, we will compare the different technique in a third environment, were we use one of the maps presented before, but all the obstacles will initially be unknown to the planners, and will become visible as the robot approaches them, forcing several re-plans. This unknown environment is illustrated in figure 4.5."
    }, {
      "heading" : "4.2 Implementation Details",
      "text" : "The algorithms where implemented in C++ using the MoPa framework1 partly developed by the author. This framework features exact collision detection, three different map formats (including .pbm images from any graphic editor), dynamic, unknown and partially known environments and support for easily adding new planners. One of the biggest downsides is that it only supports rectangular objects, so several objects\n1MoPa homepage: https://csrg.inf.utfsm.cl/twiki4/bin/view/CSRG/MoPa\n28\nmust be used to represent other geometrical shapes, as in figure 4.4, composed of 1588 rectangular objects.\nThere are several variations that can be found in the literature when implementing RRT. For all our RRT variants, the following are the details on where we departed from the basics:\n1. We always use two trees rooted at qinit and qgoal.\n2. Our EXTEND function, if the point cannot be added without collisions to a tree,\nadds the mid point between the nearest tree node and the nearest collision point to it.\n3. In each iteration, we try to add the new randomly generated point to both trees,\nand if successful in both, the trees are merged, as proposed in [KL00].\n4. We believe that there might be significant performance differences between al-\nlowing or not allowing the robot to advance towards the node nearest to the goal\n29\nwhen the trees are disconnected, as proposed in [ZKB07].\nIn point 4 above, the problem is that the robot would become stuck if it enters a small concave zone of the environment (like a room in a building) while there are moving obstacles inside that zone, but otherwise it can lead to better performance. Therefore we present results for both kinds of behavior: DRRT-adv and MP-RRT-adv move even when the trees are disconnected, while DRRT-noadv and MP-RRT-noadv only move when the trees are connected.\nIn MP-RRT, the forest was handled by simply replacing the oldest tree in it if the\nforest had reached the maximum allowed size.\nConcerning the parameter selection, the probability for selecting a point in the vicinity of a point in the waypoint cache in DRRT was set to 0.4 as suggested in [FKS06]. The probability for trying to reuse a subtree in MP-RRT was set to 0.1 as suggested in [ZKB07]. Also, the forest size was set to 25 and the minimum size of a tree to be saved in the forest was set to 5 nodes.\n30\nFor the combined RRT-EP/N, it was considered the planner was stuck after two seconds without a feasible solution in the population, at which point a new solution from a RRT variant is inserted into the population. For the simple multi-stage probabilistic algorithm, the restart is made after one second of encountering the same obstacle along the planned path. This second approach, which seems better, cannot be applied to the RRT-EP/N, because there is no single path to check for collisions, but instead a population of paths. The restart times where manually tuned."
    }, {
      "heading" : "4.3 Results",
      "text" : "The three algorithms were run a hundred times in each environment and map combination. The cutoff time was five minutes for all tests, after which the robot was considered not to have reached the goal. Results are presented concerning:\n31\n• Success rate (S.R.): The percentage of times the robot arrived at the goal, before reaching the five minutes cutoff time. This does not account for collisions or time\nthe robot was stopped waiting for a plan.\n• Number of nearest neighbor lookups performed by each algorithm (N.N.): One of the possible bottlenecks for tree-based algorithms\n• Number of collision checks performed (C.C.), which in our specific implementation takes a significant percentage of the running time\n• Time it took the robot to reach the goal, ± the standard deviation."
    }, {
      "heading" : "4.3.1 Dynamic Environment Results",
      "text" : "The results in tables 4.1 and 4.2 show that the multi-stage algorithm takes considerably less time than the DRRT and MP-RRT to reach the goal, with far less collision checks. The combined RRT-EP/N is a close second. It was expected that nearest neighbor\n32\nlookups would be much lower in both combined algorithms than in the RRT variants, because they are only performed in the initial phase and restarts, not during navigation. The combined algorithms produce more consistent results within a map, as shown by their smaller standard deviations, but also across different maps. An interesting fact is that in map 1 DRRT is slightly faster than MP-RRT, and in map 2 MP-RRT is faster than DRRT. However the differences are too small to draw any conclusions. Figures 4.6 and 4.7 show the times and success rates of the different algorithms, when changing the number of dynamic obstacles in map 1. The simple multi-stage algorithm and the mixed RRT-EP/N clearly show the best performance, while the DRRT-adv and MP-RRT-adv significantly reduce their success rate when confronted to more than 30 moving obstacles."
    }, {
      "heading" : "4.3.2 Partially Known Environment Results",
      "text" : "Taking both maps into consideration, the results in tables 4.3 and 4.4 show that both combined algorithms are faster and more consistent than the RRT variants, with the simple multi-stage algorithm being faster in both. These results were unexpected, as the combined algorithms were designed for dynamic environments. It is worth to notice though, that in map 1 DRRT-adv is a close second, but in map 2 it is a close last, so its lack of reliability does not make it a good choice in this scenario. In this environment, as in the dynamic environment, in map 1 DRRT is faster than MP-RRT, while the opposite happens in map 2."
    }, {
      "heading" : "4.3.3 Unknown Environment Results",
      "text" : "Results in table 4.5 present the combined RRT-EP/N clearly as the faster algorithm in unknown environments, with the multi-stage algorithm in second place. In contrast to\n34\ndynamic and partially known environments in this same map, MP-RRT is faster than DRRT.\n35\nChapter 5"
    }, {
      "heading" : "Conclusions and Future Work",
      "text" : "The new multi-stage algorithm proposed here has good performance in very dynamic environments. It behaves particularly well when several small obstacles are moving around at random. This is explained by the fact that if the obstacles are constantly moving, they will sometimes move out of the way by themselves, which our algorithm takes advantage of, while RRT based ones do not, they just drop branches of the tree that could prove useful again just a few moments later. The combined RRT-EP/N, although having more operators, and automatic adjustment of the operator probabilities according to their effectiveness, is still better than the RRT variants, but about 55% slower than the simple multi-stage algorithm. This is explained by the number of collision checks performed, more than twice than the multi-stage algorithm, because collision checks must be performed for the entire population, not just a single path.\nIn the partially known environment, even though the difference in collision checks is even greater than in dynamic environments, the RRT-EP/N performance is about 25% worse than the multi-stage algorithm. Overall, the RRT variants are closer to the performance of both combined algorithms.\nIn the totally unknown environment, the combined RRT-EP/N is about 30% faster than the simple multi-stage algorithm, and both outperform the RRT variants, with much smaller times and standard deviations.\nAll things considered, the simple multi-stage algorithm is the best choice in most situations, with faster and more predictable planning times, a higher success rate, fewer collision checks performed and, above all, a much simpler implementation than all the\n37\nother algorithms compared.\nThis thesis shows that a multi-stage approach, using different techniques for initial plannning and navigation, outperforms current probabilistic sampling techniques in dynamic, partially known and unknown environments.\nPart of the results presented in this thesis are published in [BALS09]."
    }, {
      "heading" : "5.1 Future Work",
      "text" : "We propose several areas of improvement for the work presented in this thesis."
    }, {
      "heading" : "5.1.1 Algorithms",
      "text" : "The most promising area of improvement seems to be to experiment with different on-line planners such as a version of the EvP ([AR05] and [AR08]) modified to work in continuous configuration space or a potential field navigator. Also, the local search presented here could benefit from the use of more sophisticated operators and the parameters for the RRT variants (such as forest size for MP-RRT), and the EP/N (such as population size) could benefit from being tuned specifically for this implementation, and not simply reusing the parameters found in previous work.\nAnother area of research that could be tackled is extending this algorithm to higher\ndimensional problems, as RRT variants are known to work well in higher dimensions.\nFinally, as RRT variants are suitable for kinodynamic planning, we only need to adapt the on-line stage of the algorithm to have a new multi-stage planner for problems with kinodynamic constraints."
    }, {
      "heading" : "5.1.2 Framework",
      "text" : "The MoPa framework could benefit from the integration of a third party logic layer, with support for arbitrary geometrical shapes, a spatial scene graph and hierarchical maps. Some candidates would be OgreODE [Ogr], Spring RTS [Spr] and ORTS [ORT].\nOther possible improvements are adding support for other map formats, including discrimination of static and moving obstacles, limited sensor range simulation and\n38\nintegration with external hardware such as the Lego NXT [Leg], to run experiments in a more realistic scenario.\n39"
    } ],
    "references" : [ {
      "title" : "Efficient nearest neighbor searching for motion planning",
      "author" : [ "A. Atramentov", "S.M. LaValle" ],
      "venue" : "In Proceedings of the IEEE International Conference on Robotics and Automation,",
      "citeRegEx" : "Atramentov and LaValle.,? \\Q2002\\E",
      "shortCiteRegEx" : "Atramentov and LaValle.",
      "year" : 2002
    }, {
      "title" : "Un algoritmo evolutivo para la resolución del problema de planificación de rutas de un robot móvil",
      "author" : [ "T. Alfaro" ],
      "venue" : "Master’s thesis, Departamento de Informática, Universidad Técnica Federico Santa Maŕıa,",
      "citeRegEx" : "Alfaro.,? \\Q2005\\E",
      "shortCiteRegEx" : "Alfaro.",
      "year" : 2005
    }, {
      "title" : "An on-the-fly evolutionary algorithm for robot motion planning",
      "author" : [ "T. Alfaro", "M. Riff" ],
      "venue" : "Lecture Notes in Computer Science,",
      "citeRegEx" : "Alfaro and Riff.,? \\Q2005\\E",
      "shortCiteRegEx" : "Alfaro and Riff.",
      "year" : 2005
    }, {
      "title" : "An evolutionary navigator for autonomous agents on unknown large-scale environments",
      "author" : [ "T. Alfaro", "M. Riff" ],
      "venue" : "Intelligent Automation and Soft Computing,",
      "citeRegEx" : "Alfaro and Riff.,? \\Q2008\\E",
      "shortCiteRegEx" : "Alfaro and Riff.",
      "year" : 2008
    }, {
      "title" : "Combining a probabilistic sampling technique and simple heuristics to solve the dynamic path planning problem",
      "author" : [ "N.A. Barriga", "M. Araya-Lopez", "M. Solar" ],
      "venue" : "In Proceedings XXVIII International Conference of the Chilean Computing Science Society (SCCC),",
      "citeRegEx" : "Barriga et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Barriga et al\\.",
      "year" : 2009
    }, {
      "title" : "Multidimensional binary search trees used for associative searching",
      "author" : [ "J.L. Bentley" ],
      "venue" : "Communications of the ACM,",
      "citeRegEx" : "Bentley.,? \\Q1975\\E",
      "shortCiteRegEx" : "Bentley.",
      "year" : 1975
    }, {
      "title" : "Real-time randomized path planning for robot navigation",
      "author" : [ "J. Bruce", "M. Veloso" ],
      "venue" : "In Proceedings of the IEEE/RSJ International Conference on Intelligent Robots and Systems,",
      "citeRegEx" : "Bruce and Veloso.,? \\Q2002\\E",
      "shortCiteRegEx" : "Bruce and Veloso.",
      "year" : 2002
    }, {
      "title" : "Genetic algorithm for dynamic path planning",
      "author" : [ "A. Elshamli", "HA Abdullah", "S. Areibi" ],
      "venue" : "In Proceedings of the Canadian Conference on Electrical and Computer Engineering,",
      "citeRegEx" : "Elshamli et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Elshamli et al\\.",
      "year" : 2004
    }, {
      "title" : "Replanning with RRTs",
      "author" : [ "D. Ferguson", "N. Kalra", "A. Stentz" ],
      "venue" : "In Proceedings of the IEEE International Conference on Robotics and Automation,",
      "citeRegEx" : "Ferguson et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Ferguson et al\\.",
      "year" : 2006
    }, {
      "title" : "Gross motion planning — a survey",
      "author" : [ "Yong K. Hwang", "Narendra Ahuja" ],
      "venue" : "ACM Computing Surveys,",
      "citeRegEx" : "Hwang and Ahuja.,? \\Q1992\\E",
      "shortCiteRegEx" : "Hwang and Ahuja.",
      "year" : 1992
    }, {
      "title" : "RRT-connect: An efficient approach to single-query path planning",
      "author" : [ "J.J. Jr. Kuffner", "S.M. LaValle" ],
      "venue" : "In Proceedings of the IEEE International Conference on Robotics and Automation,",
      "citeRegEx" : "Kuffner and LaValle.,? \\Q2000\\E",
      "shortCiteRegEx" : "Kuffner and LaValle.",
      "year" : 2000
    }, {
      "title" : "Probabilistic roadmaps for path planning in high-dimensional configuration spaces",
      "author" : [ "L.E. Kavraki", "P. Svestka", "J.-C. Latombe", "M.H. Overmars" ],
      "venue" : "IEEE Transactions on Robotics and Automation,",
      "citeRegEx" : "Kavraki et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "Kavraki et al\\.",
      "year" : 1996
    }, {
      "title" : "Rapidly-Exploring Random Trees: A new tool for path planning",
      "author" : [ "S.M. Lavalle" ],
      "venue" : "Technical report,",
      "citeRegEx" : "Lavalle.,? \\Q1998\\E",
      "shortCiteRegEx" : "Lavalle.",
      "year" : 1998
    }, {
      "title" : "Randomized kinodynamic planning",
      "author" : [ "S.M. LaValle", "J.J. Kuffner Jr." ],
      "venue" : "In Proceedings of the IEEE International Conference on Robotics and Automation,",
      "citeRegEx" : "LaValle and Jr.,? \\Q1999\\E",
      "shortCiteRegEx" : "LaValle and Jr.",
      "year" : 1999
    }, {
      "title" : "An incremental learning approach to motion planning with roadmap management",
      "author" : [ "Tsai-Yen Li", "Yang-Chuan Shie" ],
      "venue" : "In Proceedings of the IEEE International Conference on Robotics and Automation,",
      "citeRegEx" : "Li and Shie.,? \\Q2002\\E",
      "shortCiteRegEx" : "Li and Shie.",
      "year" : 2002
    }, {
      "title" : "Offline and online evolutionary bi-directional RRT algorithms for efficient re-planning in dynamic environments",
      "author" : [ "S.R. Martin", "S.E. Wright", "J.W. Sheppard" ],
      "venue" : "In Proceedings of the IEEE International Conference on Automation Science and Engineering,",
      "citeRegEx" : "Martin et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Martin et al\\.",
      "year" : 2007
    }, {
      "title" : "Path planning for a mobile robot using genetic algorithms",
      "author" : [ "G. Nagib", "W. Gharieb" ],
      "venue" : "In Proceedings of the International Conference on Electrical, Electronic and Computer Engineering,",
      "citeRegEx" : "Nagib and Gharieb.,? \\Q2004\\E",
      "shortCiteRegEx" : "Nagib and Gharieb.",
      "year" : 2004
    }, {
      "title" : "Evolutionary algorithm based offline/online path planner for UAV navigation",
      "author" : [ "I.K. Nikolos", "K.P. Valavanis", "N.C. Tsourveloudis", "A.N. Kostaras" ],
      "venue" : "IEEE Transactions on Systems, Man, and Cybernetics, Part B,",
      "citeRegEx" : "Nikolos et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Nikolos et al\\.",
      "year" : 2003
    }, {
      "title" : "Optimal and efficient path planning for partially-known environments",
      "author" : [ "A. Stentz" ],
      "venue" : "In Proceedings of the IEEE International Conference on Robotics and Automation,",
      "citeRegEx" : "Stentz.,? \\Q1994\\E",
      "shortCiteRegEx" : "Stentz.",
      "year" : 1994
    }, {
      "title" : "The focussed D* algorithm for real-time replanning",
      "author" : [ "A. Stentz" ],
      "venue" : "In International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "Stentz.,? \\Q1995\\E",
      "shortCiteRegEx" : "Stentz.",
      "year" : 1995
    }, {
      "title" : "Adding memory to the Evolutionary Planner/Navigator",
      "author" : [ "K.M. Trojanowski", "Z.J. Xiao" ],
      "venue" : "In Proceedings of the IEEE International Conference on Evolutionary Computation,",
      "citeRegEx" : "Trojanowski and Xiao.,? \\Q1997\\E",
      "shortCiteRegEx" : "Trojanowski and Xiao.",
      "year" : 1997
    }, {
      "title" : "Handbook of Evolutionary Computation, chapter G3.6 The Evolutionary Planner/Navigator in a Mobile Robot Environment",
      "author" : [ "J. Xiao" ],
      "venue" : "IOP Publishing Ltd.,",
      "citeRegEx" : "Xiao.,? \\Q1997\\E",
      "shortCiteRegEx" : "Xiao.",
      "year" : 1997
    }, {
      "title" : "Evolutionary Planner/Navigator: Operator performance and self-tuning",
      "author" : [ "J. Xiao", "Z. Michalewicz", "L. Zhang" ],
      "venue" : "In International Conference on Evolutionary Computation,",
      "citeRegEx" : "Xiao et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "Xiao et al\\.",
      "year" : 1996
    }, {
      "title" : "Adaptive Evolutionary Planner/Navigator for mobile robots",
      "author" : [ "J. Xiao", "Z. Michalewicz", "L. Zhang", "K. Trojanowski" ],
      "venue" : "Proceedings of the IEEE Transactions on Evolutionary Computation,",
      "citeRegEx" : "Xiao et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Xiao et al\\.",
      "year" : 1997
    }, {
      "title" : "Multipartite RRTs for rapid replanning in dynamic environments",
      "author" : [ "M. Zucker", "J. Kuffner", "M. Branicky" ],
      "venue" : "In Proceedings of the IEEE International Conference on Robotics and Automation,",
      "citeRegEx" : "Zucker et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Zucker et al\\.",
      "year" : 2007
    }, {
      "title" : "An efficient retraction-based RRT planner",
      "author" : [ "Liangjun Zhang", "D. Manocha" ],
      "venue" : "In Proceedings of the IEEE International Conference on Robotics and Automation,",
      "citeRegEx" : "Zhang and Manocha.,? \\Q2008\\E",
      "shortCiteRegEx" : "Zhang and Manocha.",
      "year" : 2008
    } ],
    "referenceMentions" : [ ],
    "year" : 2009,
    "abstractText" : "This document is a thesis on the subject of single-agent on-line path planning in continuous,unpredictable and highly dynamic environments. The problem is finding and traversing a collision-free path for a holonomic robot, without kinodynamic restrictions, moving in an environment with several unpredictably moving obstacles or adversaries. The availability of perfect information of the environment at all times is assumed. Several static and dynamic variants of the Rapidly Exploring Random Trees (RRT) algorithm are explored, as well as an evolutionary algorithm for planning in dynamic environments called the Evolutionary Planner/Navigator. A combination of both kinds of algorithms is proposed to overcome shortcomings in both, and then a combination of a RRT variant for initial planning and informed local search for navigation, plus a simple greedy heuristic for optimization. We show that this combination of simple techniques provides better responses to highly dynamic environments than the RRT extensions.",
    "creator" : "LaTeX with hyperref package"
  }
}