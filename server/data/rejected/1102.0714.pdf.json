{
  "name" : "1102.0714.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Una arquitectura para la evaluación de sistemas inteligentes",
    "authors" : [ "PROYECTO FINAL DE CARRERA" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "UNIVERSIDAD POLITÉCNICA DE VALENCIA",
      "text" : ""
    }, {
      "heading" : "Escuela Técnica Superior de Ingeniería Informática",
      "text" : "Una arquitectura para la evaluación\nde sistemas inteligentes\nPROYECTO FINAL DE CARRERA\nRealizado por:\nJavier Insa Cabrera\nDirigido por:"
    }, {
      "heading" : "José Hernández Orallo",
      "text" : "Valencia, 01 de octubre de 2010\nPágina I\nResumen\nUno de los principales ámbitos de investigación en Inteligencia Artificial es la codificación de agentes (programas) que sean capaces de aprender por sí solos en cualquier situación y que no sirvan únicamente para el fin que fueron creados, como por ejemplo para jugar al ajedrez. De este modo pretendemos acercarnos más a lo que realmente es la llamada Inteligencia Artificial.\nUno de los problemas para saber si realmente un agente es inteligente o no es la medición de su inteligencia, ya que de momento no existe forma alguna de medirla de forma fiable.\nEl objetivo de este proyecto es la creación de un intérprete que permita ejecutar diferentes entornos, incluso generados aleatoriamente, para que un agente (una persona o un programa) pueda interactuar en éstos. Una vez que la interacción entre el agente y el entorno ha terminado, el intérprete medirá la inteligencia del agente en función de los diferentes estados por los que ha pasado el entorno y las acciones realizadas en cada estado por el agente durante la prueba.\nDe este modo se conseguirá medir la inteligencia de los agentes en cualquier entorno posible, así como hacer comparaciones entre los distintos agentes evaluando cual de todos ellos es el más inteligente.\nPara poder realizar las pruebas, el intérprete debe ser capaz de generar aleatoriamente distintos entornos que realmente sean útiles para la medición de la inteligencia de los agentes, ya que no cualquier entorno generado aleatoriamente será útil para tal propósito.\nPágina II\nResum\nUn dels principals àmbits d’investigació en Intel·ligència Artificial és la codificació d'agents (programes) que siguen capaços d'aprendre per si mateixos en qualsevol situació i que no servisquen únicament per la finalitat que van ser creats, com per exemple per jugar als escacs. D'aquesta manera pretenem apropar-nos més al que realment és l'anomenada Intel·ligència Artificial.\nUn dels problemes per saber si realment un agent és intel·ligent o no és el mesurament de la seua intel·ligència, com que de moment no hi ha cap manera de mesurar-la de forma fiable.\nL'objectiu d'aquest projecte és la creació d'un intèrpret que permeta executar diferents entorns, fins i tot generats aleatòriament, perquè un agent (una persona o un programa) puga interactuar dins d’aquests. Una vegada que la interacció entre l'agent i l'entorn ha acabat, l'intèrpret mesurarà la intel·ligència de l'agent en funció dels diferents estats pels quals ha passat l'entorn i les accions realitzades en cada estat per l'agent durant la prova.\nD'aquesta manera s'aconseguirà mesurar la intel·ligència dels agents en qualsevol entorn possible, així com fer comparacions entre els diferents agents avaluant quin de tots ells és el més intel·ligent.\nPer poder realitzar les proves, l'intèrpret ha de ser capaç de generar aleatòriament diferents entorns que realment siguen útils per al mesurament de la intel·ligència dels agents, atés que no qualsevol entorn generat aleatòriament serà útil per al propòsit esmentat.\nPágina III\nAbstract\nOne of the main research areas in Artificial Intelligence is the coding of agents (programs) which are able to learn by themselves in any situation. This means that agents must be useful for purposes other than those they were created for, as, for example, playing chess. In this way we try to get closer to the pristine goal of Artificial Intelligence.\nOne of the problems to decide whether an agent is really intelligent or not is the measurement of its intelligence, since there is currently no way to measure it in a reliable way.\nThe purpose of this project is to create an interpreter that allows for the execution of several environments, including those which are generated randomly, so that an agent (a person or a program) can interact with them. Once the interaction between the agent and the environment is over, the interpreter will measure the intelligence of the agent according to the actions, states and rewards the agent has undergone inside the environment during the test.\nAs a result we will be able to measure agents’ intelligence in any possible environment, and to make comparisons between several agents, in order to determine which of them is the most intelligent.\nIn order to perform the tests, the interpreter must be able to randomly generate environments that are really useful to measure agents’ intelligence, since not any randomly generated environment will serve that purpose.\nPágina IV\nPágina V\nÍndice\n1. Introducción ............................................................................................................................ 1\n1.1. Contexto ........................................................................................................................... 1 1.2. Motivación ....................................................................................................................... 1 1.3. Objetivos .......................................................................................................................... 3 2. Precedentes ............................................................................................................................. 5 3. Marco conceptual ................................................................................................................... 9\n3.1. Requisitos ........................................................................................................................ 9 3.2. Entornos y agentes ....................................................................................................... 10 3.3. Medición ......................................................................................................................... 14 3.4. Distribución universal y su aplicación a entornos ................................................ 16 3.5. Entornos discriminativos: Sensibilidad a las recompensas ................................ 19 3.6. Un entorno no sesgado y balanceado ....................................................................... 21\n3.6.1. Clases de entornos Turing-completas .............................................................. 21 3.6.2. Acciones, observaciones y el espacio ............................................................... 22 3.6.3. Definición de la clase de entorno ...................................................................... 24 3.6.4. Propiedades ........................................................................................................... 28 3.6.5. Codificación y generación del entorno ............................................................. 28\n4. Implementación aproximada del marco conceptual .................................................... 31\n4.1. Diagrama de clases ....................................................................................................... 31 4.2. Principales diferencias entre el marco conceptual y la implementación realizada ..................................................................................................................................... 32\n4.2.1. Observaciones ....................................................................................................... 32 4.2.2. Objetos y agentes .................................................................................................. 33 4.2.3. Comportamiento de los agentes ........................................................................ 33 4.2.4. Interacciones entre agentes ............................................................................... 33 4.3. Descripción de las clases del sistema ....................................................................... 33\n4.3.1. Clases para representar los agentes y objetos ............................................... 33\n4.3.1.1. Agente ............................................................................................................. 33 4.3.1.2. Agente Evaluable (Subclase de Agente) ................................................... 34 4.3.1.3. Agentes Good & Evil (Subclase de Agente) .............................................. 35 4.3.1.4. Agente Humano (Subclase de Agente Evaluable) ................................... 35 4.3.1.5. Agente Aleatorio (Subclase de Agente Evaluable) ................................. 36 4.3.1.6. Agente Observador (Subclase de Agente Evaluable) ............................. 36 4.3.1.7. Objeto .............................................................................................................. 37 4.3.2. Clases para representar el espacio ................................................................... 38\n4.3.2.1. Celda ................................................................................................................ 38 4.3.2.2. Conexión ......................................................................................................... 38 4.3.2.3. Espacio ............................................................................................................ 39 4.3.3. Clases para representar los entornos .............................................................. 39\n4.3.3.1. Entorno ........................................................................................................... 39 4.3.3.2. Entorno_L (Subclase de Entorno) .............................................................. 40\nPágina VI\n4.3.3.3. Realización de una sesión de evaluación ................................................. 41\n4.3.3.3.1. Preparación del entorno ........................................................................ 41 4.3.3.3.2. Descripción del espacio .......................................................................... 42 4.3.3.3.3. Comienzo de la sesión ............................................................................. 42 4.3.3.3.4. Bucle principal.......................................................................................... 43 4.3.3.3.5. Finalización de la sesión ......................................................................... 44\n4.3.4. Otras clases auxiliares ......................................................................................... 44\n4.3.4.1. Interacción ..................................................................................................... 44 4.3.4.2. Observación ................................................................................................... 44\n4.4. Codificación y descripción de espacios .................................................................... 45\n4.4.1. Codificación del espacio ...................................................................................... 45 4.4.2. Descripción manual del espacio ........................................................................ 46 4.4.3. Descripción aleatoria del espacio ..................................................................... 46 4.5. Interfaz ........................................................................................................................... 47 5. Experimentos ........................................................................................................................ 51\n5.1. Entornos definidos manualmente............................................................................. 51 5.2. Entornos generados automáticamente .................................................................... 62\n5.2.1. Espacios generados automáticamente (Conectados) .................................... 62 5.2.2. Espacios generados automáticamente (Fuertemente conectados) ........... 72 5.3. Entorno sesgado ........................................................................................................... 82 5.4. Evaluación social .......................................................................................................... 86 5.5. Varios movimientos de los agentes generadores .................................................. 90 6. Conclusiones y trabajo futuro .......................................................................................... 103 Apéndices ..................................................................................................................................... 107\nA1. Extractos representativos del Código Fuente ....................................................... 107\nA1.1. Bucle principal .................................................................................................... 107 A1.2. Generación aleatoria de espacios ................................................................... 109 A2. Referencias .................................................................................................................. 109\nPágina VII\nPágina VIII\nPágina 1\n1. Introducción\n1.1. Contexto\nEste proyecto de fin de carrera surge a raíz de una Acción Complementaria dentro del Programa Explora-Ingenio financiada por el Ministerio de Ciencia e Innovación con título “Anytime Universal Intelligence (ANYNT)” (http://users.dsic.upv.es/proy/anynt/), cuyo investigador principal es José Hernández Orallo. El objetivo del programa Explora-Ingenio es explorar líneas de investigación de alto riesgo e impacto, posiblemente heterodoxas, cuya viabilidad se intenta determinar. Según el equipo que evaluó el proyecto, éste “es una propuesta con la suficiente osadía intelectual y riesgo como para ser considerada en este Programa explora”.\nEn el contexto de este proyecto de investigación, en 2009 se ofertaron en la ETSINF diferentes proyectos de fin de carrera relacionados con la implementación de prototipos y estructuras básicas de los tests de inteligencia que se proponía desarrollar. A finales del 2009, empecé a trabajar en el tema con José Hernández Orallo. El propio carácter del proyecto ANYNT implicaba que el proyecto de fin de carrera que me proponía tenía un carácter marcadamente investigador y que, frecuentemente, habría que tomar decisiones de implementación y de evaluación a medida que avanzara la implementación o se obtuviera algún resultado investigador. En definitiva, un proyecto bastante cerrado en su contexto (el del propio proyecto de investigación) pero inicialmente bastante abierto en objetivos, y que naturalmente ha de ser entendido en un contexto investigador, y no tanto desde la perspectiva de un buen acabado de un producto final.\nDurante la primera mitad de 2010, y compaginando los estudios, el proyecto fin de carrera fue avanzando, siguiendo fundamentalmente las publicaciones [Hernandez-Orallo 2010a] [Hernandez-Orallo 2010b] y [Hernandez-Orallo & Dowe 2010]. En junio de 2010 me presenté a una convocatoria de contratado dentro del mismo proyecto de investigación y fui seleccionado, principalmente por el premio extraordinario al expediente académico. Desde mi incorporación como contratado, el proyecto de fin de carrera constituye un primer paso a partir del cual seguir trabajando en una segunda fase más ambiciosa.\n1.2. Motivación\nUna de las cuestiones más debatidas en el campo de la inteligencia artificial, la ciencia cognitiva, la psicometría, la biología y la antropología es la definición de inteligencia y su medición.\nLa medición de la inteligencia humana es de suma relevancia para muchas áreas de aplicación. Consecuentemente, los tests psicométricos son comunes para (i) ayudar a niños y alumnos a aprender de manera eficiente (educación), (ii) evaluar al personal (selección y reclutamiento) y también (iii) en el tratamiento de diferentes enfermedades y problemas de aprendizaje (terapias de aprendizaje).\nPágina 2\nDe una manera bastante similar, la medición de la inteligencia en máquinas es requerida en áreas tales como (i) crear agentes, robots, y otros tipos de “sistemas inteligentes” que adquieran conocimientos rápidamente (adquisición de conocimiento), (ii) para seleccionar/evaluar las habilidades de “sistemas inteligentes” (acreditación/certificación) y también (iii) cuando se trata de corregir o mejorar las capacidades de estos sistemas (diseño o corrección de sistemas inteligentes).\nAunque la terminología es diferente, las similitudes en ambas áreas son claras. Adicionalmente, una tercera área afín es la psicología o cognición comparativa para varios tipos de animales, donde existe un debate sobre cómo evaluar las habilidades cognitivas en los animales superiores (en especial los grandes simios y cetáceos).\nEl caso de la medición de la inteligencia en máquinas es especialmente relevante\ndebido a varias cuestiones:\n• Una ciencia o tecnología no puede avanzar si no disponemos de técnicas de medición adecuadas para evaluar sus progresos. Es difícil desarrollar la\naeronáutica incluso a través de la observación de aves en pleno vuelo si no tenemos las mediciones de peso, altura o de aerodinámica. La inteligencia artificial tiene una referencia (el homo sapiens) pero sufre una falta de medidas y técnicas de medición para sus artefactos.\n• La ubicuidad de los robots, ayudantes, mayordomos y otros tipos de agentes autónomos que realizan tareas en lugar de los seres humanos, hace que sea difícil\ntratar apropiadamente con ellos en un nuevo espacio de colaboración donde la interacción virtual sustituye a la interacción física, tales como plataformas de colaboración, redes sociales, arquitecturas orientadas a servicios, e-burocracia, Web 2.0, etc. En muchas aplicaciones necesitamos diferenciar entre estúpidos robots capacitados para realizar una única tarea y robots más generales e inteligentes.\no Por un lado, algunas aplicaciones requieren que se les permita a los robots participar en proyectos o concederles permisos como interlocutores para la\ngestión, negociaciones o acuerdos. Por lo tanto, se espera que los robots sean eficaces para llevar a cabo las tareas que se les ha delegado, para las cuales tienen que ser inteligentes (desean evitarse los robots no inteligentes).\no Por otro lado, en algunos casos, queremos evitar que robots de cualquier tipo puedan realizar ciertas tareas (p. ej. robots maliciosos podrían crear\nmillones de cuentas en un servicio de correo gratuito). Con este fin, son extensamente utilizados los CAPTCHAs [von Ahn et al 2002] [von Ahn et al 2008], pero mecanismos más precisos y fiables serán necesarios en un futuro cercano.\nDemos un ejemplo. Imaginemos un entorno colaborativo, donde varios agentes (algunos de ellos humanos y otros máquinas), tienen que construir un sitio web especializado con información sobre un tema específico (p. ej. una entrada de la Wikipedia, un esbozo de un proyecto europeo, un evento reciente, una biblioteca de música, un proyecto geográfico, etc.). El equipo tendrá que decidir las normas de interacción (cómo la información es aceptada, integrada y publicada). Para llegar a formar\nPágina 3\nparte del equipo, cada componente necesitará certificar que él/ella tiene algunas habilidades básicas de razonamiento/aprendizaje. Si un agente inepto (o persona) trata de unirse al club requeriremos algún tipo de evaluación para decidir si debemos dejarle entrar.\n¿Existen mecanismos como estos disponibles hoy en día? La respuesta es no. A parte de los CAPTCHAs, los cuales solamente miden habilidades muy específicas, no disponemos de ningún tipo de test donde podamos evaluar rápida y fiablemente la inteligencia de un sistema inteligente (un agente).\nEl propósito del proyecto de investigación es explorar las posibilidades de construir\ntests que sean:\n• Universales: Pueden ser aplicados a humanos, robots, animales, comunidades o incluso híbridos. Para hacer frente a esta propiedad el test debe derivar de\nprincipios no antropomórficos universales fundados en ciencias de la computación y en la teoría de la información. Este objetivo, por sí mismo, es muy desafiante ya que los tests actuales se basan en suposiciones antropomórficas.\n• Anytime: Se pueden adaptar a la velocidad del examinado, y pueden adaptarse dinámicamente sus preguntas, interacciones o temas al examinado, a fin de\nevaluar su inteligencia más rápido. El test debe ser lo suficientemente flexible para evaluar muy rápidamente (con poca fiabilidad) para algunas aplicaciones (p. ej. aplicaciones donde los CAPTCHAs son usados hoy en día) o proporcionar estimaciones de alta fiabilidad si se proporciona más tiempo (p. ej. aplicaciones de las cuales se derivan serias consecuencias debido a la intromisión de un agente estúpido).\nSiguiendo las ideas de la primera definición de inteligencia y tests basados en la teoría de información algorítmica [Dowe & Hajek 1997] [Hernandez-Orallo 2000a] [Legg & Hutter 2007], nos enfrentamos al reto de construir el primer test de inteligencia universal, formal, pero al mismo tiempo práctico. La cuestión principal es la noción de test “anytime”, el cual permitirá una convergencia rápida del test al nivel de inteligencia del sujeto y una evaluación progresivamente mejor cuanto más tiempo le proporcionemos. Si tenemos éxito, la ciencia será capaz de medir la inteligencia de animales superiores (p. ej. simios) humanos y máquinas de una manera universal y práctica.\nDentro del proyecto de investigación anterior existen diferentes tareas de implementación a las cuales este proyecto de fin de carrera se circunscribe, tal y como se especifica en los objetivos que veremos a continuación.\n1.3. Objetivos\nPodemos distinguir un objetivo general, a partir del cual detallamos una serie de\nobjetivos específicos.\nPágina 4\nObjetivo general\nDesarrollar un entorno de aplicación de tests de inteligencia a diferentes agentes (máquinas o personas) usando la teoría de medición desarrollada en [Hernandez-Orallo & Dowe 2010] y la clase de entornos desarrollada en [Hernández-Orallo 2010b]. Básicamente esto significa la construcción de un sistema en donde distintos tipos de agentes sean capaces de interactuar con entornos autogenerados en donde, en base a observaciones facilitadas por el sistema y acciones respondidas por los agentes, pueda ser medida la inteligencia de estos agentes.\nObjetivos específicos\n• Intérprete de entornos: La construcción de un sistema que permita la interacción entre unos agentes en un entorno y, posteriormente, la medición de la inteligencia\ndemostrada por el agente.\n• Codificación manual de los entornos: Permitir la construcción de entornos utilizando un mecanismo manual que permita su definición interna y su\ncomportamiento.\n• Generación automática de los entornos siguiendo alguna distribución: El sistema deberá permitir la construcción de entornos automáticamente utilizando una\ndistribución para decidir su representación y su posterior construcción en base a dicha representación.\n• Entorno gráfico de evaluación de los entornos y que proporcione los resultados: Se debe facilitar al usuario una interfaz con la que interactuar con el entorno,\nofreciéndole lo necesario para la realización de los tests y que le muestre posteriormente los resultados obtenidos.\n• Realización de pruebas y experimentos con entornos y agentes muy sencillos, y con entornos y agentes aleatorios: Pruebas para comprobar que el sistema\nfunciona correctamente y experimentos para estudiar los resultados que distintos agentes obtienen al interactuar en algunos entornos codificados manualmente y en otros entornos generados automáticamente.\nPágina 5"
    }, {
      "heading" : "2. Precedentes",
      "text" : "Existen dos tipos de tests que son de interés en esta área: tests psicométricos y tests\nde inteligencia en máquinas.\nLos tests psicométricos [Martinez-Arias et al 2006] tienen una larga historia [Spearman 1904], son efectivos, fáciles de administrar, rápidos y muy estables cuando son usados en el mismo individuo a través del tiempo. De hecho, han proporcionado una de las definiciones de inteligencia más prácticas: “la inteligencia es lo que se mide por tests de inteligencia”. Sin embargo, los tests psicométricos son antropomórficos: no pueden evaluar la inteligencia de sistemas diferentes del Homo sapiens.\nNuevos enfoques en la psicometría como el Item Response Theory (IRT) permiten la selección de items basándose en sus características de demanda cognitivas, proporcionando resultados para entender lo que se está midiendo y adaptando el test al nivel del individuo que se está examinando. Los items generados por la teoría cognitiva y analizados por IRT son una herramienta prometedora, pero estos modelos no son implementados completamente en las pruebas [Embretson & Mc Collam 2000].\nA pesar de que estos y otros esfuerzos han intentado establecer “a priori” cómo debe ser un test de inteligencia (p. ej. [Embretson 1998]), y se han encontrado adaptaciones para distintos tipos de sujetos, en general necesitamos diferentes versiones de los tests psicométricos para evaluar a niños de diferentes edades, ya que los tests psicométricos para el Homo sapiens adulto se basan en unos conocimientos y habilidades que los niños no han adquirido todavía.\nLo mismo sucede con otros animales. Psicólogos comparativos y otros científicos en el área de la cognición comparativa normalmente diseñan tests específicos para especies diferentes. Se puede ver un ejemplo de estos tests especializados para niños y simios en [Herrmann et al 2007]. Adicionalmente, se ha demostrado que los tests psicométricos no funcionan para máquinas en su etapa de progreso actual de la inteligencia artificial [Sanghi & Dowe 2003], ya que pueden ser engañados por programas de ordenador muy simples. Pero el principal inconveniente de los tests psicométricos para evaluar otros sujetos diferentes a los humanos es que no existe una definición matemática tras ellos. Por lo tanto es difícil diseñar un test que funcione en cualquier sujeto inteligente (máquina, humano, animal, …), y no solo en el tipo específico de sujeto en el que experimentalmente hemos evaluado que funciona.\nLos tests de inteligencia para máquinas han sido propuestos desde que Alan Turing [Turing 1950] introdujo el juego de imitación en 1950, actualmente conocido como el test de Turing. En este test, un sistema es considerado inteligente si es capaz de imitar a un humano (p. ej. ser indistinguible de un humano) durante un periodo de tiempo y sujeto a un diálogo (tele-texto) con uno o más jueces. Aunque todavía se acepta como referencia para comprobar si finalmente la inteligencia artificial se acerca a la inteligencia de los humanos, ha generado debate a lo largo del tiempo. Por supuesto, también se han sugerido varias variantes y alternativas internas. El test de Turing e ideas relacionadas\nPágina 6\npresentan varios problemas como test de inteligencia para máquinas: el test de Turing es antropomórfico (mide la humanidad, no la inteligencia), no es gradual (no proporciona una puntuación), no es práctico (cada vez es más fácil de engañar y requiere mucho tiempo para obtener evaluaciones fiables) y requiere de un juez humano.\nUna reciente e ingenua aproximación a los tests de inteligencia para máquinas son los llamados CAPTCHAs (Completely Automated Public Turing test to tell Computers and Humans Apart) [von Ahn et al 2002] [von Ahn et al 2008]. Los CAPTCHAs son cualquier tipo de preguntas simples que puedan ser fácilmente resueltas por un humano pero no por las tecnologías de inteligencia artificial actuales. Los CAPTCHAs típicos son los problemas de reconocimiento de caracteres donde las letras aparecen distorsionadas. Estas distorsiones hacen que para las máquinas (robots) sea difícil reconocer las letras. A continuación podemos ver un ejemplo de CAPTCHA procedente de Gmail:\nEl objetivo inmediato de un CAPTCHA es separar a los humanos y a las máquinas. El objetivo final es prevenir que robots u otro tipo de agentes o programas sean capaces de crear miles de cuentas (u otras tareas que solo los humanos deberían hacer). Nótese que los robots podrían bloquear o dañar muchos servicios de Internet que utilizamos diariamente si esta u otras técnicas de control no existieran.\nEl problema de los CAPTCHAs es que se están haciendo cada vez más y más difíciles para los humanos, ya que los robots se están especializando y mejorando para poder leerlos. Siempre que una nueva técnica CAPTCHA es desarrollada, aparecen nuevos robots que tienen posibilidades de pasar el test. Esto fuerza a los desarrolladores de CAPTCHAs a que vuelvan a cambiarlos, y así sucesivamente. La razón es que son específicos y se basan en algunas tareas particulares. Aunque los CAPTCHAs funcionan\nPágina 7\nrazonablemente bien en la actualidad, dentro de 10 ó 20 años, se tendrán que hacer las cosas tan difíciles y generales, que los humanos necesitarán más tiempo y varios intentos para pasarlos. De hecho, ya está sucediendo, y perdemos cada vez más y más tiempo en los CAPTCHAs cada día.\nA parte de los tests, ciertas aproximaciones más teóricas y formales a la inteligencia de las máquinas han sido llevadas a cabo por científicos prominentes en el siglo 20 como A.M. Turing, R.J Solomonoff, E.M. Gold, C.S. Wallace, J.J. Rissanen, M. Blum, G.J. Chaitin y otros. El hito es el desarrollo de la teoría de información algorítmica (también conocida como Complejidad Kolmogorov) (ver [Li & Vitanyi 2008] para una referencia más completa), su relación con el aprendizaje (inferencia inductiva y predicción) [Solomonoff 1964] [Wallace & Boulton 1968] [Solomonoff 1986] [Wallace & Dowe 1999] [Wallace 2005] y finalmente su relación con la inteligencia.\nEstas ideas llevaron a algunos miembros del equipo del proyecto de investigación ANYNT a introducir varias definiciones formales a la inteligencia, a saber, las obras [Dowe & Hajek 1997, 1998] [Hernandez-Orallo & Minaya-Collado 1998] [Hernandez-Orallo 2000a] [Hernandez-Orallo 2000b]. Todos estos tests y definiciones son matemáticas, no antropomórficas (p. ej. universales), significativos e intuitivos. En este sentido no toman al Homo sapiens como referencia ni juez (como en el test de Turing), no han evolucionado a través de prueba y error a través de la experimentación en tests sobre sujetos durante un siglo (como generalmente se da en psicometría) sino que son construidos sobre nociones fundamentales y matemáticas en la teoría de computación. Y algunos de ellos lograron que fueran prácticos (un test de inteligencia factible) a coste de ser parcial (en el sentido de que miden rasgos necesarios de la inteligencia, pero no todos ellos). Veamos a continuación estas aproximaciones en mayor detalle:\nPor un lado, Dowe & Hajek [Dowe & Hajek 1997, 1998] sugirieron la introducción de problemas de inferencia de inducción en los tests de Turing para, entre otras cosas, hacer frente a la paradoja de Searle “La habitación China”, y también porque una habilidad de inferencia inductiva es un requisito necesario (aunque posiblemente “no suficiente”) para la inteligencia.\nPor otro lado, al mismo tiempo y de manera similar, y también de forma independiente, en [Hernandez-Orallo & Minaya-Collado 1998] [Hernandez-Orallo 2000a] la inteligencia se definió como la habilidad de comprender, dando una definición formal de la noción de comprensión como la identificación de un patrón ‘predominante’ de una evidencia dada, derivada de la teoría de inducción de Solomonoff, la complejidad de Kolmogorov y la búsqueda óptima de Levin. La definición es el resultado de un test, llamado C-test [Hernandez-Orallo & Minaya-Collado 1998] formado por series de complejidad creciente computacionalmente obtenidas. Las secuencias fueron formateadas y presentadas de una manera bastante similar a las pruebas psicométricas, y como resultado, el test fue administrado a humanos. No obstante, el objetivo principal fue que el test pudiese llegar a ser administrado a otros tipos de sistemas inteligentes.\nEn [Hernandez-Orallo 2000b] se esboza una factorización (y por lo tanto extensión) de estos tests de inferencia inductiva para explorar qué otras habilidades podrían conformar un completo (y por lo tanto suficiente) test. Con el fin de aplicar el test para sistemas\nPágina 8\ninteligentes inferiores, (todavía) incapaces de entender el lenguaje natural, el propósito de una extensión dinámica del C-test en [Hernandez-Orallo 2000a] se expresó así: “La presentación del test debería cambiar ligeramente. Los ejercicios deberán proporcionarse uno por uno y, después de cada respuesta, se le deberá proporcionar la respuesta correcta al sujeto (deberán usarse recompensas y castigos)”.\nAlgunos trabajos recientes realizados por Legg y Hutter (p. ej. [Legg & Hutter 2007]) han seguido los pasos anteriores y, fuertemente influenciados por la teoría de Hutter de los agentes óptimos AIXI [Hutter 2005], han dado otra definición de inteligencia de máquina, denominada “Inteligencia Universal”, también surgida de la complejidad de Kolmogorov y la inducción de Solomonoff.\nLa idea básica es evaluar la inteligencia de un agente π en varios entornos µ, elegidos utilizando una distribución universal (derivadas de la complejidad de Kolmogorov, p. ej. p(µ)= 2-K(µ)), utilizando recompensas que se acumulan durante la interacción con el entorno. Por tanto la inteligencia se define como la competencia de un agente en distintos entornos, donde los entornos simples tienen una mayor probabilidad que los entornos complejos.\nLa comparación con los trabajos de Hernández-Orallo (pero también el test de\ncompresión de Dowe & Hajek) se resumen en [Legg & Hutter 2007] con la siguiente tabla:\nAgente universal Test universal\nEntorno pasivo Inducción de Solomonoff C-test\nEntorno activo AIXI Inteligencia Universal\nDe hecho, la definición basada en el C-test puede ser considerada una instancia del trabajo de Legg y Hutter ya que el agente no tiene permitido hacer una acción hasta que ha visto un número de observaciones (la secuencia de inferencia inductiva). Una de las contribuciones más relevantes en el trabajo de Legs y Hutter es que su definición de Inteligencia Universal permite evaluar formalmente el funcionamiento teórico de algunos agentes: un agente aleatorio, un agente especializado, … o un agente super-inteligente, como AIXI [Hutter 2005] que según se afirma, si alguna vez se construye, sacaría la mejor puntuación en el test de Inteligencia Universal. En pocas palabras, el trabajo de Legg y Hutter es otro paso que ayuda a dar forma a las cosas que se deben abordar en un futuro próximo a fin de alcanzar finalmente una teoría de la inteligencia de máquina.\nSin embargo, existen cinco problemas que hemos identificado en su definición que evitan que se ponga en práctica. Primero, tenemos una suma infinita de todos los entornos. Segundo, también tenemos una suma infinita de todas las posibles recompensas (la vida de los agentes en cada entornos es infinita). Tercero, K() no es computable. Cuatro, y más importante, no se tiene en cuenta el tiempo. Y, quinto, hay cierta confusión entre la inducción y la predicción.\nPágina 9"
    }, {
      "heading" : "3. Marco conceptual",
      "text" : "3.1. Requisitos\nEn el proyecto de investigación se propone una modificación y extensión de las definiciones y tests previos a fin de construir un primer test y definición general, formal y factible. La definición y el test se basa en desarrollos previos en tests basados en la complejidad de Kolmogorov [Dowe & Hajek 1997, 1998] [Hernandez-Orallo & MinayaCollado 1998] [Hernandez-Orallo 2000a, 2000b] [Legg & Hutter 2007]. La principal idea de todos ellos es que se usa la Distribución Universal para la generación de preguntas y entornos, y por lo tanto cualquier sesgo particular hacia un individuo específico, especies o culturas se evita. Esto hace al test universal para cualquier posible tipo de sujeto. Pero aparte de esta condición “Universal” nos centramos en algunos requisitos prácticos adicionales:\n• Debe permitir medir cualquier tipo de sistema inteligente (biológico o computacional) que exista actualmente o pueda ser construido en el futuro\n(sistemas anytime).\n• El test debe adaptarse rápidamente al nivel de inteligencia y escala de tiempo del sistema. Debe permitir evaluar tanto sistemas ineptos como brillantes (cualquier\nnivel de inteligencia) así como a sistemas muy lentos y muy rápidos (escala any time).\n• La calidad de la evaluación dependerá del tiempo que dejemos al test. Esto significa que el test puede ser interrumpido en cualquier momento, produciendo\nuna aproximación a la puntuación de la inteligencia. Cuanto más tiempo dejemos para realizar el test, mejores evaluaciones (test anytime).\nDebido a estos requisitos llamaremos a los tests “anytime universal intelligence tests”. Si tenemos éxito, la ciencia será capaz de medir la inteligencia de animales superiores (p. ej. simios), humanos, máquinas, híbridos o comunidades de humanos y máquinas e incluso seres extraterrestres, de un modo absoluto.\nLa principal dificultad para hacerlo factible es que cuanto más general tratamos que sea el test, menos cosas del agente debemos asumir. Esto significa que es posible que necesitemos más tiempo para evaluar la inteligencia, ya que no podemos confiar en un conocimiento común ni un lenguaje común para explicar las instrucciones ni dar nada por sentado. El problema es similar para evaluar niños o animales, donde todo debe ser muy simbólico y simple, y los sujetos deben ser dirigidos hacia el objetivo a través de recompensas y castigos. Esta es la razón por la que estos tests son más interactivos que los tests psicométricos tradicionales para los Homo sapiens adultos.\nDe hecho, existe una tesis común en todas las pruebas de inteligencia (tanto de la psicometría, la cognición comparativa o la inteligencia artificial): el tiempo que se requiere para evaluar la inteligencia de un sujeto depende (1) del conocimiento o características que se esperan y conocen sobre el sujeto (misma especie, misma cultura, mismo lenguaje,\nPágina 10\netc.) y (2) en la adaptabilidad del examinador. Mientras que (1) se lleva al extremo en psicometría humana, donde los tests son simplemente formularios con preguntas explicadas en lenguaje natural, (2) se lleva al extremo en el Test de Turing o cualquier tipo de entrevista de evaluación, donde los examinadores son humanos los cuales dinámicamente adaptan sus preguntas dependiendo de las respuestas del sujeto.\nConsecuentemente, si queremos evaluar diferentes tipos de sujetos sin depender de ninguna suposición acerca de su naturaleza o conocimiento, y si queremos conseguir una valoración fiable en un reducido (práctico) periodo de tiempo, debemos necesariamente diseñar tests interactivos y adaptables.\n3.2. Entornos y agentes\nAunque muy diferentes, existen tres dimensiones donde cualquier planteamiento de medición de inteligencia tiene que tomar decisiones. En todos los ajustes de evaluación de inteligencia, encontramos (1) un sujeto o agente a examinar, (2) un conjunto de problemas, tareas o entornos y (3) un protocolo para la aplicación de medida y la derivación de uno o más resultados de rendimiento. Dependiendo de los supuestos o limitaciones impuestas a cada uno de estos temas, tenemos, como resultado, un marco de evaluación diferente. La literatura de la inteligencia artificial se ha centrado en (1) y (2), especialmente en el área de las arquitecturas cognitivas, donde implícitamente o explícitamente un conjunto de restricciones o requisitos se establece en los agentes y entornos.\nPor ejemplo, SOAR [Laird et al 1987][Laird 2008], una de las más exitosas y conocidas arquitecturas cognitivas en la inteligencia artificial, implícitamente asume algunas características sobre los agentes y entornos. Algunos de estos supuestos se convierten en requisitos explícitos en [Laird & Wray 2010], donde la relación entre los requisitos de la inteligencia y los requisitos en la arquitectura cognitiva son dilucidados. Más precisamente, este trabajo describe ocho características de los entornos, tareas y agentes los cuales son considerados importantes para el nivel de inteligencia de los humanos, de los cuales se derivan doce requisitos para las arquitecturas, p. ej. para construir agentes inteligentes. De todas formas, las características de los entornos, tareas y agentes son una buena cuenta de los requisitos en los agentes y entornos, los cuales han ido apareciendo\nPágina 11\nen la literatura en los últimos quince años. Las características pueden ser resumidas del siguiente modo: los entornos deben ser dinámicos, reactivos y complejos, conteniendo diversos objetos interactivos, y también algunos otros agentes que afecten al rendimiento. Las tareas deben ser complejas, diversas y novedosas. Debe haber regularidades en múltiples escalas de tiempo. La percepción de los agentes es limitada, y el entorno puede ser parcialmente observable. Los agentes deben ser capaces de responder rápidamente a la dinámica del entorno pero los recursos computacionales de los agentes deben considerarse limitados. Finalmente, la existencia de un agente es a largo plazo y continua, por lo que debe equilibrar las tareas o recompensas inmediatas con más objetivos a largo plazo. Podemos ver que ninguno de los enfoques de medición vistos en la subsección anterior sigue estos requisitos.\nLa noción de agente es hoy en día la corriente principal de la inteligencia artificial y, aparte de los requisitos previos (u otros), no merece una mayor aclaración. La distinción entre objetivo, tarea y entorno es una cuestión más compleja, ya que depende de la intención y la voluntad del agente. En la psicometría para niños y la cognición comparativa de animales, los tests de inteligencia no pueden asumir que seamos capaces de programar algunos objetivos o explicar explícitamente una tarea al examinado. Consecuentemente, las pruebas, se realizan generalmente utilizando recompensas, un enfoque acondicionado para que los sujetos se centren indirectamente en la tarea. Curiosamente, este es el mismo criterio adoptado en el aprendizaje por refuerzo [Sutton & Barto 1998]. A pesar de que el aprendizaje por refuerzo generalmente se ve como una formalización de este ajuste en el contexto de la inteligencia artificial y el aprendizaje de máquinas, también se puede ver con una perspectiva más amplia dado a que el aprendizaje por refuerzo es el estudio de cómo los animales y los sistemas artificiales optimizan su comportamiento condicionado por recompensas y castigos dados.\nLa idea más general de este ajuste es la interacción entre un agente y un entorno a través de acciones, recompensas y observaciones, el cual es también similar a la configuración que típicamente se usa en control o teoría de sistemas, y puede ser esbozado como se ve en la Figura 1:\nobservation\nreward\nenvironment agent\naction\nFigura 1.Interacción entre un agente y un entorno [Legg & Hutter 2007].\nLas acciones son limitadas por un conjunto finito de símbolos A, (p. ej. {izquierda, derecha, arriba, abajo}), las recompensas se recogen de un subconjunto R de números racionales entre 0 y 1, y las observaciones son también limitadas por un conjunto finito O de posibilidades (p. ej. una rejilla de celdas binarias de n×m y los objetos situados en ella, o un conjunto de diodos emisores de luz, LEDs). Utilizaremos ai, ri y oi para\nPágina 12\n(respectivamente) denotar acciones, recompensas y observaciones en la interacción o ciclo i (o estado). Las recompensas y las observaciones son las salidas del entorno. El par <ri, oi> es también conocido como una percepción. El orden de los eventos es siempre: recompensa, observación y acción. Una secuencia de estos eventos es entonces una cadena como r1o1a1r2o2a2. Tanto el agente como el entorno se definen como una medida probabilística. Por ejemplo, dado un agente, denotado como π, el termino π(ak | r1o1a1r2o2a2 … rkok) denota la probabilidad de que el agente π ejecute la acción ak después de la secuencia de eventos r1o1a1r2o2a2 … rkok. De forma similar, un entorno µ también es una medida probabilística la cual asigna probabilidades para cada posible par de observaciones y recompensas. Como µ(rkok | r1o1a1r2o2a2 … rk-1ok-1ak-1), por ejemplo, denota la probabilidad en el entorno µ de proporcionar rkok después de la secuencia de eventos r1o1a1r2o2a2 … rk-1ok-1ak-1. Nótese que si para todos los ciclos existe una única acción/percepción con probabilidad 1 (y 0 para el resto), entonces tenemos un agente/entorno determinista. Si combinamos la medición probabilística para el agente y el entorno tenemos una medida probabilística para el historial de interacción o secuencia. Los historiales de interacción serán deterministas (respectivamente, computables) si tanto el agente y el entorno son deterministas (respectivamente, computables). Denotaremos con ai µ,π , ri µ,π y oi µ,π , la acción, la recompensa y la observación en la interacción o ciclo i para el entorno µ y el agente π.\nEJEMPLO 1.\nConsidera el escenario de un test donde un chimpancé (el agente) puede presionar uno de tres posibles botones (A = {B1, B2, B3}), las recompensas son solo la entrega (o no) de una banana (R = {0, 1}) y la observación son tres celdas donde una pelota debe estar exactamente dentro de una de ellas (O = {C1, C2, C3}). Un ejemplo de un posible entorno es:\nµ(rkok | r1o1a1r2o2a2 ... rk–1ok–1ak–1) = 1 si ((ak–1 = B1 y ok–1 = C1) o (ak–1 = B2 y ok–1 = C2) o (ak–1 = B3 y ok–1 = C3)) y (rk = +1)\nµ(rkok | r1o1a1r2o2a2 ... rk–1ok–1ak–1) = 1 si ¬((ak–1 = B1 y ok–1 = C1) o (ak–1 = B2 y ok–1 = C2) o (ak–1 = B3 y ok–1 = C3)) y (rk = 0)\nµ(rkok | r1o1a1r2o2a2 ... rk–1ok–1ak–1) = 0 en cualquier otro caso.\nLa observación ok en ambos casos es generada aleatoriamente con una distribución uniforme entre las tres posibilidades de O. La primera recompensa es 1 (empezamos el juego dándole una banana al chimpancé).\nDe acuerdo con la definición del entorno anterior, un chimpancé que siempre seleccione el botón correspondiente a la celda donde se encuentre la pelota puntuará una recompensa de +1 (una banana) en cada ciclo. Por ejemplo, si el entorno muestra C2 y el chimpancé presiona B2, entonces se le recompensará con una banana.\nAunque el ejemplo anterior es muy sencillo, la configuración general que se muestra en la Figura 1, utilizando entornos, agentes, acciones, observaciones y recompensas es lo suficientemente poderoso como para representar los requisitos establecidos en [Laird &\nPágina 13\nWray 2010], así como cualquier medida de la inteligencia establecida vista en la subsección anterior (excepto, quizás, muchos tipos de tests psicométricos como CAPTCHAs o el Test de Turing, debido a la ausencia de recompensas).\nBajo esta configuración primero tenemos que pensar en un conjunto de entornos tales que sean los suficientemente complejos como para cumplir los requisitos anteriores. O, en otras palabras, no podemos asumir ninguna restricción en los entornos y observaciones si queremos que la configuración sea lo suficientemente general para una medición de inteligencia. En particular, en el aprendizaje por refuerzo, muchas técnicas asumen que el entorno es un Markov Decision Process (MDP). En otros casos, sin embargo, se asume que los entornos son completamente observables, p. ej. que existe una función entre las observaciones y los estados. No podemos asumir esto, ya que muchos problemas del mundo real no son completamente observables. Este es especialmente el caso en contextos sociales donde otros individuos pueden tener vistas diferentes (y parciales) de la misma situación.\nEn [Legg 2008], se desarrolla una taxonomía de entornos, mientras que se distingue entre muchos tipos de entornos. Por ejemplo, entornos pasivos son aquellos en los cuales las acciones de los agentes solamente pueden afectar a las recompensas pero no a las observaciones. Una sub-categoría especial es la secuencia de predicción como se utiliza en los tests psicométricos clásicos, y también los problemas de clasificación típicos en el aprendizaje automático. Algunos otros tipos de entornos son los Markov Decision Processes (MDP) de orden n, donde la siguiente observación solo puede depender de las últimas n observaciones y las últimas n acciones. Se puede ver que los MDPs de orden n pueden reducirse a MDPs de primer orden (o simplemente MDPs). En este caso, es natural hablar de “estados”, como muchos juegos de mesa y algunos laberintos, ya que la próxima recompensa y observación solo dependen de la observación y acción anterior. Un tipo especial de MDPs son los MDPs ergódicos, los cuales se caracterizan por poderse alcanzar cualquier posible observación (en uno o más ciclos) a partir de cualquier estado. Esto significa que en cualquier estado, las acciones del agente pueden hacerle recuperarse de una mala decisión anterior. Creemos que esto es una gran limitación y, como ha sido anteriormente mencionado y defendido por muchos (p. ej. [Laird & Wray 2010]), necesitamos ser tan generales como sea posible en la clase de entornos que necesitamos considerar.\nTrataremos de considerar el concepto más general (o clase) de entorno y el concepto más general de agente, a fin de permitir una prueba universal, en la forma en la que da cuenta de una variedad de contextos y aplicable a cualquier tipo de agente. Por el momento, únicamente asumiremos que los entornos son infinitos (p. ej. ninguna secuencia de acciones los hace parar) y que están basados en un modelo, p. ej., tenemos una descripción, programa o modelo tras de ellos. También asumiremos que este modelo es computable.\nAparte de las características de los entornos y agentes, cuando abordemos la cuestión de la evaluación del agente, necesitamos estudiar sin restricción alguna la distribución de las recompensas que se necesita, y, muy especialmente, cómo se agregan las recompensas. En el aprendizaje por refuerzo, se han definido muchas agregaciones de funciones o ganancias. Por ejemplo, la forma más común de evaluar el rendimiento de un\nPágina 14\nagente π en un entorno µ es calcular el valor esperado de la suma de todas las recompensas, p.ej.:\nDEFINICIÓN 1. RECOMPENSA ACUMULADA ESPERADA\n( )∑∞== 1 ,: i irEV πµπµ\nEsta no es la única opción, ya que se puede plantear a qué se le da más relevancia, si a las recompensas inmediatas o a las de largo plazo, con el fin de recompensar las políticas codiciosas o de exploración. Esto se relaciona con la vida del agente (el número de interacciones permitidas) y también si existe un límite en las recompensas [Hutter 2006]. Todo esto se volverá a examinar a continuación.\n3.3. Medición\nSiguiendo la justificación de [Hernandez-Orallo & Dowe 2010], se imponen una serie de restricciones sobre las recompensas y los entornos, con el objetivo de garantizar una serie de propiedades de convergencia y de balance frente a agentes aleatorios.\nLa primera idea es utilizar recompensas simétricas, las cuales pueden estar en un\nrango entre -1 y 1, p. ej.:\nDEFINICIÓN 2. RECOMPENSAS SIMÉTRICAS\n11: ≤≤−∀ iri\nNótese que esto no impide que la recompensa acumulada en un cierto punto sea mayor que 1 o menor que -1. Por lo que, si hacemos muchas acciones, podemos tener una recompensa acumulada mayor que 1. Observando implementaciones físicas, las recompensas negativas no tienen por qué estar asociadas con castigos, lo cual se considera poco ético para individuos biológicos. Por ejemplo, si estamos evaluando un simio, las recompensas desde -1 a -1/3 podrían implicar no dar nada, desde -1/3 a 1/3 dar una pieza de fruta, y desde 1/3 a 1 dos piezas. O una recompensa negativa puede implicar eliminar una fruta adjudicada previamente.\nSi nos fijamos en las recompensas simétricas, también esperamos que los entornos sean simétricos, o más precisamente, que sean balanceados en como proporcionan recompensas. Esto puede verse del siguiente modo: en un test fiable, queremos que muchos (si no todos) los entornos ofrezcan una recompensa de 0 para agentes aleatorios. La siguiente definición lo formaliza.\nPágina 15\nDEFINICIÓN 3. ENTORNO BALANCEADO\nUn entorno µ está balanceado si y solo si 1) 11: ≤≤−∀ iri 2) Dado un agente aleatorio π, se mantiene la siguiente igualdad:\n( ) 0 1 , == ∑ ∞ =i i rEV r πµπµ\nEsto excluye tanto a entornos hostiles como a entornos benévolos, p. ej. entornos donde realizando acciones aleatorias se conseguiría más recompensas negativas (respectivamente positivas) que positivas (respectivamente negativas). En muchos casos no es difícil de probar que un entorno particular está balanceado. Para entornos complejos, la restricción previa se puede comprobar experimentalmente. Otra aproximación es proporcionar una máquina de referencia que únicamente genere entornos balanceados.\nNótese que las modificaciones previas en las recompensas ahora nos permiten usar\nuna media en lugar de una recompensa acumulada, es decir:\nDEFINICIÓN 4. RECOMPENSA MEDIA\ni\ni\ni n\nnV nv j\nj\n)( )(\nπ µπ µ =\nY podemos calcular el valor esperado (aunque el límite no pueda existir) de la media previa, denotada por )( πµ jvE , para un valor grande arbitrario de n. Veamos esto con un ejemplo:\nEJEMPLO 2.\nConsidera una modificación de las características del test visto en el ejemplo 1. Un robot (el agente) puede presionar uno de tres posibles botones (A = {B1, B2, B3}), las recompensas son la no entrega de ninguna banana, una banana o dos bananas (R = {-1, 0, 1}) y la observación son tres celdas donde una pelota blanca y otra negra deben estar dentro de una (pero distinta) celda, es decir (O = {0WB, 0BW, W0B, B0W, WB0, 0BW}), donde W denota que la celda tiene una pelota blanca, B denota que la celda tiene una pelota negra y 0 denota que está vacía. Un ejemplo de un posible entorno es:\nµ(rkok | r1o1a1 ... rk–1ok–1ak–1) = 1 si (ak–1 = B1 y ok–1 = Wxx) o (ak–1 = B2 y ok–1 = xWx)\no (ak–1 = B3 y ok–1 = xxW) y (rk = +1)\nµ( rkok | r1o1a1 ... rk–1ok–1ak–1) = 1 si (ak–1 = B1 y ok–1 = Bxx) o (ak–1 = B2 y ok–1 = xBx) o (ak–1 = B3 y ok–1 = xxB) y (rk = −1) µ( rkok | r1o1a1 ... rk–1ok–1ak–1) = 1 si ¬((ak–1 = B1 y ok–1 = Wxx)\nPágina 16\no (ak–1 = B2 y ok–1 = xWx)\no (ak–1 = B3 y ok–1 = xxW)) y\n¬((ak–1 = B1 y ok–1 = Bxx) o (ak–1 = B2 y ok–1 = xBx)\no (ak–1 = B3 y ok–1 = xxB) y (rk = 0)\nµ( rkok | r1o1a1 ... rk–1ok–1ak–1) = 0 en cualquier otro caso La observación ok, se genera de entre las cuatro observaciones {0WB, 0BW, W0B, WB0} de modo uniformemente aleatorio. La primera recompensa r1 es 0.\nUn primer robot (π1) tiene el comportamiento de siempre presionar el botón B1, p. ej. π1(B1| X) para toda secuencia de X. Consecuentemente, el rendimiento de π1 en este entorno es:\n2\n10 lim\n2\n1 lim\n2\n1 )( 1\n, 1\n1 =+=  \n\n\n  \n =\n∞→∞→\n=\n∞→ ∑ i n i i n i\nn k k\nn nn\nn\nn\nr EvE\nii\ni\ni j\nπµ π µ\nUn segundo robot (π2) tiene el comportamiento de siempre presionar el botón B2, p.ej. π2(B2| X) para toda secuencia de X. Consecuentemente, el rendimiento de π2 en este entorno es:\n4\n10 limlim\n2\n1 lim\n4\n1 )( 1\n, 2\n2 −=+−+=  \n\n\n  \n =\n∞→∞→∞→\n=\n∞→ ∑ i n i i n i i n i\nn k k\nn nn\nn\nn\nn\nn\nr EvE\niii\ni\ni j\nπµ π µ\nUn tercer robot (π3) tiene el comportamiento de siempre presionar el botón B3, p. ej. π3(B3| X) para toda secuencia de X. Consecuentemente, el rendimiento de π3 en este entorno es:\n4\n10 limlim\n2\n1 lim\n4\n1 )( 1\n, 3\n3 −=+−+=  \n\n\n  \n =\n∞→∞→∞→\n=\n∞→ ∑ i n i i n i i n i\nn k k\nn nn\nn\nn\nn\nn\nr EvE\niii\ni\ni j\nπµ π µ\nUn cuarto robot (π4) tiene un comportamiento aleatorio. Por lo tanto el rendimiento de π4 es:\n0lim 4\n1 lim\n4\n1 lim\n2\n1\n3\n1 3...)( 1\n, 4\n4 =      −+−+⋅==  \n\n\n  \n =\n∞→∞→∞→\n=\n∞→ ∑ i i n i i n i i n i\nn k k\nn n\nn\nn\nn\nn\nn\nn\nr EvE\niii\ni\ni j\nπµ π µ\nConsecuentemente, el agente π1 es mejor que el aleatorio (π4) en este entorno, y π2 y π3 son peores. Y, finalmente, ya que la recompensa global esperada de un agente aleatorio es 0, este entorno está balanceado.\n3.4. Distribución universal y su aplicación a entornos\nEn esta sección daremos una breve introducción al área de la Teoría de Información Algorítmica y a las nociones de la complejidad de Kolmogorov, las distribuciones\nPágina 17\nuniversales, la complejidad Kt de Levin, y su relación con las nociones de dificultad, comprensión, aleatoriedad, el principio MML, la predicción y la inferencia inductiva. Después, estudiaremos las aproximaciones que han aparecido utilizando estas nociones formales para dar definiciones matemáticas a la inteligencia o desarrollar tests de inteligencia a partir de ellos, empezando por una comprensión mejorada de los tests de Turing, el C-test y la definición de Legg y Hutter de la Inteligencia Universal.\nLa Teoría de Información Algorítmica es un campo en la informática que se relaciona adecuadamente con las nociones de la computación y la información. La idea clave es la noción de la Complejidad de Kolmogorov de un objeto, el cual es definido como la longitud del programa más corto p el cual genera una cadena dada x sobre una máquina U. Formalmente,\nDEFINICIÓN 5. COMPLEJIDAD DE KOLMOGOROV\n)(min:)( )( such that plxK xpUp U = =\nDonde l(p) se refiere a la longitud en bits de p y U(p) se refiere al resultado de ejecutar p en U. Por ejemplo, si U es el lenguaje de programación Lisp y x = 1010101010101010, entonces KList(x) es la longitud en bits del programa más corto en Lisp que genera la cadena x. La relevancia en la elección de U depende mayoritariamente en el tamaño de x. Dado que cualquier máquina universal puede emular a otra, se mantiene que para cualquier par de máquinas U y V, existe una constante c(U,V), la cual solo depende de U y de V y no depende de x, y así para todo x, |KU(x) − KV(x)| ≤ c(U,V). El valor de c(U,V) es relativamente pequeño para x suficientemente largas.\nDe la definición previa, podemos definir la probabilidad universal para la máquina U\ncomo sigue:\nDEFINICIÓN 6. DISTRIBUCIÓN UNIVERSAL\n)( 2)( xK\nU Uxp\n−=\nque le da mayor probabilidad a objetos cuya descripción más corta es pequeña y menor probabilidad a objetos cuya descripción más corta sea larga. Cuando U es universal, la distribución es similar (hasta una diferencia constante) a la distribución universal para cualquier otra máquina universal diferente, dado que una puede emular a la otra. Teniendo en cuenta los programas como hipótesis en el lenguaje hipotético definido por la máquina, esto allana el camino a la teoría matemática de la inferencia inductiva, la cual fue desarrollada por Solomonoff [Solomonoff 1964], formalizando la navaja de Occam de manera adecuada para la predicción, al afirmar que la predicción que maximiza la probabilidad universal finalmente descubrirá cualquier regularidad en los datos, que se relaciona con la noción de la Longitud Mínima del Mensaje (MML) para la inferencia inductiva [Wallace & Boulton 1968] [Wallace & Dowe 1999] [Wallace 2005], y también se relaciona con la noción de la compresión de datos.\nLas nociones de predicción e inducción son muy parecidas pero no idénticas, debido a que la predicción se puede obtener por una combinación (p. ej. Bayesiana) de varios modelos plausibles, mientras que la inducción normalmente se centra en descubrir el\nPágina 18\nmodelo más plausible y por lo general implica una explicación de las observaciones. Sin embargo, estas nociones se usan frecuentemente como sinónimos. De hecho, el papel seminal de Solomonoff [Solomonoff 1964] se refiere a “la teoría de la inferencia inductiva” cuando realmente se refiere a “la teoría de la predicción”. Además, también hay importantes diferencias entre la compresión en una parte y la compresión en dos partes (inducción MML). En el primer caso, el modelo no distingue entre patrones y excepciones mientras que la segunda explícitamente separa las regularidades (patrón principal) de las excepciones. Véase [Wallace 2005] (sec. 10.1) y [Dowe 2008] (parte de sec. 0.3.1 refiriéndose a Solomonoff) para más detalles de esto.\nUno de los principales problemas de la Teoría de Información Algorítmica es que la Complejidad Kolmogorov es incomputable. Una solución popular al problema de la computabilidad de K() para cadenas finitas es utilizar una versión de tiempo limitado o ponderada de la complejidad de Kolmogorov (y por lo tanto de la distribución universal de la que se deriva). Una elección popular es la complejidad Kt de Levin [Levin 1973] [Li & Vitanyi 2008]:\nDEFINICIÓN 7. COMPLEJIDAD KT DE LEVIN\n{ }),,(log)(min:)( )( such that xpUtimeplxKt xpUp U += =\nDonde l(p) denota la longitud en bits de p, U(p) denota el resultado de ejecutar p en U\ny time(U,p,x) denota el tiempo que U utiliza ejecutando p para producir x.\nFinalmente, a pesar de la incomputabilidad de K y la complejidad computacional de sus aproximaciones, han habido algunos esfuerzos en utilizar la Teoría de Información Algorítmica para diseñar una búsqueda óptima o estrategias de aprendizaje. La búsqueda de Levin (o universal) [Levin 1973] es un algoritmo de búsqueda iterativo para resolver problemas de inversión basados en Kt, el cual ha inspirado a otras estrategias de agente general como AIXI de Hutter, un agente que es capaz de adaptarse óptimamente en algunos entornos [Hutter 2007], para los que existe una aproximación de trabajo [Veness et al 2009].\nEn [Hernandez-Orallo & Dowe 2010] se introduce una variante de la complejidad anterior que permite asegurar que las interacciones terminan en un tiempo corto, haciendo por tanto factible la medición usando la distribución que se deriva de ella.\nLa aproximación considera un tiempo máximo para cada salida. Primero definimos ∆ctime(U, p, i) como el tiempo necesario para imprimir el par <ri,oi> tras la acción ai−1, es decir el tiempo de ciclo de respuesta. A partir de aquí podemos establecer el límite superior para el tiempo de cómputo máximo que el entorno puede consumir para generar la recompensa y la observación después de la acción del agente.\nDEFINICIÓN 8. COMPLEJIDAD KT PONDERANDO LOS PASOS DE LA INTERACCIÓN\n            ∆+= ≤= )),,((maxlog)(min:),( )( such that max ipUctimeplnxKt nixpUp U\nPágina 19\nlo que significa la suma de la longitud del entorno más el logaritmo del máximo tiempo de respuesta de este entorno con la máquina U. Nótese que este límite superior puede usarse en la implementación de entornos, especialmente para hacer su generación computable. Para hacer esto, ya que son infinitos, definimos su complejidad para un número límite de ciclos n, haciendo su definición computable. Este límite n no es solo necesario para la computación; también es práctico en algunos otros casos donde la computabilidad no es un problema pero no existe un máximo. Por ejemplo, considera un entorno cuya salida i-ésima dependa del cálculo de si el número i es primo o no. En este caso, el máximo ∆ctime no está delimitado y, por tanto el KtmaxU de esta secuencia sería infinito. Por lo tanto, el entorno sería descartado si no establecemos un límite de n.\nLa función de complejidad previa asegura que el tiempo de respuesta en cualquier interacción con un entorno está delimitado, pero aún conservamos la navaja de Occam en la probabilidad derivada.\n3.5. Entornos discriminativos: Sensibilidad a las recompensas\nAdemás, muchos entornos (tanto simples como complejos) serán completamente inútiles para evaluar la inteligencia, como entornos que dejan de interactuar, o entornos con recompensas constantes, o entornos que son muy similares a otros entornos usados anteriormente, etc. Incluyendo algunos, o la mayoría, de ellos en la muestra de entornos es una pérdida de recursos de testeo; si pudiéramos hacer una muestra más precisa seríamos capaces de hacer una evaluación más eficiente. La cuestión es determinar un criterio no arbitrario para excluir algunos entornos. Por ejemplo, la definición de Legg y Hutter [Legg & Hutter 2007] fuerza a que los entornos interactúen infinitamente, y puesto que la descripción debe ser finita, debe existir algún patrón, que puede ser eventualmente aprendido (o no) por el examinado. Pero esto incluye obviamente entornos que “siempre producen la misma observación y recompensa”. De hecho, no son solo posibles sino altamente probables en muchas máquinas de referencia. Otro caso patológico es un entorno cuyas “observaciones y recompensas producidas sean aleatorias”, pero esto tiene una alta complejidad, si suponemos entornos deterministas. En ambos casos el comportamiento de cualquier agente en estos entornos casi sería el mismo. En otras palabras, no tendrían poder discriminativo. Así que estos entornos serían inútiles para discriminar entre agentes.\nEn un entorno interactivo, un requisito claro para que un entorno sea discriminativo es que lo que haga el agente debe tener consecuencias en las recompensas. Sin ninguna restricción, algunos (la mayoría) entornos simples serían completamente insensibles a las acciones de los agentes. Como se ha mencionado antes, en [Legg 2008], se ha desarrollado una taxonomía de entornos, y se presenta el concepto de MDPs ergódicos en los que siempre se puede volver a un estado anterior. Los MDP ergódicos son una restricción muy importante, mientras que muchos entornos reales no nos dan una “segunda oportunidad”. Si las “segundas oportunidades” estuvieran siempre disponibles, el comportamiento de los agentes tendería a ser más impetuoso y menos reflexivo. Además, parece más fácil aprender y tener éxito en esta clase de entornos que en una clase general.\nPágina 20\nEn lugar de eso, vamos a restringir los entornos para que sean sensibles a las acciones de los agentes. Esto significa que una acción equivocada (p. ej. Ir por una puerta equivocada) podría llevar al agente a una parte del entorno desde donde nunca podrá volver (no-ergódico), pero al menos las acciones hechas por el agente pueden modificar las recompensas en este sub-entorno. Más precisamente, queremos que un agente sea capaz de influenciar en las recompensas en cualquier punto del sub-entorno. Esto no implica ergodicidad pero si al menos sensibilidad a las recompensas. Esto significa que no podemos alcanzar un punto en donde las recompensas se dan independientemente de lo que hagamos (un callejón sin salida). Esto se puede formalizar de esta manera:\nDEFINICIÓN 9. ENTORNO SENSIBLE A LAS RECOMPENSAS Dado un entorno determinista µ, decimos que es n-acciones sensible a las recompensas si para toda secuencia de acciones a1a2…a3 de longitud k existe un entorno positivo m≤n tal que existen dos secuencias de acciones b1b2…bm y c1c2…cm cuya suma de recompensas que se obtiene con la secuencia de acciones a1a2…akb1b2…bm es diferente a la suma de recompensas de la secuencia a1a2…akc1c2…cm.\nNótese que la definición anterior no significa que cualquier acción tiene un impacto en las recompensas (inmediata o posteriormente), pero sí que en cualquier punto siempre hay al menos dos secuencias de acciones diferentes que puede llevar al agente a obtener recompensas acumuladas diferentes para n interacciones. Esto significa que estos entornos pueden tener un agente pegado por un tiempo (en un “agujero”) si no se realizan las acciones buenas, pero existe un camino para salir de ahí o al menos para encontrar recompensas diferentes dentro del agujero. En otras palabras, no existen puntos cielo/infierno ni tienen un comportamiento “observador”, así que en cualquier punto el agente puede esforzarse para incrementar sus recompensas (o impedir que decrezcan).\nSegún las definiciones anteriores, muchos juegos de mesa que conocemos no son entornos sensibles a las recompensas. Por ejemplo, existen posiciones en el juego de las damas donde inevitablemente cualquier movimiento conduce a una distinta forma de perder/ganar (asumiendo cierta habilidad por parte del oponente o usando la solución perfecta dada por [Schaeffer 2007]). Pero también nótese que no es muy difícil modificar la puntuación para hacerla completamente sensible a las recompensas asignándole puntos a la puntuación que dependan de los movimientos y la posición antes de perder (p. ej. perder en 45 movimientos es mejor que perder en 25 movimientos).\nAhora vamos a dar a una definición más refinada de la Inteligencia Universal utilizando los entornos sensibles a las recompensas, las recompensas simétricas, el entorno balanceado y la media de las recompensas:\nPágina 21\nDEFINICIÓN 10. INTELIGENCIA UNIVERSAL (CONJUNTO FINITO DE ENTORNOS BALANCEADOS Y SENSIBLE A LAS RECOMPENSAS, NÚMERO FINITO DE INTERACCIONES, COMPLEJIDAD KTMAX) CON PUNTUACIÓN AJUSTADA.\nϒIV(π, U, m, ni) := ∑ ∈⋅ S ii nV nm jµ π µ )( 1 donde S es un subconjunto finito de m entornos balanceados siendo ambos nr-acciones sensible a las recompensas (con nr =ni) extraído con ),(max 2)( iU nKt U tp µµ −=\n3.6. Un entorno no sesgado y balanceado\nEn esta sección presentamos una clase de entornos apropiada para la evaluación\nsiguiendo las propiedades de la sección anterior."
    }, {
      "heading" : "3.6.1. Clases de entornos Turing-completas",
      "text" : "Definir cualquier clase de entorno y construir un generador de entornos a partir de ella es fácil. De hecho, hay muchos entornos y generadores de juegos, los cuales construyen diferentes campos de juegos siguiendo algunas metareglas básicas (p. ej. [Pell 1994]). Una cuestión diferente es si queremos seleccionar una clase de entorno que sea universal (p. ej. Turing-completo) e imparcial (no particularmente fácil para algunos tipos de agentes y difíciles para otros). El problema es especialmente incómodo ya que no solo estamos hablando sobre un lenguaje que sea capaz de expresar estos entornos, sino un lenguaje que pueda usarse para automáticamente generar dichos entornos. Piénsese, por ejemplo, que podemos generar aleatoriamente programas en cualquier lenguaje de programación, pero la probabilidad de que alguno de estos programas tenga algún sentido es ridícula.\nEl tipo y expresividad de entornos es un problema típico en inteligencia artificial. Por ejemplo, [Weyns, Parunak & Michel 2005] es un estudio de entornos usados en sistemas multiagente. En este estudio, podemos ver muchas formas específicas en las cuales las acciones y las observaciones pueden expresarse.\nRadicalmente opuesto es ir a lo más general posible y utilizar las propias máquinas de Turing. Esta aproximación es demasiado general en muchos sentidos: haciendo un filtro de tal manera que cada computación entre estados sea finita es un problema difícil (más precisamente, indecidible). Pero si restringimos la clase de entorno a una clase de entorno no universal (o más drásticamente a clases de entornos finitas), no solo podemos tener una gran parcialidad sino también podemos tener algunas otras propiedades indeseables.\nAparte de las máquinas de Turing (o variantes) hay muchos otros modelos de computación Turing-completos. De hecho, en [Hernandez-Orallo & Minaya-Collado 1998] y [Hernandez-Orallo 2000a], para medir la habilidad inductiva secuencial, usamos un tipo de máquina de registro.\nPágina 22\nPor ejemplo, los algoritmos de Markov [Markov 1960] son formalismos Turingcompletos que pueden fácilmente usarse para representar entornos (véase una definición de estos algoritmos y su uso para codificar entornos y agentes en [Hernandez-Orallo 2010b]).\nEl problema de utilizar un lenguaje universal como un algoritmo de Markov es que muchos conjuntos de producción no construyen un entorno válido. Pueden producir una secuencia inválida de recompensas, observaciones y acciones, o secuencia alguna, o secuencias muy pequeñas (por lo que el entorno deja de interactuar muy pronto) o no terminan. Adicionalmente, considerando solo los entornos sintácticamente válidos y terminantes, hay otras restricciones impuestas por el marco [Hernandez-Orallo & Dowe 2010]: deben ser entornos sensibles a las recompensas y deben estar balanceados con respecto a los agentes aleatorios. Y finalmente, también hay una certeza de que de este modo es muy improbable generar un entorno que sea social, p. ej. que pueda contener otros agentes con los que interactuar. Como se ha tratado frecuentemente (véase p. ej. [Hernandez-Orallo & Dowe 2010]) la inteligencia de los animales (y consecuentemente de los humanos) debe haber evolucionado en entornos reales llenos de objetos y otros animales.\nNuestra aproximación será diferente. En lugar de generar entornos de máquinas universales incontroladas, definiremos un conjunto controlado, y entonces incluiremos dentro el comportamiento universal."
    }, {
      "heading" : "3.6.2. Acciones, observaciones y el espacio",
      "text" : "Aparte del comportamiento de un entorno, que puede variar desde ser muy simple a muy complejo, debemos primero clarificar la interfaz. ¿Cuántas acciones se van a permitir? ¿Cuántas observaciones diferentes? Está claro que el mínimo número de acciones tienen que ser dos, pero no parece decidirse a priori ningún límite superior. Lo mismo ocurre con las observaciones.\nSi echamos un vistazo a algunos tests de cognición para humanos y animales nohumanos, las acciones pueden ser muy variadas. Para los humanos, puede ser escribiendo una palabra o número siguiendo una secuencia. Para animales, típicamente es más reducido, con un número de botones a presionar pequeño. Las observaciones pueden tener una variedad mucho mayor. Por ejemplo, una secuencia de cuadrados y símbolos, o una secuencia de números o palabras, o incluso imágenes, son típicas en los tests de IQ. Incluso en los tests para animales, podemos tener observaciones dinámicas (rotaciones, movimientos, sonidos…). Típicamente, incluso para entornos discretos, el espacio de observaciones se hace grande por simple combinatoria.\nAntes de meternos en detalles con la interfaz, tenemos que pensar en entornos que puedan contener agentes. Esto no solo sucede en la vida real, sino también es un requisito para la evolución y, por lo tanto, para la inteligencia como la conocemos. La existencia de varios agentes que pueden interactuar requiere de un espacio. El espacio no es necesariamente un espacio físico o virtual, sino un conjunto de reglas comunes que\nPágina 23\ngobiernen lo que los agentes pueden percibir y hacer. En el mundo real, este conjunto de reglas comunes es la física.\nLo bueno de pensar en espacios es que un espacio implica la reducción de las percepciones y acciones posibles. Si definimos un espacio común, tenemos muchas elecciones sobre observaciones y acciones ya adoptadas. Una primera (y común) idea para un espacio es una rejilla 2D. Esta es la elección típica en laberintos y videojuegos 2D. A partir de una rejilla 2D, la observación es una imagen de la rejilla con los objetos y los agentes dentro. Las acciones típicas son los movimientos: izquierda, derecha, arriba y abajo. Alternativamente, por supuesto, podemos usar un espacio 3D, ya que nuestro mundo es 3D.\nEl problema de una rejilla 2D o 3D es que está claramente pensada a favor de los humanos y muchos otros animales que tienen habilidades para orientarse en este tipo de espacios. Otros tipos de animales o personas con discapacidades (p. ej. personas ciegas) podrían tener algunas dificultades en este tipo de espacios.\nFigura 1: Dos espacios. Una rejilla toroidal y un anillo de dos niveles.\nFigura 2: Interfaces posibles para un espacio adimensional. Izquierda: Se muestran todas las celdas.\nDerecha: Solo se muestran las celdas accesibles.\nEn vez de esto proponemos un tipo de espacio más general. Una rejilla 2D es un grafo con una topología muy especial, donde hay conceptos como la dirección, adyacencia, etc. Una generalización es un grafo donde las celdas están libremente conectadas a otras celdas sin ningún patrón particularmente predefinido. La Figura 1 muestra dos espacios. Nótese que la proximidad actual de dos celdas (en términos de flechas entre ellas) generalmente no corresponde con su proximidad en una representación 2D (incluso en estos espacios relativamente regulares).\nPágina 24\nLas observaciones y acciones pueden verse gráficamente, como se puede ver en la parte más a la izquierda de la Figura 2 la cual ilustra dos interfaces posibles. Nótese que las celdas no están distribuidas por su proximidad actual, sino simplemente en una línea horizontal. La celda con el borde más grueso es la celda actual, y las celdas a las que apuntan las flechas son las celdas donde el agente puede moverse. Los agentes y objetos son representados por símbolos diferentes. Dependiendo del agente (p. ej. un humano adulto o un chimpancé), esto puede convertirse en un tipo de interfaz táctil (donde las celdas pueden presionarse) o en uno más robusto (con botones). Para agentes artificiales, realmente da lo mismo.\nNótese que todas las conexiones entre las celdas no son explícitas (no vemos el grafo completo, solo la parte que está conectada a la celda actual). Podemos restringir además la observación a solo la celda actual y las celdas donde llevan las acciones (derecha de la Figura 2). Esto será problemático para algunos agentes (p. ej. niños pequeños y algunos animales) para los cuales lo que no ves no existe. Al final, hay muchas opciones para representar la interfaz y tenemos que ser muy cuidadosos para evitar sesgos."
    }, {
      "heading" : "3.6.3. Definición de la clase de entorno",
      "text" : "Después de la discusión previa, estamos listos para hacer varias elecciones importantes y dar la definición de la clase de entorno. Primero debemos definir el espacio y los objetos, y entonces las observaciones, acciones y recompensas.\nCon na = |A| ≥ 2 representamos el número de acciones, con nc ≥ 2 el número de celdas, y con no el número de objetos/agentes (sin incluir el agente que será evaluado y dos objetos especiales conocidos como Good y Evil)."
    }, {
      "heading" : "Espacio",
      "text" : "El espacio se define como un grafo dirigido etiquetado de nc nodos (o vértices), donde cada nodo representa una celda. Los nodos se numeran, empezando desde 1, por lo que las celdas se referencian como C1, C2,…, Cnc. Desde cada celda salen na flechas (o aristas), cada uno de ellos denota Ci →α Cj, significando que la acción α Є A va desde Ci hasta Cj. Al menos dos flechas han de dirigirse a diferentes celdas. Al menos una de las flechas debe llevar a la misma celda.\nUn camino desde Ci hasta Cm es una secuencia de flechas Ci → Cj, Cj → Ck,…, Cl → Cm. El grafo debe ser completamente conectado, p. ej., para cada par de celdas Ci, Cj existe un camino de Ci a Cj y viceversa.\nDada la definición previa, la topología del espacio puede ser muy variada. Puede incluir una rejilla típica, y también topologías mucho más complejas. En general, el número de acciones na es un factor que influencia mucho más a la topología que el número de celdas nc.\nPágina 25"
    }, {
      "heading" : "Objetos",
      "text" : "Las celdas pueden contener objetos de un conjunto predefinido de objetos Ω, donde nω = |Ω|. Los objetos pueden realizar acciones siguiendo las reglas del espacio, pero aparte de estas reglas, pueden tener cualquier comportamiento (determinista o no). Los objetos pueden ser reactivos a sus observaciones. Los objetos realizan una y solo una acción en cada interacción del entorno (excepto los agentes especiales Good y Evil, que pueden realizar varias acciones de golpe).\nAparte del agente evaluable π, como ya hemos mencionado, existen dos objetos especiales, llamados Good y Evil, representados por ⊕ y ⊖ respectivamente, los cuales pueden ser vistos por el agente evaluable π. Sin embargo, son indistinguibles para el resto de objetos (incluyéndose a sí mismos), por lo que para ellos en sus observaciones se representan con el mismo símbolo ⊙.\nGood y Evil deben tener el mismo comportamiento. Esto no quiere decir que realicen los mismos movimientos, sino que tengan la misma lógica o programa tras de ellos. Nótese que Good y Evil se ven mutuamente de la misma forma (e igualmente el resto de objetos excepto π).\nLos objetos pueden compartir una misma celda, excepto Good y Evil, que no pueden estar en la misma celda. Si su comportamiento les conduce a la misma celda, entonces uno (elegido aleatoriamente con la misma probabilidad) realiza el movimiento y el otro se queda en su celda original. Los objetos ⊕ y ⊖ pueden realizar varias acciones en una única interacción, p. ej. pueden realizar cualquier secuencia de acciones (no-vacía). Una razón para esto es evitar que Good sea seguido por el agente de una manera fácil y óptima para conseguir recompensas positivas en la mayoría de los entornos. Los objetos son colocados aleatoriamente en las celdas en la inicialización del entorno.\nAunque Good y Evil tengan el mismo comportamiento, la celda inicial la cual es asignada (aleatoriamente) a cada uno de ellos debería determinar una situación donde su comportamiento es finalmente muy asimétrico desde el punto de vista del agente π. Por ejemplo, considera el siguiente ejemplo:\nFigura 3: Un espacio anillo donde el estado inicial puede ser crítico.\nPágina 26\nEjemplo Imagina el espacio visto en la Figura 3 y considera el comportamiento de ⊕ y ⊖ de forma que realizan la acción r si y solo si el agente π comparte una celda con cualquiera de ellos. De lo contrario, realizan la acción l.\nDesde el estado representado en la Figura 3, está claro que la situación relativa de los tres objetos solo puede ser como se ha visto (π, ⊖, ⊕) o cuando el agente comparte una celda con ⊖ seguido por ⊕ a la derecha. Así, en este entorno, es imposible para π compartir celda con ⊕, mientras que si que es posible con ⊖, aunque ⊕ y ⊖ tienen el mismo comportamiento. El estado inicial es crítico.\nSiguiendo el ejemplo anterior, podemos definir una “cláusula cíclica” que funciona como sigue. Dado un entorno con na acciones, y nc celdas, calculamos un número aleatorio n entre 1 y nc ^ (na) (uniformemente), y entonces después de n interacciones, las posiciones de ⊕ y ⊖ son intercambiadas. Entonces, calculamos nuevamente otro número aleatorio (de la misma forma) y cambiamos de nuevo las posiciones. Y así sucesivamente. La razón de ser al azar es para evitar que el ciclo coincida con ningún ciclo o patrón que esté presente en el comportamiento de los agentes. El objetivo de esta cláusula es evitar la relevancia del estado inicial.\nFinalmente, las primeras interacciones con el entorno pueden tener lo que llamamos “basura inicial” [Hernandez-Orallo 2009]. Considera, p. ej., un comportamiento para ⊕ y ⊖ que sea “empezar haciendo a1a2a0a1a1a1a0a2a2a0a1a1a0a0 y entonces hacer a0a1 siempre”. La primera parte de su comportamiento es completamente aleatoria y completamente no-discriminativa. Solo cuando se llega al patrón (la segunda parte del comportamiento), tiene sentido empezar a evaluar el comportamiento del agente. Consecuentemente, sugerimos dejar a un agente jugar durante n interacciones para superar la mayor parte de la basura inicial (si existe) y entonces empezar la evaluación. El valor para n puede calcularse igual que el valor usado anteriormente para la “cláusula cíclica”."
    }, {
      "heading" : "Observaciones y acciones",
      "text" : "Una observación es una secuencia de contenido de celdas. Cada elemento en la secuencia muestra la presencia o ausencia de cada objeto, incluyendo al agente evaluable. Adicionalmente, cada celda que es alcanzable por una acción incluye la información de la acción que lleva a la celda.\nEn particular, el contenido de cada celda es una secuencia de objetos, donde π debe aparecer antes de ⊕ y ⊖, y del resto de objetos siguiendo sus índices. Después siguen las acciones posibles, también ordenadas por su índice, y denotadas por Ai en lugar de αi. Cada secuencia contenida en la celda está separada por el símbolo ‘:’.\nPor ejemplo, si tenemos un entorno con na = 2, nc = 4 y no = 2 entonces la siguiente secuencia πω2A1 : ⊖ : ⊕ω1A2 : es una posible observación vista por el agente evaluable π. El significado de esta secuencia es que en la celda 1 tenemos al agente evaluable y al objeto ω2, en la celda 2 tenemos a Evil, en la celda 3 tenemos a Good y al objeto ω1 y la celda 4 está vacía. Adicionalmente, vemos que podemos quedarnos en la celda 1 con la acción α1 y podemos ir a la celda 3 con la acción α2. La misma observación sería vista como πω2A1 : ⊙ : ⊙ω1A2 : por el resto de objetos (incluyendo a Good y Evil).\nPágina 27"
    }, {
      "heading" : "Recompensas",
      "text" : "Trabajaremos con la noción de “rastro” y la noción de “recompensa de celda” que denotamos como r(Ci). Inicialmente, r(Ci) = 0 para todo i. Las recompensas de las celdas se actualizan con los movimientos de ⊕ y ⊖. En cada interacción, ponemos ri⊕ a la recompensa de la celda donde esté ⊕ y -ri⊖ a la recompensa de la celda donde esté ⊖. En cada interacción, todas las demás recompensas de las celdas se dividen entre 2. Por lo que, intuitivamente podemos ver que ⊕ va dejando un rastro positivo y ⊖ va dejando un rastro negativo. El agente π se come la recompensa que encuentra en la celda que ocupa, actualizando la recompensa acumulada p = p + r(Ci). Con se come se refiere a que justo después de obtener la recompensa, la recompensa de la celda se establece a 0.\nLos objetos ⊕ y ⊖ dan una recompensa de 0 si comparten una celda con π. Los valores de ri⊕ y -ri⊖ que dejan ⊕ y ⊖ en el resto de las ocasiones son también parte del comportamiento de ⊕ y ⊖ (lo cual es lo mismo, pero esto no significa que ri⊕ = -ri⊖, para todo i). Solo una restricción es impuesta en cómo estos valores pueden ser generados, ∀i : 0 < ri⊕ ≤ ½ y 0 < ri⊖ ≤ ½. Finalmente, nótese que las recompensas y los rastros no son parte de las observaciones, por lo que no se pueden (directamente) observar por un objeto (incluyendo a π).\nA fin de mantener las recompensas acumuladas entre -1 y 1 y prevenir que π se duerma en los laureles, al final de la evaluación, dividimos la recompensa acumulada por el número final de interacciones, con un ajuste, como se ve en [Hernandez-Orallo 2010a].\nUsaremos el término Λ para esta clase de entorno."
    }, {
      "heading" : "Ejemplos",
      "text" : "Dada la configuración de la clase de entorno dada arriba, veamos algunos ejemplos\ndentro de Λ. Empecemos con el entorno más simple dentro de la clase.\nEjemplo Considera na = 2 = |{α1, α2}|, nc = 2 y no = 0. El espacio está necesariamente compuesto de dos celdas y dos flechas, α1 que va a la misma celda y α2 que se dirige a la otra celda. El comportamiento más simple para ⊕ y ⊖ es ejecutar siempre α1 o α2, y teniendo ri⊕ = ri⊖ = ½ para siempre. Inicialmente, Good y Evil son situados aleatoriamente en las dos celdas (sin poder situarse en la misma celda). Ya que el entorno es simétrico, considera que ⊕ está en la celda 1 y ⊖ está en la celda 2. En el caso de que el comportamiento sea α1 (recuerda que es el mismo para ambos ⊕ y ⊖), entonces ambos Good y Evil se quedarán para siempre en su celda. La recompensa será entonces ½ si el agente empieza en la posición donde está ⊖ y se mueve al lugar donde está ⊕, entonces recibirá recompensas de 0 ya que se mantiene donde está ⊕. Si el agente empieza donde está ⊕ entonces el movimiento a la celda donde está ⊖ recibirá -½ y pronto intentará volver donde está ⊕, recibiendo ½. Aunque la media convergerá a 0, es conveniente mantenerse donde esté ⊕. En el caso de que el comportamiento de ⊕ y ⊖ sea α2, entonces ambos Good y Evil intercambiarán siempre las celdas. Consecuentemente, la mejor estrategia para el agente será moverse a la celda donde esté ⊕, obteniendo ½ de media.\nPágina 28\nOtros entornos más complejos pueden verse en [Hernandez-Orallo 2010b]. De hecho, con un poco de paciencia, cualquier tipo de juego o tarea que conocemos puede ser simulado utilizando esta clase de entorno, como vemos con el tres en raya en [Hernandez-Orallo 2010b]."
    }, {
      "heading" : "3.6.4. Propiedades",
      "text" : "En esta sección, analizamos si la clase de entorno anterior es sensible a las recompensas (el agente puede realizar acciones de forma que pueden afectar a las recompensas), y también es balanceado (un agente aleatorio tendrá una recompensa acumulada esperada igual a 0). Para la definición formal de estas propiedades, véase [Hernandez-Orallo & Dowe 2010]. Para las pruebas de las siguientes proposiciones véase [Hernandez-Orallo 2010b].\nProposición 0.1 Λ es sensible a las recompensas.\nProposición 0.2 Λ está balanceado.\nLas proposiciones previas muestran que los entornos siguen los requisitos de un test\nanytime [Hernandez-Orallo & Dowe 2010]."
    }, {
      "heading" : "3.6.5. Codificación y generación del entorno",
      "text" : "Finalmente, para construir un test, necesitamos generar los entornos automáticamente y calcular su complejidad. Para generar un entorno, necesitamos generar el espacio (constantes y topología) y el comportamiento de todos los objetos (excepto π). La primera idea puede ser usar una gramática generativa, como de costumbre. Sin embargo, podemos elegir una gramática generativa que no sea universal pero que solo genere espacios válidos. Esto es un error. Con una gramática generativa nouniversal podría ocurrir que la complejidad de un espacio con 100 celdas idénticas pueda ser 100 veces la complejidad de un espacio con una celda. Pero esto va completamente en contra de la complejidad de Kolmogorov y el ordenamiento de los entornos que estamos buscando. En lugar de esto, usaremos gramáticas generativas universales, en concreto algoritmos de Markov."
    }, {
      "heading" : "Codificando y generando espacios",
      "text" : "Primero codificamos el número de acciones na utilizando cualquier codificación estándar para los número naturales (p. ej. la función log* en [Rissanen 1983] [Wallace 2005]). El grafo del espacio está definido por un algoritmo de Markov sin restricciones en su definición, pero con la siguiente post-condición. El espacio generado tiene que definirse por una cadena como sigue (utilizamos una notación en lenguaje regular)\nPágina 29\n[{+|-}a1 + ][{+|-}a2 + ]…[{+|-}ana + ] para cada celda. Esto significa que enumeramos todas las celdas, y la información en cada celda se compone de las flechas salientes (más precisamente a qué celdas llega por el número de veces que la acción aparece). Utilizamos un índice toroidal donde, p. ej. 1 – 2 = nc – 1, por lo que podemos usar referencias positivas o negativas (este es el significado de +|-). Cuando nos referimos a la misma celda se omite la acción.\nEl espacio de la Figura 3 se codifica con +r+r+r+r+r y un algoritmo de Markov que lo\ngenera es:\n1. S → +r 2. → SSSSSΩ 3. Ω →∙\nCon la descripción y definiciones anteriores no es difícil ver como codificar (inequívocamente) cualquier entorno válido. Sin embargo, si queremos generar entornos usando algoritmos de Markov, la cosa es mucho más difícil, ya que una generación aleatoria de las reglas de Markov puede generar cadenas que no representen ningún entorno. Aunque las optimizaciones pueden existir, ya que no queremos perder generalidad y manejar la medición de la complejidad, aquí proponemos dejar al algoritmo ejecutarse un número limitado de iteraciones y entonces pasarle un postprocesamiento (eliminar + repetidos, símbolos inválidos, etc.) y entonces comprobar si la cadena resultante es un entorno válido (sintáctica y semánticamente).\nPara el cálculo de la complejidad, cualquier aproximación de la longitud del algoritmo de Markov (p. ej. el número de símbolos del algoritmo entero) sería válido como una aproximación a su complejidad."
    }, {
      "heading" : "Codificando y generando objetos",
      "text" : "Primero codificamos el número de objetos nω, utilizando cualquier codificación para los números naturales como se menciona arriba. Después tenemos que codificar su celda inicial, codificando también no + 3 números naturales delimitados por nc (no necesariamente diferentes, consecuentemente log nc cada uno). En el caso de que ⊕ y ⊖ estén en la misma celda, una nueva celda es generada aleatoriamente y asignada a ⊖.\nEl comportamiento (que debe ser universal) es generado por otro algoritmo de Markov como sigue. La cadena de entrada del algoritmo es la observación, codificada como hemos visto en secciones anteriores. Solo con la observación actual los objetos no tendrían acceso a la memoria y estarían muy limitados, por lo que dos símbolos especiales ∆ y ∇ significan poner la cadena actual en memoria o recuperar la última cadena insertada a la memoria respectivamente. Una vez el algoritmo de Markov es ejecutado, todos los símbolos que no están en el conjunto de acciones A son eliminados de la cadena generada. Entonces, para todos los objetos (excepto para ⊕ y ⊖), la acción más a la derecha en la cadena es la acción a realizar. Para ⊕ y ⊖ se utiliza toda la cadena.\nPágina 30\nVeamos un ejemplo del comportamiento para ⊕ y ⊖ (recordando que son iguales)\npara el espacio visto en la Figura 3 y sin considerar otros objetos:\n1. π[⊙]L →∙ rrr 2. →∙ l\nLa notación [] representa una parte opcional. Consecuentemente, el algoritmo previo significa realizar siempre la acción l a menos que π se encuentre inmediatamente a la izquierda. En este caso, realizamos la acción r tres veces. Por ejemplo, si la observación en la Figura 3 para ⊖ se representa por : πL : ⊙ : R⊙ :, entonces la aplicación al algoritmo previo en esta observación proporciona como resultado : rrr⊙ : R⊙ : y después del postprocesamiento (todos los símbolos que no están en el conjunto de acciones A son eliminados) tendremos rrr.\nPara el cálculo de la complejidad, alguna aproximación de la longitud del algoritmo (p.\nej. el número de símbolos del algoritmo entero) sería válido como su complejidad.\nEs importante remarcar que la complejidad de un conjunto de objetos no es la suma de las complejidades de los objetos. Una opción es generar un único algoritmo de Markov para todos los objetos, pero en este caso llegaríamos a la solución general (pero impracticable) de la que hemos hablado al principio. Alternativamente, sugerimos utilizar un bit extra en cada regla y entonces tenemos una forma de referirnos a otras reglas en otros objetos. Consecuentemente, si 100 objetos comparten muchas reglas, la complejidad de todo el conjunto será mucho más pequeña que la suma de las partes.\nPágina 31"
    }, {
      "heading" : "4. Implementación aproximada del marco",
      "text" : "conceptual\nYa que el marco conceptual es una idea general de cómo debe construirse el sistema, para comenzar a construirlo hemos decidido implementar una aproximación de este marco conceptual anteriormente descrito. Hemos implementado las características y propiedades más generales definidas en el apartado anterior y se ha optado por realizar una simplificación sobre otros aspectos más concretos de implementación sin por ello descuidar las propiedades que debe tener el sistema. La intención es poder empezar a evaluar el marco conceptual con este prototipo, para tener una primera estimación de su viabilidad.\nPor una parte hemos mantenido la estructura principal: manteniendo a los agentes, entornos y espacios y las interacciones entre ellos. Por otro lado hemos simplificado otros aspectos como la construcción de las observaciones, la codificación y generación de los espacios, el comportamiento de los agentes y algunos aspectos de las interacciones entre los agentes.\nEn esta sección se describe cómo se ha estructurado el programa. En concreto veremos un diagrama de clases, donde queda representado a grandes rasgos la estructura interna del sistema, las principales diferencias entre el marco conceptual antes descrito y la implementación realizada, una descripción de las clases más importantes del sistema, como se han codificado y descrito los espacios y la interfaz de usuario construida para el entorno Λ.\n4.1. Diagrama de clases\nPara facilitar el entendimiento del diagrama de clases se han suprimido las funciones\nde las clases, ya que, de lo contrario, resultaba complicado entender su estructura.\nPágina 32\nEn la siguiente imagen podemos ver el diagrama de clases simplificado del sistema.\n4.2. Principales diferencias entre el marco conceptual y la implementación realizada"
    }, {
      "heading" : "4.2.1. Observaciones",
      "text" : "Según el marco conceptual visto anteriormente, a los agentes se les proporcionan las observaciones como una tira de caracteres tal y como podemos ver en el apartado 3.6.3. Sin embargo, para esta primera implementación, hemos optado por realizar una copia de la estructura del espacio que lo representa dentro del programa y facilitarles a todos los agentes esta misma copia. De este modo se les facilita a todos los agentes la observación del entorno dándoles a todos una misma visión del entorno.\nPágina 33"
    }, {
      "heading" : "4.2.2. Objetos y agentes",
      "text" : "Hemos realizado una distinción mayor entre los objetos y los agentes. En esta implementación hemos optado por dividir estos dos tipos de modo que los objetos sean objetos inanimados mientras que los agentes se podrán mover a través del espacio."
    }, {
      "heading" : "4.2.3. Comportamiento de los agentes",
      "text" : "De momento no hemos codificado ningún lenguaje de especificación para la generación del comportamiento de los agentes. A los agentes se les indicará de forma manual cual será su comportamiento, siendo éste una decisión aleatoria, un patrón de movimientos a seguir, etc."
    }, {
      "heading" : "4.2.4. Interacciones entre agentes",
      "text" : "Por un lado los agentes generadores de recompensas (Good y Evil) siempre dejan caer la misma recompensa pasen por la celda que pasen y compartan o no celda con cualquier otro agente. Sin embargo hemos optado por dividir las recompensas que los agentes recogen de las celdas entre todos los agentes que se encuentren en ese momento en la celda, de modo que si en una celda que contiene una recompensa de +1 se encuentran 4 agentes dentro de la celda, cada agente recibirá +0.25 de recompensa.\n4.3. Descripción de las clases del sistema\nEn las siguientes subsecciones veremos la descripción de las clases implementadas en\nel sistema."
    }, {
      "heading" : "4.3.1. Clases para representar los agentes y objetos",
      "text" : "4.3.1.1. Agente\nPara representar a las entidades que interactúan dentro del sistema se ha desarrollado la clase Agent. Estas entidades representan tanto a las personas que interaccionan con el sistema, a programas o máquinas que pueden interactuar automáticamente con éste, como a entidades que forman parte del sistema y, por lo tanto, son controladas directamente por éste.\nAl iniciar la sesión cada agente se sitúa aleatoriamente en una celda y, en cada interacción con el sistema, éste se puede mover a las celdas adyacentes o puede decidir realizar una acción que le mantiene en la misma celda. De este modo los agentes tienen la libertad de moverse libremente a través del espacio donde realizan la sesión.\nPágina 34\nDebido a que existen varios tipos de agentes que pueden interactuar dentro del sistema, la clase Agent se ha especializado en varias clases hijas encargadas de proporcionar una funcionalidad especializada para cada tipo de agente.\nA continuación podemos ver una tabla con los atributos y funciones de la clase.\nAtributos Descripción\nEnvironment Entorno en el que está subscrito el agente\nName Nombre que identifica al agente\nActions Conjunto de acciones que puede realizar\nLocation Celda en la que se encuentra\nNObservationsSaved Número de observaciones que es capaz de recordar\nInteractionHistory Historial de interacciones realizadas con el entorno\nFunciones Descripción\nSetLocation(NewCell) Coloca al agente en la nueva celda\nAct() Almacena y devuelve la acción realizada y almacena\nel tiempo tardado en realizarla\nReward(Reward) Almacena la recompensa y termina la interacción\nactual\nObservation(Observation) Comienza una nueva interacción y almacena la\nobservación\nAction() Devuelve la acción que realiza durante la interacción\ncon el entorno\n4.3.1.2. Agente Evaluable (Subclase de Agente)\nPara representar a los agentes que se desea que el sistema evalúe se ha creado la clase EvaluableAgent. Los agentes que se instancien bajo esta clase son los que el sistema evaluará.\nA continuación podemos ver una tabla con las funciones de la clase.\nFunciones Descripción\nGetTotalReward() Calcula y devuelve la recompensa global del agente\nPágina 35\n4.3.1.3. Agentes Good & Evil (Subclase de Agente)\nEn todo entorno existen dos agentes llamados Good y Evil. Estos agentes son los encargados de proporcionar las recompensas en el espacio. Al comenzar cada interacción, estos agentes dejan caer recompensas en la celda en la que se encuentren en ese momento, de forma que van dejando un rastro de recompensas en el espacio. Estas recompensas son valores numéricos entre -1 y 1 y serán el objetivo de los agentes evaluables, los cuales tratarán de conseguir la mayor recompensa posible durante la sesión. Así pues, si la instancia de la clase representa al agente Good, éste deja caer recompensas positivas, mientras que el agente Evil deja caer recompensas negativas. Al finalizar cada interacción las recompensas que se encuentren por todo el entorno se dividen entre 2, disminuyendo así progresivamente su valor.\nPor norma general estos agentes tratan de moverse a una celda adyacente. Como caso excepcional, ambos agentes no pueden encontrarse simultáneamente en la misma celda, por lo que si se diera la situación de que ambos agentes tratasen de moverse a la misma celda al mismo tiempo, uno de ellos no podrá realizar su última acción, quedándose así en la celda en la que se encontraba en la interacción anterior. De este modo se consigue que ambos agentes no se encuentren nunca en la misma celda.\nA continuación podemos ver una tabla con los atributos y funciones de la clase.\nAtributos Descripción\nRandomMovements Indica si el agente se moverá de forma aleatoria o,\npor el contrario, seguirá un patrón de movimientos\nMovements Patrón que contiene la secuencia de movimientos\nque realizará indefinidamente el agente\nFunciones Descripción\nAction() Devuelve la acción a realizar tanto si el agente actúa\nde forma aleatoria o siguiendo un patrón\n4.3.1.4. Agente Humano (Subclase de Agente Evaluable)\nDentro de los agentes evaluables se encuentra HumanAgent. Esta clase permite al usuario interactuar con el sistema. En cada interacción, el agente puede elegir de entre las acciones posibles, qué acción realizar, teniendo también la opción de permanecer en la misma celda y, por lo tanto, no moverse en esa interacción.\nPágina 36\nA continuación podemos ver una tabla con las funciones de la clase.\nFunciones Descripción\nAction() Espera a recibir la acción del usuario y la devuelve\n4.3.1.5. Agente Aleatorio (Subclase de Agente Evaluable)\nDentro de los agentes evaluables también se encuentra RandomAgent. Este agente es controlado por el sistema y representa a un agente que realiza acciones dentro del espacio de forma completamente aleatoria, eligiendo en cada interacción una acción cualquiera de entre todas las posibles dentro del rango de acciones permitidas.\nPara controlar el rango de tiempo que tardará un agente aleatorio en realizar una acción, se le especifica el tiempo mínimo y máximo del que dispondrá para realizar dicha acción. Este tiempo será “virtual”, de modo que el agente realmente no tardará este tiempo en realizar cada acción.\nA continuación podemos ver una tabla con los atributos y funciones de la clase.\nAtributos Descripción\nMinimumTime Indica el tiempo mínimo que tardará en realizar un\nmovimiento\nMaximumTime Indica el tiempo máximo que tardará en realizar un\nmovimiento\nFunciones Descripción\nAction() Devuelve la acción a realizar elegida aleatoriamente\n4.3.1.6. Agente Observador (Subclase de Agente Evaluable)\nAl igual que el agente aleatorio, el ObserverAgent está controlado por el sistema. A diferencia del agente aleatorio, este agente puede mirar las celdas que tiene a su alrededor para decidir a cuál de ellas moverse. Para ello comprueba si están los agentes Good o Evil en alguna de estas celdas, en el caso de encontrar al agente Good se moverá a la celda donde éste se encuentre, de lo contrario, se moverá a cualquier otra celda adyacente siempre y cuando no se encuentre el agente Evil en esa celda.\nPágina 37\nA continuación podemos ver una tabla con los atributos y funciones de la clase.\nAtributos Descripción\nMinimumTime Indica el tiempo mínimo que tardará en realizar un\nmovimiento\nMaximumTime Indica el tiempo máximo que tardará en realizar un\nmovimiento\nGoodAgent Referencia al agente Good dentro del entorno actual\nEvilAgent Referencia al agente Evil dentro del entorno actual\nFunciones Descripción\nAction() Devuelve la acción a realizar mirando las celdas\nadyacentes\n4.3.1.7. Objeto\nLos objetos (Objeto) representan entidades inanimadas, las cuales, al igual que los agentes, se encuentran en todo momento en una celda, con la salvedad de que estos objetos no pueden moverse de la celda en la que se encuentren, permaneciendo así en la misma celda durante el transcurso de la sesión.\nEstos objetos sirven para enriquecer la definición del entorno, de modo que, por ejemplo, los agentes pueden recordar haber pasado por una celda al ver que en ésta se encuentra un objeto que ya vio anteriormente. Así el agente tiene más información de la zona del espacio en la que se encuentra y podrá decidir mejor que acción realizar.\nA continuación podemos ver una tabla con los atributos y funciones de la clase.\nAtributos Descripción\nName Nombre que identifica al objeto\nLocation Celda en la que se encuentra\nFunciones Descripción\nSetLocation(NewCell) Coloca al objeto en la nueva celda\nPágina 38"
    }, {
      "heading" : "4.3.2. Clases para representar el espacio",
      "text" : "4.3.2.1. Celda\nUna celda (Cell) representa una ubicación donde se pueden situar elementos durante el transcurso de las sesiones. Dentro de cada celda se pueden situar tanto objetos como agentes. Estos agentes pueden ir cambiando de celda durante cada interacción, mientras que los objetos permanecen inmóviles en su celda durante el transcurro de la sesión. Además, cada celda contiene la recompensa que deja caer los agentes Good y Evil si alguno de estos pasa en algún momento por ésta, e irá disminuyendo su valor dividiéndose entre 2 en cada iteración.\nA continuación podemos ver una tabla con los atributos y funciones de la clase.\nAtributos Descripción\nNumber Número que identifica la celda del conjunto de\nceldas\nObjects Lista de objetos que se encuentran situados en la\ncelda\nAgents Lista de agentes que se encuentran situados en la\ncelda\nReward Recompensa que queda en la celda\nFunciones Descripción\nClone() Crea una copia de la celda actual\nGetActions() Devuelve el conjunto de acciones que se pueden\nrealizar desde la celda\nMove(Action) Devuelve la celda a la que se accede si se realizase la\nacción Action\n4.3.2.2. Conexión\nAl igual que en la teoría de grafos, donde para pasar de un vértice a otro contiguo se debe atravesar una arista, para moverse de una celda a otra contigua se debe pasar a través de una conexión (Connection). Cada conexión representa la acción que se debe gastar desde la celda que la contiene para poder llegar a la celda contigua. De modo que al encontrarse en una celda donde exista una conexión representando a una acción, al utilizar esta acción se llegará a la celda con la que conecte esta conexión.\nPágina 39\nA continuación podemos ver una tabla con los atributos y funciones de la clase.\nAtributos Descripción\nAction Acción que el agente debe realizar para utilizar la\nconexión\nFunciones Descripción\nGetStartCell() Devuelve la celda que contiene a la conexión\nGetEndCell() Devuelve la celda a la que se llega tras atravesar la\nconexión\n4.3.2.3. Espacio\nToda sesión se realiza dentro de un espacio (Space), donde los agentes podrán moverse libremente. Este espacio se define como un grafo dirigido y, por lo tanto, hereda las características de estos grafos, conteniendo así una lista de vértices que representan a las celdas contenidas en el espacio, y una lista de aristas las cuales representan las conexiones entre las celdas.\nA continuación podemos ver una tabla con las funciones de la clase.\nFunciones Descripción\nGetNumberOfCells() Devuelve el número de celdas que existen en el\nespacio\nLocateObject(Object, Number)\nColoca un objeto en la celda con número Number\nLocateAgent(Agent, Number)\nMueve un agente a la celda con número Number"
    }, {
      "heading" : "4.3.3. Clases para representar los entornos",
      "text" : "4.3.3.1. Entorno\nEn los entornos (Environment) se engloban todos los elementos necesarios para poder realizar las sesiones. Esta clase tiene asociados unos agentes y sus acciones y recompensas, determina el agente que se evaluará, qué acciones podrán realizar los agentes, etc. y se encarga de realizar la secuencia de acciones e interacciones\nPágina 40\nA continuación podemos ver una tabla con los atributos y funciones de la clase.\nAtributos Descripción\nActions Acciones permitidas\nMinReward Mínima recompensa que se podrá devolver a un\nagente\nMaxReward Máxima recompensa que se podrá devolver a un\nagente\nAgents Lista de agentes que interactúan\nObjects 1 Lista de objetos definidos en el espacio\nFunciones Descripción\nSetEvaluableAgent(Agent) Indica qué agente va a ser evaluado\nAddAgent(Agent) Añade un agente a la lista de agentes\nInteract (Number of Interactions) Realiza una sesión durante el número de interacciones definido\nInteractWithTime(Time) Realiza una sesión durante el tiempo definido\n4.3.3.2. Entorno_L (Subclase de Entorno)\nUna de las principales clases del sistema es la clase Environment_L que describe un tipo de entorno adecuado para realizar tests de inteligencia como se describe en el capitulo 3 (sección 3.5). En esta clase se puede definir, además de lo que permite su clase padre, cómo será el espacio donde interactuarán los agentes. Además, integra automáticamente a los agentes Good y Evil dentro del entorno.\nPara conseguir que la evaluación sea no sesgada para un agente aleatorio (su esperanza sea 0) existe la posibilidad de relocalizar la posición de los agentes Good y Evil cada vez que transcurra cierto número de interacciones.\n1 Esta funcionalidad no se desarrolla en este PFC.\nPágina 41\nA continuación podemos ver una tabla con los atributos y funciones de la clase.\nAtributos Descripción\nSpace Espacio donde se realiza la sesión\nSpaceDescription Descripción textual del espacio\nGoodAgent Agente Good presente en la sesión\nEvilAgent Agente Evil presente en la sesión\nFunciones Descripción\nInteract (Number of Interactions) Realiza la sesión durante el número de interacciones definido\nInteract (Number of Interactions, Number of Interactions to relocate) Realiza la sesión durante el número de interacciones definido y relocaliza a los agentes Good y Evil cada número de interacciones para relocalizar\nInteractWithTime(Time) Realiza la sesión durante el tiempo definido\nInteractWithTime(Time, Number of Interactions to relocate) Realiza la sesión durante el tiempo definido y relocaliza a los agentes Good y Evil cada número de interacciones para relocalizar\nGenerateSpace Genera aleatoriamente el espacio donde se realiza la\nsesión\nInterpretSpace (Description)\nInterpreta y construye el espacio a partir de su descripción\n4.3.3.3. Realización de una sesión de evaluación\n4.3.3.3.1. Preparación del entorno\nAl iniciar una sesión, se debe especificar en el entorno cuál será el agente que se desea\nevaluar y cómo será el espacio en el que realizará la sesión.\nAl construir el entorno se crean automáticamente los agentes Good y Evil y se añaden\na la lista de agentes que el entorno va a manejar.\nAntes de comenzar la interacción con los agentes, éstos deben suscribirse al entorno para que puedan interactuar con éste. Sin embargo, solamente uno podrá ser el agente a evaluar, debiendo indicarlo antes de comenzar la sesión.\nPágina 42\n4.3.3.3.2. Descripción del espacio\nPara describir cómo será el espacio donde se realizará la sesión, existen dos métodos\npara definir la distribución de las celdas y las conexiones entre estas:\n• Dejar que el entorno genere aleatoriamente el espacio obteniendo así una descripción del entorno, para posteriormente interpretarlo y construirlo.\no Para ello se ha diseñado un mecanismo en donde, para cada celda, se van generando las acciones que se pueden realizar y con qué celda se conecta a\ntravés de dicha acción. De este modo conseguimos un espacio en donde todas las celdas se comunican con las demás celdas a través de las acciones.\n• Proporcionar manualmente la descripción de cómo debe ser el espacio y construirlo en función de ésta.\no Otro mecanismo para definir el espacio es la introducción manual de la representación del espacio. La representación usada para construir el\nespacio utilizando este mecanismo es la misma que los espacios creados a través del mecanismo anterior.\nNo todos los espacios generados son válidos para las sesiones que se desean realizar. Por ejemplo, un espacio en el que no se pueda acceder de ninguna forma a una celda no será válido para la evaluación de la sesión. Para que un espacio sea válido, todas las celdas deberán estar conectadas entre sí, sin dejar ninguna celda aislada del resto. Es decir, como se vio en la sección 3.5 el espacio debe ser un grafo completamente conectado.\nEn esta implementación se le facilita al usuario unas funciones en donde podrá decidir si desea generar automáticamente un espacio conectado, fuertemente conectado o si, por el contrario, desea crearlo siguiendo la descripción que él proporciona quedando bajo su responsabilidad que el espacio esté o no balanceado. En el caso de que decida generar automáticamente el espacio, el sistema se encargará de generar un espacio y comprobará que sea conectado (o fuertemente conectado, dependiendo de cómo quiere el usuario que sea el espacio), en caso de que no lo sea volverá a generar automáticamente otro nuevo espacio hasta generar uno que cumpla con la conectividad requerida por el usuario.\n4.3.3.3.3. Comienzo de la sesión\nUna vez que se inicia la sesión, el sistema prepara el entorno para poder comenzar.\n• En primer lugar se sitúa cada agente en una celda elegida aleatoriamente. • Hay que tener en cuenta que los agentes Good y Evil no pueden encontrarse en\nningún momento en la misma celda, por lo que, en el caso de que al colocarlos inicialmente se encuentren en la misma celda, se deben recolocar de nuevo hasta que acaben en celdas distintas.\nPágina 43\n• Finalmente se les asocia una recompensa a todas las celdas de 0, indicando así que todas las celdas tienen inicialmente una recompensa nula.\n4.3.3.3.4. Bucle principal\nTras tener preparado el entorno, el sistema comienza las interacciones con los\nagentes, siguiendo estos pasos:\n• Si en un principio se quería que los agentes Good y Evil se resituasen transcurridos un cierto número de interacciones y ha llegado el momento, se procede a su\nrelocalización.\n• Inicialmente los agentes Good y Evil dejan caer sus respectivas recompensas en la celda en la que se encuentran, dejando caer el agente Good una recompensa\npositiva y el agente Evil una recompensa negativa.\n• Posteriormente se crea una copia del espacio tal y como se encuentra en ese preciso instante, el cual será el que se les mande a los agentes como la\nobservación del espacio.\n• A continuación y para cada agente: o Se entrega la recompensa de la última interacción que realizaron. En caso de\nser la primera interacción se le da al agente una recompensa inicial de 0.\no Se manda la observación actual del entorno. o Cada agente proporciona la acción que desea realizar en la iteración actual.\n• Una vez que todos los agentes han interactuado en la iteración actual, se actualiza el estado del entorno realizando simultáneamente las acciones de todos los\nagentes.\n• Ya que los agentes Good y Evil no deben poder encontrarse en la misma celda, se comprueba si tras realizar el último movimiento ambos se encuentran\nsimultáneamente en la misma celda. Si ambos se encontrasen en la misma se procede de la siguiente manera para resolver el conflicto:\no Si el agente Good no se movió en esta interacción, se devuelve al agente Evil a la celda en la que se encontraba. o Análogamente a la situación anterior, si el agente Evil no se movió se devuelve al agente Good a la celda en la que se encontraba. o Si ambos agentes se movieron durante la interacción, se decide aleatoriamente cual de los dos agentes no se mueve en esta interacción y es\ndevuelto a la celda en la que se encontraba.\n• Una vez que todos los agentes han sido colocados, se les almacena, para su posterior entrega en la siguiente iteración, la recompensa de la celda a la que se\nmovieron. Dada la situación de que varios agentes acaben en la misma celda, la recompensa que esté en ésta se divide entre el número de agentes que se encuentren en dicha celda.\n• Como último paso del bucle se actualizan las recompensas de todas las celdas, dividiendo todas entre 2 y colocando una recompensa de 0 en las celdas donde se\nencuentre algún agente.\nPágina 44\nEn la sección A1.1 podemos ver el código fuente del bucle principal escrito en JAVA.\n4.3.3.3.5. Finalización de la sesión\n• Finalmente, cuando se ha completado el número de interacciones o el tiempo disponible para realizar la sesión, el sistema la da por terminada y muestra el\nresultado que ha obtenido el agente que se está evaluando, obteniendo así la medida de rendimiento o inteligencia que ha mostrado el agente durante el transcurso de la sesión."
    }, {
      "heading" : "4.3.4. Otras clases auxiliares",
      "text" : "4.3.4.1. Interacción\nTodos los agentes guardan un historial de las interacciones (Interaction) realizadas con el entorno durante la sesión en donde pueden consultar todo lo que realizaron durante ésta.\nPara poder guardar la observación de cada interacción se ha tenido que duplicar la información contenida en el espacio, ya que, de lo contrario, al guardar directamente la información del espacio y realizar modificaciones, la información guardada sería modificada.\nUn inconveniente de tener que duplicar la información contenida en el espacio, es que esta información es la que más espacio ocupa (computacionalmente hablando), por lo que se ha tenido que dar la posibilidad de dejar un máximo de las últimas interacciones a almacenar, de modo que el agente podrá “recordar” hasta un máximo de observaciones pasadas (Atributo NObservationsSaved en Agent).\nA continuación podemos ver una tabla con los atributos de la clase.\nAtributos Descripción\nObservation Observación proporcionada por el entorno\nAction Acción realizada por el agente\nReward Recompensa devuelta por el entorno\nElapsedTime Tiempo tardado en realizar la acción\n4.3.4.2. Observación\nPara permitir distintos tipos de representaciones de las observaciones se ha creado una estructura de clases en donde se almacenará la observación. Existen dos opciones\nPágina 45\npara representar las observaciones: las “Observaciones Simples” (Simple Observation) que representan a las observaciones como una tira de caracteres, y las “Observaciones L” (Observation L) en donde se almacena la estructura del espacio con los objetos y agentes presentes en él para representar las observaciones.\n4.4. Codificación y descripción de espacios\nExisten dos formas de construir los espacios: proporcionando manualmente una\ndescripción del espacio o dejando que el entorno lo genere aleatoriamente.\nEn ambos casos es necesaria una descripción de cómo será el espacio para que posteriormente el entorno lo interprete y lo genere utilizando un grafo dirigido para representarlo.\nA continuación veremos cómo se codifican estos espacios y los distintos\nprocedimientos para su construcción."
    }, {
      "heading" : "4.4.1. Codificación del espacio",
      "text" : "Para codificar los espacios se ha optado por crear una descripción textual de éstos donde se indicará: cuántas celdas contiene el espacio y las conexiones existentes entre estas celdas.\nEn primer lugar se divide el espacio por partes en función del número de celdas que tenga, de modo que si tiene 5 celdas, la descripción del espacio se dividirá en 5 partes separadas por barras verticales “|”.\nUna vez ya dividido el espacio por celdas, se procede a codificar qué acciones se pueden hacer desde cada una de las celdas y a qué celda se llegará a través de dicha acción. Para ello inicialmente se indican, de forma numérica, todas las acciones que se pueden realizar durante la sesión y, tras cada acción, a qué celda se moverá una vez realizada la acción. Para poder indicar a qué celda se moverá se ha optado por representar el movimiento como un desplazamiento de un número de celdas a partir de la celda actual, indicándolo como una sucesión de “+” o “-”, que representarán un movimiento hacia delante o hacia atrás respectivamente. En caso de que una acción no tenga ningún desplazamiento significará que desde esa celda el uso de esa acción no hará cambiar al agente de celda. Si al intentar realizar un desplazamiento hacia delante se llegase a una celda fuera del número de celdas se seguirá a partir de la primera celda y, análogamente, al intentar realizarlo hacia atrás se seguirá a partir de la última celda. Es decir se sigue un razonamiento circular.\nPara entender mejor la codificación de los espacios vamos a ver un ejemplo:\nComo descripción del espacio se tiene la siguiente tira de caracteres:\n1+2++3|1+23-|1+23|1+2--3-\nPágina 46\nComo podemos ver en la descripción, el espacio se divide en 4 celdas y se pueden realizar 3 acciones. Desde la primera celda se llega hasta la segunda celda tras realizar la acción 1, la acción 2 nos lleva a la tercera celda y la acción 3 deja al agente en la misma celda. Si vemos la descripción de la cuarta celda podemos ver como la acción 1 nos mueve a la primera celda, con la acción 2 llegamos a la segunda celda y la acción 3 nos devuelve a la tercera celda.\nEn la siguiente imagen podemos ver una representación gráfica del espacio descrito."
    }, {
      "heading" : "4.4.2. Descripción manual del espacio",
      "text" : "Una forma de construir el espacio es proporcionándole directamente al entorno, utilizando la codificación antes descrita, un tira de caracteres describiendo cómo debe ser el espacio que se va a utilizar. Una vez obtenida la descripción del espacio, el entorno lo generará automáticamente construyendo el grafo dirigido que lo representa, creando las celdas y conexiones necesarias para representar adecuadamente el espacio descrito."
    }, {
      "heading" : "4.4.3. Descripción aleatoria del espacio",
      "text" : "La segunda forma de construir el espacio es dejando que el entorno se encargue automáticamente de generar de forma aleatoria la descripción del espacio que se utilizará para la sesión para que, posteriormente, sea interpretado y generado de igual modo que en la forma manual.\nPágina 47\nPara generar aleatoriamente el espacio se ha decidido utilizar el siguiente método:\n• Inicialmente se decide cuál es el número de celdas de las que se compone el espacio a generar. Para ello se ha utilizado una distribución universal como la\ndescrita en la sección 3.3, pero para enteros. En esta distribución se considera que el número con mayor probabilidad de salir será el número más pequeño desde el que iniciamos la distribución, con un 50% de probabilidad, en caso de no elegirse este número se pasará a considerar el siguiente número con la misma probabilidad (50%) y así sucesivamente hasta que se decida el número de casillas de las que se dispondrá. El número mínimo de celdas que tendrá el espacio es 2.\n• Al igual que para elegir el número de celdas, se utiliza una distribución universal para decidir el número de acciones disponibles, utilizando como cota máxima el\nnúmero de celdas que tendrá el espacio, ya que, si hubieran más acciones que celdas, dos acciones de la misma celda siempre acabarán haciendo lo mismo.\n• Una vez que disponemos del número de celdas y de acciones que tendrá el espacio, generamos aleatoriamente (con una distribución uniforme), para cada\ncelda y cada acción, con qué celda se conectará (con cada una de las acciones) cada una de las celdas, pudiéndose incluso decidir que una acción no conectará la celda con ninguna otra y asumiéndose en este caso que la acción lo mantiene en la celda. Para ello se elige: el símbolo indicando si la conexión se hará con una celda anterior o posterior y un número aleatorio entre 0 y el número de celdas del espacio para saber cuántas celdas se desplazará el agente.\nEn la sección A1.2 podemos ver el código fuente de la generación aleatoria de espacios\nescrito en JAVA.\n4.5. Interfaz\nA continuación vamos a explicar en detalle cómo funciona la interfaz de usuario del\nprograma.\nNada más empezar podemos elegir en el menú inicial cuál será el agente evaluable que utilizaremos para realizar la sesión (humano o aleatorio) y cómo queremos que se construya el espacio (de forma manual o aleatoria).\nUna vez decidida la configuración que utilizaremos, podemos empezar la sesión.\nAl comenzar la sesión, el entorno se prepara para empezar, preparando el espacio y colocando aleatoriamente a los agentes que interactuarán durante el transcurso de la sesión.\nPágina 48\nEn la siguiente imagen podemos ver cómo queda el entorno tras indicarle que el agente evaluable será un agente humano, y que deseamos utilizar un espacio definido por nosotros. Para explicar la interfaz hemos habilitado la visibilidad de las recompensas en cada celda, sin embargo para realizar una sesión real esta información permanecerá oculta, por lo que los agentes no podrán utilizarla.\nComo podemos ver, la celda con el borde más grueso indica dónde se encuentra situado el agente que el sistema está evaluando. A su vez, dentro de cada celda podemos ver una representación gráfica de los agentes y objetos que están situados dentro de éstas. Entre los agentes vemos representados: al agente que se está evaluando como π, al agente Good como ⊕ y al agente Evil como ⊖.\nA continuación y en cada celda podemos ver de forma textual: la recompensa que tiene la celda, los agentes que están situados en ésta y la lista de acciones que se puede realizar y con qué celda conecta la acción.\nFinalmente podemos ver en tiempo real la recompensa global que está teniendo el\nagente durante el transcurso de la sesión.\nPuesto que el agente a evaluar es humano, el entorno nos permite seleccionar qué movimientos queremos realizar. Para ello podemos elegir utilizando los botones situados en la sección Movements la celda a la que queremos movernos.\nPágina 49\nEn la imagen siguiente podemos ver cómo reacciona el entorno tras realizar el\nmovimiento B (correspondiente a la acción 1).\nComo podemos ver, el agente evaluable ha recogido la recompensa 1 que estaba situada en la celda 2, mientras que los agentes Good y Evil se han movido a las celdas 1 y 4 respectivamente, dejando caer en sus respectivas celdas sus recompensas. Si nos fijamos en la celda 3 podemos ver como el agente Evil ha dejado tras de sí su rastro de recompensas, que como se ha explicado anteriormente va dividiéndose entre 2 en cada iteración.\nSi hubiéramos elegido al agente Aleatorio como agente a evaluar la interfaz de usuario hubiera cambiado ligeramente. Puesto que un agente Aleatorio no puede ser controlado por el usuario, el interfaz no nos permite la interacción con el entorno deshabilitándonos las acciones que puede realizar el agente. En la siguiente imagen podemos ver el mismo entorno habiendo seleccionado como agente a evaluar al agente Aleatorio.\nPágina 50\nPágina 51"
    }, {
      "heading" : "5. Experimentos",
      "text" : "En esta sección veremos los resultados de algunos experimentos realizados utilizando la arquitectura diseñada. En ellas veremos cómo se cumplen las características de los entornos balanceados, dando para agentes aleatorios resultados cercanos a 0. También veremos los resultados de los mismos tipos de entornos para un agente llamado Observador, el cual dispone de información adicional que le ayuda a conseguir mejores resultados.\nA continuación veremos los resultados de los experimentos realizados utilizando espacios previamente diseñados y generados aleatoriamente, los cuales contienen diversidad de celdas y acciones. Los resultados de los experimentos se muestran como la media de varias sesiones siguiendo un amplio rango de iteraciones. También veremos los resultados de experimentos en donde no se garantizan entornos balanceados y en donde se evalúan a varios agentes en una misma sesión.\nTodos los experimentos se han realizado tanto relocalizando a los agentes generadores de recompensas (Good y Evil) como sin relocalizarlos. Para ver la distinción podemos ver, en las tablas donde se resumen los experimentos, la marca “(Sin cambio)” en aquellos experimentos en donde no se relocalizan a los agentes generadores y ninguna marca para aquellos en donde sí se les relocaliza.\n5.1. Entornos definidos manualmente\nEn este apartado veremos los resultados de experimentos realizados en entornos completamente balanceados, con los agentes Good y Evil siguiendo el mismo comportamiento y con espacios desde 2 hasta 10 celdas para los cuales los espacios estarán siempre completamente conectados, es decir, se podrá llegar siempre desde cualquier celda a cualquier otra celda realizando las acciones oportunas. Para cada espacio veremos su codificación y una visión gráfica donde podremos ver como se conecta el espacio.\nEn todos los espacios mostrados a continuación, todas las celdas tienen siempre una acción por defecto que conecta a una celda consigo misma a través de la acción 0. Para no repetir continuamente esta información en las imágenes y en la codificación de los espacios esta información se obvia, siendo el sistema el encargado de construir esta acción para todas las celdas.\nPágina 52"
    }, {
      "heading" : "Experimentos con un espacio de 2 celdas",
      "text" : "Espacio definido manualmente\nCodificación del espacio: 1+|1-\nNúmero de celdas: 2\nNúmero de acciones: 1\nGood y Evil: Comportamiento aleatorio\nVisión gráfica\nMedia de resultados tras 10 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 0.04 0.5 0 0.5\n10 -0.02 0.5 0.03 0.5\n20 -0.015 0.5 -0.055 0.5\n50 0.0260 0.5 0.01 0.5\n100 -0.028 0.5 -0.002 0.5\n200 -0.008 0.5 -0.012 0.5\n500 0.0114 0.5 -0.009 0.5\n1000 0.0137 0.5 -0.0017 0.5\n2000 -0.0002 0.5 -0.00525 0.5\n1000000 0.0000453 0.5 0.0000849 0.5\nComo podemos observar, los resultados obtenidos por los agentes aleatorios van acercándose a resultados cercanos a 0, pudiendo ser estos resultados tanto positivos como negativos, a medida que las sesiones tienen más iteraciones los resultados obtenidos para un agente aleatorio se acercan cada vez más a 0. Esto se debe a que en sesiones con pocas iteraciones no es posible medir fiablemente la inteligencia de un agente, ya que en cualquier momento podría disponer de golpes de suerte (o de mala suerte). Al aumentar el número de iteraciones necesarias para la sesión, el agente aleatorio obtiene cifras mucho más cercanas a 0, lo cual reafirma que la inteligencia demostrada por un agente aleatorio es la esperada para un entorno balanceado.\nPágina 53\nEn lo referente al agente observador podemos ver como en este espacio siempre obtiene una recompensa de 0.5. Esto es debido a que ambas celdas siempre están ocupadas por algún agente distinto al que se está evaluando, los cuales son o Good o Evil, y por lo tanto siempre deberá compartir la recompensa obtenida en cualquier celda. Debido a que las sesiones se han realizado en un espacio tan pequeño, el agente observador siempre puede ver al agente Good, y por lo tanto siempre irá a por su recompensa. Sin embargo, como ya se ha dicho antes, está recompensa se dividirá entre los dos agentes que ocupan la celda obteniendo siempre recompensas de 0.5. Por lo tanto, en este espacio tan pequeño, el agente observador siempre obtiene la mayor recompensa posible dando como resultado una recompensa media de 0.5.\nPágina 54"
    }, {
      "heading" : "Experimentos con un espacio de 4 celdas",
      "text" : "Espacio definido manualmente\nCodificación del espacio: 1+2++3|1+23-|1+23|1+2--3-\nNúmero de celdas: 4\nNúmero de acciones: 3\nGood y Evil: Comportamiento aleatorio\nVisión gráfica\nMedia de resultados tras 10 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 0.01375 0.61 0.1 0.5\n10 0.03484375 0.695 -0.011875 0.685\n20 -0.06 0.66625 -0.05875 0.6525\n50 -0.045953125 0.717 0.020953125 0.686\n100 -0.0232026367 0.689125 0.0274492188 0.6895\n200 -0.0216215820 0.6755625 0.0034672851 0.67675\n500 -0.0226217712 0.6805734375 -0.0022934555 0.69005\n1000 -0.012627417 0.6735982422 -0.0053155426 0.6942\n2000 -0.0032242306 0.6795856934 -0.0125768757 0.68945\n1000000 -0.0001506778 0.6871037385 0.0014431725 0.7003017\nLos resultados obtenidos por el agente aleatorio siguen el mismo patrón que en los\nexperimentos anteriores.\nPágina 55\nUna vez que disponemos de un espacio con un mayor número de celdas, las recompensas que se encuentran en éstas no siempre deberán compartirse entre varios agentes, por lo tanto la esperanza media de recompensas será superior a 0.5. Si realizamos los mismos experimentos sin recolocar a los agentes Good y Evil las recompensas obtenidas por el agente observador siempre resultan ligeramente superiores a cuando se realizaba el cambio de posiciones de Good y Evil. Este es debido a que el agente observador no debe volver a buscar al agente Good tras cada relocalización y, por lo tanto, no perderá la recompensa que va dejando al tratar de encontrarle.\nPágina 56"
    }, {
      "heading" : "Experimentos con un espacio de 6 celdas",
      "text" : "Espacio definido manualmente\nCodificación del espacio: 1--2+|1++2--|1++2-|12---|1-2+|12---\nNúmero de celdas: 6\nNúmero de acciones: 2\nGood y Evil: Comportamiento aleatorio\nVisión gráfica\nMedia de resultados tras 10 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 -0.03 0.5 0.155625 0.405"
    }, {
      "heading" : "10 0.1425390625 0.54125 0.01984375 0.60125",
      "text" : "20 0.0127319336 0.765 -0.026171875 0.698125\n50 -0.0056818848 0.7214375 -0.0224951172 0.7095\n100 0.0046063232 0.6898037109 0.0245116272 0.71296875\n200 -0.0140901871 0.6739960926 0.0214790373 0.7415\n500 -0.0093691259 0.6934712868 -0.0014536697 0.734\n1000 0.0033478214 0.6812413848 -0.0005849602 0.737475\n2000 -0.0000222531 0.6858013640 -0.0103504164 0.7333\n1000000 -0.0021152493 0.6837011002 -0.0020848308 0.7384596\nPágina 57\nComo podemos ver, el agente aleatorio sigue obteniendo resultados cercanos a 0. Aunque en algunos experimentos ha tenido más suerte que en otros y por lo tanto su recompensa media difiere bastante del resto de experimentos. Podemos ver esto en los experimentos para el agente aleatorio con 10 iteraciones y con 5 iteraciones sin cambio para Good y Evil. Estos resultados excepcionales normalmente solo se dan en experimentos realizados en sesiones con pocas iteraciones, en donde la media de las recompensas obtenidas aun no es del todo fiable.\nAl igual que en los experimentos realizados en el espacio de 4 celdas, el agente observador sigue manteniendo resultados superiores a 0.5. Sin embargo podemos ver que existe una mayor diferencia entre los resultados obtenidos en los entornos donde no se cambia a Good ni a Evil y aquellos en los que si se les cambia. Esta diferencia va aumentando debido a que al agente observador le cuesta más encontrar nuevamente a Good en espacios cada vez más grandes, por lo que pierde cada vez más recompensas positivas tratando de encontrarle. Por otro lado podemos ver como las recompensas del observador son algo superiores que en el espacio anterior, ya que en espacios cada vez mayores los agentes Good y Evil tendrán una menor probabilidad de encontrarse y el agente Good no deberá renunciar a su movimiento, por lo que habrán menos ocasiones en donde su recompensa la comparta con el observador. Por lo tanto, el observador compartirá menos recompensas conforme el espacio contenga más celdas.\nPágina 58"
    }, {
      "heading" : "Experimentos con un espacio de 8 celdas",
      "text" : "Espacio definido manualmente\nCodificación del espacio: 1+2+++3|1+2-3---|1++2-3|1---2++3+|1+++2--3-|1--2+3|1-\n2+3+++|1-2---3\nNúmero de celdas: 8\nNúmero de acciones: 3\nGood y Evil: Comportamiento aleatorio\nVisión gráfica\nPágina 59\nMedia de resultados tras 10 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 -0.0675 0.6525 0.0325 0.67\n10 0.026328125 0.795 0.0076171875 0.725\n20 0.0646356201 0.73625 -0.0195324707 0.67125\n50 0.0005088654 0.731375 -0.0046048894 0.77675\n100 0.0064107894 0.7168063924 0.0373921991 0.768\n200 -0.0098070030 0.7353776855 0.0008353519 0.7845\n500 -0.0026782425 0.7257369799 0.0045596895 0.7877\n1000 -0.0076095967 0.7322875084 -0.0029735875 0.79015\n2000 0.0052535156 0.7306702732 0.0043954454 0.790825\n1000000 0.0012538494 0.7362988065 0.0005897395 0.79489045\nSiguiendo la dinámica de los experimentos anteriores, el agente aleatorio sigue\nmanteniendo resultados en torno a 0.\nEn este caso, los resultados del agente observador son aún superiores que en los experimentos del espacio con 6 celdas. Como se ha visto antes esto se debe a que existen menos probabilidades de que los agentes Good y Evil se encuentren y por lo tanto la recompensa de Good se comparte con menor frecuencia. Sin embargo existe un motivo añadido por lo que los resultados del observador han aumentado tanto con respecto a la diferencia entre los experimentos del espacio con 4 celdas y el de 6, en donde los resultados difieren en 0.4 mientras que los resultados entre estos experimentos y los experimentos del espacio anterior difieren en un intervalo entre 0.5 y 0.6. Esto es porque en estos experimentos Good y Evil disponen de más acciones para realizar desde prácticamente todas las celdas y, por lo tanto, decidirán con menor frecuencia permanecer en su celda, aumentando la media de recompensas que recogerá el observador.\nPágina 60"
    }, {
      "heading" : "Experimentos con un espacio de 10 celdas",
      "text" : "Espacio definido manualmente\nCodificación del espacio: 123+++++|1-23+++++|1-2+3+++++|12+3+++++|123+++++\n|1+2++3|1+23|1++++2-----3----|12-3|1--2-3\nNúmero de celdas: 10\nNúmero de acciones: 3\nGood y Evil: Comportamiento aleatorio\nVisión gráfica\nPágina 61\nMedia de resultados tras 10 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 0.049375 0.3575 0.0175 0.31\n10 0.056484375 0.47609375 0.0416992188 0.535\n20 -0.0252062988 0.6625 0.0191992188 0.7175\n50 -0.0045199013 0.72475 -0.0269153652 0.673484375\n100 0.0023949995 0.6618558960 -0.0203063105 0.73071875\n200 -0.011540667 0.6591534714 -0.0131583569 0.75575\n500 -0.0026265456 0.6586628568 -0.0004145666 0.76438125\n1000 0.0022877179 0.6650044655 -0.0145762173 0.7564539063\n2000 -0.0041933919 0.6580340589 -0.0041297061 0.7626625\n1000000 -0.0028186475 0.6693211141 -0.0017103821 0.7645574133\nComo cabría esperar al agente aleatorio sigue manteniendo los mismos resultados.\nAl agente observador le cuesta más encontrar al Good en este espacio con esta\ntopología, por lo que la diferencia de los resultados entre relocalizar o no a Good y a Evil\naumenta en estos experimentos. Cabría esperar que los resultados medios del\nobservador sin relocalizar a Good y a Evil fuera superior que en los experimentos con el\nespacio de 8 celdas, ya que contiene más celdas y el mismo número de acciones. Si nos\nfijamos más en la topología del espacio generalmente solo se pueden realizar una o dos\nacciones desde cada celda, sin contar quedarse en la misma celda, cuando en los\nexperimentos anteriores desde las celdas se podían realizar dos o tres acciones. Ya que el\nagente Good tendrá una mayor probabilidad de mantenerse en la celda en la que se\nencuentre sus recompensas serán más veces compartidas y, por lo tanto, la media de\nrecompensas no aumenta como era de esperar.\nPágina 62\n5.2. Entornos generados automáticamente\nA continuación mostramos los resultados a los experimentos realizados generando\naleatoriamente los espacios tal y como se describe en el apartado 4.4.3."
    }, {
      "heading" : "5.2.1. Espacios generados automáticamente (Conectados)",
      "text" : "Veamos los resultados obtenidos utilizando una media de 100 sesiones con los\ndistintos agentes e iteraciones utilizando distintos espacios en cada sesión teniendo como\núnica restricción que ninguna celda quede desconectada del resto.\n4-celdas 3-acciones\nEspacio generado automáticamente (Conectado)\nNúmero de celdas: 4\nNúmero de acciones: 3\nGood y Evil: Comportamiento aleatorio\nMedia de resultados tras 100 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 0.04675 0.522 -0.008 0.4825\n10 0.02975 0.543625 0.0120546875 0.5098125\n20 0.0395100098 0.565125 -0.0101875 0.56775\n50 0.0152491213 0.506125 0.0058412355 0.5735\n100 0.0092045895 0.5229386719 0.0242653084 0.5480625\n200 -0.003388797 0.4989532227 -0.0251157016 0.5288375\n500 -0.0006818127 0.478607851 -0.0309036888 0.537445\n1000 0.0044138150 0.4782791846 0.0101541339 0.56831375\n2000 0.0012512472 0.4670196489 0.0160087209 0.556584375\n100000 0.0018664954 0.4964514401 -0.0035218350 0.56775625\nPágina 63\n4-celdas 4-acciones\nEspacio generado automáticamente (Conectado)\nNúmero de celdas: 4\nNúmero de acciones: 4\nGood y Evil: Comportamiento aleatorio\nMedia de resultados tras 100 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 0.036375 0.59 0.022125 0.577\n10 -0.031546875 0.5985 -0.013078125 0.6525\n20 0.0068369140 0.6365 -0.0067470703 0.6276875\n50 0.0070780273 0.6219117188 -0.0065885833 0.6309\n100 -1.7125701829 0.6148359130 0.0050069703 0.651575\n200 -0.0031231798 0.6204983398 -0.0150923710 0.6380875\n500 0.0021759797 0.6267056823 -0.0115480778 0.655715\n1000 0.0037967063 0.5886907487 -0.0030248689 0.636795\n2000 -0.0025212755 0.6180830476 0.0154158361 0.645344375\n100000 0.0019821357 0.6394119529 0.0072174910 0.643137375\nPágina 64\n6-celdas 4-acciones\nEspacio generado automáticamente (Conectado)\nNúmero de celdas: 6\nNúmero de acciones: 4\nGood y Evil: Comportamiento aleatorio\nMedia de resultados tras 100 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 0.071625 0.553375 -0.061 0.57875\n10 0.0483203125 0.6700625 0.0099902343 0.656375\n20 0.0061313476 0.6654373798 0.0136739501 0.68552929687\n50 0.0057017860 0.6950187499 0.0234200533 0.7143734375\n100 0.0201091887 0.6770288970 -0.0002505793 0.722665625\n200 0.0015357381 0.6742627235 -0.0030017522 0.72453125\n500 0.0070556115 0.6666639230 0.0029403885 0.71003\n1000 0.0056254281 0.6698362898 0.0136878712 0.7185325\n2000 0.0079251038 0.6946516539 -0.0032442967 0.72596\n100000 0.0040647799 0.6860570746 -0.0038440883 0.731519625\nPágina 65\n6-celdas 6-acciones\nEspacio generado automáticamente (Conectado)\nNúmero de celdas: 6\nNúmero de acciones: 6\nGood y Evil: Comportamiento aleatorio\nMedia de resultados tras 100 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 0.0075625 0.707125 -0.0470625 0.689\n10 -0.0184033203 0.7268125 0.0123828125 0.746375\n20 -0.0197189598 0.74665625 -0.0074642486 0.75175\n50 -0.0037345133 0.757561615 0.0013374073 0.769125\n100 0.0076907712 0.7611456665 0.0012145443 0.77585\n200 0.0033358568 0.7593348992 0.0064964131 0.7769125\n500 0.0026132700 0.756693748 0.0007169638 0.771575\n1000 -0.0000698110 0.7598566768 0.0006846164 0.775176875\n2000 0.0010336988 0.759557398 -0.0044459509 0.7708675\n100000 0.0019426404 0.7601891151 0.0018648231 0.778565075\nPágina 66\n8-celdas 4-acciones\nEspacio generado automáticamente (Conectado)\nNúmero de celdas: 8\nNúmero de acciones: 4\nGood y Evil: Comportamiento aleatorio\nMedia de resultados tras 100 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 0.024375 0.5385625 0.0236875 0.4915\n10 -0.007171875 0.65865625 -0.0072167968 0.629703125\n20 0.0188020324 0.71584375 0.0037644996 0.67070898437\n50 -0.0033710265 0.6881226531 -0.0117281041 0.7314\n100 -0.0022428926 0.7237871719 0.0012601332 0.75131875\n200 0.0173139745 0.7016593765 0.0022134205 0.75735419921\n500 0.0028826708 0.7079315228 -0.0077612121 0.751844375\n1000 0.0023655002 0.7005680074 0.0001749424 0.767868125\n2000 0.0018537326 0.7140603729 0.0026119929 0.7673409375\n100000 0.0043064303 0.7171128281 0.0082247295 0.7661230625\nPágina 67\n8-celdas 6-acciones\nEspacio generado automáticamente (Conectado)\nNúmero de celdas: 8\nNúmero de acciones: 6\nGood y Evil: Comportamiento aleatorio\nMedia de resultados tras 100 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 -0.042125 0.6885 0.006 0.681\n10 0.010375 0.7228125 -0.026921875 0.7365625\n20 -0.0080527896 0.7798125 -0.0188741035 0.7798125\n50 -0.0015797378 0.7846015625 -0.0023470562 0.8034875\n100 -0.0002917564 0.7820518463 -0.0029158655 0.80525\n200 0.0007346433 0.7814969837 -0.0053570862 0.810796875\n500 -0.0023997683 0.7827005168 -0.0012930265 0.809630625\n1000 -0.0000345703 0.7824668042 0.0009552746 0.810276875\n2000 0.0012363421 0.7830145245 -0.0005975208 0.8101525\n100000 0.0002894769 0.7804884726 0.0009075608 0.8102544\nPágina 68\n8-celdas 8-acciones\nEspacio generado automáticamente (Conectado)\nNúmero de celdas: 8\nNúmero de acciones: 8\nGood y Evil: Comportamiento aleatorio\nMedia de resultados tras 100 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 -0.064875 0.757 -0.01025 0.74925\n10 -0.0170507812 0.795125 0.0113867187 0.79775\n20 0.0048254966 0.8055625 0.0104834518 0.815375\n50 -0.0065295809 0.8153328063 0.0034930459 0.820025\n100 -0.0016721380 0.8144338834 -0.0001513715 0.8249\n200 -0.0039921943 0.8135470728 -0.0044161980 0.831725\n500 0.0005881382 0.8154931645 -0.0014925117 0.83276\n1000 -0.0056278378 0.8151737539 0.0004738523 0.8343375\n2000 -0.0030229432 0.8151252478 -0.0035334687 0.83393125\n100000 -0.0004472968 0.8144933822 -0.0022796966 0.833287725\nPágina 69\n10-celdas 4-acciones\nEspacio generado automáticamente (Conectado)\nNúmero de celdas: 10\nNúmero de acciones: 4\nGood y Evil: Comportamiento aleatorio\nMedia de resultados tras 100 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 -0.003375 0.503 0.0348125 0.496\n10 -0.0067871093 0.6367578125 0.0029042968 0.618125\n20 0.0029400844 0.662703125 0.0060056285 0.6786015625\n50 -0.0126927395 0.720691467 -0.0003916556 0.74152036132\n100 0.0010064249 0.7064358273 -0.0025521861 0.777025\n200 0.0021113307 0.7126902210 -0.0017698301 0.76821494140\n500 0.0081824189 0.7088160847 -0.0064782360 0.781974375\n1000 0.0023236015 0.7163777811 0.0137967548 0.78701601562\n2000 0.0054380301 0.7104929906 0.0007256349 0.78096863281\n100000 0.0047555243 0.7138575059 0.0045655560 0.78658997968\nPágina 70\n10-celdas 7-acciones\nEspacio generado automáticamente (Conectado)\nNúmero de celdas: 10\nNúmero de acciones: 7\nGood y Evil: Comportamiento aleatorio\nMedia de resultados tras 100 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 0.0025 0.66275 0.007375 0.62725"
    }, {
      "heading" : "10 0.0162539062 0.7975 0.0067558593 0.77346875",
      "text" : "20 -0.0139494881 0.80575 -0.0144310302 0.818671875\n50 0.0058377407 0.811679782 -0.0038752322 0.83715\n100 -0.0123828109 0.8106688241 0.0032449395 0.833878125\n200 -0.0005640175 0.8066227070 0.0021693778 0.8405\n500 -0.0002181396 0.8103837011 0.0013080553 0.8436875\n1000 -0.0018019882 0.8113200001 0.0003544006 0.845283125\n2000 -0.0005624005 0.8105365493 0.0004085095 0.8450575\n100000 0.0000173130 0.8120781481 0.0000560432 0.84557391875\nPágina 71\n10-celdas 10-acciones\nEspacio generado automáticamente (Conectado)\nNúmero de celdas: 10\nNúmero de acciones: 10\nGood y Evil: Comportamiento aleatorio\nMedia de resultados tras 100 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 0.0100625 0.7665 -0.019375 0.7645\n10 0.00984375 0.8095625 0.0020917968 0.8275\n20 -0.003994873 0.84775 0.0191303443 0.84225\n50 -0.0153001013 0.8492577506 -0.0099471920 0.86035\n100 0.0017704384 0.8515060465 0.0041125094 0.8641625\n200 0.0055527598 0.8467617110 0.0028669731 0.86915\n500 -0.0025842754 0.8505609456 0.0037606309 0.868675\n1000 -0.0016398764 0.8476845503 0.0003439481 0.8681925\n2000 0.0003998080 0.8493090214 0.0002639389 0.86781\n100000 0.0004557696 0.8486287340 0.0004261841 0.8679295\nComo hemos podido observar el agente aleatorio siempre obtiene resultados cercanos\na 0, cumpliéndose las propiedades de un entorno balanceado.\nA medida que va creciendo el número de celdas y de acciones, al igual que con los\nespacios definidos, el agente Good tiene menor probabilidad de encontrarse con el\nagente Evil y más posibilidades de cambiar de celda, lo cual explica los crecientes\nresultados a medida que va aumentando el número de celdas y de acciones. Como cabría\nesperar el observador sigue obteniendo mejores resultados cuando no se relocalizan ni a\nGood ni a Evil.\nPágina 72"
    }, {
      "heading" : "5.2.2. Espacios generados automáticamente (Fuertemente",
      "text" : "conectados)\nVeamos los resultados obtenidos utilizando una media de 100 sesiones con los\ndistintos agentes e iteraciones utilizando distintos espacios en cada sesión teniendo como\nrestricciones que ninguna celda quede desconectada del resto de celdas y que siempre\nexista la posibilidad de llegar de una celda a cualquier otra del espacio.\n4-celdas 3-acciones\nEspacio generado automáticamente (Fuertemente conectado)\nNúmero de celdas: 4\nNúmero de acciones: 3\nGood y Evil: Comportamiento aleatorio\nMedia de resultados tras 100 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 -0.0559375 0.52925 -0.054 0.5615"
    }, {
      "heading" : "10 0.0311015625 0.616875 0.0290976562 0.63703125",
      "text" : "20 -0.0162795429 0.669 -0.0282729492 0.650625\n50 -0.0041670043 0.6596765625 0.0190241519 0.672775\n100 0.0059552291 0.6535291015 0.0021379867 0.666625\n200 0.0028428422 0.6621362792 -0.0039155030 0.67644375\n500 0.0090564506 0.6549043872 -0.0027577401 0.67529\n1000 -0.0040643431 0.6541745177 -0.0019210290 0.67767125\n2000 -0.0016869102 0.6556849958 0.0041417218 0.678718125\n100000 -0.0000455535 0.6540757565 -0.0007266093 0.6762191\nPágina 73\n4-celdas 4-acciones\nEspacio generado automáticamente (Fuertemente conectado)\nNúmero de celdas: 4\nNúmero de acciones: 4\nGood y Evil: Comportamiento aleatorio\nMedia de resultados tras 100 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 0.0060625 0.604 0.0163125 0.585125\n10 -0.0125957031 0.65425 0.0022734375 0.658375\n20 -0.0071548156 0.675875 0.0328095550 0.6716875\n50 0.0172693517 0.6737371093 0.0148806640 0.68635\n100 0.0063840385 0.6824394531 0.0041909473 0.691725\n200 0.0030967557 0.6686276851 -0.0033190012 0.68488125\n500 -0.0017187205 0.6787061772 -0.0023710905 0.6845\n1000 0.0040511488 0.6716999725 0.0028339158 0.69140375\n2000 0.0026429969 0.6824245528 0.0033481580 0.6919275\n100000 0.0036169436 0.6779132341 0.0034483574 0.68647725625\nPágina 74\n6-celdas 4-acciones\nEspacio generado automáticamente (Fuertemente conectado)\nNúmero de celdas: 6\nNúmero de acciones: 4\nGood y Evil: Comportamiento aleatorio\nMedia de resultados tras 100 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 -0.008375 0.6135 0.0236875 0.5605\n10 0.0096523437 0.65303125 -0.0134296875 0.6638125\n20 0.0170052347 0.7070625 0.0073968658 0.7104375\n50 0.0015991142 0.7195690429 -0.0071953084 0.726825\n100 0.0009080716 0.7096931018 0.0102078705 0.74024375\n200 0.0037127370 0.7114983885 0.0098327245 0.74724335937\n500 0.0037571275 0.7191618014 0.0066783974 0.74959375\n1000 0.0067209183 0.7128960171 0.0073153420 0.75042359375\n2000 0.0091325779 0.7167080586 0.0072821669 0.7497528125\n100000 0.0032163755 0.7157017915 0.0034025599 0.7522874875\nPágina 75\n6-celdas 6-acciones\nEspacio generado automáticamente (Fuertemente conectado)\nNúmero de celdas: 6\nNúmero de acciones: 6\nGood y Evil: Comportamiento aleatorio\nMedia de resultados tras 100 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 0.03225 0.68525 0.047625 0.715\n10 -0.011875 0.724375 -0.0522226562 0.75675\n20 -0.0195453338 0.76275 0.0059307861 0.7605625\n50 0.0023880575 0.7547959472 0.0118458852 0.76375\n100 -0.0015145474 0.7639124877 0.0021453768 0.7742625\n200 0.0006489422 0.7598449461 -0.0046083085 0.7756625\n500 0.0034337616 0.7645893438 0.0034215969 0.77374\n1000 0.0060917931 0.7606200810 0.0028078536 0.7797375\n2000 0.0023283563 0.7632689170 0.0015290917 0.77973375\n100000 0.0006137602 0.7573598717 0.0014342578 0.779636525\nPágina 76\n8-celdas 4-acciones\nEspacio generado automáticamente (Fuertemente conectado)\nNúmero de celdas: 8\nNúmero de acciones: 4\nGood y Evil: Comportamiento aleatorio\nMedia de resultados tras 100 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 0.0224375 0.613375 -0.0093125 0.5381875"
    }, {
      "heading" : "10 0.0230917968 0.676484375 -0.0049335937 0.64228125",
      "text" : ""
    }, {
      "heading" : "20 -0.0042501735 0.7115859375 0.0056370620 0.72321875",
      "text" : "50 0.0279502706 0.7356921047 0.0033554223 0.758615625\n100 0.0124253130 0.7113351461 0.0156291859 0.772246875\n200 0.0118206168 0.7252318740 0.0092197083 0.7791625\n500 0.0070662716 0.7219434424 0.0083700529 0.77841421875\n1000 0.0101475394 0.7241803343 0.0089241963 0.78193796875\n2000 0.0088895304 0.7209748786 0.0047236072 0.778891875\n100000 0.0073447912 0.7218125279 0.0089199839 0.77512321093\nPágina 77\n8-celdas 6-acciones\nEspacio generado automáticamente (Fuertemente conectado)\nNúmero de celdas: 8\nNúmero de acciones: 6\nGood y Evil: Comportamiento aleatorio\nMedia de resultados tras 100 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 -0.001375 0.7145 -0.034375 0.706625\n10 0.0178945312 0.74125 0.0070058593 0.7331875\n20 -0.0105775337 0.7750625 -0.0031084747 0.765125\n50 0.001415135 0.7886808349 -0.006634225 0.796225\n100 0.0019076936 0.7850293668 -0.0033597725 0.804325\n200 -0.0056681451 0.7861249763 -0.0043902148 0.806825\n500 0.0023970364 0.7844784053 -0.002102987 0.81118\n1000 0.0001708415 0.7815085989 0.0003116397 0.80873875\n2000 -0.0007306984 0.7794557296 0.0006464564 0.811493125\n100000 0.0002585017 0.7821838415 0.0004136819 0.81182739375\nPágina 78\n8-celdas 8-acciones\nEspacio generado automáticamente (Fuertemente conectado)\nNúmero de celdas: 8\nNúmero de acciones: 8\nGood y Evil: Comportamiento aleatorio\nMedia de resultados tras 100 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 -0.0059375 0.7355 0.0151875 0.78625\n10 -0.0131113281 0.78775 0.0077460937 0.7980625\n20 -0.0044685211 0.807625 -0.0247678604 0.818625\n50 0.0025694720 0.8138312362 -0.0081238818 0.83015\n100 -0.0094017859 0.8167993530 0.0052363706 0.83363125\n200 0.0004332004 0.8149542020 0.0084704842 0.8295125\n500 -0.0018826736 0.8152654870 -0.0030245552 0.8297325\n1000 -0.0021321778 0.8156104487 -0.0006740240 0.831035\n2000 0.0016597958 0.8157987536 0.0003517454 0.83301125\n100000 -0.0017017071 0.8133519223 -0.0008519155 0.83378475\nPágina 79\n10-celdas 4-acciones\nEspacio generado automáticamente (Fuertemente conectado)\nNúmero de celdas: 10\nNúmero de acciones: 4\nGood y Evil: Comportamiento aleatorio\nMedia de resultados tras 100 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 -0.00775 0.545875 -0.003375 0.529125"
    }, {
      "heading" : "10 -0.0133144531 0.6095546875 0.0135009765 0.62215625",
      "text" : "20 0.0223903026 0.7179296875 0.0149272508 0.681453125\n50 0.0086390515 0.7318503353 -0.0141471834 0.7633\n100 0.0130662086 0.7185673772 0.0061895334 0.77265546875\n200 0.0018630807 0.7143527745 0.0076909615 0.77997851562\n500 -0.0006402785 0.7220285703 0.0063592927 0.790005625\n1000 0.0026376552 0.7135880569 -0.0015747931 0.79191449218\n2000 0.0047512678 0.7179938130 0.0014539369 0.789928125\n100000 0.0031840408 0.7188911904 0.0025455900 0.797118975\nPágina 80\n10-celdas 7-acciones\nEspacio generado automáticamente (Fuertemente conectado)\nNúmero de celdas: 10\nNúmero de acciones: 7\nGood y Evil: Comportamiento aleatorio\nMedia de resultados tras 100 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 0.0315625 0.722 -0.056125 0.70175\n10 0.0343896484 0.769375 0.0120039062 0.78725\n20 -0.0026242761 0.79628125 0.0078400764 0.80175\n50 0.0017691624 0.8128048820 -0.0073491173 0.831412\n100 -0.0023990369 0.8117279079 0.0019531691 0.83767\n200 0.0000650018 0.8123028149 0.0005083199 0.84008828125\n500 0.0005450867 0.8121905251 0.0008084398 0.8453025\n1000 -0.0019673875 0.8136747984 0.0000549403 0.8451721875\n2000 0.0007466091 0.8102686322 0.0004461757 0.845355625\n100000 -0.0000180668 0.8137150793 -0.0001898676 0.84364703125\nPágina 81\n10-celdas 10-acciones\nEspacio generado automáticamente (Fuertemente conectado)\nNúmero de celdas: 10\nNúmero de acciones: 10\nGood y Evil: Comportamiento aleatorio\nMedia de resultados tras 100 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 -0.0226875 0.7615 -0.0031875 0.775\n10 0.0153847656 0.816875 -0.0310585937 0.8255\n20 -0.0223733577 0.849765625 0.0195264005 0.8361875\n50 -0.0142524479 0.8452241943 -0.0022178101 0.86205\n100 -0.0032213712 0.8499759917 -0.0010602513 0.8656125\n200 0.0033599156 0.8477624884 0.0016957615 0.8649625\n500 -0.0024712512 0.8475952018 0.0012036416 0.867875\n1000 -0.0002777197 0.8477101014 0.0013118449 0.8696825\n2000 0.0005061001 0.8487137980 0.0018370838 0.8685675\n100000 -0.0001684560 0.8475726295 -0.0002814336 0.8673165875\nEl agente aleatorio sigue la misma línea que el resto de espacios vistos hasta el\nmomento, por lo cual los espacios generados fuertemente conectados siguen cumpliendo\nlas propiedades de un entorno balanceado.\nCon respecto al agente observador, sigue exactamente la misma dinámica que en los\nexperimentos realizados anteriormente con los espacios conectados generados. Si nos\nfijamos en estos resultados y los obtenidos con los espacios generados conectados\npodemos ver como son prácticamente iguales. Esto se debe a que al permitir que se\ngeneren tanta cantidad de acciones, los espacios que se crean raramente tienen un\npequeño conjunto de estados en donde el agente evaluable pueda quedarse encerrado\ndurante toda la sesión. De hecho, haciendo pruebas con esta distribución del espacio (10\nceldas y 10 acciones) teniendo como restricción que los espacios generados sean\nconectados, únicamente 3 de los 2000 espacios que se han generado no son también\nfuertemente conectados, lo que explica la gran similitud entre los resultados obtenidos.\nPágina 82\n5.3. Entorno sesgado\nA continuación veremos los resultados a experimentos realizados en el espacio\ndefinido de 4 celdas utilizando comportamientos distintos para el agente Good y para Evil.\nEntorno sesgado 1\nEntorno sesgado\nNúmero de celdas: 4\nNúmero de acciones: 3\nGood y Evil: Comportamiento aleatorio\nVisión gráfica\nPágina 83\nMedia del resultado tras 10 sesiones realizadas donde Good se mantiene siempre en la\nmisma celda.\nAgente\nIteraciones Aleatorio\nAleatorio\n(Sin cambio)\n5 0.0275 -0.0925\n10 -0.0853125 -0.0834570312\n20 -0.0733984375 -0.1013476943\n50 -0.0744572753 -0.0545395507\n100 -0.0721672363 -0.080703125\n200 -0.0798338012 -0.1081768798\n500 -0.0763609828 -0.0759708496\n1000 -0.0705885308 -0.0916902229\n2000 -0.0833871496 -0.0610014770\n1000000 -0.0864727326 -0.0988842842\nEn estos experimentos el agente aleatorio siempre compartirá las recompensas\npositivas con el agente Good y seguirá recogiendo las recompensas negativas como\nanteriormente hacía. Esto hace que la media de recompensas recogidas siempre sea\nnegativa.\nPágina 84\nEntorno sesgado 2\nEntorno sesgado\nNúmero de celdas: 4\nNúmero de acciones: 3\nGood y Evil: Comportamiento aleatorio\nVisión gráfica\nMedia del resultado tras 10 sesiones realizadas donde Good siempre trata de cambiar\nde celda.\nAgente\nIteraciones Aleatorio\nAleatorio\n(Sin cambio)\n5 0.01875 0.21125\n10 0.095625 0.21125\n20 0.072265625 0.0569726562\n50 -0.0179550781 0.0548925781\n100 0.0143828125 0.0466845703\n200 0.0472050781 0.0500693359\n500 0.0506410400 0.0425306884\n1000 0.0511209838 0.0387437622\n2000 0.0498806686 0.0543033935\n1000000 0.0523993359 0.0546207446\nPágina 85\nEn este caso el agente Good siempre tratará de cambiar de celda, a menos que se encuentre con Evil en cuyo caso uno de los dos tendrá que esperar en su celda, por lo que generalmente el agente no compartirá la recompensa con el agente Good.\nComo podemos ver en ambos entornos existe un sesgo con respecto a los resultados obtenidos por el agente aleatorio, lo cual significa que no se cumplen las propiedades de un entorno balanceado. Esto es debido a que no se han introducido elementos complementarios en el entorno (el agente Good y el agente Evil no se comportan exactamente igual), siendo predominante en cada uno de los experimentos uno de los elementos.\nPágina 86\n5.4. Evaluación social\nEn este caso vamos a medir a varios agentes evaluándose simultáneamente en la misma sesión, por lo que podremos ver como se ven modificados los resultados de los distintos agentes al existir otros compitiendo por las recompensas durante el transcurso de las sesiones. En estos experimentos introduciremos a los agentes aleatorio y observador simultáneamente en el entorno.\nEn la tabla vemos los resultados por parejas, donde cada resultado de Aleatorio y de\nObservador será el resultado para cada uno al evaluarlos sobre las mismas sesiones.\nEspacio definido manualmente - 8 celdas\nEvaluación social - Espacio definido manualmente\nNúmero de celdas: 8\nNúmero de acciones: 3\nGood y Evil: Comportamiento aleatorio\nVisión gráfica\nPágina 87\nMedia del resultado tras 10 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 -0.0925 0.5316666666 0.0316666666 0.365\n10 -0.0190104166 0.61 -0.0347135416 0.61541666666\n20 -0.0845389811 0.7216666666 -0.1060742187 0.61833333333\n50 -0.0875097198 0.7161197915 -0.0821009115 0.71566666666\n100 -0.0736087347 0.7053124389 -0.0480256779 0.74825\n200 -0.0784876931 0.6839524720 -0.0745241745 0.741\n500 -0.0781876082 0.6871417968 -0.0746585093 0.73788333333\n1000 -0.0810844671 0.6835628865 -0.0829523893 0.73548333333\n2000 -0.0724479806 0.6936914750 -0.0688205723 0.74119895833\n1000000 -0.0713102075 0.6929307734 -0.0793472724 0.74182583333\nPágina 88"
    }, {
      "heading" : "Espacio generado automáticamente (Conectado)",
      "text" : "8-celdas 6-acciones\nEvaluación social - Espacio generado automáticamente (Conectado)\nNúmero de celdas: 8\nNúmero de acciones: 6\nGood y Evil: Comportamiento aleatorio\nMedia del resultado evaluando 100 sesiones realizadas con espacios generados al azar.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 -0.0634583333 0.6508333333 -0.0559583333 0.62533333333\n10 -0.0872135416 0.6813958333 -0.0926223958 0.688625\n20 -0.1037266680 0.7412083333 -0.0984965496 0.7297916666\n50 -0.0785706488 0.7436425781 -0.0929490238 0.743475\n100 -0.0998179061 0.7346942586 -0.1027326131 0.7559\n200 -0.0921733936 0.7361930467 -0.0953013076 0.7541885416\n500 -0.0939403367 0.7300403093 -0.0977293596 0.754136666\n1000 -0.0931912955 0.7300650927 -0.0982186178 0.75964125\n2000 -0.0928543908 0.7290798694 -0.0985127970 0.75536802083\n100000 -0.0942372888 0.7236268737 -0.0982732850 0.74866333541\nPágina 89"
    }, {
      "heading" : "Espacio generado automáticamente (Fuertemente",
      "text" : "conectado)\n8-celdas 6-acciones\nEvaluación social - Espacio generado automáticamente (Fuertemente conectado)\nNúmero de celdas: 8\nNúmero de acciones: 6\nGood y Evil: Comportamiento aleatorio\nMedia del resultado evaluando 100 sesiones realizadas con espacios generados al azar.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 -0.0839166666 0.657 -0.0596875 0.62591666666\n10 -0.0926793619 0.7100416666 -0.0718736979 0.6895\n20 -0.0907177225 0.7303958333 -0.0816079489 0.7171875\n50 -0.0822846768 0.7236609375 -0.0895003887 0.74218333333\n100 -0.0889639014 0.7329951766 -0.1074970967 0.7507125\n200 -0.0911916412 0.7366449244 -0.0916739162 0.75441666666\n500 -0.0947957406 0.7306393021 -0.0982189874 0.75883\n1000 -0.0932831643 0.7326538204 -0.0987799716 0.75638041666\n2000 -0.0927858311 0.7291214223 -0.0969757873 0.7553403125\n100000 -0.0938490195 0.7351404194 -0.0975634640 0.758923725\nComo podemos observar la introducción de un agente observador obliga al agente\naleatorio a recoger mayoritariamente recompensas negativas y a compartir las positivas\ncon el observador, por lo que sus resultados son siempre negativos.\nSin embargo, el agente observador también resulta perjudicado al incluir al agente\naleatorio, ya que de vez en cuando también debe compartir las recompensas positivas\ncon el agente aleatorio, lo cual se traduce en una disminución de los resultados con\nrespecto a los mismos experimentos evaluación social.\nPágina 90\n5.5. Varios movimientos de los agentes generadores\nHasta el momento hemos realizado los experimentos teniendo en cuenta que los\nagentes generadores Good y Evil solo podían moverse de una casilla a otra adyacente, sin\nembargo estos agentes deberían poder moverse varias celdas simultáneamente. En estos\nexperimentos hemos dado a los agentes Good y Evil la oportunidad de moverse\nrealizando 2, 3 y 4 acciones simultáneas a través del espacio."
    }, {
      "heading" : "2 Movimientos",
      "text" : "Espacio definido manualmente - 8 celdas\n2 Movimientos – Espacio definido manualmente\nNúmero de celdas: 8\nNúmero de acciones: 3\nGood y Evil: Comportamiento aleatorio\nVisión gráfica\nPágina 91\nMedia del resultado tras 10 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 -0.04 0.405 -0.05 0.42625\n10 0.03796875 0.3821875 0.0153515625 0.412578125\n20 -0.0363085937 0.4236915588 -0.0047903442 0.51425292968\n50 0.0097206726 0.5009875142 -0.0005978928 0.55971380615\n100 -0.0066461486 0.4774788761 -0.0101414661 0.51140614509\n200 -0.0080702943 0.4481070556 0.0126746131 0.49184478485\n500 -0.0166377544 0.4458106359 0.0032025186 0.50211970045\n1000 -0.0026152616 0.4622730091 -0.0045706541 0.49065660272\n2000 0.0006304102 0.4678949345 -0.0016159894 0.48975005375\n1000000 -0.0007433638 0.4675208032 -0.0006717888 0.47645791772\nPágina 92"
    }, {
      "heading" : "2 Movimientos",
      "text" : ""
    }, {
      "heading" : "Espacio generado automáticamente (Conectado)",
      "text" : "8-celdas 6-acciones\n2 Movimientos – Espacio generado automáticamente (Conectado)\nNúmero de celdas: 8\nNúmero de acciones: 6\nGood y Evil: Comportamiento aleatorio\nMedia del resultado evaluando 100 sesiones realizadas con espacios generados al azar.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 -0.0119375 0.5341875 -0.0072 0.55075\n10 0.0064091796 0.5379550781 -0.0058457031 0.53960351562\n20 0.0082336196 0.5430779724 -0.0035347251 0.56109193801\n50 0.006022677 0.5298084959 -0.0000125740 0.55853964548\n100 -0.0081134941 0.5518187971 -0.0095100618 0.55345392186\n200 -0.0064818422 0.5524241160 -0.0036136333 0.54766000853\n500 -0.0043393588 0.5505275479 -0.0027577104 0.55116168168\n1000 0.0007476604 0.5445017800 0.0016774965 0.54745065584\n2000 -0.0002261323 0.5371404278 0.0006449761 0.54885647237\n100000 0.0000726315 0.5445200320 -0.0006092810 0.54809953458\nPágina 93"
    }, {
      "heading" : "2 Movimientos",
      "text" : ""
    }, {
      "heading" : "Espacio generado automáticamente (Fuertemente",
      "text" : "conectado)\n8-celdas 6-acciones\n2 Movimientos – Espacio generado automáticamente (Fuertemente conectado)\nNúmero de celdas: 8\nNúmero de acciones: 6\nGood y Evil: Comportamiento aleatorio\nMedia del resultado evaluando 100 sesiones realizadas con espacios generados al azar.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 -0.006875 0.538125 -0.0324375 0.572062\n10 0.0100273437 0.5299609375 0.0036308593 0.5477578125\n20 0.0226711483 0.5366146240 -0.002918045 0.54955162048\n50 0.0077164861 0.5502106540 -0.0006324388 0.54632609325\n100 -0.0046460433 0.5414063711 -0.0064156002 0.53228034219\n200 0.0003139742 0.5421837545 0.0018089704 0.55251558018\n500 -0.0000909382 0.5393919641 0.0001765426 0.55325090242\n1000 0.000387935 0.5465902676 0.0000794154 0.54417609374\n2000 -0.0005180299 0.5382306384 -0.0020435247 0.55555706237\n100000 -0.0003742777 0.5446807327 -0.0004220987 0.55247444172\nPágina 94\n3 Movimientos\nEspacio definido manualmente - 8 celdas\n3 Movimientos – Espacio definido manualmente\nNúmero de celdas: 8\nNúmero de acciones: 3\nGood y Evil: Comportamiento aleatorio\nVisión gráfica\nPágina 95\nMedia del resultado tras 10 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 0.015 0.3075 0.0675 0.525\n10 0.0778125 0.495 0.0000195312 0.4809765625\n20 -0.0155657958 0.3947705078 -0.0081640625 0.48546264648\n50 -0.0277063903 0.4672634277 -0.0041567382 0.466694458\n100 -0.0123266344 0.4584087065 -0.008754115 0.47171520423\n200 0.0026176177 0.4822813549 -0.0004651916 0.44741162168\n500 -0.0020008018 0.4646291565 0.0111973494 0.45438940498\n1000 0.0027786851 0.4469535351 -0.0055641521 0.45812849095\n2000 -0.0051659124 0.4550553326 0.0015448156 0.45724515918\n1000000 0.0013313368 0.4527268877 0.0021513511 0.45961500528\nPágina 96"
    }, {
      "heading" : "3 Movimientos",
      "text" : ""
    }, {
      "heading" : "Espacio generado automáticamente (Conectado)",
      "text" : "8-celdas 6-acciones\n3 Movimientos – Espacio generado automáticamente (Conectado)\nNúmero de celdas: 8\nNúmero de acciones: 6\nGood y Evil: Comportamiento aleatorio\nMedia del resultado evaluando 100 sesiones realizadas con espacios generados al azar.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 -0.0219375 0.49325 0.0156875 0.4818125\n10 0.008234375 0.5291503906 0.0188515625 0.52532421875\n20 -0.0003603782 0.5175086669 0.0001126976 0.51278277587\n50 0.0021808862 0.5166270456 -0.0115737323 0.51555128552\n100 0.001067267 0.5179938519 -0.0027140024 0.52435035397\n200 0.0020297547 0.5180077101 -0.0039365435 0.51644639428\n500 0.0021116354 0.5238462684 0.0019011115 0.51839674259\n1000 0.0041763178 0.5146958811 -0.0013714009 0.5152991525\n2000 0.0002451868 0.5107994995 0.0006154981 0.52274517534\n100000 0.0002321834 0.5141149108 0.0007630815 0.5186971441\nPágina 97"
    }, {
      "heading" : "3 Movimientos",
      "text" : ""
    }, {
      "heading" : "Espacio generado automáticamente (Fuertemente",
      "text" : "conectado)\n8-celdas 6-acciones\n3 Movimientos – Espacio generado automáticamente (Fuertemente conectado)\nNúmero de celdas: 8\nNúmero de acciones: 6\nGood y Evil: Comportamiento aleatorio\nMedia del resultado evaluando 100 sesiones realizadas con espacios generados al azar.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 -0.002375 0.5063125 -0.025625 0.4895\n10 0.0151914062 0.5172207031 -0.0110566406 0.54356054687\n20 -0.0289168739 0.5175667724 0.003539978 0.53750369262\n50 0.004336184 0.5057879984 -0.0066616579 0.50712485746\n100 0.0048225043 0.5112355104 0.0027196029 0.51155243528\n200 0.0025973139 0.5132000347 -0.0041791193 0.51492348993\n500 0.0011507622 0.5113789919 0.0018582105 0.51214954175\n1000 -0.0010128764 0.5093485237 0.0011275919 0.52257547003\n2000 0.0025834348 0.5034636958 0.0011110905 0.51276348561\n100000 0.0005249084 0.5076676257 -0.0001681908 0.51862807874\nPágina 98"
    }, {
      "heading" : "4 Movimientos",
      "text" : "Espacio definido manualmente - 8 celdas\n4 Movimientos – Espacio definido manualmente\nNúmero de celdas: 8\nNúmero de acciones: 3\nGood y Evil: Comportamiento aleatorio\nVisión gráfica\nPágina 99\nMedia del resultado tras 10 sesiones realizadas.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 0.03625 0.295 -0.02 0.4325"
    }, {
      "heading" : "10 0.04359375 0.40609375 -0.0296875 0.39453125",
      "text" : "20 -0.0076364135 0.3544236755 0.0228564453 0.43929321289\n50 0.0297216796 0.4356188964 0.0276926269 0.45490655517\n100 0.0031295781 0.4159604034 0.0263404192 0.41855424499\n200 -0.0018015873 0.4172509078 0.0131416435 0.41539114761\n500 -0.0047641256 0.4048449179 0.000372763 0.41228777224\n1000 0.0091366043 0.4071086136 0.0001288413 0.40876417505\n2000 0.0003983884 0.4061799454 -0.0062200826 0.40967137190\n1000000 0.0000415605 0.4042661129 0.0000581977 0.40725332197\nPágina 100"
    }, {
      "heading" : "4 Movimientos",
      "text" : ""
    }, {
      "heading" : "Espacio generado automáticamente (Conectado)",
      "text" : "8-celdas 6-acciones\n4 Movimientos – Espacio generado automáticamente (Conectado)\nNúmero de celdas: 8\nNúmero de acciones: 6\nGood y Evil: Comportamiento aleatorio\nMedia del resultado evaluando 100 sesiones realizadas con espacios generados al azar.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 -0.019125 0.437375 0.0034375 0.4781875\n10 -0.0234580078 0.5111425781 -0.0145878906 0.49786328125\n20 0.0228353652 0.5105960083 -0.0145878906 0.49482608032\n50 -0.0199328547 0.4969350477 -0.0145878906 0.51526614642\n100 -0.0081563807 0.5143437625 -0.0029857476 0.49809998298\n200 0.0014267878 0.5008350189 0.0020672845 0.50130601562\n500 -0.0018580099 0.5021560366 -0.000277568 0.50506489835\n1000 -0.0005966052 0.5052771370 0.0009364216 0.51094270662\n2000 -0.0000055866 0.5043260169 -0.0014542887 0.51026966205\n100000 -0.0004186722 0.5009204262 -0.0005286776 0.50773962979\nPágina 101"
    }, {
      "heading" : "4 Movimientos",
      "text" : ""
    }, {
      "heading" : "Espacio generado automáticamente (Fuertemente",
      "text" : "conectado)\n8-celdas 6-acciones\n4 Movimientos – Espacio generado automáticamente (Fuertemente conectado)\nNúmero de celdas: 8\nNúmero de acciones: 6\nGood y Evil: Comportamiento aleatorio\nMedia del resultado evaluando 100 sesiones realizadas con espacios generados al azar.\nAgente\nIteraciones Aleatorio Observador\nAleatorio\n(Sin cambio)\nObservador\n(Sin cambio)\n5 0.003125 0.49075 0.0433125 0.4849375\n10 0.0253671875 0.515 -0.0003730468 0.4478125\n20 0.0045796928 0.502413928 0.0094997062 0.51073068237\n50 0.0153383504 0.5048348373 -0.0027522481 0.49465015575\n100 -0.0094204826 0.496507526 -0.0097997535 0.50584293028\n200 -0.0042613635 0.4981908917 0.0006317677 0.50560896818\n500 -0.0029455798 0.5028718157 -0.0016293615 0.50808030833\n1000 -0.0006098342 0.5102287993 -0.002906116 0.49683524799\n2000 0.0008494687 0.5019137961 -0.0001656485 0.51116060912\n100000 -0.0004016026 0.5041956411 -0.0002865026 0.50274058414\nComo podemos observar el agente aleatorio no ve modificados sus resultados, ya que\nel cambio que se ha realizado ha sido en ambos agentes generadores (Good y Evil) y, por\nlo tanto, se siguen manteniendo las propiedades de un entorno balanceado.\nPágina 102\nAl agente observador sí que le afecta este cambio, ya que ahora no le resulta tan fácil\nseguir a Good a través del espacio. Mientras que antes tenía que seguir continuamente a\nGood durante toda la sesión ahora tiene que realizar movimientos aleatorios hasta\nencontrarle y seguramente le volverá a perder de vista al poco tiempo, por lo que no le\nresulta tan fácil conseguir tan buenos resultados en este tipo de entornos. También\npodemos ver como conforme aumenta el número de movimientos que pueden realizar\nGood y Evil al observador le resulta más y más difícil conseguir buenos resultados. Esto se\ndebe a que existen más posibilidades de que Good se aleje lo suficiente del observador\ncomo para que éste no pueda seguirle en vez de mantenerse a una distancia lo\nsuficientemente cercana como para que continúe siguiéndole.\nPágina 103"
    }, {
      "heading" : "6. Conclusiones y trabajo futuro",
      "text" : "Conclusiones\nPodemos analizar los resultados de este proyecto de fin de carrera conforme a dos perspectivas diferentes: el cumplimiento de los objetivos marcados y el conocimiento que se ha adquirido a partir del desarrollo del proyecto y de los experimentos.\n1. Tras la realización del proyecto se han cumplido todos los objetivos propuestos en el apartado 1.3.\n• Tras la construcción de la arquitectura del sistema, éste está preparado para realizar los tests propuestos a distintos tipos de agentes: Los experimentos\nrealizados demuestran que el sistema y su arquitectura son lo suficientemente potentes como para ser utilizado para evaluar agentes. El hecho de que el resultado medio obtenido por agentes aleatorios, en los entornos tanto definidos como autogenerados, sea cercano a 0 demuestra que la arquitectura construida está preparada para realizar tests en entornos balanceados y, por lo tanto, está listo para la evaluación de la inteligencia en agentes. • El sistema permite la construcción de los entornos de forma manual: El sistema es capaz de construir y preparar un entorno desde cero a partir de la\ndescripción del entorno que el usuario desee construir.\n• El sistema permite la construcción de los entornos de forma automática y aleatoria: El sistema es capaz de construir y preparar un entorno desde cero\nautogenerando la descripción que tendrá el entorno y posteriormente construyéndolo a partir de éste. La autogeneración puede incluir la comprobación de ciertas propiedades que el entorno debe cumplir para ser un entorno válido. • El sistema cuenta con una interfaz de usuario que permite la evaluación para agentes humanos: Se ha construido una interfaz que permite que los agentes\nhumanos sean evaluados dentro del sistema, así como mostrar el resultado obtenido por este al finalizar la prueba. Además, la interfaz también permite que el usuario observe el desarrollo de pruebas en todo tipo de agentes. • Las pruebas y experimentos realizados han sido de ayuda para evaluar el sistema construido: Tras realizar las pruebas y el estudio de los experimentos\nhemos podido ver que el sistema cumple con las propiedades inicialmente deseadas y hemos podido observar la inteligencia de varios tipos de agentes.\n2. Con la generación de entornos sencillos y generadores de recompensas aleatorios hemos podido ver la diferencia entre agentes aleatorios y agentes con cierta\nestrategia. También hemos visto su interrelación cuando varios agentes compiten por las mismas recompensas. • Tras lo visto durante los experimentos realizados hemos podido observar como cambios en el comportamiento de los agentes que tratamos de evaluar\nsuponen cambios significativos en su inteligencia. Tal y como hemos podido ver\nPágina 104\nun comportamiento aleatorio de los agentes no supone inteligencia alguna, ya que no trata de resolver el problema, únicamente se mueve aleatoriamente sin importarle los resultados a obtener. Por otro lado el simple hecho de ver las casillas adyacentes y, por lo tanto, poder decidir moverse a la mejor celda posible demuestra un aumento significativo de inteligencia como hemos podido observar en los experimentos. De lo que podemos deducir que si añadimos más comportamiento inteligente a los agentes resultará en una mejora en su evaluación. • La interrelación de varios agentes en el mismo entorno entorpece la evaluación del agente a evaluar en lo que a recompensas se refiere, ya que hace disminuir\nsu recompensa media conforme se encuentren simultáneamente más agentes en el entorno. Según lo visto, la compartición de las recompensas entre todos los agentes no resulta adecuado, por lo que se deberá estudiar otra forma de introducir nuevos agentes sin que, por ello, entorpezca la evaluación del agente que se esté evaluando.\nTrabajo futuro\nA la vista de todo lo anterior, pensamos que la arquitectura supone una base de evaluación sobre la cual iremos refinando y completando la variedad y complejidad de entornos y de agentes, así como el diseño de experimentos.\nEn concreto, el trabajo futuro se centrará en:\n• Generar los espacios siguiendo una distribución universal: De momento los espacios se generan siguiendo una distribución uniforme. Los espacios deberán\ngenerarse siguiendo una distribución universal, para acercarse más a la noción intuitiva de complejidad.\n• Generar objetos: La generación de los entornos deberá permitir la generación automática de los objetos. • Generar otros agentes y su comportamiento: El entorno deberá poder generar automáticamente nuevos agentes y su comportamiento utilizando para ello el\nlenguaje de especificación descrito en la sección 3.5.5.\n• Generar entornos automáticamente siguiendo alguna distribución: Se deberán poder generar y construir automáticamente todos los elementos de los entornos\n(espacios, objetos y agentes).\n• Construir la observación del entorno siguiendo el lenguaje de especificación descrito en la sección 3.5.3: De momento a los agentes se les entrega la\nobservación como una copia del espacio utilizado durante la prueba, se deberá construir una tira de caracteres que represente a las observaciones para entregárselas a los agentes.\n• Modificar la interfaz para que se ajuste a las interfaces mostradas en el apartado 3.5.2: Se deberá completar el desarrollo de la interfaz y también se insertarán\nnuevas funcionalidades.\n• Construir los tests a partir de sesiones: Se deberán crear los tests a partir de las sesiones ya construidas.\nPágina 105\n• Autoajustar la complejidad del entorno para cada sesión en función de los resultados obtenidos por el agente que se está evaluando: Para la evaluación\ncorrecta de los agentes se deberá poder autoajustar la complejidad de los entornos generados para cada sesión, siguiendo el algoritmo en [Hernandez-Orallo & Dowe 2010].\n• Evaluar personas y animales. • Evaluar sistemas de IA, como las variantes de AIXI [Veness et al 2009] o agentes\ncon técnicas de Q-learning u otros.\nPágina 106\nPágina 107\nApéndices\nDebido a que el código fuente de este proyecto debe ser portable y ejecutable en\ncualquier máquina, preferiblemente como Applet Web, la aplicación ha sido desarrollada en JAVA utilizando el entorno Eclipse. Los comentarios se han realizado en inglés, por si en el futuro parte del proyecto es utilizado o extendido por otros equipos investigadores."
    }, {
      "heading" : "A1. Extractos representativos del Código Fuente",
      "text" : "En este apéndice incluimos dos partes relevantes del código fuente; la que se encarga del bucle principal de la interacción entre entorno y agente; y la generación aleatoria de entornos.\nA1.1. Bucle principal // Loop to interact between the Environment and the Agent for (int actualInteraction = 0; actualInteraction <\nnumberOfInteractions; actualInteraction++) { if (numberOfInteractionsToRelocate != 0 && actualInteraction != 0 && actualInteraction % numberOfInteractionsToRelocate == 0)\nthis.RelocateGoodAndEvilAgents(); // Set the rewards to the cells where are the Good and Evil Agents Cell goodCell = this.goodAgent.GetLocation(); Cell evilCell = this.evilAgent.GetLocation(); goodCell.SetReward(this.maxReward); evilCell.SetReward(this.minReward); for (int actualAgent = 0; actualAgent < this.agents.size();\nactualAgent++) { Agent agent = this.agents.get(actualAgent); // Sends the last Reward to the agent double reward = interactions[actualAgent].GetReward(); this.SendReward(agent, reward); } Observation observation = this.TakeObservation(); for (int actualAgent = 0; actualAgent < this.agents.size(); actualAgent++) { Agent agent = this.agents.get(actualAgent); // Shows the actual Observation to the agent interactions[actualAgent].SetObservation(observation); this.SendObservation(agent, observation); } for (int actualAgent = 0; actualAgent < this.agents.size(); actualAgent++) { Agent agent = this.agents.get(actualAgent);\nPágina 108\n// Asks to the Agent for the next action int[] action = this.GetAction(agent); long elapsedTime = agent.GetElapsedTime(); interactions[actualAgent].SetAction(action); interactions[actualAgent].SetElapsedTime(elapsedTime); } // Makes the actions made by the Agents for (int actualAgent = 0; actualAgent < this.agents.size();\nactualAgent++) { Agent agent = this.agents.get(actualAgent); int[] action = interactions[actualAgent].GetAction(); this.MakeAction(agent, action); } // If Good and Evil Agents are in the same cell one of them doesn't move if (this.goodAgent.GetLocation() == this.evilAgent.GetLocation()) // If the Good Agent didn't move the Evil Agent doesn't move if (this.goodAgent.GetLocation() == goodCell) this.LocateAgent(this.evilAgent, evilCell.GetNumber()); // If the Evil Agent didn't move the Good Agent doesn't move else if (this.evilAgent.GetLocation() == evilCell) this.LocateAgent(this.goodAgent, goodCell.GetNumber()); // If both Agents had move one of them doesn't move else if (new Random().nextInt(2) == 0) this.LocateAgent(this.goodAgent, goodCell.GetNumber()); else this.LocateAgent(this.evilAgent, evilCell.GetNumber()); // Set rewards to the Agents for (int actualAgent = 0; actualAgent < this.agents.size(); actualAgent++) { Agent agent = this.agents.get(actualAgent); // Evaluates the Agent action in the Environment double obtainedReward = this.EvaluateAction(agent, interactions[actualAgent]); interactions[actualAgent].SetReward(obtainedReward); } // Update the rewards of all cells by dividing by 2 for (int index = 1; index <= this.space.GetNumberOfCells(); index++) { Cell cell = this.space.GetCell(index); cell.SetReward(cell.GetReward() / 2); } // Update the reward to 0 of all cells where there is an Agent for (Agent agent:this.agents) { Cell cell = agent.GetLocation(); cell.SetReward(0.0); } }\nPágina 109\nA1.2. Generación aleatoria de espacios Random random = new Random(); Distribution distribution = new UniversalDistribution(); // Select the number of cells of the space int numCells = distribution.GetValue(Environment_L.MIN_CELLS); // Select the maximum actions available for the selected number of\ncells int maxActions = Math.min(numCells, Environment_L.MAX_ACTIONS); // Select the number of actions of the space int numActions = distribution.GetValue(Environment_L.MIN_ACTIONS, maxActions); // Constructs the space with the number of cells and actions selected String description = \"\"; // Construct each cell for (int cell = 0; cell < numCells; cell++) { if (cell != 0) description += \"|\"; // For each cell, generate each action for (int action = 1; action < numActions; action++) { int movements = random.nextInt(numCells); char movement = random.nextInt(2) == 0 ? '+' : '-'; description += action; for (int index = 0; index < movements; index++) description += movement; } } return description;"
    }, {
      "heading" : "A2. Referencias",
      "text" : "[Dowe & Hajek 1997] D L Dowe, A R Hajek (1997), \"A computational extension to the\nTuring Test\", Technical Report #97/322, Dept Computer Science, Monash University, Melbourne, 9pp, 1997. http://www.csse.monash.edu.au/publications/1997/tr-cs97322-abs.html.\n[Dowe & Hajek 1998] D L Dowe and A R Hajek (1998). A non-behavioural, computational\nextension to the Turing Test, pp101-106, Proceedings of the International Conference on Computational Intelligence & Multimedia Applications (ICCIMA'98), Gippsland, Australia, February 1998.\n[Dowe 2008] Dowe, D.L. “Foreword re C. S. Wallace”, Computer Journal, 51, 5, pp. 523 –\n560, September, 2008, Christopher Stewart WALLACE (1933-2004) memorial special issue.\n[Embretson & Mc Collam 2000] Embretson, S.E. y McCollam, K.M.S. (2000). Psychometric\napproaches to understanding and measuring intelligence. En R.J. Sternberg (Ed.). Handbook of intelligence (pp. 423-444). Cambridge, UK: Cambridge University Press.\nPágina 110\n[Embretson 1998] Embretson, S. E. (1998). A cognitive design system approach to\ngenerating valid tests: Application to abstract reasoning. Psychological Methods, 3, 300-396.\n[Hernandez-Orallo & Dowe 2010] J. Hernández-Orallo, D.L. Dowe “Measuring Universal\nIntelligence: Towards an Anytime Intelligence Test” Artificial Intelligence Journal, Elsevier, doi:10.1016/j.artint.2010.09.006, 2010.\n[Hernandez-Orallo & Minaya-Collado 1998] Hernández-Orallo, José; Minaya-Collado, N.: A\nFormal Definition of Intelligence Based on an Intensional Variant of Kolmogorov Complexity, Proceedings of the International Symposium of Engineering of Intelligent Systems (EIS'98) ICSC Press 1998, pp. 146-163.\n[Hernandez-Orallo 2000a] José Hernández-Orallo: Beyond the Turing Test. Journal of\nLogic, Language and Information 9(4): 447-466 (2000).\n[Hernandez-Orallo 2000b] Hernández-Orallo, José On The Computational Measurement\nof Intelligence Factors, appeared in A. Meystel Performance Metrics for Intelligent Systems Workshop, National Institute of Standards and Technology, Gaithersburg, MD, USA, August 14-16, 2000, pp. 1-8, section XXI.\n[Hernandez-Orallo 2009] J. Hernández-Orallo. On discriminative environments,\nrandomness, two-part compression and mml. TR, available at http://users.dsic.upv.es/proy/anynt/, 2009.\n[Hernandez-Orallo 2010a] J. Hernández-Orallo, On evaluating agent performance in a\nfixed period of time, in: M. Hutter, E. Baum, E. Kitzelmann (Eds.), Artificial General Intelligence, 3rd International Conference AGI, Proceedings, “Advances in Intelligent Systems Research\" series, Atlantis Press, 2010, pp. 25-30.\n[Hernandez-Orallo 2010b] J. Hernández-Orallo, A (hopefully) non-biased universal\nenvironment class for measuring intelligence of biological and artificial systems, in: M. Hutter, E. Baum, E. Kitzelmann (Eds.), Artificial General Intelligence, 3rd International Conference AGI, Proceedings, “Advances in Intelligent Systems Research\" series, Atlantis Press, 2010, pp. 182-183.\n[Herrmann et al 2007] Herrmann, E., Call, J., Hernández-Lloreda, M.V., Hare, B.,\nTomasello, M. “Humans Have Evolved Specialized Skills of Social Cognition: The Cultural Intelligence Hypothesis”, Science, 7 September 2007, Vol. 317. no. 5843, pp. 1360 - 1366, DOI: 10.1126/science.1146282.\n[Hutter 2005] Hutter, M. “Universal Artificial Intelligence: Sequential Decisions based on\nAlgorithmic Probability”, Springer, 2005.\n[Hutter 2006] Marcus Hutter, “General Discounting Versus Average Reward”, ALT, Jose L.\nBalcazar and Philip M. Long and Frank Stephan, 244-258, Springer, Lecture Notes in Computer Science, 4264, 2006, http://dblp.unitrier.de/db/conf/alt/alt2006.html#Hutter06.\nPágina 111\n[Hutter 2007] Hutter, M. “Universal algorithmic intelligence: A mathematical top→down\napproach”. In Artificial General Intelligence, pages 227–290. Springer, Berlin, 2007.\n[Laird & Wray 2010] Laird, J.E. and Wray III, R.E., “Cognitive Architecture Requirements\nfor Achieving AGI”, Advances in Intelligent Systems Research\" (ISSN 1951-6851), \"Artificial General Intelligence\", Third Conference on Artificial General Intelligence, AGI 2010, Lugano, Switzerland, March 5-8, 2010, editors, Eric Baum, Marcus Hutter and Emanuel Kitzelmann, ISBN: 978-90-78677-36-9.\n[Laird et al 1987] Laird, Rosenbloom, Newell, John and Paul, Allen (1987). \"Soar: An\nArchitecture for General Intelligence\". Artificial Intelligence, 33: 1-64.\n[Laird 2008] Laird, J.E. “Extending the Soar cognitive architecture”, Artificial General\nIntelligence 2008: Proceedings of the First AGI Conference, 2008.\n[Legg & Hutter 2007] Legg, S.; Hutter, M. Universal Intelligence: A Definition of Machine\nIntelligence Shane Legg and Marcus Hutter. In Minds and Machines, pages 391-444, volume 17, number 4, November 2007. http://www.vetta.org/documents/UniversalIntelligence.pdf.\n[Legg 2008] Shane Legg. Department of Informatics, University of Lugano, June 2008.\nhttp://www.vetta.org/documents/Machine_Super_Intelligence.pdf.\n[Levin 1973] Levin, L.A. \"Universal search problems\" Problems Inform. Transmission,\n9:265-266, 1973.\n[Li & Vitanyi 2008] Li, Ming; Vitányi, Paul \"An Introduction to Kolmogorov Complexity and\nits Applications\" 3rd Edition. Springer-Verlag, New York, 2008.\n[Markov 1960] A. A. Markov. The theory of algorithms. American Mathematical Society\nTranslations, series 2, 15:1-14, 1960.\n[Martinez-Arias et al 2006] Martínez-Arias, M.Rosario; Hernández-Lloreda, M.Victoria;\nHernández-Lloreda, M.José. “Psicometría”, Alianza Editorial 2006.\n[Pell 1994] B. Pell. A strategic metagame player for general chesslike games. In AAAI,\npages 1378-1385, 1994.\n[Rissanen 1983] J. Rissanen. A universal prior for integers and estimation by minimum\ndescription length. Annals of Statistics, 11(2):416-431, 1983.\n[Sanghi & Dowe 2003] Sanghi, P. and D.L. Dowe (2003). A computer program capable of\npassing I.Q. tests, Proc. 4th International Conference on Cognitive Science (and 7th Australasian Society for Cognitive Science Conference), ICCS ASCS 2003 (http://www.cogsci.unsw.edu.au), Univ. of NSW, Sydney, Australia, 13-17 July 2003, Vol. 2, pp. 570-575.\n[Schaeffer 2007] Schaeffer, J. and Burch, N. and Bjornsson, Y. and Kishimoto, A. and\nMuller, M. and Lake, R. and Lu, P. and Sutphen, S., “Checkers is solved”, Science, 317, 5844, 1518, 2007, AAAS.\nPágina 112\n[Solomonoff 1964] Solomonoff, R.J. \"A formal theory of inductive inference\" inform.\nContr. vol. 7, pp. 1-22, Mar. 1964; also, pp. 224-254, June 1964.\n[Solomonoff 1986] Solomonoff, R.J. \"The Application of Algorithmic Probability to\nProblems in Artificial Intelligence\" in L.N.Karnal and J.F. Lemmer (eds.) Uncertainty in Artificial Intelligence (L.N. Karnal and J.F. Lemmer, eds.), Elsevier Science, pp. 473-491, 1986.\n[Spearman 1904] Spearman, C. “ ‘General Intelligence’ objectively determined and\nmeasured” American Journal of Psychology 15, 201-293, 1904.\n[Sutton & Barto 1998] Sutton, Richard S.; Andrew G. Barto (1998). Reinforcement\nLearning: An Introduction. MIT Press.\n[Turing 1950] Turing, Alan “Computing Machinery and Intelligence” Reprinted in “Minds\nand Machines”, edited by Alan Ross Anderson, Englewood Cliffs, N.J., Prentice Hall 1964.\n[Veness et al 2009] Joel Veness, Kee Siong Ng, Marcus Hutter, and David Silver. A Monte\nCarlo AIXI Approximation. CoRR, abs/0909.0801, 2009. informal publication (http://arxiv.org/abs/0909.0801).\n[von Ahn et al 2002] von Ahn, L.; Blum, M.; Langford, J. “Telling Humans and Computers\nApart (Automatically) or How Lazy Cryptographers do AI” Communications of the ACM, 2002. www.captcha.net.\n[von Ahn et al 2008] von Ahn, L.; Maurer, B.; McMillen, C.; Blum, M. \"reCAPTCHA:\nHuman-Based Character Recognition via Web Security Measures\" Science, Vol. 321, September 12th, 2008.\n[Wallace & Boulton 1968] Wallace, C.S. and Boulton, D. M. \"An Information Measure for\nClassification\" Computer Journal, 11, 2, pp. 185-195, 1968.\n[Wallace & Dowe 1999] C. S. Wallace and D. L. Dowe \"Minimum Message Length and\nKolmogorov Complexity\", Computer Journal, 1999, vol 42, no. 4,, pp. 270-283.\n[Wallace 2005] C. S. Wallace, Statistical and Inductive Inference by Minimum Message\nLength, Information Science and Statistics\", 432, Springer Verlag, May, 2005.\n[Weyns, Parunak & Michel 2005] D. Weyns, H.V.D. Parunak, F. Michel, T. Holvoet, and J.\nFerber. Environments for multi-agent systems, state-of-the-art and research challenges. In Environments for multi-agent systems, volume 3374 of LNCS, 2005."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2010,
    "abstractText" : null,
    "creator" : "PDFCreator Version 0.9.7"
  }
}