{
  "name" : "1205.2638.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Temporal Action-Graph Games: A New Representation for Dynamic Games",
    "authors" : [ "Albert Xin Jiang", "Kevin Leyton-Brown" ],
    "emails" : [ "jiang@cs.ubc.ca", "kevinlb@cs.ubc.ca", "apfeffer@cra.com" ],
    "sections" : [ {
      "heading" : null,
      "text" : "In this paper we introduce temporal action graph games (TAGGs), a novel graphical representation of imperfect-information extensive form games. We show that when a game involves anonymity or context-specific utility independencies, its encoding as a TAGG can be much more compact than its direct encoding as a multiagent influence diagram (MAID). We also show that TAGGs can be understood as indirect MAID encodings in which many deterministic chance nodes are introduced. We provide an algorithm for computing with TAGGs, and show both theoretically and empirically that our approach improves significantly on the previous state of the art."
    }, {
      "heading" : "1 Introduction",
      "text" : "Game theory is the main formal model used to study decision-making in the presence of other rational agents (see e.g., [5]). In this paper we investigate game-theoretic models that include sequential moves (so-called extensiveform games) and utility uncertainty (so-called Bayesian games, or “chance nodes” in the extensive form). When agents move sequentially and are able to perfectly observe all moves, extensive-form games are said to exhibit perfect information; otherwise, extensive-form games exhibit imperfect information.\nIn the last decade, researchers have begun to study compact representations of various game types, inspired by the success of probabilistic graphical models. For imperfectinformation extensive form games, the most influential model is multiagent influence diagrams, or MAIDs [11]. (Game networks are a very similar representation and were invented concurrently [13].) MAIDs are compact when players’ utility functions exhibit independencies; such compactness can also be leveraged for computational benefit [2].\nExample 1: Twenty cars are approaching a tollbooth with three lanes. The drivers must decide which lane to use. The cars arrive in four waves of five cars each. In each wave, the drivers must pick lanes simultaneously, and can see the number of cars before them in each lane. A driver’s utility decreases with the number of cars that chose the same lane either before him or at the same time.\nWhen represented as a MAID, the game of Example 1 contains very little structure, meaning that computation would be highly inefficient. However, the game really is highly structured: agents’ payoffs exhibit context-specific independence (utility depends only on the number of cars in the chosen lane) and agents’ payoffs exhibit anonymity (utility depends on the numbers of other agents taking given actions, not on these agents’ identities). The problem with a straightforward MAID representation of this game is that it does not capture either of these kinds of payoff structure.\nA wider variety of compact game representations exist for simultaneous-move (i.e., non-extensive-form) games [10]. In particular, several of these game representations can compactly represent anonymity and context-specific independence (CSI) structures (see, e.g., [20; 14]). ActionGraph Games (AGGs) unify these past representations by compactly representing both anonymity and CSI while still retaining the ability to represent any game [1; 9]. Furthermore, structure in AGGs can be leveraged for computational benefit [8]. AGGs have been used to model realworld systems such as auctions for search engine keywords [21]. However, AGGs are unable to represent the game presented in Example 1 because they cannot describe sequential moves or imperfect information.\nIn this paper we present a new representational framework called Temporal Action-Graph Games (TAGGs) that allows us to capture this kind of structure. Like AGGs, TAGGs can represent anonymity and CSI, but unlike AGGs they can also represent games with dynamics, imperfect information and uncertainty. We first define the representation of TAGGs, and then show formally how they define a game using an induced Bayesian network (BN). We demonstrate\nthat TAGGs can represent any MAID, but can also represent situations that are hard to capture naturally as MAIDs. If the TAGG representation of a game contains anonymity or CSI, the induced BN will have special structure that can be exploited by inference algorithms. We present an algorithm for computing expected utility of TAGGs that exploits this structure. Our algorithm first transforms the induced BN to another BN that represents the structure more explicitly, then computes expected utility using a specialized inference algorithm on the transformed BN. We show that it performs better than using a MAID in which the structure is not represented explicitly, and better than using a standard BN inference algorithm on the transformed BN."
    }, {
      "heading" : "2 Representation",
      "text" : ""
    }, {
      "heading" : "2.1 AGG",
      "text" : "We first introduce the core concepts of (simultaneousmove) AGGs. An Action-Graph Game (AGG) is a game played by a set of agents N = {1, . . . , n} on a set of action nodes A. To play the game, each agent i simultaneously chooses an action node Ai ∈ Ai, where Ai ⊆ A. Each action node thus corresponds to an action choice that is available to one or more of the agents. Once the agents have made their choices, for each action node A ∈ A, an action count is tallied, which is the number of agents that have chosen A. The action graph is a directed graph on the action nodes A. We say A′ is a neighbor of A if there is an edge from A′ to A. An agent’s utility depends only on the node she chose and the action counts on the neighbors of the chosen node. This allows us to represent the utilities of the game by specifying a utility functionUA for each action node A, that maps from the set of configurations over the neighbors of A (vectors of action counts) to a real value.\nConsider a simultaneous-move version of Example 1, where all the cars arrive at the tollbooth together in one wave, and have to pick lanes simultaneously. A driver’s utility depends on the number of cars that chose the same lane. This game can be compactly represented as an AGG. We have one action node corresponding to each lane of the tollbooth. Each agent can choose any of the lanes, so Ai = A for all i. The only edges in the action graph are from each action node to itself, since the utility of choosing a lane only depends on the action count on the same lane."
    }, {
      "heading" : "2.2 TAGG",
      "text" : "At a high level, Temporal Action-Graph Games (TAGGs) extend the AGG representation by introducing the concepts of time, uncertainty and imperfect information, while adapting the AGG concepts of action nodes and actionspecific utility functions to the dynamic setting. We first give an informal description of these concepts.\nTemporal structure. A TAGG describes a dynamic game\nplayed over a series of time steps 1, . . . , T , on a set of action nodes A. At each time step a version of a static AGG is played by a subset of agents on A, and the action counts on the action nodes are accumulated.\nChance variables. TAGGs model uncertainty via chance variables. Like random variables in a Bayes net, a chance variable is associated with a set of parents and a conditional probability table (CPT). The parents may be action nodes or other chance variables. Each chance variable is associated with an instantiation time; once instantiated, its value stays the same for the rest of the game.\nDecisions. At each time step one or more agents move simultaneously, represented by agent-specific decisions. TAGGs model imperfect information by allowing each agent to condition his decision on observed values of a given subset of decisions, chance variables, and the previous time step’s action counts.\nAction nodes. Each decision is a choice of one from a number of available action nodes. As in AGGs, the same action may be available to more than one player. Action nodes provide a time-dependent tally: the action count for each action A in each time step τ is the number of times A has been chosen during the time period 1, . . . , τ .\nUtility functions. There is a utility function U τA associated with each action A at each time τ , which specifies the utility a player receives at time τ for having chosen action A. Each U τA has a set of parents which must be action nodes or chance variables. The utility of playing action A depends only on what happens over these parents. An agent who took action A (once) may receive utility at multiple times (e.g., short-term cost and long-term benefit); this is captured by associating a set of payoff times with each decision. An agent’s overall utility is defined as the sum of the utilities received at all time steps.\nPlay of a TAGG can be summarized as follows:\n1. At time 0, action counts are initialized to zero; chance variables with instantiation time 0 are instantiated,\n2. At each time τ ∈ {1, . . . , T}:\n(a) all agents with decisions at τ observe the appropriate action counts, chance variables, and decisions, if any.\n(b) all decisions at τ are made simultaneously. (c) action counts at τ are tallied. (d) chance variables at time τ are instantiated. (e) for each action A, utility function U τA is evalu-\nated, with this amount of utility accruing to every agent who took action a at a decision whose payoff times include τ ; the result is not revealed to any of the players.1\n1If an agent plays action A for two decisions that have the\n3. At the end of the game, each agent receives the sum of all utility allocations throughout the game.\nIntuitively, the process can be seen as a sequence of AGGs played over time. At each time step τ , the players that have a decision at time τ participate in a simultaneous-move AGG on the set of action nodes, whose action counts are initialized to be the counts at τ − 1. Each action A’s utility function is U τA and A’s neighbors in the action graph correspond to the parents of U τA. For the tollbooth games of Example 1, the TAGG has actions corresponding to lanes, and the action graphs are the same across different times, containing only self edges from each action to itself.\nBefore formally defining TAGGs, we need to first define the concept of a configuration at time τ over a set of action nodes, decisions and chance variables, which is intuitively an instantiation at time τ of a corresponding set of variables.\nDefinition 2: Given a set of action nodes A, a set of decisions D, a set of chance variables X , and a set B ⊆ A ∪ X ∪ D, a configuration at time τ over B, denoted as CτB , is a |B|-tuple of values, one for each node in B. For each node b ∈ B, the corresponding element in CτB , denoted as Cτ (b), must satisfy the following:\n• if b ∈ A, Cτ (b) is an integer in {0, . . . , |D|} specifying the action count on b at τ , i.e. the number of times action b has been chosen during the time period 1, . . . , τ .\n• if b ∈ D, Cτ (b) is an action inA, specifying the action chosen at D.\n• if b ∈ X , Cτ (b) is a value from the domain of the random variable, Dom[b].\nLet CτB be the set of all configurations at τ over B.\nWe now offer formal definitions of chance variables, decisions, and utility functions.\nDefinition 3: A chance variable X is defined by:\n1. a domain Dom[X ], which is a nonempty finite set;\n2. a set of parents Pa[X ], which are a set of chance variables and/or actions;\n3. an instantiation time t(X), which specifies the time at which the action counts in Pa[X ] are instantiated;\n4. a CPT Pr(X |Pa[X ]), which specifies the conditional probability distribution of X given each configuration C t(X)\nPa[X].\nsame payoff time τ , then the agent receives twice the value of U τ\nA.\nWe require that each chance variable’s instantiation time be no earlier than its parent chance variable’s instantiation times, i.e. if chance variable X ′ ∈ Pa[X ], then t(X ′) ≤ t(X).\nDefinition 4: A decision D is defined by:\n1. the player making the decision, pl(D). A player may make multiple decisions, but not more than one at the same time step. The set of decisions belonging to a player ℓ is denoted by Decs[ℓ].\n2. its decision time t(D) ∈ {1, . . . , T}.\n3. its action set Dom[D], a nonempty set of actions.\n4. the set of payoff times pt(D) ⊆ {1, . . . , T}. We assume that τ ≥ t(D) for all τ ∈ pt(D).\n5. its observation set O[D]: a set of decisions, actions, and chance variables, whose configuration at time t(D) − 1 (i.e. Ct(D)−1\nO[D] ) is observed by pl(D) prior to making the decision. We require that if decision D′ is an observation of D, then t(D′) < t(D). Furthermore if chance variableX is an observation of D, then t(X) < t(D).\nDefinition 5: Each action A at each time τ is associated with one utility function U τA. Each U τ A is associated with a set of parents Pa[U τA], which is a set of actions and chance variables. We require that if chance variable X ∈ Pa[U τA], then t(X) ≤ τ . Each utility functionU τA is a mapping from the set of configurations CτPa[Uτ\nA ]\nto a real value.\nWe can now formally define TAGGs.\nDefinition 6: A Temporal Action-Graph Game (TAGG) is a tuple (N,T,A,X ,D,U), where:\n1. N = {1, . . . , n} is a set of players.\n2. T is the duration of the game.\n3. A is a set of actions.\n4. X is a set of chance variables. Let G be the induced directed graph over X . We require that G be a directed acyclic graph (DAG).\n5. D is the set of decisions. we require that each decision D’s action set Dom[D] ⊆ A.\n6. U = {U τA : A ∈ A, 1 ≤ τ ≤ T } is the set of utility functions.\nFirst, let us see how to represent Example 1 as a TAGG. The set N corresponds to the cars. The duration T = 4. We have one action node for each lane. For each time τ , we have five decisions, each belonging to a car that arrives at time τ . The action set for each decision is the entire set A. The payoff time for each decision is the time the\ndecision is made, i.e., pt(D) = {t(D)}. Each decision has all actions as observations. For each A and τ , the utility U τA has A as its only parent. The representation size of each utility function is at most n; the size of the entire TAGG is O(|A|Tn).\nThe TAGG representation is useful beyond compactly representing MAIDs. The representation can also be used to specify information structures that would be difficult to represent in a MAID. For example, we can represent games in which agents’ abilities to observe the decisions made by previous agents depend on what actions these agents took.\nExample 7: There are 2T ice cream vendors, each of which must choose a location along a beach. For every day from 1 to T , two of the vendors simultaneously set up their ice cream stands. Each vendor lives in one of the locations. When a vendor chooses an action, it knows the location of vendors who set up stands in previous days in the location where it lives or in one of the neighboring locations. The payoff to a vendor in a given day depends on how many vendors set up stands in the same location or in a neighboring location.\nExample 7 can be represented as a TAGG, the key elements of which are as follows. There is an action A for each location. Each player j has one decision Dj , whose observations include actions for the location j lives in and neighboring locations. The payoff time for each decision is T , and the utility function UTA has A and its neighboring locations as parents.\nLet us consider the size of a TAGG. It follows from Definition 6 that the space bottlenecks of the representation are the CPTs Pr(X |Pa[X ]) and the utility functions U τA, which have polynomial sizes when the numbers of their parents are bounded by a constant.\nLemma 8 : Given TAGG (N,T,A,X ,D,U), if maxX∈X |Pa[X ]| and maxU∈U |Pa[U ]| are bounded by a constant, then the size of the TAGG is bounded by a polynomial in maxX∈X Dom[X ], |X |, |D|, |U|, and T ."
    }, {
      "heading" : "2.3 Strategies",
      "text" : "We now define an agent’s strategies in a TAGG. We start with pure strategies, where at each decision D, an action is chosen deterministically as a function of observed information, i.e., the configuration Ct(D)−1\nO[D] . In game theory, pure strategies are not generally sufficient (e.g., for guaranteeing existence of Nash equilibrium). We often want to consider strategies in which players randomize over their choices when making decisions. A mixed strategy of a player i is a probability distribution over pure strategies of i. Use of mixed strategies is problematic, because the choices at different decisions may be correlated, which allows a player to condition her later choice on her earlier decisions, regardless of whether these earlier decisions are observed by\nher. In other words, mixed strategies allow a player to act as if she observes more information than what is specified by the game. We thus restrict our attention to behavior strategies, in which the action choices at different decisions are randomized independently.\nDefinition 9: A behavior strategy at decision D is a function σD : Ct(D)−1\nO[D] → ϕ(Dom[D]), where ϕ(Dom[D]) is the set of probability distributions over Dom[D]. A behavior strategy for player i, denoted σi, is a tuple consisting of a behavior strategy for each of her decisions. A behavior strategy profile σ = (σ1, . . . , σn) consists of a behavior strategy σi for all i.\nAn agent has perfect recall when she never forgets her action choices and observations at earlier decisions. Equilibria in behavior strategies always exist in games of perfect recall [12]. However, strategies in perfect recall games can be computationally expensive to represent and reason about. In single-agent settings, perfect recall can be relaxed using limited memory influence diagrams (LIMIDs) [17]. For multi-agent imperfect recall games, existence of Nash equilibria in behavior strategies is not guaranteed; nevertheless one might still want to search for Nash equilibria using heuristic algorithms. There have also been positive results for certain types of imperfect recall games, where information irrelevant to the utility can be safely forgotten, e.g. [15]. The TAGG representation does not enforce perfect recall; TAGGs can represent perfect recall games as well as non-perfect-recall games."
    }, {
      "heading" : "2.4 Expected Utility",
      "text" : "Now we use the language of Bayesian networks to formally define an agent’s expected utility in a TAGG given a behavior strategy profile σ. Specifically, we define an induced BN that formally describes how the TAGG is played out. The induced BN is over a set of random variables representing decisions, chance variables, action counts and utilities. Given a behavioral strategy profile, decisions, chance variables and utilities can naturally be understood as random variables. On the other hand, action counts are timedependent. Thus, we have a separate action count variable for each action at each time step.\nDefinition 10: Let A ∈ A be an action and τ ∈ {1, ..., T} be a time point. Aτ denotes the action count variable representing the number of times A was chosen from time 1 to time τ . Let A0 be the variable which is constantly 0.\nWe would like to define expected utility for each player, which is the sum of expected utilities of her decisions. On the other hand, the utility functions in TAGGs are action specific. To bridge the gap, we create new decision-payoff variables in the induced BN that represent the utilities of decisions received at each of their payoff time points.\nDefinition 11: Given a TAGG and a behavior strategy profile σ, the induced BN is defined over the following variables: for each decision D ∈ D there is a variable which by abuse of notation we shall also denote by D; for each chance variable X ∈ X there is a variable which we shall also denote by X ; there is a variable Aτ for each action A ∈ A and time step τ ∈ {1, ..., T}; for each utility function U τA for actions A ∈ A and time points τ ∈ {1, ..., T}, there is a utility variable also denoted by U τA; for each decision D and each time τ ∈ pt(D), there is a decision-payoff variable uτD.\nWe define the actual parents of each variable V , denoted APa[V ], as follows: The actual parents of a decision variable D are the variables corresponding to O[D], with each action Ak ∈ O[D] replaced by A t(D)−1 k . The actual parents of an action count variable Aτ are all decision variables D whose decision time t(D) ≤ τ and A ∈ Dom[D]. The actual parents of a chance variable X are the variables corresponding to Pa[X ], with each action Ak ∈ Pa[X ] replaced by A t(X) k . The actual parents of a utility variable U τA are the variables corresponding to Pa[U τA], with each action Ak ∈ Pa[U τ A] replaced by A τ k . where {A1, ..., Aℓ} = Dom[D].\nThe CPDs of chance variables are the CPDs of the corresponding chance variables in the TAGG. The CPD of each decision variable D is the behavior strategy σD. The CPD of each utility variable U τA is a deterministic function defined by the corresponding utility function U τA. The CPD of each action count variable Aτ is a deterministic function that counts the number of decisions in APa[A] that are assigned value A. The CPD of each decision-payoff variable uτD is a multiplexer, i.e. a deterministic function that selects the value of its utility variable parent according to the choice of its decision parent. For example, if the value of D is Ak, then the value of uτD is the value of U τ Ak .\nTheorem 12: Given a TAGG, let F be the directed graph over the variables of the induced BN in which there is an edge from V1 to V2 iff V1 is an actual parent of V2. Then F is acyclic.\nThis follows from the definition of TAGGs and the way we set up the actual parents in Definition 11.\nBy Theorem 12, the induced BN defines a joint probability distribution over its variables, which we denote by Pσ . Given σ, denote by Eσ [V ] the expected value of variable V in the induced BN. We are now ready to define the expected utility to players under behavior strategy profiles.\nDefinition 13 : The expected utility to player ℓ under behavior strategy profile σ is EUσ(ℓ) = ∑\nD∈Decs[ℓ] ∑ τ∈pt(D) E σ [uτD].\nFigure 1 shows an induced BN of a TAGG based on Example 1 with six cars and three lanes. Note that although we\nuse squares to represent decision variables, they are random variables and not actual decisions as in influence diagrams."
    }, {
      "heading" : "2.5 The Induced MAID of a TAGG",
      "text" : "Given a TAGG we can construct a MAID that describes the same game. We use a similar construction as the induced Bayesian Network, but with two differences. First, instead of decision variables with CPDs assigned by σ, we have decision nodes in the MAID. Second, each decision-payoff variable uτD becomes a utility node for player pl(D) in the MAID. The resulting MAID describes the same game as the TAGG, because it offers agents the same strategies and their expected utilities are defined by the same BN. We call this the induced MAID of the TAGG."
    }, {
      "heading" : "2.6 Expressiveness",
      "text" : "It is natural to ask about the expressiveness of TAGGs: what games can we represent? It turns out that TAGGs are at least as expressive as MAIDs.\nLemma 14: Any MAID can be represented as a TAGG with the same space complexity.\nAs a result, TAGGs can represent any extensive form games representable as MAIDs. These include all perfect recall games, and the subclass of imperfect recall games where each information set does not involve multiple time steps.\nOn the other hand, since the induced MAID of a TAGG is payoff equivalent to the TAGG, it trivially follows that any TAGG can be represented by a MAID. However, the induced MAID has a large in-degree, and can thus be exponentially larger than the TAGG. For example, in the games\nof Examples 1 and 7, the induced MAIDs have max indegrees that are equal to the number of decisions, which implies that the sizes of the MAIDs grow exponentially with the number of decisions, whereas the sizes of the TAGGs for the same games grow linearly in the number of decisions. This is not surprising, since TAGGs can exploit more kinds of structure in the game (CSI, anonymity) compared to a straightforward MAID representation. In Section 3.1 we show that the induced MAID can be transformed into a MAID that explicitly represents the underlying structure. The size of the transformed MAID is polynomial in the size of the TAGG.\nThe TAGG representation is also a true generalization of AGGs, since any simultaneous-move AGG can be straightforwardly represented as a TAGG with T = 1."
    }, {
      "heading" : "3 Computing Expected Utility",
      "text" : "A compact game representation is not very useful if we cannot perform game-theoretic computations efficiently with respect to the size of the representation. In this section, we consider the task of computing expected utility EUσ [j] to a player j given a mixed strategy profile σ. Computation of EU is an essential step in many game-theoretic computations, such as finding a best response given other players’ strategy profile, and the iterated best response algorithm, which is not guaranteed to converge but finds a Nash equilibrium if it converges. In Section 4 we discuss extending our methods in this section to a subtask in the GovidanWilson algorithm for computing Nash equilibria, which is guaranteed to converge. Thus we can achieve speedup of all these computations by speeding up their bottleneck steps.\nOne benefit of formally defining EU in terms of BNs is that now the problem of computing EU can be naturally cast as a Bayes-net inference problem. By Definition 13, EUσ [j] is the sum of a polynomial number of terms of the form Eσ [uτD]. We thus focus on computing one such E\nσ [uτD]. This can be computed by applying a standard Bayes-net inference algorithm on the induced BN. In fact, Bayes-net inference is the standard approach for computing expected utility in MAIDs [11]. Thus the above approach for TAGGs is computationally equivalent to the standard approach for a natural MAID representation of the same game. In this section, we show that the induced BNs of TAGGs have special structure that can be exploited to speed up computation, and present an algorithm that exploits this structure."
    }, {
      "heading" : "3.1 Exploiting causal independence",
      "text" : "The standard BN inference approach for computing EU does not take advantage of some kinds of TAGG structure. In particular, recall that in the induced network, each action count variable Aτ ’s parents are all previous decisions that have Aτ in their action sets, implying large in-degrees for\naction variables. Considering for example the clique-tree algorithm, this means large clique sizes, which is problematic because running time scales exponentially in the largest clique size of the clique tree. However, the CPDs of these action count variables are structured counting functions. Such structure is an instance of causal independence in BNs [7]. It also corresponds to anonymity structure for static game representations like symmetric games and AGGs [8].\nWe can exploit this structure to speed up computation of expected utility in TAGGs. Our approach is a specialization of Heckerman and Breese’s method [7] for exploiting causal independence in BNs. At a high level, Heckerman and Breese’s method transforms the original BN by creating new nodes that represent intermediate results, and rewiring some of the arcs, resulting in an equivalent BN with small in-degree. They then apply conventional inference algorithms on the new BN. For example, given an action count variable Aτk with parents {D1 . . . Dℓ}, create a node Mi for each i ∈ {1 . . . ℓ − 1}, representing the count induced by D1 . . . Di. Then, instead of having D1 . . . Dℓ as parents of Aτk, its parents become Dℓ and Mℓ−1, and each Mi’s parents are Di and Mi−1. The resulting graph would have in-degree at most 2 for Aτk and the Mi’s.\nIn our induced BN, the action count variables Atk at earlier time steps t < τ already represent some of these intermediate counts, so we do not need to duplicate them. Formally, we modify the original BN in the following way: for each action count variable Aτk , first remove the edges from its current parents. Instead, Aτk now has two parents: the action count variableAτ−1k and a new nodeM τ Ak\nrepresenting the contribution of decisions at time τ to the count of Ak. If there is more than one decision at time τ that has Ak in its action set, we create intermediate variables as in Heckerman and Breese’s method. We call the resulting BN the transformed BN of the TAGG. Figure 2 shows the transformed BN of the tollbooth game whose induced BN was given in Figure 1.\nWe can then use standard algorithms to compute probabilities P (ut ′\nD) on the transformed BN. For classes of BNs with bounded treewidths, these probabilities (and thus E[ut ′\nD])\ncan be computed in polynomial time."
    }, {
      "heading" : "3.2 Exploiting temporal structure",
      "text" : "In practice, the standard inference approaches use heuristics to find an elimination ordering. This might not be optimal for our BNs. We present an algorithm based on the idea of eliminating variables in the temporal order. For the rest of the section, we fix D and a time t′ ∈ pt(D) and consider the computation of Eσ [ut ′\nD].\nWe first group the variables of the induced network by time steps: variables at time τ include decisions at τ , action count variables Aτ , chance variables X with instantiation time τ , intermediate nodes between decisions and action counts at τ , and utility variables U τA. As we are only concerned about Eσ [ut ′\nD] for a t ′ ∈ pt(D), we can safely dis-\ncard the variables after time t′, as well as utility variables before t′. It is straightforward to verify that the actual parents of variables at time τ are either at τ or before τ .\nWe say a network satisfies the Markov property if the actual parents of variables at time τ are either at τ or at τ−1. Parts of the induced BN (e.g. the action count variables) already satisfy the Markov property, but in general the network does not satisfy the property. Exceptions include chance variable parents and decision parents from more than one time step ago.\nGiven an induced BN, we can transform it into an equivalent network satisfying the Markov property. If a variable V1 at t1 is a parent of variable V2 at t2, with t2 − t1 > 1, then for each t1 < τ < t2 we create a dummy variable V τ1 belonging to time τ so that we copy the value of V1 to V t2−11 . We then delete the edge from V1 to V2 and add an edge from V t2−11 to V2.\nThe Markov property is computationally desirable because variables in time τ d-separate past variables from future variables. A straightforward approach to exploiting the Markov property is the following: as τ goes from 1 to t′, compute the joint distribution over variables at τ using the joint distribution over variables at τ − 1.\nIn fact, we can do better by adapting the interface algorithm [4] for dynamic Bayesian networks (DBNs) to our setting.2 Define the interface Iτ to be the set of variables in time τ that have children in time τ + 1. Iτ d-separates past from future, where past is all variables before τ and noninterface variables in τ , and future is all variables after τ .\nIn an induced BN, Iτ consists of: action count variables at time τ ; chance variables X at time τ that have children in\n2Whereas in DBNs the set of variables for each time step remains the same, for our setting this is no longer the case. It turns out that the interface algorithm can be adapted to work on our transformed BNs. Also, the transformed BNs of TAGGs have more structure than DBNs, particularly within the same time step, which we exploit for further computational speedup.\nfuture; decisions at τ that are observed by future decisions; decision D which is a parent of ut ′\nD, and dummy variables created by the transform.\nWe define the set of effective variables at time τ , denoted by Vτ , as the subset of Iτ that are ancestors of ut ′\nD. For time t′, we let Vt ′ = {ut ′\nD}. Intuitively, at each time step τ we only need to keep track of the distribution P (Vτ ), which acts as a sufficient statistic as we go forward in time. For each τ , we calculate P (Vτ ) by conditioning on instantiations of P (Vτ−1). The interface algorithm for TAGGs can be summarized as the following:\n1. compute distribution P (V0)\n2. for τ = 1 to t′\n(a) for each instantiation of Vτ−1, vτ−1j , compute the distribution over Vτ : P (\nV τ |Vτ−1 = vτ−1j\n)\n(b) P (Vτ ) = ∑ v P ( V τ |Vτ−1 = v ) P ( V τ−1 = v )\n3. since Vt ′ = {ut ′ D}, we now have P (u t′ D) 4. return the expected value E[ut ′\nD]\nWe can further improve on this, in particular on the subtask of computing P (Vτ |Vτ−1). We observe that there is also a temporal order among variables in each time τ : first the decisions and intermediate variables, then action count variables, and finally chance variables. Partition Vτ into four subsets consisting of action count variables Aτ , chance variables Xτ , decision variables Dτ and dummy copy variables Cτ . Then P (Vτ |Vτ−1) can be factored into P (Cτ |Vτ−1)P (Dτ ,Aτ |Vτ−1)P (Xτ |Aτ ,Vτ−1). This allows us to first focus on decisions and action count variables to compute P (Dτ ,Aτ |Vτ−1) and then carry out inference on the chance variables.\nCalculating P (Dτ ,Aτ |Vτ−1) involves eliminating all decision variables not in Dτ as well as the intermediate variables. Note that conditioned on Vτ−1, all decisions at time τ are independent. This allows us to efficiently eliminate variables along the chains of intermediate variables. Let the decisions at time τ be {Dτ1 , . . . , D τ ℓ }. Let M\nτ be the set of intermediate variables corresponding to action count variables in Aτ . Let Mτk be the subset of M\nτ that summarizes the contribution of Dτ1 , . . . , D τ k . We eliminate variables in the order Dτ1 , D τ 2 ,M τ 2 , D τ 3 ,M τ 3 , . . . ,M τ ℓ , except for decisions in Dτ . The tables in the variable elimination algorithm need to keep track of at most |Dτ | + |Aτ | variables. Thus the complexity of computing P (Dτ ,Aτ |Vτ−1) for an instantiation of Vτ−1 is exponential only in |Dτ |+|Aτ |.\nComputing P (Xτ |Aτ ,Vτ−1) for each instantiation of A\nτ ,Vτ−1 involves eliminating the chance variables not in Xτ . Any standard inference algorithm can be applied here. The complexity is exponential in the treewidth of the induced BN restricted on all chance variables at time τ , which we denote by Gτ .\nPutting everything together, the bottleneck of our algorithm is constructing the tables for the joint distributions on Vτ , as well as doing inference on Gτ .\nTheorem 15: Given a TAGG and behavior strategy profile σ, if for all τ , both |Vτ | and the treewidth of Gτ are bounded by a constant, then for any player j the expected utility EUσ [j] can be computed in time polynomial in the size of the TAGG representation and the size of σ.\nOur algorithm is especially effective for induced networks that are close to having the Markov property, in which case we only add a small number of dummy copy variables to Vτ . The time complexity of computing expected utility then grows linearly in the duration of the game. On the other hand, for induced networks far from having the Markov property, |Vτ | can grow linearly as τ increases, implying that the time complexity is exponential."
    }, {
      "heading" : "3.3 Context-specific independence",
      "text" : "TAGGs have action-specific utility functions, which allows them to express context-specific payoff independence: which utility function is used depends on which action is chosen at the decision. This is translated to context-specific independence structure in the induced BN, specifically in the CPD of uτD. Conditioned on the value of D, u τ D only depends on one of its utility variable parents.\nThere are several ways of exploiting such structure computationally, including conditioning on the value of the decision D [3], or exploiting the context-specific independence in a variable elimination algorithm [19]. One particularly simple approach that works for multiplexer utility nodes is to decompose the utility into a sum of utilities [18]. For each utility node parent U tk of u t D, there is a utility function utD,k that depends on U t k and D. If D = k, u t D,k is equal to U tk. Otherwise, u t D,k is 0. It is easy to see that utD(U t 1, . . . , U t m, D) = ∑m k=1 u t D,k(U t k, D).\nWe can then modify our algorithm to compute each E[utD,k] instead of E[u t D]. This results in a reduction in the set of effective variables Vτk , which are now the variables at τ that are ancestors of utD,k. Furthermore, whenever Vτk = V τ k′ for some k, k\n′, the distributions over them are identical and thus can be reused.\nFor static games represented as TAGGs with T = 1, our algorithm is equivalent to the polynomial-time expected utility algorithm [8] for AGGs.\nApplying our algorithm to tollbooth games of Example 1 and ice cream games of Example 7, we observe that for both cases Vτ consists of a subset of action count variables at τ plus the decision whose utility we are computing. Therefore the expected utilities of these games can be computed in polynomial time if |A| is bounded by a constant."
    }, {
      "heading" : "4 Computing Nash Equilibria",
      "text" : "Nash equilibrium is one of the central solution concepts of game theory. Since the induced MAID of a TAGG is payoff equivalent to the TAGG, algorithms for computing the Nash equilibria of MAIDs [11; 15; 2] can be directly applied to an induced MAID to find Nash equilibria of a TAGG. However, this approach does not exploit all TAGG structure. We can do better by constructing a transformed MAID, in a manner similar to the transformed BN, exploiting causal independence and CSI as in Sections 3.1 and 3.3.\nWe can do better yet and exploit the temporal structure as described in Section 3.2, if we use a solution algorithm that requires computation of probabilities and expected utilities. Govindan and Wilson [6] presented an algorithm for computing equilibria in perfect-recall extensive-form games using a continuation method. Blum, Shelton and Koller [2] adapted this algorithm to MAIDs. A key step in the algorithm is, for each pair of players i and j, and one of i’s utility nodes, computing the marginal distribution over i’s decisions and their parents, j’s decisions and their parents, and the utility node. Our algorithm in Section 3.2 can be adapted to compute this distribution. This approach is efficient if each player only has a small number of decisions, as in the games in Examples 1 and 7."
    }, {
      "heading" : "5 Experiments",
      "text" : "We have implemented our algorithm for computing expected utility in TAGGs, and run experiments on the efficiency and scalability of our algorithm. We compared three approaches for computing expected utility given a TAGG:\nApproach 1 applying the standard clique tree algorithm (as implemented by the Bayes Net Toolbox [16]) on the induced BN;\nApproach 2 applying the same clique tree algorithm on the transformed BN;\nApproach 3 our proposed algorithm.\nAll approaches were implemented in MATLAB. All our experiments were performed using a computer cluster consisting of machines with dual Intel Xeon 3.2GHz CPUs, 2MB cache and 2GB RAM.\nWe ran experiments on tollbooth game instances of varying sizes. For each game instance we measured the CPU times for computing expected utility of 100 random behavior strategy profiles. Figure 3 (left) shows the results in log scale for toll booth games with 3 lanes and 5 cars per time step, with the duration varying from 1 to 15. Approach 1 ran out of memory for games with more than 1 time step. Approach 2 was more scalable; but ran out of memory for games with more than 5 time steps. Approach 3 was the most scalable. On smaller instances it was faster\nthan the other two approaches by an order of magnitude, and it did not run out of memory as we increased the size of the TAGGs to at least 20 time steps. For the toll booth game with 14 time steps it took 1279 seconds, which is approximately the time Approach 2 took for the game instance with 5 time steps. Figure 3 (middle) shows the results in log scale for tollbooth games with 3 time steps and 3 lanes, varying the number of cars per time step from 1 to 20. Approach 1 ran out of memory for games with more than 3 cars per time step; Approach 2 ran out of memory for games with more than 6 cars per time step; and again Approach 3 was the most scalable.\nWe also ran experiments on the ice cream games of Example 7. Figure 3 (right) shows the results in log scale for ice cream games with 4 locations, two vendors per time step, and durations varying from 1 to 15. The home locations for each vendor were generated randomly. Approaches 1 and 2 ran out of memory for games with more than 3 and 4 time steps, respectively. Approach 3 finished for games with 15 time steps in about the same time as Approach 2 took for games with 4 time steps."
    }, {
      "heading" : "6 Conclusions",
      "text" : "TAGGs are a novel graphical representation of imperfectinformation extensive-form games. They are an extension of simultaneous-move AGGs to the dynamic setting; and can be thought of as a sequence of AGGs played over T time steps, with action counts accumulating as time progresses. This process can be formally described by the induced BN. For situations with anonymity or CSI structure, the TAGG representation can be exponentially more compact than a direct MAID representation. We presented an algorithm for computing expected utility for TAGGs that exploits its anonymity, CSI as well as temporal structure. We showed both theoretically and empirically that our approach is significantly more efficient than the standard approach on a direct MAID representation of the same game."
    } ],
    "references" : [ {
      "title" : "Computing Nash equilibria of Action-Graph Games",
      "author" : [ "N. Bhat", "K. Leyton-Brown" ],
      "venue" : "UAI",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "A continuation method for Nash equilibria in structured games",
      "author" : [ "B. Blum", "C. Shelton", "D. Koller" ],
      "venue" : "IJCAI",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Context-specific independence in Bayesian networks",
      "author" : [ "C. Boutilier", "N. Friedman", "M. Goldszmidt", "D. Koller" ],
      "venue" : "UAI, pages 115–123",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "Constant-space reasoning in dynamic Bayesian networks",
      "author" : [ "A. Darwiche" ],
      "venue" : "International Journal of Approximate Reasoning, 26(3):161–178",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Game Theory",
      "author" : [ "D. Fudenberg", "J. Tirole" ],
      "venue" : "MIT Press",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Structure theorems for game trees",
      "author" : [ "S. Govindan", "R. Wilson" ],
      "venue" : "Proceedings of the National Academy of Sciences, 99(13):9077–9080",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Causal independence for probability assessment and inference using Bayesian networks",
      "author" : [ "D. Heckerman", "J.S. Breese" ],
      "venue" : "IEEE Transactions on Systems, Man and Cybernetics, Part A, 26(6):826–831",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "A polynomial-time algorithm for Action-Graph Games",
      "author" : [ "A.X. Jiang", "K. Leyton-Brown" ],
      "venue" : "AAAI",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Action-graph games",
      "author" : [ "A.X. Jiang", "K. Leyton-Brown", "N. Bhat" ],
      "venue" : "Technical Report TR-2008-13, University of British Columbia",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Graphical models for game theory",
      "author" : [ "M.J. Kearns", "M.L. Littman", "S.P. Singh" ],
      "venue" : "UAI",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Multi-agent influence diagrams for representing and solving games",
      "author" : [ "D. Koller", "B. Milch" ],
      "venue" : "Games and Economic Behavior, 45(1):181–221",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Extensive games and the problem of information",
      "author" : [ "H. Kuhn" ],
      "venue" : "Harold Kuhn and Arthur Tucker, editors, Contributions to the Theory of Games, volume II, pages 193–216",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 1953
    }, {
      "title" : "Game networks",
      "author" : [ "P. La Mura" ],
      "venue" : "UAI",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Local-effect games",
      "author" : [ "K. Leyton-Brown", "M. Tennenholtz" ],
      "venue" : "IJCAI",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Ignorable information in multiagent scenarios",
      "author" : [ "B. Milch", "D. Koller" ],
      "venue" : "Technical Report MIT-CSAIL-TR-2008- 029, MIT",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Bayes Net Toolbox for Matlab",
      "author" : [ "K. Murphy" ],
      "venue" : "http://bnt.sourceforge.net",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Evaluating influence diagrams using LIMIDs",
      "author" : [ "D. Nilsson", "S.L. Lauritzen" ],
      "venue" : "UAI, pages 436–445",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Probabilistic reasoning for complex systems",
      "author" : [ "A. Pfeffer" ],
      "venue" : "PhD thesis, Computer Science Department, Stanford University",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Exploiting contextual independence in probabilistic inference",
      "author" : [ "D. Poole", "N.L. Zhang" ],
      "venue" : "Journal of Artificial Intelligence Research, 18:263–313",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "A class of games possessing pure-strategy Nash equilibria",
      "author" : [ "R.W. Rosenthal" ],
      "venue" : "International Journal of Game Theory, 2:65–67",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 1973
    }, {
      "title" : "Computational analysis of perfect-information position auctions",
      "author" : [ "David R.M. Thompson", "Kevin Leyton-Brown" ],
      "venue" : "In ACM-EC,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2009
    } ],
    "referenceMentions" : [ {
      "referenceID" : 4,
      "context" : ", [5]).",
      "startOffset" : 2,
      "endOffset" : 5
    }, {
      "referenceID" : 10,
      "context" : "For imperfectinformation extensive form games, the most influential model is multiagent influence diagrams, or MAIDs [11].",
      "startOffset" : 117,
      "endOffset" : 121
    }, {
      "referenceID" : 12,
      "context" : "(Game networks are a very similar representation and were invented concurrently [13].",
      "startOffset" : 80,
      "endOffset" : 84
    }, {
      "referenceID" : 1,
      "context" : ") MAIDs are compact when players’ utility functions exhibit independencies; such compactness can also be leveraged for computational benefit [2].",
      "startOffset" : 141,
      "endOffset" : 144
    }, {
      "referenceID" : 9,
      "context" : ", non-extensive-form) games [10].",
      "startOffset" : 28,
      "endOffset" : 32
    }, {
      "referenceID" : 7,
      "context" : "Furthermore, structure in AGGs can be leveraged for computational benefit [8].",
      "startOffset" : 74,
      "endOffset" : 77
    }, {
      "referenceID" : 20,
      "context" : "AGGs have been used to model realworld systems such as auctions for search engine keywords [21].",
      "startOffset" : 91,
      "endOffset" : 95
    }, {
      "referenceID" : 11,
      "context" : "Equilibria in behavior strategies always exist in games of perfect recall [12].",
      "startOffset" : 74,
      "endOffset" : 78
    }, {
      "referenceID" : 16,
      "context" : "In single-agent settings, perfect recall can be relaxed using limited memory influence diagrams (LIMIDs) [17].",
      "startOffset" : 105,
      "endOffset" : 109
    }, {
      "referenceID" : 14,
      "context" : "[15].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 10,
      "context" : "In fact, Bayes-net inference is the standard approach for computing expected utility in MAIDs [11].",
      "startOffset" : 94,
      "endOffset" : 98
    }, {
      "referenceID" : 6,
      "context" : "Such structure is an instance of causal independence in BNs [7].",
      "startOffset" : 60,
      "endOffset" : 63
    }, {
      "referenceID" : 7,
      "context" : "It also corresponds to anonymity structure for static game representations like symmetric games and AGGs [8].",
      "startOffset" : 105,
      "endOffset" : 108
    }, {
      "referenceID" : 6,
      "context" : "Our approach is a specialization of Heckerman and Breese’s method [7] for exploiting causal independence in BNs.",
      "startOffset" : 66,
      "endOffset" : 69
    }, {
      "referenceID" : 3,
      "context" : "In fact, we can do better by adapting the interface algorithm [4] for dynamic Bayesian networks (DBNs) to our setting.",
      "startOffset" : 62,
      "endOffset" : 65
    }, {
      "referenceID" : 2,
      "context" : "There are several ways of exploiting such structure computationally, including conditioning on the value of the decision D [3], or exploiting the context-specific independence in a variable elimination algorithm [19].",
      "startOffset" : 123,
      "endOffset" : 126
    }, {
      "referenceID" : 18,
      "context" : "There are several ways of exploiting such structure computationally, including conditioning on the value of the decision D [3], or exploiting the context-specific independence in a variable elimination algorithm [19].",
      "startOffset" : 212,
      "endOffset" : 216
    }, {
      "referenceID" : 17,
      "context" : "One particularly simple approach that works for multiplexer utility nodes is to decompose the utility into a sum of utilities [18].",
      "startOffset" : 126,
      "endOffset" : 130
    }, {
      "referenceID" : 7,
      "context" : "For static games represented as TAGGs with T = 1, our algorithm is equivalent to the polynomial-time expected utility algorithm [8] for AGGs.",
      "startOffset" : 128,
      "endOffset" : 131
    }, {
      "referenceID" : 5,
      "context" : "Govindan and Wilson [6] presented an algorithm for computing equilibria in perfect-recall extensive-form games using a continuation method.",
      "startOffset" : 20,
      "endOffset" : 23
    }, {
      "referenceID" : 1,
      "context" : "Blum, Shelton and Koller [2] adapted this algorithm to MAIDs.",
      "startOffset" : 25,
      "endOffset" : 28
    }, {
      "referenceID" : 15,
      "context" : "Approach 1 applying the standard clique tree algorithm (as implemented by the Bayes Net Toolbox [16]) on the induced BN;",
      "startOffset" : 96,
      "endOffset" : 100
    } ],
    "year" : 2009,
    "abstractText" : "In this paper we introduce temporal action graph games (TAGGs), a novel graphical representation of imperfect-information extensive form games. We show that when a game involves anonymity or context-specific utility independencies, its encoding as a TAGG can be much more compact than its direct encoding as a multiagent influence diagram (MAID). We also show that TAGGs can be understood as indirect MAID encodings in which many deterministic chance nodes are introduced. We provide an algorithm for computing with TAGGs, and show both theoretically and empirically that our approach improves significantly on the previous state of the art.",
    "creator" : null
  }
}