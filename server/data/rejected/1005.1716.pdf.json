{
  "name" : "1005.1716.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Heuristics in Conflict Resolution",
    "authors" : [ "Christian Drescher", "Martin Gebser", "Torsten Schaub" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "Introduction",
      "text" : "The popularity of Answer Set Programming (ASP; (Baral 2003)) as a paradigm for knowledge representation and reasoning is mainly due to two factors: first, its rich modeling language and, second, the availability of highperformance ASP systems. In fact, modern ASP solvers, such as clasp (Gebser et al. 2007a), cmodels (Giunchiglia, Lierler, & Maratea 2006), and smodelscc (Ward & Schlipf 2004), have meanwhile closed the gap to Boolean Satisfiability (SAT; (Mitchell 2005)) solvers. In both fields, conflict-driven learning and related techniques have led to significant performance boosts (Bayardo & Schrag 1997; Marques-Silva & Sakallah 1999; Moskewicz et al. 2001; Gebser et al. 2007d). The basic prerequisite for the application of such techniques is conflict analysis, that is, the extraction of non-trivial reasons for dead ends encountered during search. Even though ASP and SAT solvers exploit different inference patterns, their underlying search techniques are closely related to each other. For instance, the basic search strategy of SAT solver chaff (Moskewicz et al. 2001), nowadays a quasi standard in SAT solving, is also exploited by ASP solver clasp, in particular, the principles of conflict analysis are similar. Vice versa, the solution enumeration approach implemented in clasp (Gebser et al. 2007b) could also be applied by SAT solvers. Given these similarities, general search or, more specifically, conflict analysis techniques developed in one community can\n(almost) immediately be exploited in the other field too. In this paper, we address the problem of identifying “good” reasons for conflicts to be recorded within an ASP solver. In fact, conflict-driven learning exhibits several degrees of freedom. For instance, several constraints may become violated simultaneously, in which case one can choose the conflict(s) to be analyzed. Furthermore, distinct schemes may be used for conflict analysis, such as the resolutionbased First-UIP and Last-UIP scheme (Zhang et al. 2001). Finally, if conflict analysis is based on resolution, several constraints may be suitable resolvents, likewise permitting to eliminate some literal in a resolution step.\nFor the feasibility of our study, it was necessary to prune dimensions of freedom in favor of predominant options. In the SAT area, the First-UIP scheme (Marques-Silva & Sakallah 1999) has empirically been shown to yield better performance than other known conflict resolution strategies (Zhang et al. 2001). We thus fix the conflict analysis strategy to conflict resolution according to the First-UIP scheme. Furthermore, it seems reasonable to analyze the first conflict detected by a solver (although conflicts encountered later on may actually yield “better” reasons). This leaves to us the choice of the resolvents to be used for conflict resolution, and we investigate this issue with respect to different goals: reducing the size of reasons to be recorded, skipping greater portions of the search space by backjumping (explained below), reducing the number of conflict resolution steps, and reducing the overall number of encountered conflicts (roughly corresponding to runtime). To this end, we modified the conflict analysis procedure of our ASP solver clasp1 for accommodating a variety of heuristics for choosing resolvents. The developed heuristics and comprehensive empirical results for them are presented in this paper."
    }, {
      "heading" : "Logical Background",
      "text" : "We assume basic familiarity with answer set semantics (see, for instance, (Baral 2003)). This section briefly introduces notations and recalls a constraint-based characterization of answer set semantics according to (Gebser et al. 2007c). We consider propositional (normal) logic programs over an alphabet P . A logic program is a finite set of rules\np0 ← p1, . . . , pm,∼pm+1, . . . ,∼pn (1) 1http://www.cs.uni-potsdam.de/clasp\nar X\niv :1\n00 5.\n17 16\nv1 [\ncs .A\nI] 1\n1 M\nay 2\n01 0\nwhere 0 ≤ m ≤ n and pi ∈ P is an atom for 0 ≤ i ≤ n. For a rule r as in (1), let head(r) = p0 be the head of r and body(r) = {p1, . . . , pm,∼pm+1, . . . ,∼pn} be the body of r. The set of atoms occurring in a logic program Π is denoted by atom(Π), and the set of bodies in Π is body(Π) = {body(r) | r ∈ Π}. For regrouping bodies sharing the same head p, define body(p) = {body(r) | r ∈ Π, head(r) = p}.\nFor characterizing the answer sets of a program Π, we consider Boolean assignments A over domain dom(A) = atom(Π) ∪ body(Π). Formally, an assignment A is a sequence (σ1, . . . , σn) of (signed) literals σi of the form Tv or Fv for v ∈ dom(A) and 1 ≤ i ≤ n. Intuitively, Tv expresses that v is true and Fv that it is false in A. We denote the complement of a literal σ by σ, that is, Tv = Fv and Fv = Tv. Furthermore, we let A ◦ B denote the sequence obtained by concatenating two assignments A and B. We sometimes abuse notation and identify an assignment with the set of its contained literals. Given this, we access the true and false propositions in A via AT = {p ∈ dom(A) | Tp ∈ A} and AF = {p ∈ dom(A) | Fp ∈ A}. Finally, we denote the prefix of A up to a literal σ by\nA[σ] = { (σ1, . . . , σm) if A = (σ1, . . . , σm, σ, . . . , σn) A if σ /∈ A .\nIn our context, a nogood (Dechter 2003) is a set {σ1, . . . , σm} of literals, expressing a constraint violated by any assignment containing σ1, . . . , σm. An assignment A such that AT ∪AF = dom(A) and AT ∩AF = ∅ is a solution for a set ∆ of nogoods if δ 6⊆ A for all δ ∈ ∆. Given a logic program Π, we below specify nogoods such that their solutions correspond to the answer sets of Π.\nWe start by describing nogoods capturing the models of the Clark’s completion (Clark 1978) of a program Π. For (β = {p1, . . . , pm,∼pm+1, . . . ,∼pn}) ∈ body(Π), let\n∆β = {Tp1, . . . ,Tpm,Fpm+1, . . . ,Fpn,Fβ},{Fp1,Tβ}, . . . , {Fpm,Tβ},{Tpm+1,Tβ}, . . . , {Tpn,Tβ}  .\nObserve that every solution for ∆β must assign body β equivalent to the conjunction of its elements. Similarly, for an atom p ∈ atom(Π), the following nogoods stipulate p to be equivalent to the disjunction of body(p) = {β1, . . . , βk}:\n∆p = { {Fβ1, . . . ,Fβk,Tp}, {Tβ1,Fp}, . . . , {Tβk,Fp} } .\nCombining the above nogoods for Π, we get ∆Π = ⋃ β∈body(Π)∆β ∪ ⋃ p∈atom(Π)∆p .\nThe solutions for ∆Π correspond one-to-one to the models of the completion of Π. If Π is tight (Fages 1994; Erdem & Lifschitz 2003), these models are guaranteed to match the answer sets of Π. This can be formally stated as follows.\nTheorem 1 ((Gebser et al. 2007c)) Let Π be a tight logic program. Then, X ⊆ atom(Π) is an answer set of Π iff X = AT ∩ atom(Π) for a (unique) solution A for ∆Π.\nWe proceed by considering non-tight programs Π. As shown in (Lin & Zhao 2004), loop formulas can be added to the completion of Π to establish full correspondence to the answer sets of Π. For U ⊆ atom(Π), let EBΠ(U) be\n{body(r) | r ∈ Π, head(r) ∈ U, body(r) ∩ U = ∅} .\nObserve that EBΠ(U) contains the bodies of all rules in Π that can externally support (Lee 2005) an atom in U . Given U = {p1, . . . , pj} and EBΠ(U) = {β1, . . . , βk}, the following nogoods capture the loop formula of U :\nΛU = { {Fβ1, . . . ,Fβk,Tp1}, . . . , {Fβ1, . . . ,Fβk,Tpj} } .\nFurthermore, we define ΛΠ = ⋃ U⊆atom(Π)ΛU .\nBy augmenting ∆Π with ΛΠ, Theorem 1 can be extended to non-tight programs. Theorem 2 ((Gebser et al. 2007c)) Let Π be a logic program. Then, X ⊆ atom(Π) is an answer set of Π iff X = AT∩atom(Π) for a (unique) solutionA for ∆Π∪ΛΠ.\nBy virtue of Theorem 2, the nogoods in ∆Π ∪ ΛΠ provide us with a constraint-based characterization of the answer sets of Π. However, it is important to note that the size of ∆Π is linear in atom(Π)×body(Π), while ΛΠ contains exponentially many nogoods. As shown in (Lifschitz & Razborov 2006), under current assumptions in complexity theory, the exponential number of elements in ΛΠ is inherent, that is, it cannot be reduced significantly in the worst case. Hence, ASP solvers do not determine the nogoods in ΛΠ a priori, but include mechanisms to determine them on demand. This is illustrated further in the next section."
    }, {
      "heading" : "Algorithmic Background",
      "text" : "This section recalls the basic decision procedure of clasp (Gebser et al. 2007c), abstracting Conflict-Driven Clause Learning (CDCL; (Mitchell 2005)) for SAT solving from clauses, that is, Conflict-Driven Nogood Learning (CDNL)."
    }, {
      "heading" : "Conflict-Driven Nogood Learning",
      "text" : "Algorithm 1 shows our main procedure for deciding whether a program Π has some answer set. The algorithm starts with an empty assignment A and an empty set ∇ of recorded nogoods (Lines 1–2). Note that dynamic nogoods added to ∇ in Line 5 are elements of ΛΠ, while those added in Line 9 result from conflict analysis (Line 8). In addition to conflict-driven learning, the procedure performs backjumping (Lines 10–11), guided by a decision level k determined by conflict analysis. Via decision level dl , we count decision literals, that is, literals in A that have been heuristically selected in Line 15. The initial value of dl is 0 (Line 3), and it is incremented in Line 16 before a decision literal is added to A (Line 17). All literals in A that are not decision literals have been derived by propagation in Line 5, and we call them implied literals. For any literal σ in A, we write dl(σ) to refer to the decision level of σ, that is, the value dl had when σ was added to A. After propagation, the main loop\nAlgorithm 1: CDNL Input : A program Π. Output: An answer set of Π. A← ∅ // assignment over atom(Π) ∪ body(Π)1 ∇ ← ∅ // set of (dynamic) nogoods2 dl ← 0 // decision level3 loop4 (A,∇)← PROPAGATION(Π,∇, A)5 if ε ⊆ A for some ε ∈ ∆Π ∪∇ then6\nif dl = 0 then return no answer set7 (δ, k)← CONFLICTANALYSIS(ε,Π,∇, A)8 ∇ ← ∇∪ {δ}9 A← A \\ {σ ∈ A | k < dl(σ)}10 dl ← k11\nelse if AT ∪AF = atom(Π) ∪ body(Π) then12 return AT ∩ atom(Π)13 else14 σd ← SELECT(Π,∇, A)15 dl ← dl + 116 A← A ◦ (σd)17\n(Lines 4–17) distinguishes three cases: a conflict detected via a violated nogood (Lines 6–11), a solution (Lines 12– 13), or a heuristic selection with respect to a partial assignment (Lines 14–17). Finally, note that a conflict at decision level 0 signals that Π has no answer set (Line 7)."
    }, {
      "heading" : "Propagation",
      "text" : "Our propagation procedure, shown in Algorithm 2, derives implied literals and adds them to A. Lines 3–9 describe unit propagation (cf. (Mitchell 2005)) on ∆Π∪∇. If a conflict is detected in Line 4, unit propagation terminates immediately (Line 5). Otherwise, in Line 6, we determine all nogoods δ that are unit-resulting wrt A, that is, the complement σ of some literal σ ∈ δ must be added to A because all other literals of δ are already true inA. If there is some unit-resulting nogood δ (Line 7), A is augmented with σ in Line 8. Observe that δ is chosen non-deterministically, and several distinct nogoods may imply σ wrt A. This non-determinism gives rise to our study of heuristics for conflict resolution, selecting a resolvent among the nogoods δ that imply σ.\nThe second part of Algorithm 2 (Lines 10–14) checks for unit-resulting or violated nogoods in ΛΠ. If Π is tight (Line 10), sophisticated checks are unnecessary (cf. Theorem 1). Otherwise, we consider sets U ⊆ atom(Π) such that EBΠ(U) ⊆ AF, called unfounded sets (Van Gelder, Ross, & Schlipf 1991). An unfounded set U is determined in Line 12 by a dedicated algorithm, whereU∩AF = ∅. If such a nonempty unfounded set U exists, each nogood δ ∈ ΛU is either unit-resulting or violated wrt A, and an arbitrary δ ∈ ΛU is recorded in Line 14 for triggering unit propagation. Note that all atoms in U must be falsified before another unfounded set is determined (cf. Lines 11–12). Eventually, propagation terminates in Line 13 if no nonempty unfounded set has been detected in Line 12.\nAlgorithm 2: PROPAGATION Input : A program Π, a set∇ of nogoods, and an\nassignment A. Output: An extended assignment and set of nogoods. U ← ∅ // unfounded set1 loop2 repeat3 if δ ⊆ A for some δ ∈ ∆Π ∪∇ then4 return (A,∇)5 Σ← {δ ∈ ∆Π ∪∇ | δ \\A = {σ}, σ /∈ A}6 if Σ 6= ∅ then let σ ∈ δ \\A for some δ ∈ Σ in7\nA← A ◦ (σ)8 until Σ = ∅9 if TIGHT(Π) then return (A,∇)10 U ← U \\AF11 if U = ∅ then U ← UNFOUNDEDSET(Π, A)12 if U = ∅ then return (A,∇)13 let δ ∈ ΛU in∇ ← ∇∪ {δ}14\nAlgorithm 3: CONFLICTANALYSIS Input : A violated nogood δ, a program Π, a set ∇ of\nnogoods, and an assignment A. Output: A derived nogood and a decision level. loop1 let σ ∈ δ such that δ \\A[σ] = {σ}2 k ← max ({dl(ρ) | ρ ∈ δ \\ {σ}} ∪ {0})3 if k = dl(σ) then4 Σ← {ε ∈ ∆Π ∪∇ | ε \\A[σ] = {σ}}5 ε← SELECTANTECEDENT(Σ)6 δ ← (δ \\ {σ}) ∪ (ε \\ {σ})7\nelse return (δ, k)8"
    }, {
      "heading" : "Conflict Analysis",
      "text" : "Algorithm 3 shows our conflict analysis procedure, which is based on resolution. Given a nogood δ that is violated wrt A, we determine in Line 2 the literal σ ∈ δ added last to A. If σ is the single literal of its decision level dl(σ) in δ (cf. Line 3), it is called a unique implication point (UIP; (Marques-Silva & Sakallah 1999)). Among a number of conflict resolution schemes, the First-UIP scheme, stopping conflict resolution as soon as the first UIP is reached, has turned out to be the most efficient and most robust strategy (Zhang et al. 2001). Our conflict analysis procedure follows the First-UIP scheme by performing conflict resolution only if σ is not a UIP (tested in Line 4) and, otherwise, returning δ along with the smallest decision level k at which σ is implied by δ after backjumping (Line 8).\nLet us take a closer look at conflict resolution steps in Lines 5–7. It is important to note that, if σ is not a UIP, it cannot be the decision literal of dl(σ). Rather, it must have been implied by some nogood ε ∈ ∆Π ∪ ∇. As a consequence, the set Σ determined in Line 5 cannot be empty, and\nwe call its elements antecedents of σ. Note that each antecedent ε contains σ and had been unit-resulting immediately before σ was added to A; we thus call ε \\ {σ} a reason for σ. Knowing that σ may have more than one antecedent, a non-deterministic choice among them is made in Line 6. Exactly this choice is subject to the heuristics studied below. Furthermore, as σ is the literal of δ added last toA, δ\\{σ} is also a reason for σ. Since they imply complementary literals, no solution can jointly contain both reasons, viz., δ\\{σ} and ε \\ {σ}. Hence, combining them in Line 7 gives again a nogood violated wrt A. Finally, note that conflict resolution is guaranteed to terminate at some UIP, but different heuristic choices in Line 6 may result in different UIPs."
    }, {
      "heading" : "Implication Graphs and Conflict Graphs",
      "text" : "To portray the matter of choosing among several distinct antecedents, we modify the notion of an implication graph (Beame, Kautz, & Sabharwal 2004). At a given state of CDNL, the implication graph contains a node for each literal σ in assignment A and, for a violated nogood δ ⊆ A, a node σ is included, where σ is the literal of δ added last toA, that is, δ \\ A[σ] = {σ}. Furthermore, for each antecedent δ of an implied literal σ, the implication graph contains directed edges labeled with δ from all literals in the reason δ \\ {σ} to σ. Different from (Beame, Kautz, & Sabharwal 2004), where implication graphs reflect exactly one reason per implied literal, our implication graph thus includes all of them. If the implication graph contains both σ and σ, we call them conflicting literals. Note that an implication graph contains at most one such pair {σ, σ}, called conflicting assignment, because our propagation procedure in Algorithm 2 stops as soon as a nogood becomes violated (cf. Lines 4–5).\nAn exemplary implication graph is shown in Figure 1. Each of its nodes (except for one among the two conflicting literals) corresponds to a literal that is true in assignment\nA = ( Fa,Fb,Fp,Tq,Tr,Ts,Fv,Tt,Fu,Fw,Tx ) .\nThe three decision literals in A are underlined, and all other literals are implied. For each literal σ, its decision level dl(σ) is also provided in Figure 1 in parentheses. Every edge is labeled with at least one antecedent of its target, that is, the edges represent the following nogoods:\nn0 = {Fa,Tb} n1 = {Tr,Fs} n2 = {Ts,Ft} n3 = {Ts,Tu} n4 = {Ts,Tw} n5 = {Tr,Tv} n6 = {Tq,Fv,Tw} n7 = {Tt,Fu,Fx} n8 = {Fp,Tt,Fx} n9 = {Fw,Tx} .\nFurthermore, nogood {Ta} is unit-resulting wrt the empty assignment, thus, implied literal Fa (whose decision level is 0) does not have any incoming edge. Observe that the implication graph contains conflicting assignment {Tx,Fx}, where Tx has been implied by nogood n7 and likewise by n8. It is also the last literal inA belonging to violated nogood n9, so that its complement Fx is the second conflicting literal in the implication graph. Besides Tx, literal Fw has multiple antecedents, namely, n4 and n6, which can be read off the labels of the incoming edges of Fw.\nThe conflict resolution done in Algorithm 3, in particular, the heuristic choice of antecedents in Line 6, can now be viewed as an iterative projection of the implication graph. In fact, if an implied literal has incoming edges with distinct labels, all edges with a particular label are taken into account, while the edges with different labels only are dropped. This observation motivates the following definition: a subgraph of an implication graph is a conflict graph if it contains a conflicting assignment and, for each implied literal σ in the subgraph, the set of predecessors of σ is a reason for σ. Note that this definition allows us to drop all literals that do not have a path to any conflicting literal, such as Fa and Fb in Figure 1. Furthermore, the requirement that the predecessors of an implied literal form a reason corresponds to the selection of an antecedent, where only the incoming edges with a particular label are traced via conflict resolution.\nThe next definition accounts for a particularity of ASP solving related to unfounded set handling: a conflict graph is level-aware if each conflicting literal σ has some predecessor ρ such that dl(ρ) = dl(σ). In fact, propagation in Algorithm 2 is limited to falsifying unfounded atoms, thus, unit propagation on nogoods in ΛΠ is performed only partially and may miss implied literals corresponding to external bodies (cf. (Gebser et al. 2007c)). If a conflict graph is not level-aware, the violated nogood δ provided as input to Algorithm 3 already contains a UIP, thus, δ itself is returned without performing any conflict resolution inbetween. Given that we are interested in conflict resolution, we below consider level-aware conflict graphs only.\nFinally, we characterize nogoods derived by Algorithm 3 by cuts in conflict graphs (cf. (Zhang et al. 2001; Beame, Kautz, & Sabharwal 2004)). A conflict cut in a conflict graph is a bipartition of the nodes such that all decision literals belong to one side, called reason side, and the conflicting assignment is contained in the other side, called conflict side. The set of nodes on the reason side that have some edge into the conflict side form the conflict nogood associated with a particular conflict cut. For illustration, a First-New-Cut (Beame, Kautz, & Sabharwal 2004) is shown in Figure 2. For the underlying conflict graph, we can choose among the"
    }, {
      "heading" : "Reason",
      "text" : "incoming edges of Tx whether to include the edges labeled with n7 or the ones labeled with n8. With n7, we get conflict nogood {Tt,Fu,Fw}, while n8 yields {Fp,Tt,Fw}.\nDifferent conflict cuts correspond to different resolution schemes, where we are particularly interested in the FirstUIP scheme. Given a conflict graph and conflicting assignment {σ, σ}, a UIP σUIP can be identified as a node such that all paths from σd, the decision literal of decision level dl(σ) = dl(σ), to either σ or σ go through σUIP (cf. (Zhang et al. 2001)). In view of this alternative definition of a UIP, it becomes even more obvious than before that σd is indeed a UIP, also called the Last-UIP. In contrast, a literal σUIP is the First-UIP if it is the UIP “closest” to the conflicting literals, that is, if no other UIP is reachable from σUIP . The First-UIP-Cut is then given by the conflict cut that has all literals lying on some path from the First-UIP to a conflicting literal, except for the First-UIP itself, on the conflict side and all other literals (including the First-UIP) on the reason side. The First-UIP-Nogood, that is, the conflict nogood associated with the First-UIP-Cut, is exactly the nogood derived by conflict resolution in Algorithm 3 when antecedents that contribute edges to the conflict graph are selected for conflict resolution. Also note that the First-UIP-Cut for a conflict graph is unique, thus, by projecting an implication graph to a conflict graph, we implicitly fix the First-UIP-Nogood. With this is mind, the next section deals with heuristics for extracting conflict graphs from implication graphs."
    }, {
      "heading" : "Heuristics",
      "text" : "In this section, we propose several heuristics for conflict resolution striving for different goals."
    }, {
      "heading" : "Recording Short Nogoods",
      "text" : "Under the assumption that short nogoods prune larger portions of the search space than longer ones, a First-UIPNogood looks the more attractive the less literals it contains. In addition, unit propagation on shorter nogoods is usually faster and might even be enabled to use particularly optimized data structures, for instance, specialized to binary or ternary nogoods (Ryan 2004). As noticed in (Mahajan, Fu,"
    }, {
      "heading" : "Reason",
      "text" : "& Malik 2005), a conflict nogood stays short when the resolvents are short, when the number of resolvents is small, or when the resolvents have many literals in common. In the SAT area, it has been observed that preferring short nogoods in conflict resolution may lead to resolution sequences involving mostly binary and ternary nogoods, so that derived conflict nogoods are not much longer than the originally violated nogoods (Mitchell 2005). Our first heuristics,Hshort , thus selects an antecedent containing the smallest number of literals among the available antecedents of a literal. Given the same implication graph as in Figure 1 and 2, Hshort may yield the conflict graph shown in Figure 3 by preferring antecedent n7 of Tx over n8 and antecedent n4 of Fw over n6 during conflict resolution. The corresponding FirstUIP-Nogood, {Ts}, is indeed short and enables CDNL to after backjumping derive Fs by unit propagation at decision level 0. However, the antecedents n7 and n8 of Tx are of the same size, thus, Hshort may likewise pick n8, in which case the First-UIP-Cut in Figure 4 is obtained. The corresponding First-UIP-Nogood, {Fp,Ts}, is longer. Nonetheless, our experiments below empirically confirm that Hshort tends to reduce the size of First-UIP-Nogoods. But before, we describe further heuristics focusing also on other aspects."
    }, {
      "heading" : "Performing Long Backjumps",
      "text" : "By backjumping, CDNL may skip the exhaustive exploration of regions of the search space, possibly escaping spare regions not containing any solution. Thus, it seems reasonable to aim at First-UIP-Nogoods such that their literals belong to small decision levels, as they are the determining factor for the lengths of backjumps. Our second heuristics, Hlex , thus uses a lexicographic order to rank antecedents according to the decision levels of their literals. Given an antecedent δ of a literal σ, we arrange the literals in the reason δ \\ {σ} for σ in descending order of their decision levels. The so obtained sequence (σ1, . . . , σm), where δ \\ {σ} = {σ1, . . . , σm}, induces a descending list levels(δ) = (dl(σ1), . . . , dl(σm)) of decision levels. An antecedent δ is then considered to be smaller than another antecedent ε, viz., δ < ε, if the first element that differs in levels(δ) and levels(ε) is smaller in levels(δ) or if levels(δ)"
    }, {
      "heading" : "Reason",
      "text" : "is a prefix of levels(ε) and shorter than levels(ε). Due to the last condition, Hlex also prefers an antecedent δ that is shorter than ε, provided that literals of the same decision levels as in δ are also found in ε. Reconsidering the implication graph in Figure 1 and 2, we obtain levels(n8) = (3, 1) < (3, 3) = levels(n7) for antecedents n7 and n8 of Tx, and we have levels(n4) = (3) < (3, 2) = levels(n6) for antecedents n4 and n6 of Fw. By selecting antecedents that are lexicographically smallest, Hlex leads us to the conflict graph shown in Figure 4. In this example, the corresponding First-UIP-Nogood, {Fp,Ts}, is weaker than {Ts}, which may be obtained with Hshort (cf. Figure 3).\nGiven that lexicographic comparisons are computationally expensive, we also consider a lightweight variant of ranking antecedents according to decision levels. Our third heuristics, Havg , prefers an antecedent δ over ε if the average of levels(δ) is smaller than the average of levels(ε). In our example, we get avg [levels(n8)] = avg(3, 1) = 2 < 3 = avg(3, 3) = avg [levels(n7)] and avg [levels(n6)] = avg(3, 2) = 2.5 < 3 = avg(3) = avg [levels(n4)], yielding the conflict graph shown in Figure 5. Unfortunately, the corresponding First-UIP-Nogood, {Fp,Tq,Tr}, does not match the goal of Havg as backjumping only returns to decision level 2, where Tr is then flipped to Fr. Note that this behavior is similar to chronological backtracking, which can be regarded as the most trivial form of backjumping."
    }, {
      "heading" : "Shortening Conflict Resolution",
      "text" : "Our fourth heuristics,Hres , aims at speeding up conflict resolution itself by shortening resolution sequences. In order to earlier encounter a UIP, Hres prefers antecedents such that the number of literals at the current decision level dl is smallest. In our running example,Hres prefers n8 over n7 as it contains fewer literals whose decision level is 3. However, antecedents n4 and n6 of Fw are indifferent, thus,Hres may yield either one of the conflict graphs in Figure 4 and 5."
    }, {
      "heading" : "Search Space Pruning",
      "text" : "The heuristics presented above rank antecedents merely by structural properties, thus disregarding their contribution in the past to solving the actual problem. The latter is estimated by nogood deletion heuristics of SAT solvers (Goldberg &"
    }, {
      "heading" : "Reason",
      "text" : "Novikov 2002; Mahajan, Fu, & Malik 2005), and clasp also maintains activity scores for nogoods (Gebser et al. 2007a). Our fifth heuristics, Hactive , makes use of them and ranks antecedents according to their activities.\nFinally, we investigate a heuristics,Hprop , that stores (and prefers) the smallest decision level at which a nogood has ever been unit-resulting. The intuition underlying Hprop is that the number of implied literals at small decision levels can be viewed as a measure for the progress of CDNL, in particular, as attesting unsatisfiability requires a conflict at decision level 0. Thus, it might be a good idea to prefer nogoods that gave rise to implications at small decision levels."
    }, {
      "heading" : "Experiments",
      "text" : "For their empirical assessment, we have implemented the heuristics proposed above in a prototypical extension of our ASP solver clasp version 1.0.2. (Even though there are newer versions of clasp, a common testbed, omitting some optimizations, is sufficient for a representative comparison.) Note that clasp (Gebser et al. 2007a) incorporates various advanced Boolean constraint solving techniques, e.g.: • lookback-based decision heuristics (Goldberg & Novikov\n2002), • restart and nogood deletion policies (Eén & Sörensson\n2003), • watched literals for unit propagation on “long” nogoods\n(Moskewicz et al. 2001), • dedicated treatment of binary and ternary nogoods (Ryan\n2004), and • early conflict detection (Mahajan, Fu, & Malik 2005). Due to this variety, the solving process of clasp is a complex interplay of different features. Thus, it is almost impossible to observe the impact of a certain feature, such as our conflict resolution heuristics, in isolation. However, we below use a considerable number of benchmark classes with different characteristics and shuffled instances, so that noise effects should be compensated at large.\nFor accommodating conflict resolution heuristics considering several antecedents per literal, the low-level implementation of clasp had to be modified. These modifications\nare less optimized than the original implementation, so that our prototype incurs some disadvantages in raw speed that can potentially be reduced by optimizing the implementation. However, for comparison, we include unmodified clasp version 1.0.2, not applying any particular heuristics in conflict resolution. Given that unit propagation in clasp privileges binary and ternary nogoods, they are more likely to be used as antecedents than longer nogoods, as original clasp simply stores the first antecedent it encounters and ignores others. In view of this, unit propagation of original clasp leads conflict resolution into the same direction as Hshort , though in a less exact way. The next table summarizes all clasp variants and conflict resolution heuristics under consideration, denoting the unmodified version simply by clasp:\nLabel Heuristics Goal clasp — speeding up unit propagation claspshort Hshort recording short nogoods clasplex Hlex performing long backjumps claspavg Havg performing long backjumps claspres Hres shortening conflict resolution claspactive Hactive search space pruning claspprop Hprop search space pruning\nNote that all clasp variants perform early conflict detection, that is, they encounter a unique conflicting assignment before beginning with conflict resolution. Furthermore, all of them perform conflict resolution according to the First-UIP scheme. Thus, we do not explore the first two among the three degrees of freedom mentioned in the introductory section and concentrate fully on the choice of resolvents.\nWe conducted experiments on the benchmarks used in categories SCore and SLparse of the first ASP system competition (Gebser et al. 2007d). Tables 1–4 group benchmark instances by their classes, viz., Classes 1–11. Via superscripts s and r in the first column, we indicate whether the n instances belonging to a class are structured (e.g., 15-Puzzle) or randomly generated (e.g., BlockedN-Queens). We omit classifying Factoring, which is a worst-case problem where an efficient algorithm would yield a cryptographic attack. Furthermore, Tables 1–4 show results for computing one answer set or deciding that an instance has no answer set. For each benchmark instance, we performed five runs on different shuffles, resulting in 5n runs per benchmark class. All experiments were run on a 3.4GHz PC under Linux; each run was limited to 600s time and 1GB RAM. Note that, in Tables 1–3, we consider only the instances on which runs were completed by all considered clasp variants.\nTable 1 shows the average lengths of First-UIP-Nogoods for the heuristics aiming at short nogoods, implemented by claspshort and clasplex , among which the latter uses the lengths of antecedents as a tie breaker. For comparison, we also include original clasp. On most benchmark classes, we observe that claspshort as well as clasplex tend to reduce the lengths of First-UIP-Nogoods, up to 14 percent shorter than the ones of clasp on BlockedN-Queens. But there remains only a slight reduction of about 6 percent shorter FirstUIP-Nogoods of clasplex in the summary of all benchmark classes (weighted equally). We also observe that claspshort , more straightly preferring short antecedents than clasplex ,\ndoes not reduce First-UIP-Nogood lengths any further. Interestingly, there is no clear distinction between structured and randomly generated instances, neither regarding magnitudes nor reduction rates of First-UIP-Nogood lengths.\nTable 2 shows the average backjump lengths in terms of decision levels for the clasp variants aiming at long backjumps, viz., claspavg and clasplex . We note that average backjump lengths of more than 2 decision levels indicate structured instances, except for BoundedSpanningTree. Regarding the increase of backjump lengths, claspavg does not exhibit significant improvements, and the polarity of differences to original clasp varies. Only the more sophisticated heuristics of clasplex almost consistently leads to increased backjump lengths (except for HamiltonianPath), but the amounts of improvements are rather small.\nTable 3 shows the average numbers of conflict resolution steps for claspres and clasplex , among which the former particularly aims at their reduction. Somewhat surprisingly, claspres in all performs more conflict resolution steps even than original clasp, while clasplex almost consistently exhibits a reduction of conflict resolution steps (except for Su-Doku). This negative result for claspres suggests that trimming conflict resolution regardless of its outcome is not advisable. The quality of recorded nogoods certainly is a key factor for the performance of conflict-driven learning solvers for ASP and SAT, thus, shallow savings in their retrieval are not worth it and might even be counterproductive globally.\nFinally, Table 4 provides average numbers of conflicts and average runtimes in seconds for all clasp variants. For each benchmark class, the first line provides the average numbers of conflicts encountered on instances where runs were completed by all clasp variants, while the second line gives the average times of completed runs and numbers of timeouts in parentheses. (Recall that all clasp variants were run on 5n shuffles of the n instances per class, leading to more than n timeouts on BlockedN-Queens and, with some clasp variants, also on Solitaire.) At the bottom of Table 4, we summarize average numbers of conflicts and average runtimes over all benchmark classes (weighted equally). Note that the last but one line provides the sums of timeouts in parentheses, while the last line penalizes timeouts with max-\nimum time, viz., 600 seconds. As mentioned above, original clasp is highly optimized and does not suffer from the overhead incurred by the extended infrastructure for applying heuristics in conflict resolution. As a consequence, we observe that original clasp outperforms its variants on most benchmark classes as regards runtime. Among the variants of clasp, claspavg in all exhibits the best average number of conflicts and runtime. However, it also times out most often and behaves unstable, as the poor performance on Classes 2 and 11 shows. In contrast, claspshort and clasplex lead to fewest timeouts (in fact, as many timeouts as clasp), and clasplex encounters fewer conflicts than claspshort . Variant claspactive , preferring “critical” antecedents, exhibits a comparable performance, while claspres and claspprop yield more timeouts and also encounter relatively many conflicts. Overall, we notice that some clasp variants perform reasonably well, but without significantly decreasing the number of conflicts in comparison to original clasp. As there is no clear winner among our clasp variants, unfortunately, they do not suggest any “universal” conflict resolution heuristics."
    }, {
      "heading" : "Discussion",
      "text" : "We have proposed a number of heuristics for conflict resolution and conducted a systematic empirical study in the context of our ASP solver clasp. However, it is too early to conclude any dominant approach or to make general recommendations. As has also been noted in (Mitchell 2005), conflict resolution strategies are almost certainly important but have received little attention in the literature so far. In fact, dedicated approaches in the SAT area (Ryan 2004; Mahajan, Fu,\n& Malik 2005) merely aim at reducing the size of recorded nogoods. Though this might work reasonably well in practice, it is unsatisfactory when compared to sophisticated decision heuristics (Goldberg & Novikov 2002; Ryan 2004; Mahajan, Fu, & Malik 2005; Dershowitz, Hanna, & Nadel 2005) resulting from more profound considerations. We thus believe that heuristics in conflict resolution deserve further attention. Future lines of research may include developing more sophisticated scoring mechanisms than the ones proposed here, combining several scoring criterions, or even determining and possibly recording multiple reasons for a conflict (corresponding to different conflict graphs). Any future improvements in these directions may significantly boost the state-of-the-art in both ASP and SAT solving."
    } ],
    "references" : [ {
      "title" : "Knowledge Representation, Reasoning and Declarative Problem Solving",
      "author" : [ "C. Baral" ],
      "venue" : "Cambridge University Press.",
      "citeRegEx" : "Baral,? 2003",
      "shortCiteRegEx" : "Baral",
      "year" : 2003
    }, {
      "title" : "Using CSP look-back techniques to solve real-world SAT instances",
      "author" : [ "R. Bayardo", "R. Schrag" ],
      "venue" : "Proceedings of the Fourteenth National Conference on Artificial Intelligence (AAAI’97), 203–208. AAAI Press/MIT Press.",
      "citeRegEx" : "Bayardo and Schrag,? 1997",
      "shortCiteRegEx" : "Bayardo and Schrag",
      "year" : 1997
    }, {
      "title" : "Towards understanding and harnessing the potential of clause learning",
      "author" : [ "P. Beame", "H. Kautz", "A. Sabharwal" ],
      "venue" : "Journal of Artificial Intelligence Research 22:319–351.",
      "citeRegEx" : "Beame et al\\.,? 2004",
      "shortCiteRegEx" : "Beame et al\\.",
      "year" : 2004
    }, {
      "title" : "Negation as failure",
      "author" : [ "K. Clark" ],
      "venue" : "Gallaire, H., and Minker, J., eds., Logic and Data Bases, 293–322. Plenum Press.",
      "citeRegEx" : "Clark,? 1978",
      "shortCiteRegEx" : "Clark",
      "year" : 1978
    }, {
      "title" : "Constraint Processing",
      "author" : [ "R. Dechter" ],
      "venue" : "Morgan Kaufmann Publishers.",
      "citeRegEx" : "Dechter,? 2003",
      "shortCiteRegEx" : "Dechter",
      "year" : 2003
    }, {
      "title" : "A clausebased heuristic for SAT solvers",
      "author" : [ "N. Dershowitz", "Z. Hanna", "A. Nadel" ],
      "venue" : "Bacchus, F., and Walsh, T., eds., Proceedings of the Eigth International Conference on Theory and Applications of Satisfiability Testing (SAT’05), 46–60. Springer-Verlag.",
      "citeRegEx" : "Dershowitz et al\\.,? 2005",
      "shortCiteRegEx" : "Dershowitz et al\\.",
      "year" : 2005
    }, {
      "title" : "An extensible SATsolver",
      "author" : [ "N. Eén", "N. Sörensson" ],
      "venue" : "Proceedings of the Sixth International Conference on Theory and Applications of Satisfiability Testing (SAT’03), 502–518.",
      "citeRegEx" : "Eén and Sörensson,? 2003",
      "shortCiteRegEx" : "Eén and Sörensson",
      "year" : 2003
    }, {
      "title" : "Tight logic programs",
      "author" : [ "E. Erdem", "V. Lifschitz" ],
      "venue" : "Theory and Practice of Logic Programming 3(4-5):499– 518.",
      "citeRegEx" : "Erdem and Lifschitz,? 2003",
      "shortCiteRegEx" : "Erdem and Lifschitz",
      "year" : 2003
    }, {
      "title" : "Consistency of Clark’s completion and the existence of stable models",
      "author" : [ "F. Fages" ],
      "venue" : "Journal of Methods of Logic in Computer Science 1:51–60.",
      "citeRegEx" : "Fages,? 1994",
      "shortCiteRegEx" : "Fages",
      "year" : 1994
    }, {
      "title" : "clasp: A conflict-driven answer set solver",
      "author" : [ "M. Gebser", "B. Kaufmann", "A. Neumann", "T. Schaub" ],
      "venue" : "Baral et al. (2007), 260–265.",
      "citeRegEx" : "Gebser et al\\.,? 2007a",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2007
    }, {
      "title" : "Conflict-driven answer set enumeration",
      "author" : [ "M. Gebser", "B. Kaufmann", "A. Neumann", "T. Schaub" ],
      "venue" : "Baral et al. (2007), 136–148.",
      "citeRegEx" : "Gebser et al\\.,? 2007b",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2007
    }, {
      "title" : "Conflict-driven answer set solving",
      "author" : [ "M. Gebser", "B. Kaufmann", "A. Neumann", "T. Schaub" ],
      "venue" : "Veloso, M., ed., Proceedings of the Twentieth International Joint Conference on Artificial Intelligence (IJCAI’07), 386–392. AAAI Press/MIT Press.",
      "citeRegEx" : "Gebser et al\\.,? 2007c",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2007
    }, {
      "title" : "The first answer set programming system competition",
      "author" : [ "M. Gebser", "L. Liu", "G. Namasivayam", "A. Neumann", "T. Schaub", "M. Truszczyński" ],
      "venue" : "Baral et al. (2007), 3–17.",
      "citeRegEx" : "Gebser et al\\.,? 2007d",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2007
    }, {
      "title" : "Answer set programming based on propositional satisfiability",
      "author" : [ "E. Giunchiglia", "Y. Lierler", "M. Maratea" ],
      "venue" : "Journal of Automated Reasoning 36(4):345–377.",
      "citeRegEx" : "Giunchiglia et al\\.,? 2006",
      "shortCiteRegEx" : "Giunchiglia et al\\.",
      "year" : 2006
    }, {
      "title" : "BerkMin: A fast and robust SAT solver",
      "author" : [ "E. Goldberg", "Y. Novikov" ],
      "venue" : "Proceedings of the Fifth Conference on Design, Automation and Test in Europe (DATE’02), 142– 149. IEEE Press.",
      "citeRegEx" : "Goldberg and Novikov,? 2002",
      "shortCiteRegEx" : "Goldberg and Novikov",
      "year" : 2002
    }, {
      "title" : "A model-theoretic counterpart of loop formulas",
      "author" : [ "J. Lee" ],
      "venue" : "Kaelbling, L., and Saffiotti, A., eds., Proceedings of the Nineteenth International Joint Conference on Artificial Intelligence (IJCAI’05), 503–508. Professional Book Center.",
      "citeRegEx" : "Lee,? 2005",
      "shortCiteRegEx" : "Lee",
      "year" : 2005
    }, {
      "title" : "Why are there so many loop formulas",
      "author" : [ "V. Lifschitz", "A. Razborov" ],
      "venue" : "ACM Transactions on Computational Logic 7(2):261–268",
      "citeRegEx" : "Lifschitz and Razborov,? \\Q2006\\E",
      "shortCiteRegEx" : "Lifschitz and Razborov",
      "year" : 2006
    }, {
      "title" : "ASSAT: computing answer sets of a logic program by SAT solvers",
      "author" : [ "F. Lin", "Y. Zhao" ],
      "venue" : "Artificial Intelligence 157(1-2):115–137.",
      "citeRegEx" : "Lin and Zhao,? 2004",
      "shortCiteRegEx" : "Lin and Zhao",
      "year" : 2004
    }, {
      "title" : "Zchaff2004: An efficient SAT solver",
      "author" : [ "Y. Mahajan", "Z. Fu", "S. Malik" ],
      "venue" : "Hoos, H., and Mitchell, D., eds., Proceedings of the Seventh International Conference on Theory and Applications of Satisfiability Testing (SAT’04), 360– 375. Springer-Verlag.",
      "citeRegEx" : "Mahajan et al\\.,? 2005",
      "shortCiteRegEx" : "Mahajan et al\\.",
      "year" : 2005
    }, {
      "title" : "GRASP: A search algorithm for propositional satisfiability",
      "author" : [ "J. Marques-Silva", "K. Sakallah" ],
      "venue" : "IEEE Transactions on Computers 48(5):506–521.",
      "citeRegEx" : "Marques.Silva and Sakallah,? 1999",
      "shortCiteRegEx" : "Marques.Silva and Sakallah",
      "year" : 1999
    }, {
      "title" : "A SAT solver primer",
      "author" : [ "D. Mitchell" ],
      "venue" : "Bulletin of the European Association for Theoretical Computer Science 85:112–133.",
      "citeRegEx" : "Mitchell,? 2005",
      "shortCiteRegEx" : "Mitchell",
      "year" : 2005
    }, {
      "title" : "Chaff: Engineering an efficient SAT solver",
      "author" : [ "M. Moskewicz", "C. Madigan", "Y. Zhao", "L. Zhang", "S. Malik" ],
      "venue" : "Proceedings of the Thirty-eighth Conference on Design Automation (DAC’01), 530–535. ACM Press.",
      "citeRegEx" : "Moskewicz et al\\.,? 2001",
      "shortCiteRegEx" : "Moskewicz et al\\.",
      "year" : 2001
    }, {
      "title" : "Efficient algorithms for clause-learning SAT solvers",
      "author" : [ "L. Ryan" ],
      "venue" : "Master’s thesis, Simon Fraser University.",
      "citeRegEx" : "Ryan,? 2004",
      "shortCiteRegEx" : "Ryan",
      "year" : 2004
    }, {
      "title" : "The wellfounded semantics for general logic programs",
      "author" : [ "A. Van Gelder", "K. Ross", "J. Schlipf" ],
      "venue" : "Journal of the ACM 38(3):620–650.",
      "citeRegEx" : "Gelder et al\\.,? 1991",
      "shortCiteRegEx" : "Gelder et al\\.",
      "year" : 1991
    }, {
      "title" : "Answer set programming with clause learning",
      "author" : [ "J. Ward", "J. Schlipf" ],
      "venue" : "Lifschitz, V., and Niemelä, I., eds., Proceedings of the Seventh International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’04), 302–313. Springer-Verlag.",
      "citeRegEx" : "Ward and Schlipf,? 2004",
      "shortCiteRegEx" : "Ward and Schlipf",
      "year" : 2004
    }, {
      "title" : "Efficient conflict driven learning in a Boolean satisfiability solver",
      "author" : [ "L. Zhang", "C. Madigan", "M. Moskewicz", "S. Malik" ],
      "venue" : "Proceedings of the International Conference on Computer-Aided Design (ICCAD’01), 279–285.",
      "citeRegEx" : "Zhang et al\\.,? 2001",
      "shortCiteRegEx" : "Zhang et al\\.",
      "year" : 2001
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "The popularity of Answer Set Programming (ASP; (Baral 2003)) as a paradigm for knowledge representation and reasoning is mainly due to two factors: first, its rich modeling language and, second, the availability of highperformance ASP systems.",
      "startOffset" : 47,
      "endOffset" : 59
    }, {
      "referenceID" : 9,
      "context" : "In fact, modern ASP solvers, such as clasp (Gebser et al. 2007a), cmodels (Giunchiglia, Lierler, & Maratea 2006), and smodelscc (Ward & Schlipf 2004), have meanwhile closed the gap to Boolean Satisfiability (SAT; (Mitchell 2005)) solvers.",
      "startOffset" : 43,
      "endOffset" : 64
    }, {
      "referenceID" : 20,
      "context" : "2007a), cmodels (Giunchiglia, Lierler, & Maratea 2006), and smodelscc (Ward & Schlipf 2004), have meanwhile closed the gap to Boolean Satisfiability (SAT; (Mitchell 2005)) solvers.",
      "startOffset" : 155,
      "endOffset" : 170
    }, {
      "referenceID" : 21,
      "context" : "In both fields, conflict-driven learning and related techniques have led to significant performance boosts (Bayardo & Schrag 1997; Marques-Silva & Sakallah 1999; Moskewicz et al. 2001; Gebser et al. 2007d).",
      "startOffset" : 107,
      "endOffset" : 205
    }, {
      "referenceID" : 12,
      "context" : "In both fields, conflict-driven learning and related techniques have led to significant performance boosts (Bayardo & Schrag 1997; Marques-Silva & Sakallah 1999; Moskewicz et al. 2001; Gebser et al. 2007d).",
      "startOffset" : 107,
      "endOffset" : 205
    }, {
      "referenceID" : 21,
      "context" : "For instance, the basic search strategy of SAT solver chaff (Moskewicz et al. 2001), nowadays a quasi standard in SAT solving, is also exploited by ASP solver clasp, in particular, the principles of conflict analysis are similar.",
      "startOffset" : 60,
      "endOffset" : 83
    }, {
      "referenceID" : 10,
      "context" : "Vice versa, the solution enumeration approach implemented in clasp (Gebser et al. 2007b) could also be applied by SAT solvers.",
      "startOffset" : 67,
      "endOffset" : 88
    }, {
      "referenceID" : 25,
      "context" : "Furthermore, distinct schemes may be used for conflict analysis, such as the resolutionbased First-UIP and Last-UIP scheme (Zhang et al. 2001).",
      "startOffset" : 123,
      "endOffset" : 142
    }, {
      "referenceID" : 25,
      "context" : "In the SAT area, the First-UIP scheme (Marques-Silva & Sakallah 1999) has empirically been shown to yield better performance than other known conflict resolution strategies (Zhang et al. 2001).",
      "startOffset" : 173,
      "endOffset" : 192
    }, {
      "referenceID" : 0,
      "context" : "We assume basic familiarity with answer set semantics (see, for instance, (Baral 2003)).",
      "startOffset" : 74,
      "endOffset" : 86
    }, {
      "referenceID" : 11,
      "context" : "This section briefly introduces notations and recalls a constraint-based characterization of answer set semantics according to (Gebser et al. 2007c).",
      "startOffset" : 127,
      "endOffset" : 148
    }, {
      "referenceID" : 4,
      "context" : "In our context, a nogood (Dechter 2003) is a set {σ1, .",
      "startOffset" : 25,
      "endOffset" : 39
    }, {
      "referenceID" : 3,
      "context" : "We start by describing nogoods capturing the models of the Clark’s completion (Clark 1978) of a program Π.",
      "startOffset" : 78,
      "endOffset" : 90
    }, {
      "referenceID" : 8,
      "context" : "If Π is tight (Fages 1994; Erdem & Lifschitz 2003), these models are guaranteed to match the answer sets of Π.",
      "startOffset" : 14,
      "endOffset" : 50
    }, {
      "referenceID" : 11,
      "context" : "Theorem 1 ((Gebser et al. 2007c)) Let Π be a tight logic program.",
      "startOffset" : 11,
      "endOffset" : 32
    }, {
      "referenceID" : 15,
      "context" : "Observe that EBΠ(U) contains the bodies of all rules in Π that can externally support (Lee 2005) an atom in U .",
      "startOffset" : 86,
      "endOffset" : 96
    }, {
      "referenceID" : 11,
      "context" : "Theorem 2 ((Gebser et al. 2007c)) Let Π be a logic program.",
      "startOffset" : 11,
      "endOffset" : 32
    }, {
      "referenceID" : 11,
      "context" : "This section recalls the basic decision procedure of clasp (Gebser et al. 2007c), abstracting Conflict-Driven Clause Learning (CDCL; (Mitchell 2005)) for SAT solving from clauses, that is, Conflict-Driven Nogood Learning (CDNL).",
      "startOffset" : 59,
      "endOffset" : 80
    }, {
      "referenceID" : 20,
      "context" : "2007c), abstracting Conflict-Driven Clause Learning (CDCL; (Mitchell 2005)) for SAT solving from clauses, that is, Conflict-Driven Nogood Learning (CDNL).",
      "startOffset" : 59,
      "endOffset" : 74
    }, {
      "referenceID" : 20,
      "context" : "(Mitchell 2005)) on ∆Π∪∇.",
      "startOffset" : 0,
      "endOffset" : 15
    }, {
      "referenceID" : 25,
      "context" : "Among a number of conflict resolution schemes, the First-UIP scheme, stopping conflict resolution as soon as the first UIP is reached, has turned out to be the most efficient and most robust strategy (Zhang et al. 2001).",
      "startOffset" : 200,
      "endOffset" : 219
    }, {
      "referenceID" : 11,
      "context" : "(Gebser et al. 2007c)).",
      "startOffset" : 0,
      "endOffset" : 21
    }, {
      "referenceID" : 25,
      "context" : "(Zhang et al. 2001; Beame, Kautz, & Sabharwal 2004)).",
      "startOffset" : 0,
      "endOffset" : 51
    }, {
      "referenceID" : 25,
      "context" : "(Zhang et al. 2001)).",
      "startOffset" : 0,
      "endOffset" : 19
    }, {
      "referenceID" : 22,
      "context" : "In addition, unit propagation on shorter nogoods is usually faster and might even be enabled to use particularly optimized data structures, for instance, specialized to binary or ternary nogoods (Ryan 2004).",
      "startOffset" : 195,
      "endOffset" : 206
    }, {
      "referenceID" : 20,
      "context" : "In the SAT area, it has been observed that preferring short nogoods in conflict resolution may lead to resolution sequences involving mostly binary and ternary nogoods, so that derived conflict nogoods are not much longer than the originally violated nogoods (Mitchell 2005).",
      "startOffset" : 259,
      "endOffset" : 274
    }, {
      "referenceID" : 9,
      "context" : "Novikov 2002; Mahajan, Fu, & Malik 2005), and clasp also maintains activity scores for nogoods (Gebser et al. 2007a).",
      "startOffset" : 95,
      "endOffset" : 116
    }, {
      "referenceID" : 9,
      "context" : ") Note that clasp (Gebser et al. 2007a) incorporates various advanced Boolean constraint solving techniques, e.",
      "startOffset" : 18,
      "endOffset" : 39
    }, {
      "referenceID" : 21,
      "context" : "• watched literals for unit propagation on “long” nogoods (Moskewicz et al. 2001),",
      "startOffset" : 58,
      "endOffset" : 81
    }, {
      "referenceID" : 22,
      "context" : "• dedicated treatment of binary and ternary nogoods (Ryan 2004), and",
      "startOffset" : 52,
      "endOffset" : 63
    }, {
      "referenceID" : 12,
      "context" : "We conducted experiments on the benchmarks used in categories SCore and SLparse of the first ASP system competition (Gebser et al. 2007d).",
      "startOffset" : 116,
      "endOffset" : 137
    }, {
      "referenceID" : 20,
      "context" : "As has also been noted in (Mitchell 2005), conflict resolution strategies are almost certainly important but have received little attention in the literature so far.",
      "startOffset" : 26,
      "endOffset" : 41
    }, {
      "referenceID" : 22,
      "context" : "Though this might work reasonably well in practice, it is unsatisfactory when compared to sophisticated decision heuristics (Goldberg & Novikov 2002; Ryan 2004; Mahajan, Fu, & Malik 2005; Dershowitz, Hanna, & Nadel 2005) resulting from more profound considerations.",
      "startOffset" : 124,
      "endOffset" : 220
    } ],
    "year" : 2010,
    "abstractText" : "Modern solvers for Boolean Satisfiability (SAT) and Answer Set Programming (ASP) are based on sophisticated Boolean constraint solving techniques. In both areas, conflict-driven learning and related techniques constitute key features whose application is enabled by conflict analysis. Although various conflict analysis schemes have been proposed, implemented, and studied both theoretically and practically in the SAT area, the heuristic aspects involved in conflict analysis have not yet received much attention. Assuming a fixed conflict analysis scheme, we address the open question of how to identify “good” reasons for conflicts, and we investigate several heuristics for conflict analysis in ASP solving. To our knowledge, a systematic study like ours has not yet been performed in the SAT area, thus, it might be beneficial for both the field of ASP as well as the one of SAT solving.",
    "creator" : "TeX"
  }
}