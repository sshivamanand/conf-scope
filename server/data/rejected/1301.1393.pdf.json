{
  "name" : "1301.1393.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Two New Definitions of Stable Models of Logic Programs with Generalized Quantifiers",
    "authors" : [ "Joohyung Lee", "Yunsong Meng" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Most versions of the stable model semantics involve grounding. For instance, according to the FLP semantics from [1; 2], assuming that the domain is {−1, 1, 2}, program\np(2) ← ınot SUM〈x :p(x)〉<2 p(−1) ← SUM〈x :p(x)〉>−1 p(1) ← p(−1)\n(1)\nis identified with its ground instance w.r.t the domain:\np(2) ← ınot SUM〈{−1:p(−1), 1:p(1), 2:p(2)}〉<2 p(−1) ← SUM〈{−1:p(−1), 1:p(1), 2:p(2)}〉>−1 p(1) ← p(−1) .\n(2)\nAs described in [1], it is straightforward to extend the definition of satisfaction to ground aggregate expressions. For instance, set {p(−1), p(1)} does not satisfy the body of the first rule of (2), but satisfies the bodies of the other rules. The FLP reduct of program (2) relative to {p(−1), p(1)} consists of the last two rules, and {p(−1), p(1)} is its minimal model. Indeed, {p(−1), p(1)} is the only FLP answer set of program (2).\nOn the other hand, according to the semantics from [3], program (2) is identified with some complex propositional formula containing nested implications:( ¬ ( (p(2)→p(−1)∨p(1)) ∧ (p(1)∧p(2)→p(−1)) ∧ (p(−1)∧p(1)∧p(2)→⊥) ) → p(2)\n) ∧ (( p(−1)→p(1)∨p(2) ) → p(−1)\n) ∧ ( p(−1)→ p(1) ) .\nar X\niv :1\n30 1.\n13 93\nv1 [\ncs .L\nO ]\n8 J\nan 2\n01 3\nUnder the stable model semantics of propositional formulas [3], this formula has two answer sets: {p(−1), p(1)} and {p(−1), p(1), p(2)}. The relationship between the FLP and the Ferraris semantics was studied in [4; 5].\nUnlike the FLP semantics, the definition from [3] is not applicable when the domain is infinite because it would require the representation of an aggregate expression to involve “infinite” conjunctions and disjunctions. This limitation was overcome in the semantics presented in [4; 6], which extends the first-order stable model semantics from [7; 8] to incorporate aggregate expressions. Recently, it was further extended to formulas involving generalized quantifiers [9], which provides a unifying framework of various extensions of the stable model semantics, including programs with aggregates, programs with abstract constraint atoms [10], and programs with nonmonotonic dl-atoms [11].\nIn this paper, we revisit the first-order stable model semantics and its extension to incorporate generalized quantifiers. We provide an alternative, equivalent definition of a stable model by referring to grounding and reduct instead of the SM operator. Our work is inspired by the work of Truszczynski [12], who introduces infinite conjunctions and disjunctions to account for grounding quantified sentences. Our definition of a stable model can be viewed as a reformulation and a further generalization of his definition to incorporate generalized quantifiers. We define grounding in the same way as done in the FLP semantics, but define a reduct differently so that the semantics agrees with the one by Ferraris [3]. As we explain in Section 3.3, our reduct of program (2) relative to {p(−1), p(1)} is\n⊥ ← ⊥ p(−1) ← SUM〈{−1:p(−1), 1:p(1), 2:⊥)〉}>−1 p(1) ← p(−1) ,\n(3)\nwhich is the program obtained from (2) by replacing each maximal subformula that is not satisfied by {p(−1), p(1)} with ⊥. Set {p(−1), p(1)} is an answer set of program (1) as it is a minimal model of the reduct. Likewise the reduct relative to {p(−1), p(1), p(2)} is\np(2) ← > p(−1) ← SUM{〈−1:p(−1), 1:p(1), 2:p(2)〉}>−1 p(1) ← p(−1)\nand {p(−1), p(1), p(2)} is a minimal model of the program. The semantics is more direct than the one from [3] as it does not involve the complex translation into a propositional formula.\nWhile the FLP semantics in [1] was defined in the context of logic programs with aggregates, it can be straightforwardly extended to allow other “complex atoms.” Indeed, the FLP reduct is the basis of the semantics of HEX programs [13]. In [14], the FLP reduct was applied to provide a semantics of nonmonotonic dl-programs [11]. In [5], the FLP semantics of logic programs with aggregates was generalized to the first-order level. That semantics is defined in terms of the FLP operator, which is similar to the SM operator. This paper further extends the definition to allow generalized quantifiers.\nBy providing an alternative definition in the way that the other semantics was defined, this paper provides a useful insight into the relationship between the first-order\nstable model semantics and the FLP stable model semantics for programs with generalized quantifiers. While the two semantics behave differently in the general case, we show that they coincide on some reasonable syntactic class of logic programs. This implies that an implementation of one of the semantics can be viewed as an implementation of the other semantics if we limit attention to that class of logic programs.\nThe paper is organized as follows. Section 2 reviews the first-order stable model semantics and its equivalent definition in terms of grounding and reduct, and Section 3 extends that definition to incorporate generalized quantifiers. Section 4 provides an alternative definition of the FLP semantics with generalized quantifiers via a translation into second-order formulas. Section 5 compares the FLP semantics and the first-order stable model semantics in the general context of programs with generalized quantifiers."
    }, {
      "heading" : "2 First-Order Stable Model Semantics",
      "text" : ""
    }, {
      "heading" : "2.1 Review of First-Order Stable Model Semantics",
      "text" : "This review follows [8], a journal version of [7], which distinguishes between intensional and non-intensional predicates.\nA formula is defined the same as in first-order logic. A signature consists of function constants and predicate constants. Function constants of arity 0 are also called object constants. We assume the following set of primitive propositional connectives and quantifiers:\n⊥,>, ∧, ∨, →, ∀, ∃ .\n¬F is an abbreviation of F → ⊥, and F ↔ G stands for (F → G) ∧ (G → F ). We distinguish between atoms and atomic formulas as follows: an atom of a signature σ is an n-ary predicate constant followed by a list of n terms that can be formed from function constants in σ and object variables; atomic formulas of σ are atoms of σ, equalities between terms of σ, and the 0-place connectives ⊥ and >.\nThe stable models of F relative to a list of predicates p = (p1, . . . , pn) are defined via the stable model operator with the intensional predicates p, denoted by SM[F ;p].1 Let u be a list of distinct predicate variables u1, . . . , un. By u = p we denote the conjunction of the formulas ∀x(ui(x) ↔ pi(x)), where x is a list of distinct object variables of the same length as the arity of pi, for all i = 1, . . . , n. By u ≤ p we denote the conjunction of the formulas ∀x(ui(x) → pi(x)) for all i = 1, . . . , n, and u < p stands for (u ≤ p) ∧ ¬(u = p). For any first-order sentence F , expression SM[F ;p] stands for the second-order sentence\nF ∧ ¬∃u((u < p) ∧ F ∗(u)),\nwhere F ∗(u) is defined recursively:\n– pi(t)∗ = ui(t) for any list t of terms; – F ∗ = F for any atomic formula F that does not contain members of p; – (F ∧G)∗ = F ∗ ∧G∗;\n1 The intensional predicates p are the predicates that we “intend to characterize” by F .\n– (F ∨G)∗ = F ∗ ∨G∗; – (F → G)∗ = (F ∗ → G∗) ∧ (F → G); – (∀xF )∗ = ∀xF ∗; – (∃xF )∗ = ∃xF ∗.\nA model of a sentence F (in the sense of first-order logic) is called p-stable if it satisfies SM[F ;p].\nExample 1 Let F be sentence ∀x(¬p(x)→ q(x)), and let I be an interpretation whose universe is the set of all nonnegative integers N, and pI(n) = FALSE, qI(n) = TRUE for all n ∈ N. Section 2.4 of [8] tells us that I satisfies SM[F ; pq]."
    }, {
      "heading" : "2.2 Alternative Definition of First-Order Stable Models via Reduct",
      "text" : "For any signature σ and its interpretation I , by σI we mean the signature obtained from σ by adding new object constants ξ , called object names, for every element ξ in the universe of I . We identify an interpretation I of σ with its extension to σI defined by I(ξ ) = ξ.\nIn order to facilitate defining a reduct, we provide a reformulation of the standard semantics of first-order logic via “a ground formula w.r.t. an interpretation.”\nDefinition 1. For any interpretation I of a signature σ, a ground formula w.r.t. I is defined recursively as follows.\n– p(ξ 1 , . . . , ξ n), where p is a predicate constant of σ and ξ i are object names of σI , is a ground formula w.r.t. I; – > and ⊥ are ground formulas w.r.t. I; – If F and G are ground formulas w.r.t. I , then F ∧ G, F ∨ G, F → G are ground\nformulas w.r.t. I; – If S is a set of pairs of the form ξ :F where ξ is an object name in σI and F is a\nground formula w.r.t. I , then ∀(S) and ∃(S) are ground formulas w.r.t. I .\nThe following definition describes a process that turns any first-order sentence into a ground formula w.r.t. an interpretation:\nDefinition 2. Let F be any first-order sentence of a signature σ, and let I be an interpretation of σ whose universe is U . By grI [F ] we denote the ground formula w.r.t. I , which is obtained by the following process:\n– grI [p(t1, . . . , tn)] = p((tI1) , . . . , (tIn) );\n– grI [t1 = t2] = { > if tI1 = tI2, and ⊥ otherwise; – grI [>] = >; grI [⊥] = ⊥; – grI [F G] = grI [F ] grI [G] ( ∈ {∧,∨,→}); – grI [QxF (x)] = Q({ξ :grI [F (ξ )] | ξ ∈ U}) (Q ∈ {∀,∃}).\nDefinition 3. For any interpretation I and any ground formula F w.r.t. I , the truth value of F under I , denoted by F I , is defined recursively as follows.\n– p(ξ 1 , . . . , ξ n)I = pI(ξ1, . . . , ξn); – >I = TRUE; ⊥I = FALSE; – (F ∧G)I = TRUE iff F I = TRUE and GI = TRUE; – (F ∨G)I = TRUE iff F I = TRUE or GI = TRUE; – (F → G)I = TRUE iff GI = TRUE whenever F I = TRUE; – ∀(S)I = TRUE iff the set {ξ | ξ :F (ξ ) ∈ S and F (ξ )I = TRUE} is the same as\nthe universe of I; – ∃(S)I = TRUE iff the set {ξ | ξ :F (ξ ) ∈ S and F (ξ )I = TRUE} is not empty.\nWe say that I satisfies F , denoted I |= F , if F I = TRUE.\nExample 1 continued (I). grI [F ] is ∀({n : (¬p(n )→ q(n )) | n ∈ N}). Clearly, I satisfies grI [F ].\nAn interpretation I of a signature σ can be represented as a pair 〈I f unc, Ipred〉, where I f unc is the restriction of I to the function constants of σ, and Ipred is the set of atoms, formed using predicate constants from σ and the object names from σI , which are satisfied by I . For example, interpretation I in Example 1 can be represented as 〈I f unc, {q(n ) | n ∈ N}〉, where I f unc maps each integer to itself.\nThe following proposition is immediate from the definitions:\nProposition 1. Let σ be a signature that contains finitely many predicate constants, let σpred be the set of predicate constants in σ, let I = 〈I f unc, Ipred〉 be an interpretation of σ, and let F be a first-order sentence of σ. Then I |= F iff Ipred |= grI [F ].\nThe introduction of the intermediate form of a ground formula w.r.t. an interpretation helps us define a reduct.\nDefinition 4. For any ground formula F w.r.t. I , the reduct of F relative to I , denoted by F I , is obtained by replacing each maximal subformula that is not satisfied by I with ⊥. It can also be defined recursively as follows.\n– (p(ξ 1 , . . . , ξ n))I =\n{ p(ξ 1 , . . . , ξ n) if I |= p(ξ 1 , . . . , ξ n),\n⊥ otherwise; – >I = >; ⊥I = ⊥;\n– (F G)I = { F I GI if I |= F G ( ∈ {∧,∨,→}), ⊥ otherwise;\n– Q(S)I = { Q({ξ : (F (ξ ))I | ξ :F (ξ ) ∈ S}) if I |= Q(S) (Q ∈ {∀,∃}), ⊥ otherwise.\nThe following theorem tells us how first-order stable models can be characterized in terms of grounding and reduct.\nTheorem 1. Let σ be a signature that contains finitely many predicate constants, let σpred be the set of predicate constants in σ, let I = 〈I f unc, Ipred〉 be an interpretation of σ, and let F be a first-order sentence of σ. I satisfies SM[F ;σpred] iff Ipred is a minimal set of atoms that satisfies (ıgrI [F ]) I .\nExample 1 continued (II). The reduct of grI [F ] relative to I , (grI [F ])I , is ∀({n : (¬⊥ → q(n )) | n ∈ N}), which is equivalent to ∀({n : q(n ) | n ∈ N}). Clearly, Ipred = {q(n ) | n ∈ N} is a minimal set of atoms that satisfies (grI [F ])I ."
    }, {
      "heading" : "2.3 Relation to Infinitary Formulas by Truszczynski",
      "text" : "The definitions of grounding and a reduct in the previous section are inspired by the work of Truszczynski [12], where he introduces infinite conjunctions and disjunctions to account for the result of grounding ∀ and ∃ w.r.t. a given interpretation. Differences between the two approaches are illustrated in the following example:\nExample 2 Consider the formula F = ∀x p(x) and the interpretation I whose universe is the set of all nonnegative integers N. According to [12], grounding of F w.r.t. I results in the infinitary propositional formula\n{p(n ) | n ∈ N}∧ .\nOn the other hand, formula grI [F ] is\n∀({n :p(n ) | n ∈ N}).\nOur definition of a reduct is essentially equivalent to the one defined in [12]. In the next section, we extend our definition to incorporate generalized quantifiers."
    }, {
      "heading" : "3 Stable Models of Formulas with Generalized Quantifiers",
      "text" : ""
    }, {
      "heading" : "3.1 Review: Formulas with Generalized Quantifiers",
      "text" : "We follow the definition of a formula with generalized quantifiers from [15, Section 5] (that is to say, with Lindström quantifiers [16] without the isomorphism closure condition).\nWe assume a set Q of symbols for generalized quantifiers. Each symbol in Q is associated with a tuple of nonnegative integers 〈n1, . . . , nk〉 (k ≥ 0, and each ni is ≥ 0), called the type. A (GQ-)formula (with the set Q of generalized quantifiers) is defined in a recursive way:\n– an atomic formula (in the sense of first-order logic) is a GQ-formula; – if F1, . . . , Fk (k ≥ 0) are GQ-formulas and Q is a generalized quantifier of type 〈n1, . . . , nk〉 in Q, then\nQ[x1] . . . [xk](F1(x1), . . . , Fk(xk)) (4)\nis a GQ-formula, where each xi (1 ≤ i ≤ k) is a list of distinct object variables whose length is ni.\nWe say that an occurrence of a variable x in a GQ-formula F is bound if it belongs to a subformula of F that has the form Q[x1] . . . [xk](F1(x1), . . . , Fk(xk)) such that x is in some xi. Otherwise the occurrence is free. We say that x is free in F if F contains a free occurrence of x. A (GQ-)sentence is a GQ-formula with no free variables.\nWe assume that Q contains type 〈〉 quantifiers Q⊥ and Q>, type 〈0, 0〉 quantifiers Q∧, Q∨, Q→, and type 〈1〉 quantifiers Q∀, Q∃. Each of them corresponds to the standard logical connectives and quantifiers — ⊥,>,∧,∨,→,∀,∃. These generalized quantifiers will often be written in the familiar form. For example, we write F ∧ G in place of Q∧[][](F,G), and write ∀xF (x) in place of Q∀[x](F (x)).\nAs in first-order logic, an interpretation I consists of the universe U and the evaluation of predicate constants and function constants. For each generalized quantifier Q of type 〈n1, . . . , nk〉, QU is a function from P(Un1)× · · · × P(Unk) to {TRUE, FALSE}, where P(Uni) denotes the power set of Uni .\nExample 3 Besides the standard connectives and quantifiers, the following are some examples of generalized quantifiers.\n– type 〈1〉 quantifier Q≤2 such that QU≤2(R) = TRUE iff |R| ≤ 2; 2 – type 〈1〉 quantifier Qmajority such that QUmajority(R) = TRUE iff |R| > |U \\R|; – type 〈1, 1〉 quantifier Q(SUM,<) such that QU(SUM,<)(R1, R2) = TRUE iff • SUM(R1) is defined, • R2 = {b}, where b is an integer, and • SUM(R1) < b.\nGiven a sentence F of σI , F I is defined recursively as follows:\n– p(t1, . . . , tn)I = pI(tI1, . . . , tIn), – (t1 = t2)I = (tI1 = tI2), – For a generalized quantifier Q of type 〈n1, . . . , nk〉,\n(Q[x1] . . . [xk](F1(x1), . . . , Fk(xk))) I = QU ((x1 :F1(x1)) I , . . . , (xk :Fk(xk)) I),\nwhere (xi :Fi(xi))I = {ξ ∈ Uni | (Fi(ξ ))I = TRUE}.\nWe assume that, for the standard logical connectives and quantifiers Q, functions QU have the standard meaning:\n– QU∀ (R) = TRUE iff R = U ; – QU∃ (R) = TRUE iff R ∩ U 6= ∅; – QU∧ (R1, R2) = TRUE iff R1 = R2 = { };3 – QU∨ (R1, R2) = TRUE iff R1 = { } or R2 = { };\n– QU→(R1, R2) = TRUE iff R1 is ∅ or R2 is { }; – QU⊥() = FALSE; – QU>() = TRUE.\n2 It is clear from the type of the quantifier that R is any subset of U . We will skip such explanation. 3 denotes the empty tuple. For any interpretation I , U0 = { }. For I to satisfy Q∧[][](F,G), both ( :F )I and ( :G)I have to be { }, which means that F I = GI = TRUE.\nWe say that an interpretation I satisfies a GQ-sentence F , or is a model of F , and write I |= F , if F I = TRUE. A GQ-sentence F is logically valid if every interpretation satisfies F . A GQ-formula with free variables is said to be logically valid if its universal closure is logically valid.\nExample 4 Program (1) in the introduction is identified with the following GQ-formulaF1:\n(¬Q(SUM,<)[x][y](p(x), y=2)→ p(2)) ∧ (Q(SUM,>)[x][y](p(x), y=−1)→ p(−1)) ∧ (p(−1)→ p(1)) .\nConsider two Herbrand interpretations of the universeU = {−1, 1, 2}: I1 = {p(−1), p(1)} and I2 = {p(−1), p(1), p(2)}. We have (Q(SUM,<)[x][y](p(x), y = 2))I1 = TRUE since\n– (x : p(x))I1 = {−1, 1} and (y : y=2)I1 = {2}; – QU(SUM,<)({−1, 1}, {2}) = TRUE.\nSimilarly, (Q(SUM,>)[x][y](p(x), y=−1))I2 = TRUE since\n– (x : p(x))I2 = {−1, 1, 2} and (y : y=−1)I2 = {−1}; – QU(SUM,>)({−1, 1, 2}, {−1}) = TRUE.\nConsequently, both I1 and I2 satisfy F1.\n3.2 Review: SM-Based Definition of Stable Models of GQ-Formulas\nFor any GQ-formula F and any list of predicates p = (p1, . . . , pn), formula SM[F ;p] is defined as\nF ∧ ¬∃u((u < p) ∧ F ∗(u)),\nwhere F ∗(u) is defined recursively:\n– pi(t)∗ = ui(t) for any list t of terms; – F ∗ = F for any atomic formula F that does not contain members of p; –\n(Q[x1] . . . [xk](F1(x1), . . . , Fk(xk))) ∗ =\nQ[x1] . . . [xk](F ∗ 1 (x1), . . . , F ∗ k (xk)) ∧ Q[x1] . . . [xk](F1(x1), . . . , Fk(xk)).\nWhen F is a sentence, the models of SM[F ;p] are called the p-stable models of F : they are the models of F that are “stable” on p. We often simply write SM[F ] in place of SM[F ;p] when p is the list of all predicate constants occurring in F , and call p-stable models simply stable models.\nAs explained in [17], this definition of a stable model is a proper generalization of the first-order stable model semantics.\nExample 4 continued (I). For GQ-sentence F1 considered earlier, SM[F1] is\nF1 ∧ ¬∃u(u < p ∧ F ∗1 (u)) , (5)\nwhere F ∗1 (u) is equivalent to the conjunction of F1 and\n(¬Q(SUM,<)[x][y](p(x), y=2)→ u(2)) ∧ ((Q(SUM,>)[x][y](u(x), y=−1) ∧ Q(SUM,>)[x][y](p(x), y=−1))→ u(−1)) ∧ (u(−1)→ u(1)) .\nThe equivalence can be explained by Proposition 1 from [9], which simplifies the transformation for monotone and antimonotone GQs. I1 and I2 considered earlier satisfy (5) and thus are stable models of F1."
    }, {
      "heading" : "3.3 Reduct-Based Definition of Stable Models of GQ-Formulas",
      "text" : "The reduct-based definition of stable models presented in Section 2.2 can be extended to GQ-formulas as follows.\nLet I be an interpretation of a signature σ. As before, we assume a set Q of generalized quantifiers, which contains all propositional connectives and standard quantifiers.\nDefinition 5. A ground GQ-formula w.r.t. I is defined recursively as follows:\n– p(ξ 1 , . . . , ξ n), where p is a predicate constant of σ and ξ i are object names of σI , is a ground GQ-formula w.r.t. I; – for any Q ∈ Q of type 〈n1, . . . , nk〉, if each Si is a set of pairs of the form ξ :F where ξ is a list of object names from σI whose length is ni and F is a ground GQ-formula w.r.t. I , then\nQ(S1, . . . , Sk)\nis a ground GQ-formula w.r.t. I .\nThe following definition of grounding turns any GQ-sentence into a ground GQformula w.r.t. an interpretation:\nDefinition 6. Let F be a GQ-sentence of a signature σ, and let I be an interpretation of σ. By grI [F ] we denote the ground GQ-formula w.r.t. I that is obtained by the process similar to the one in Definition 2 except that the last two clauses are replaced by the following single clause:\n– grI [Q[x1] . . . [xk](F1(x1), . . . , Fk(xk))] = Q(S1, . . . , Sk) where Si = {ξ :grI [Fi(ξ )] | ξ is a list of object names from σI whose length is ni}.\nFor any interpretation I and any ground GQ-formula F w.r.t. I , the satisfaction relation I |= F is defined recursively as follows.\nDefinition 7. For any interpretation I and any ground GQ-formula F w.r.t. I , the satisfaction relation I |= F is defined similar to Definition 3 except that the last five clauses are replaced by the following single clause:\n– Q(S1, . . . , Sk)I = QU (SI1 , . . . , SIk) where SIi = {ξ | ξ :F (ξ ) ∈ Si, F (ξ )I =\nTRUE}.\nExample 4 continued (II). For Herbrand interpretation I1 = {p(−1), p(1)}, formula grI1 [F1] is 4\n(¬Q(SUM,<)({−1:p(−1), 1:p(1), 2:p(2)}, {−1:⊥, 1:⊥, 2:>})→ p(2)) ∧ (Q(SUM,>)({−1:p(−1), 1:p(1), 2:p(2)}, {−1:>, 1:⊥, 2:⊥})→ p(−1)) ∧ (p(−1)→ p(1)) .\n(6)\nI1 satisfies Q(SUM,<)({−1 : p(−1), 1 : p(1), 2 : p(2)}, {−1 : ⊥, 1 : ⊥, 2 : >}) because I1 |= p(−1), I1 |= p(1), I1 6|= p(2), and\nQU(SUM,<)({−1, 1}, {2}) = TRUE.\nI1 satisfies Q(SUM,>)({−1:p(−1), 1:p(1), 2:p(2)}, {−1:>, 1:⊥, 2:⊥}) because\nQU(SUM,>)({−1, 1}, {−1}) = TRUE.\nConsequently, I1 satisfies (6).\nProposition 2. Let σ be a signature that contains finitely many predicate constants, let σpred be the set of predicate constants in σ, let I = 〈I f unc, Ipred〉 be an interpretation of σ, and let F be a GQ-sentence of σ. Then I |= F iff Ipred |= grI [F ].\nDefinition 8. For any GQ-formula F w.r.t. I , the reduct of F relative to I , denoted by F I , is defined in the same way as in Definition 4 by replacing the last two clauses with the following single clause:\n– (Q(S1, . . . , Sk))I =\n{ Q(S\nI 1 , . . . , S I k) if I |= Q(S1, . . . , Sk),\n⊥ otherwise; where SIi = {ξ : (F (ξ ))I | ξ :F (ξ ) ∈ Si}.\nTheorem 2. Let σ be a signature that contains finitely many predicate constants, let σpred be the set of predicate constants in σ, let I = 〈I f unc, Ipred〉 be an interpretation of σ, and let F be a GQ-sentence of σ. I |= SM[F ;σpred] iff Ipred is a minimal set of atoms that satisfies (ıgrI [F ]) I .\nExample 4 continued (III). Interpretation I1 considered earlier can be identified with the tuple 〈I f unc, {p(−1), p(1)}〉 where I f unc maps every term to itself. The reduct (grI1 [F1]) I1 is\n(⊥ → ⊥) ∧ (Q(SUM,>)({−1:p(−1), 1:p(1), 2:⊥}, {−1:>, 1:⊥, 2:⊥})→ p(−1)) ∧ (p(−1)→ p(1)) ,\nwhich is the GQ-formula representation of (3). We can check that {p(−1), p(1)} is a minimal model of the reduct.\nExtending Theorem 2 to allow an arbitrary list of intensional predicates, rather than σpred, is straightforward in view of Proposition 1 from [18].\n4 For simplicity, we write −1, 1, 2 instead of their object names (−1) , 1 , 2 ."
    }, {
      "heading" : "4 FLP Semantics of Programs with Generalized Quantifiers",
      "text" : "The FLP stable model semantics [1] is an alternative way to define stable models. It is the basis of HEX programs, an extension of the stable model semantics with higherorder and external atoms, which is implemented in system DLV-HEX. The first-order generalization of the FLP stable model semantics for programs with aggregates was given in [5], using the FLP operator that is similar to the SM operator. In this section we show how it can be extended to allow generalized quantifiers."
    }, {
      "heading" : "4.1 FLP Semantics of Programs with Generalized Quantifiers",
      "text" : "A (general) rule is of the form H ← B (7)\nwhere H and B are arbitrary GQ-formulas. A (general) program is a finite set of rules. Let p be a list of distinct predicate constants p1, . . . , pn, and let u be a list of distinct predicate variables u1, . . . , un. For any formula G, formula G(u) is obtained from G by replacing all occurrences of predicates from p with the corresponding predicate variables from u.\nLet Π be a finite program whose rules have the form (7). The GQ-representation ΠGQ of Π is the conjunction of the universal closures of B → H for all rules (7) in Π . By FLP[Π;p] we denote the second-order formula\nΠGQ ∧ ¬∃u(u < p ∧Π4(u))\nwhere Π4(u) is defined as the conjunction of the universal closures of\nB ∧B(u)→H(u)\nfor all rules H ← B in Π . We will often simply write FLP[Π] instead of FLP[Π;p] when p is the list of all predicate constants occurring in Π , and call a model of FLP[Π] an FLP-stable model of Π .\nExample 4 continued (IV). For formula F1 considered earlier, FLP[F1] is\nF1 ∧ ¬∃u(u < p ∧ F41 (u)) , (8)\nwhere F41 (u) is\n(¬Q(SUM,<)[x][y](p(x), y=2) ∧ ¬Q(SUM,<)[x][y](u(x), y=2)→ u(2)) ∧ (Q(SUM,>)[x][y](p(x), y=−1) ∧ (Q(SUM,>)[x][y](u(x), y=−1)→ u(−1)) ∧ (p(−1) ∧ u(−1)→ u(1)) .\nI1 considered earlier satisfies (8) but I2 does not."
    }, {
      "heading" : "5 Comparing the FLP Semantics and the First-Order Stable Model Semantics",
      "text" : "In this section, we show a class of programs with GQs for which the FLP semantics and the first-order stable model semantics coincide.\nThe following definition is from [17]. We say that a generalized quantifier Q is monote in the i-th argument position if the following holds for any universe U : if QU (R1, . . . , Rk) = TRUE and Ri ⊆ R′i ⊆ Uni , then\nQU (R1, . . . , Ri−1, R ′ i, Ri+1, . . . , Rk) = TRUE.\nConsider a program Π consisting of rules of the form\nA1; . . . ;Al ← E1, . . . , Em, ınot Em+1, . . . , ınot En\n(l ≥ 0; n ≥ m ≥ 0), where each Ai is an atomic formula and each Ei is an atomic formula or a GQ-formula (4) such that all F1(x1), . . . , Fk(xk) are atomic formulas. Furthermore we require that, for every GQ-formula (4) in one of Em+1, . . . , En, Q is monotone in all its argument positions.\nProposition 3. Let Π be a program whose syntax is described as above, and let F be the GQ-representation of Π . Then FLP[Π;p] is equivalent to SM[F ;p].\nExample 5 Consider the following one-rule program:\np(a)← ınot Q≤0[x] p(x) . (9)\nThis program does not belong to the syntactic class of programs stated in Proposition 3 since Q≤0[x] p(x) is not monotone in {1}. Indeed, both ∅ and {p(a)} satisfy SM[Π; p], but only ∅ satisfies FLP[Π; p].\nConditions under which the FLP semantics coincides with the first-order stable model semantics has been studied in [4; 5] in the context of logic programs with aggregates."
    }, {
      "heading" : "6 Conclusion",
      "text" : "We introduced two definitions of a stable model. One is a reformulation of the first-order stable model semantics and its extension to allow generalized quantifiers by referring to grounding and reduct, and the other is a reformulation of the FLP semantics and its extension to allow generalized quantifiers by referring to a translation into secondorder logic. These new definitions help us understand the relationship between the FLP semantics and the first-order stable model semantics, and their extensions. For the class of programs where the two semantics coincide, system DLV-HEX can be viewed as an implementation of the stable model semantics of GQ-formulas; A recent extension of system F2LP [19] to allow “complex” atoms may be considered as a front-end to DLVHEX to implement the generalized FLP semantics."
    }, {
      "heading" : "Acknowledgements",
      "text" : "We are grateful to Vladimir Lifschitz for useful discussions related to this paper. We are also grateful to Joseph Babb and the anonymous referees for their useful comments. This work was partially supported by the National Science Foundation under Grant IIS0916116 and by the South Korea IT R&D program MKE/KIAT 2010-TD-300404-001."
    } ],
    "references" : [ {
      "title" : "Recursive aggregates in disjunctive logic programs: Semantics and complexity",
      "author" : [ "W. Faber", "N. Leone", "G. Pfeifer" ],
      "venue" : "Proceedings of European Conference on Logics in Artificial Intelligence (JELIA).",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Semantics and complexity of recursive aggregates in answer set programming",
      "author" : [ "W. Faber", "G. Pfeifer", "N. Leone" ],
      "venue" : "Artificial Intelligence 175(1)",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Answer sets for propositional theories",
      "author" : [ "P. Ferraris" ],
      "venue" : "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR).",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "On reductive semantics of aggregates in answer set programming",
      "author" : [ "J. Lee", "Y. Meng" ],
      "venue" : "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR).",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "First-order extension of the flp stable model semantics via modified circumscription",
      "author" : [ "M. Bartholomew", "J. Lee", "Y. Meng" ],
      "venue" : "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI).",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "On the stable model semantics of first-order formulas with aggregates",
      "author" : [ "P. Ferraris", "V. Lifschitz" ],
      "venue" : "Proceedings of International Workshop on Nonmonotonic Reasoning (NMR).",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "A new perspective on stable models",
      "author" : [ "P. Ferraris", "J. Lee", "V. Lifschitz" ],
      "venue" : "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI), AAAI Press",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Stable models and circumscription",
      "author" : [ "P. Ferraris", "J. Lee", "V. Lifschitz" ],
      "venue" : "Artificial Intelligence 175",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Stable models of formulas with generalized quantifiers (preliminary report)",
      "author" : [ "J. Lee", "Y. Meng" ],
      "venue" : "Technical Communications of the 28th International Conference on Logic Programming.",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Logic programs with abstract constraint atoms",
      "author" : [ "V.W. Marek", "M. Truszczynski" ],
      "venue" : "Proceedings of the AAAI Conference on Artificial Intelligence (AAAI).",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Combining answer set programming with description logics for the semantic web",
      "author" : [ "T. Eiter", "G. Ianni", "T. Lukasiewicz", "R. Schindlauer", "H. Tompits" ],
      "venue" : "Artificial Intelligence 172(1213)",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Connecting first-order ASP and the logic FO(ID) through reducts",
      "author" : [ "M. Truszczynski" ],
      "venue" : "Correct Reasoning: Essays on Logic-Based AI in Honor of Vladimir Lifschitz.",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "A uniform integration of higher-order reasoning and external evaluations in answer-set programming",
      "author" : [ "T. Eiter", "G. Ianni", "R. Schindlauer", "H. Tompits" ],
      "venue" : "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI).",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "A logical semantics for description logic programs",
      "author" : [ "M. Fink", "D. Pearce" ],
      "venue" : "Proceedings of European Conference on Logics in Artificial Intelligence (JELIA).",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Generalized quantifiers",
      "author" : [ "D. Westerståhl" ],
      "venue" : " In: The Stanford Encyclopedia of Philosophy (Winter 2008 Edition). ",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "First-order predicate logic with generalized quantifiers",
      "author" : [ "P. Lindström" ],
      "venue" : "Theoria 32",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 1966
    }, {
      "title" : "Stable models of formulas with generalized quantifiers",
      "author" : [ "J. Lee", "Y. Meng" ],
      "venue" : "Proceedings of International Workshop on Nonmonotonic Reasoning (NMR).",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Reformulating the situation calculus and the event calculus in the general theory of stable models and in answer set programming",
      "author" : [ "J. Lee", "R. Palla" ],
      "venue" : "Journal of Artificial Intelligence Research (JAIR) 43",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "System F2LP — computing answer sets of first-order formulas",
      "author" : [ "J. Lee", "R. Palla" ],
      "venue" : "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR).",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2009
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "As described in [1], it is straightforward to extend the definition of satisfaction to ground aggregate expressions.",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 2,
      "context" : "On the other hand, according to the semantics from [3], program (2) is identified with some complex propositional formula containing nested implications: ( ¬ ( (p(2)→p(−1)∨p(1)) ∧ (p(1)∧p(2)→p(−1)) ∧ (p(−1)∧p(1)∧p(2)→⊥) ) → p(2) )",
      "startOffset" : 51,
      "endOffset" : 54
    }, {
      "referenceID" : 2,
      "context" : "Under the stable model semantics of propositional formulas [3], this formula has two answer sets: {p(−1), p(1)} and {p(−1), p(1), p(2)}.",
      "startOffset" : 59,
      "endOffset" : 62
    }, {
      "referenceID" : 2,
      "context" : "Unlike the FLP semantics, the definition from [3] is not applicable when the domain is infinite because it would require the representation of an aggregate expression to involve “infinite” conjunctions and disjunctions.",
      "startOffset" : 46,
      "endOffset" : 49
    }, {
      "referenceID" : 8,
      "context" : "Recently, it was further extended to formulas involving generalized quantifiers [9], which provides a unifying framework of various extensions of the stable model semantics, including programs with aggregates, programs with abstract constraint atoms [10], and programs with nonmonotonic dl-atoms [11].",
      "startOffset" : 80,
      "endOffset" : 83
    }, {
      "referenceID" : 9,
      "context" : "Recently, it was further extended to formulas involving generalized quantifiers [9], which provides a unifying framework of various extensions of the stable model semantics, including programs with aggregates, programs with abstract constraint atoms [10], and programs with nonmonotonic dl-atoms [11].",
      "startOffset" : 250,
      "endOffset" : 254
    }, {
      "referenceID" : 10,
      "context" : "Recently, it was further extended to formulas involving generalized quantifiers [9], which provides a unifying framework of various extensions of the stable model semantics, including programs with aggregates, programs with abstract constraint atoms [10], and programs with nonmonotonic dl-atoms [11].",
      "startOffset" : 296,
      "endOffset" : 300
    }, {
      "referenceID" : 11,
      "context" : "Our work is inspired by the work of Truszczynski [12], who introduces infinite conjunctions and disjunctions to account for grounding quantified sentences.",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 2,
      "context" : "We define grounding in the same way as done in the FLP semantics, but define a reduct differently so that the semantics agrees with the one by Ferraris [3].",
      "startOffset" : 152,
      "endOffset" : 155
    }, {
      "referenceID" : 2,
      "context" : "The semantics is more direct than the one from [3] as it does not involve the complex translation into a propositional formula.",
      "startOffset" : 47,
      "endOffset" : 50
    }, {
      "referenceID" : 0,
      "context" : "While the FLP semantics in [1] was defined in the context of logic programs with aggregates, it can be straightforwardly extended to allow other “complex atoms.",
      "startOffset" : 27,
      "endOffset" : 30
    }, {
      "referenceID" : 12,
      "context" : "” Indeed, the FLP reduct is the basis of the semantics of HEX programs [13].",
      "startOffset" : 71,
      "endOffset" : 75
    }, {
      "referenceID" : 13,
      "context" : "In [14], the FLP reduct was applied to provide a semantics of nonmonotonic dl-programs [11].",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 10,
      "context" : "In [14], the FLP reduct was applied to provide a semantics of nonmonotonic dl-programs [11].",
      "startOffset" : 87,
      "endOffset" : 91
    }, {
      "referenceID" : 4,
      "context" : "In [5], the FLP semantics of logic programs with aggregates was generalized to the first-order level.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 7,
      "context" : "This review follows [8], a journal version of [7], which distinguishes between intensional and non-intensional predicates.",
      "startOffset" : 20,
      "endOffset" : 23
    }, {
      "referenceID" : 6,
      "context" : "This review follows [8], a journal version of [7], which distinguishes between intensional and non-intensional predicates.",
      "startOffset" : 46,
      "endOffset" : 49
    }, {
      "referenceID" : 7,
      "context" : "4 of [8] tells us that I satisfies SM[F ; pq].",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 11,
      "context" : "The definitions of grounding and a reduct in the previous section are inspired by the work of Truszczynski [12], where he introduces infinite conjunctions and disjunctions to account for the result of grounding ∀ and ∃ w.",
      "startOffset" : 107,
      "endOffset" : 111
    }, {
      "referenceID" : 11,
      "context" : "According to [12], grounding of F w.",
      "startOffset" : 13,
      "endOffset" : 17
    }, {
      "referenceID" : 11,
      "context" : "Our definition of a reduct is essentially equivalent to the one defined in [12].",
      "startOffset" : 75,
      "endOffset" : 79
    }, {
      "referenceID" : 15,
      "context" : "We follow the definition of a formula with generalized quantifiers from [15, Section 5] (that is to say, with Lindström quantifiers [16] without the isomorphism closure condition).",
      "startOffset" : 132,
      "endOffset" : 136
    }, {
      "referenceID" : 16,
      "context" : "As explained in [17], this definition of a stable model is a proper generalization of the first-order stable model semantics.",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 8,
      "context" : "The equivalence can be explained by Proposition 1 from [9], which simplifies the transformation for monotone and antimonotone GQs.",
      "startOffset" : 55,
      "endOffset" : 58
    }, {
      "referenceID" : 17,
      "context" : "Extending Theorem 2 to allow an arbitrary list of intensional predicates, rather than σ, is straightforward in view of Proposition 1 from [18].",
      "startOffset" : 138,
      "endOffset" : 142
    }, {
      "referenceID" : 0,
      "context" : "The FLP stable model semantics [1] is an alternative way to define stable models.",
      "startOffset" : 31,
      "endOffset" : 34
    }, {
      "referenceID" : 4,
      "context" : "The first-order generalization of the FLP stable model semantics for programs with aggregates was given in [5], using the FLP operator that is similar to the SM operator.",
      "startOffset" : 107,
      "endOffset" : 110
    }, {
      "referenceID" : 16,
      "context" : "The following definition is from [17].",
      "startOffset" : 33,
      "endOffset" : 37
    }, {
      "referenceID" : 18,
      "context" : "For the class of programs where the two semantics coincide, system DLV-HEX can be viewed as an implementation of the stable model semantics of GQ-formulas; A recent extension of system F2LP [19] to allow “complex” atoms may be considered as a front-end to DLVHEX to implement the generalized FLP semantics.",
      "startOffset" : 190,
      "endOffset" : 194
    } ],
    "year" : 2013,
    "abstractText" : "We present alternative definitions of the first-order stable model semantics and its extension to incorporate generalized quantifiers by referring to the familiar notion of a reduct instead of referring to the SM operator in the original definitions. Also, we extend the FLP stable model semantics to allow generalized quantifiers by referring to an operator that is similar to the SM operator. For a reasonable syntactic class of logic programs, we show that the two stable model semantics of generalized quantifiers are interchangeable.",
    "creator" : "LaTeX with hyperref package"
  }
}