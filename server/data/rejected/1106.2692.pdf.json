{
  "name" : "1106.2692.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Generating Schemata of Resolution Proofs",
    "authors" : [ "Vincent Aravantinos", "Nicolas Peltier" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n10 6.\n26 92\nv1 [\ncs .A\nI] 1\n4 Ju\nIn [2, 4] a tableau calculus (called Stab) is presented for reasoning on schemata of propositional problems. This proof procedure is able to test the validity of logical formulæ built on a set of indexed propositional symbols, using generalized connectives such as ∨ n i=1 or ∧ n\ni=1, where i, n are part of the language (n denotes a parameter, i.e. an existentially quantified variable). A schema is unsatisfiable iff it is unsatisfiable for every value of n. Stab combines the usual expansion rules of propositional logic with some delayed instantiation schemes that perform a case-analysis on the value of the parameter n. Termination is ensured for a specific class of schemata, called regular, thanks to a loop detection rule which is able to prune infinite tableaux into finite ones, by encoding a form a mathematical induction (by “descente infinie”). A related algorithm, called Dpll∗ and based on an extension of the Davis-Putnam-Logemann-Loveland procedure, is presented in [3].\nIn the present work, we show that resolution proofs can be automatically extracted from the closed tableaux constructed by Stab or Dpll∗ on unsatisfiable schemata. More precisely, we present an algorithm that, given a closed tableau T for a schema φn, returns a schema of a refutation of φn in the resolution calculus [9]. In the usual propositional case, it is well-known that algorithms exist to extract resolution proofs from closed tableaux constructed either by the usual structural rules [11, 13] or by the DPLL algorithm [7, 6]. The resolution proofs are used in various applications, for instance for certification [14], for abstraction-refinement [10] or for explanations generation [8]. The present paper extends these techniques to propositional schemata. Beside the previously mentioned applications, this turned out to be particularly important in the context of the ASAP project [1] in which schemata calculi are applied to the formalisation and analysis of mathematical proofs via cut-elimination. Indeed, the algorithm used for cut-elimination, called CERES [5], explicitly relies\non the existence of a resolution proof of the so-called characteristic clause set extracted from the initial proof. The cut-free proof is reconstructed from this refutation, by replacing the clauses occurring in this set by some “projections” of the original proof. While Stab and Dpll∗ are able to detect the unsatisfiability of characteristic clause sets, as such this is completely useless since actually it is known that those sets are always unsatisfiable (see Proposition 3.2 in [5]). It is thus essential to be able to generate explicitly a representation of the resolution proof. This is precisely the aim of the present paper. Since the initial formula depends on a parameter n, its proof will also depend on n (except in very particular and trivial cases), i.e. it must be a schema of resolution proof (which will be encoded by recursive definitions).\nThe rest of the paper is structured as follows. In Section 1 we introduce the basic notions and notations used throughout our work, in particular the logic of propositional schemata (syntax and semantics). In Section 2 we define a tableau-based proof procedure for this logic. This calculus simulates both Stab and Dpll∗ (for the specific class of schemata considered in the present paper). In Section 3 we provide an algorithm to extract resolution proofs from closed tableaux. Similarly to the formulæ themselves, the constructed derivations are represented by rewrite systems. In Section 4 we introduce a second algorithm which generates simpler derivations but that requires that one of the closure rules defined in Section 2 (the so-called Loop Detection rule) be replaced by a less powerful rule, called the Global Loop Detection rule. Section 5 briefly concludes our work."
    }, {
      "heading" : "1 Propositional schemata",
      "text" : "The definitions used in the present paper differ from the previous ones, but the considered logic is equivalent to the class of regular schemata considered in [2] (it is thus strictly less expressive than general schemata, for which the satisfiability problem is undecidable). We consider three disjoint sets of symbols: a set of arithmetic variables V , a set of propositional variables Ω and a set of defined symbols Υ. Let ≺ be a total well-founded ordering on the symbols in Υ. An index expression is either a natural number or of the form n + k, where n is an arithmetic variable and k is a natural number. Let I be a set of index expressions. The set F(I) of formulæ built on I is inductively defined as follows: if p ∈ Ω ∪ Υ and α ∈ I then pα ∈ F(I); ⊤,⊥ ∈ F(I); and if φ, ψ ∈ F(I) then ¬φ, φ ∨ ψ, φ ∧ ψ, φ ⇒ ψ and φ ⇔ ψ are in F(I).\nDefinition 1 We assume that each element υ ∈ Υ is mapped to two rewrite rules ρ1υ and ρ 0 υ that are respectively of the form υi+1 → φ (inductive case) and υ0 → ψ (base case), where φ ∈ F({i+ 1, i, 0}), ψ ∈ F({0}) and:\n1. For every atom τα occurring in φ such that τ ∈ Υ we have either τ ≺ υ and α ∈ {i+ 1, i, 0} or τ = υ and α ∈ {0, i}.\n2. For every atom τα occurring in ψ such that τ ∈ Υ we have τ ≺ υ and α = 0. ✸\nWe denote by R the rewrite system: {ρ1υ, ρ 0 υ | υ ∈ Υ}. The rules ρ 1 υ and ρ 0 υ\nare provided by the user, they encode the semantics of the defined symbols.\nProposition 2 R is convergent.\nProof. By Conditions 1 and 2 in Definition 1, the rules in R either strictly decrease the values of the defined symbols occurring in the formula w.r.t. ≺ or do not increase the value of these symbols but strictly decreases the value of their indices. Thus termination is obvious. Confluence is then immediate since the system is orthogonal.\nFor every formula φ, we denote by φ↓R the unique normal form of φ. A schema (of parameter n) is an element of F({0, n, n+ 1}). We denote by φ{n ← k} the formula obtained from φ by replacing every occurrence of n by k. Obviously for any schema φ, φ{n ← k} ∈ F({0, k, k + 1}). A propositional formula is a formula φ ∈ F(N) containing no defined symbols. Notice that if φ ∈ F(N) then φ↓R is a propositional formula.\nProposition 3 If φ ∈ F(N) then φ↓R is a propositional formula.\nProof. By definition ofR, φ↓R∈ F(N). Furthermore, if φ↓R contains a defined symbol υ then either ρ1υ or ρ 0 υ applies, which is impossible.\nAn interpretation is a function mapping every arithmetic variable n to a natural number and every atom of the form pk (where k ∈ N) to a truth value true or false. An interpretation I validates a propositional formula φ iff one of the following conditions holds: φ is of the form pk and I(pk) = true; φ is of the form ¬ψ and I does not validate ψ; or φ is of the form ψ1 ∨ ψ2 (resp. ψ1 ∧ ψ2) and I validates ψ1 or ψ2 (resp. ψ1 and ψ2). I validates a schema φ (written I |= φ) iff I validates φ{n ← I(n)}↓R. We write φ |= ψ if every interpretation I validating φ also validates ψ and φ ≡ ψ if φ |= ψ and ψ |= φ. Example 4 The schema p0∧ ∧ n\ni=1(pi−1 ⇒ pi)∧¬pn is encoded by p0∧υn∧¬pn, where υ is defined by the rules: υi+1 → (¬pi ∨ pi+1) ∧ υi and υ0 → ⊤.\nThe schema ∨ n i=1 pi ∧ ∧ n i=1 ¬pi is encoded by τn ∧ τ ′ n , where τ and τ ′ are\ndefined by the rules: τi+1 → pi+1 ∨ τi, τ0 → ⊥, τ ′ i+1 → ¬pi+1 ∧ τ ′ i and τ ′0 → ⊤.\nBoth schemata are obviously unsatisfiable. The schema (pn ⇔ (pn−1 ⇔ (. . . (p1 ⇔ p0) . . .))) is defined by υ ′ n , where:\nυ′ i+1 → (pi+1 ⇔ υ ′ i ) and υ′0 → p0. ♣"
    }, {
      "heading" : "2 Proof procedure",
      "text" : "In this section we define the proof procedure used to decide the validity of propositional schemata. We assume for simplicity that the considered schemata are in negative normal form and that the defined symbols occur only positively1.\n1If a defined symbol υ occurs negatively then it is easy to replace every literal of the form ¬υα by an atom υα where υ denotes the complementary of υ. The rewrite rules for υ are obtained by negating the right-hand side of the rules of υ, e.g. the atom υ corresponding to the symbol υ in Example 4 is defined by the rewrite rules υi+1 → (pi ∧ ¬pi+1) ∨ υi and υ0 → ⊥.\nThe procedure is similar to the one presented in [2] and based on propositional block tableaux [12]. It constructs a tree labeled by finite sets of schemata, using expansion rules of the form: Φ\nΨ1 . . . Ψk , meaning that a leaf whose label\nis of the form Φ∪Φ′ (and does not already contain ⊥) is expanded by adding k children labeled by Φ′ ∪Ψ1, . . . , Φ\n′ ∪Ψk respectively. If α is a node in T , then T (α) denotes the label of α. The expansion rules are defined as follows:\nNormalisation: υα\nυα↓R if υα is reducible w.r.t. R\n∨-Decomposition ∧-Decomposition Closure φ ∨ ψ φ ψ φ ∧ ψ φ, ψ φ,¬φ ⊥\nPurity rule: pn+k ⊤\n¬pn+k ⊤\nif k > 0 and the previous rules do not apply\nNote that the notion of pure literal is much simpler here than in [2]. This is due to the fact that no constant index distinct from 0 and no index of the form i+ k where k > 1 are allowed.\nA node that is irreducible w.r.t. all the previous rules is called a layer. The Loop Detection rule applies to nodes containing previously generated layers:\nLoop Detection: Φ ⊥\nif a non leaf layer labeled by Φ exists in the tree\nNote that the layer does not necessarily occur in the same branch as the one on which the rule is applied. The essential point is that the set of schemata Φ has already been considered somewhere - consequently if it has a model then an open branch necessarily exists elsewhere in the tree.\nFinally, the last rule performs a case analysis on n (in this particular rule, Φ denotes the whole label of the considered node):\nExplosion: Φ Φ{n ← 0} Φ{n ← n+ 1} if no other rule applies and n occurs in Φ\nA tableau is closed if the labels of all leaves contain ⊥.\nTheorem 5 The tableau expansion rules are terminating, i.e. there is no infinite sequence (Ti)i∈N such that for every i ∈ N, Ti+1 is obtained from Ti by applying one of the previous rules.\nProof. The termination of the rules Normalisation, Decomposition, Closure and Loop Detection is obvious: indeed, the Normalisation rule strictly decreases the value of the indices occurring in the formulæ, whereas the other rules cannot increase these indices and strictly reduces the size of the label (i.e. the number of symbols). Thus we only have to show that the number of layers is finite. Let\nS be the set of layers generated by the expansion rule on a given set of schemata of some parameter n. By definition, a layer is irreducible by the Decomposition rules, thus every formula occurring in T (α) where α ∈ S must be a literal. By irreducibility w.r.t. the Normalisation and Purity rules, the indices of these literals must be either n or 0. Since ≺ is well-founded, and since all labels are finite, the number of symbols occurring in the tableau must be finite, hence the set {T (α) | α ∈ S} is finite. By the order of application of the expansion rules, the Explosion rule cannot be applied on two layers labeled by the same set of formulæ. Thus S is finite.\nThe next theorem states that the calculus is correct:\nTheorem 6 If T contains an irreducible leaf not containing ⊥, then the label of the root of T is satisfiable.\nProof. Let α be the root of T . The proof is by induction on the depth of the irreducible node in T .\n• Assume that α is irreducible. α must be a layer, thus T (α) is a set of literals, indexed by the parameter n or by 0 (as shown in the proof of Theorem 5). By irreducibility w.r.t. the Explosion rule, n cannot occur in the label. Thus T (α) is a set of literals indexed by 0. Furthermore, T (α) cannot contain two complementary literals, hence must be satisfiable.\n• If α is not irreducible, then some expansion rule must be applied on α. The rule cannot be the Closure rule, nor the Loop Detection rule (otherwise α would necessarily contain ⊥). We distinguish several cases:\n– If the ∧-decomposition rule is applied on α then α has one child β. By the induction hypothesis T (β) is satisfiable. By definition of the rule, we have T (α) ≡ T (β) hence T (α) is satisfiable.\n– If the ∨-decomposition rule is applied on α then α has two children β1 and β2. By definition, the irreducible node must occur in the branch of β1 or β2, say β1. By the induction hypothesis T (β1) is satisfiable. By definition of the rule, we have T (β1) |= T (α) hence T (α) is satisfiable.\n– If the Explosion rule is applied on α then α has two children β1 and β2 corresponding to the case n ← 0 and n ← n + 1 respectively. By definition, the irreducible node must occur in the branch of β1 or β2. If it occurs in the branch of β1, then by the induction hypothesis β1 has a model I. Moreover, by definition of the rule T (β1) contains no occurrence of n (since n is replaced by 0), thus the truth value of T (β1) is independent of the value of n. We may thus assume that I(n) = 0. Then I |= T (α) iff I |= T (α){n ← 0}, i.e. iff I |= T (β1). Therefore, I is a model of α.\nIf the irreducible node is a descendant of β2, then by the induction hypothesis β2 has a model I. Let J be an interpretation coinciding\nwith I except that J(n) def\n= I(n)+1. By definition, we have J |= T (α) iff I |= T (α){n ← n+ 1}, i.e. if I |= T (β2). Therefore, J is a model of α.\n– If the Purity rule is applied on α, then α has one child β. We have T (α) = T (β) ∪ {pn+k} (resp. T (β) ∪ {¬pn+k}), where k > 0. By the induction hypothesis, T (β) has a model I. We remark that the truth value of T (β) does not depend on the value of pn+k. Indeed, pn+k cannot occur in T (β) (otherwise the Closure rule would be applicable on T (α) which is impossible). Furthermore, by irreducibility w.r.t. the Normalisation rule, the indices of the defined symbols occurring in α must be 0 or n. Since the rewrite rules in R cannot increase the value of the these indices, the truth value of these indexed defined symbols depends only of the values of the atoms indexed by I(n), I(n − 1), . . . , I(0). Thus we may assume that I(pn+k) = true (resp. I(pn+k) = false). Hence I |= T (α).\nWe will not prove the converse (namely that the root of every closed tableau is unsatisfiable), because this is subsumed by Theorem 18 in Section 3 (ensuring the existence of a resolution proof for every instance of the root schema).\nExample 7 The schema φ : p0 ∧ ¬pn ∧ υn, where υ is defined as in Example 4 is unsatisfiable. For instance, φ{n ← 2} is p0 ∧ ¬p2 ∧ (¬p0 ∨ p1) ∧ (¬p1 ∨ p2). The reader can check that the expansion rules construct the following tableau. The root is actually a layer, hence the Explosion rule is applied on it. The node (3) is deduced by the Purity rule and closed by applying the Loop Detection rule (with the root). The other rule applications are straightforward.\nφ (7)\np0,¬p0, υ0 (1)\n⊥\np0,¬pn+1υn+1 (6)\np0,¬pn+1, υn, (¬pn ∨ pn+1) (5)\np0,¬pn+1, υn, pn+1 (2)\n⊥\np0,¬pn+1, υn,¬pn (4)\np0, υn,¬pn (3)\n⊥ ♣\nThe Dpll∗ procedure in [3] can be simulated by the previous expansion rules, simply by adding for each propositional symbol p ∈ Ω, a defined symbol υp with two rules: υp\ni+1 → ((pi∨¬pi)∧υ p i ) and υp0 → ⊤. Then the case splitting\nrule of the DPLL procedure on a variable p corresponds to an application of the ∧-rule on υp\nn+1↓R (yielding pn∨¬pn) followed by an application of the ∨-rule on pn ∨ ¬pn. The propagation rule is then simulated by combining the ∨-rule and the closure rule2."
    }, {
      "heading" : "3 Constructing resolution proofs",
      "text" : ""
    }, {
      "heading" : "3.1 Propositional resolution calculus",
      "text" : "We first briefly recall the notion of resolution inference (in propositional logic). A literal is either an atom pk or the negation of an atom ¬pk (where p ∈ Ω and k ∈ N). A clause is a (possibly empty) disjunction (or set) of literals. A derivation from a set of clauses S is a finite sequence C1, . . . , Cm such that for every i ∈ [1,m], Ci is either an element of S or obtained from C1, . . . , Cm−1 by applying the resolution rule, defined as follows: pk ∨X ¬pk ∨ Y\nX ∨ Y A refutation is a derivation containing⊥ (the empty clause). For any formula φ, ∆ is a derivation from φ if it is a derivation from a clausal form of φ. It is well-known [9] that every unsatisfiable set of (propositional) clauses has a refutation. In the context of propositional schemata, this means that every instance φ{n ← k}↓R of an unsatisfiable propositional schema φ of parameter n has a refutation ∆k (which in general depends on k). The problem is then to construct a representation of the sequence of refutations ∆0,∆1, . . . ,∆k, . . . This sequence may be seen as a schema of refutation which (similarly to the semantics of the defined symbols) will be denoted by a system of rewrite rules. From now, we assume that the considered schema is in conjunctive normal form (i.e. it contains no conjunctions inside disjunctions, even if these conjunctions are “hidden” in the inductive definitions of the defined symbols, e.g. the schema pn ∨ υn, where υ is defined as in Example 4 is forbidden)."
    }, {
      "heading" : "3.2 A language for representing refutations",
      "text" : "Additional definitions are needed to provide suitable formal languages for denoting such schemata of derivations. Let D and X be two disjoint sets of symbols (disjoint from V , Ω and Υ). The symbols in D are the ∆-symbols and the ones in X are the ∆-variables. The symbols in X are intended to be instantiated by schemata, whereas the symbols d ∈ D will denote schemata of refutations, defined by induction (and possibly depending on an additional argument ∆ denoting a formula). We assume that ≺ is extended into a well-founded ordering on D.\nFormally, the set of ∆-expressions is inductively defined as follows:\n• All schemata and all ∆-variables are ∆-expressions.\n2This “trick” does not actually simulate the full procedure in [3], because the latter handles schemata that are more complex than the ones considered in the present paper, possibly containing nested iterations.\n• If d ∈ D, α is an index expression and ∆ is a ∆-expression, then dα and dα(∆) are ∆-expressions.\n• If ∆ and Γ are ∆-expressions then ∆∨Γ, ∆∧Γ and ∆·Γ are ∆-expressions.\nThe expression ∆·Γ is to be interpreted as the concatenation of two sequences ∆ and Γ. Note that ∆-expressions can represent uniformly schemata of clauses, schemata of clause sets, or schemata of derivations (i.e. schemata of sequences of clauses). For the sake of conciseness and simplicity, the previous definition does not ensure that the constructions are well-typed, e.g. we can consider ∆- expressions of the form ∆∨Γ where ∆ and Γ are two sequences of clauses (which obviously does not make sense: ∆ and Γ should rather be clauses). But in the forthcoming definitions we will ensure that all the considered ∆-expressions are well-typed.\nExample 8 Let d ∈ D. Then (p2 ∨ q0) · d2(q0) · ¬q0 · ⊥ is a ∆-expression. ♣\nA ∆-expression is ground if it contains no index variable and no ∆-variable. In order to interpret (ground) ∆-expressions, the value of the ∆-symbols is specified using a rewrite system, exactly as schemata can be transformed into propositional formulæ by interpreting the defined symbols (using the rewrite system R). The rewrite systems used in this section are more complicated than in the previous one, since the symbols in D may have an additional argument.\nA ∆-substitution is a function mapping every arithmetic variable to an index expression and every ∆-variable to a ∆-expression. If ∆ is a ∆-expression and σ is a ∆-substitution, then ∆σ denotes the ∆-expression obtained from ∆ by replacing every variable x ∈ V ∪ X by σ(x).\nDefinition 9 A D-system is a set of rewrite rules of the form ∆ → Γ, where ∆,Γ are two ∆-expressions such that every arithmetic variable and every ∆- variable occurring in Γ also occurs in ∆. A D-system is propositional if it contains no ∆-variables (it may contain arithmetic variables).\nGiven two ∆-expressions ∆ and Γ and a D-system R, we write ∆ →R Γ if there exists a rule ∆′ → Γ′ in R and a ∆-substitution σ such that Γ is obtained from ∆ by replacing an occurrence of an expression ∆′σ by Γ′σ. ✸\nFor matching, the associativity and commutativity of logical symbols are not taken into account in general, except for conjunctions occurring at the root level (this rather unusual convention is needed to ensure confluence without having to bother on the order of the schemata at the root level). For instance the rule d(p ∧ ((r ∧ q) ∨ ¬r)) → p does not apply on d(p ∧ (¬r ∨ (r ∧ q))) nor on d(p∧((q∧r)∨¬r)), but it applies on d(((r∧q)∨¬r)∧p). Similarly, d(p∧q) → p applies on d(p) by assuming q = ⊤.\nExample 10 Consider the following rewrite system (Z is a ∆-variable).\n{di+1(Z) → (¬pi+1 ∨ pi) · (pi ∨ Z) · di(Z), d0(Z) → ¬p0 · Z}\nThe reader can check that it reduces the ∆-expression of Example 8 to:\n(p2 ∨ q0) · (¬p2 ∨ p1) · (p1 ∨ q0) · (¬p1 ∨ p0) · (p0 ∨ q0) · ¬p0 · q0 · ¬q0 · ⊥\nThis last expression is a refutation. ♣"
    }, {
      "heading" : "3.3 From closed tableaux to resolution proofs",
      "text" : "Let T be a closed tableau of a schema φ. The general idea is to construct, from T , a D-system R(T ) representing a schema of refutation for φ. Obviously, R(T ) represents an inductive proof of the assertion: “for every n ∈ N, the corresponding instance of φ is unsatisfiable”. Ideally, we would just refute the base case, and then build a refutation of φ at n+ 1 from a refutation of φ at n. However, as often in inductive reasoning, we need to generalize the conjecture in order to refute it properly. This is done as follows: recall that our aim is to construct a refutation of φ, i.e. a derivation of ⊥ from φ; instead, however, R(T ) will describe how to build a derivation of X from φ ∨ X , for any X (formally, X will be a ∆-variable). Then, our original goal will be reached by just substituting ⊥ to X . In practice, we need to generalize even more this reasoning since the construction of R(T ) is done by mapping every node α of T to some rewrite rules. So, instead of considering only the root schema φ, we need to consider all the formulæ {φ1, . . . , φk} that occur in T (α). And, instead of building a derivation of X from φ∨X , we build a derivation of X1 ∨ · · · ∨Xk from (φ1∨X1)∧· · ·∧(φk∨Xk), for some ∆-variablesX1, . . . , Xk. More precisely we build a derivation of a clause C ⊆ X1 ∨ . . .∨Xk, since some formulæ φi ∨Xi may be useless. We retrieve our original goal when we just substitute the root of T to α.\nThe following definition constructs a D-system R(T ) and two ∆-symbols να and µα such that, if T (α) = {φ1, . . . , φk} and U denotes the formula (φ1∨X1)∧ · · · ∧ (φk ∨ Xk) then µ α n (U) denotes the above clause C and να n (U) denotes a derivation of C from U . This system is constructed by induction on the tableau.\nDefinition 11 Let T be a tableau. We map every node α in T to two ∆- symbols να and µα. We assume that the symbols να and µα are pairwise distinct. The system of rules R(T ) is defined by the rules in R and the following rules, for every node α in T (we distinguish several cases, according to the rule applied on α):\n• If no rule is applied on α: να n ((⊥∨X)∧Y ) → X µα n ((⊥∨X)∧Y ) → X\n• If the Normalisation rule is applied on α, using a formula φ, yielding a node β:\nνα n ((φ ∨X) ∧ Y ) → νβ n ((φ↓R ∨X) ∧ Y ) µα n ((φ ∨X) ∧ Y ) → µβ n ((φ↓R ∨X) ∧ Y )\n• If the Closure rule is applied on α, using φ and ¬φ:\nνα n ((φ ∨X) ∧ (¬φ ∨ Y ) ∧ Z) → (¬φ ∨ Y ) · (φ ∨X) · (X ∨ Y )\nµα n ((φ ∨X) ∧ (¬φ ∨ Y ) ∧ Z) → (X ∨ Y )\n• If ∧-Decomposition is applied on α, yielding a child β:\nνα n (((φ1 ∧ φ2) ∨X) ∧ Y ) → ν β n ((φ1 ∨X) ∧ (φ2 ∨X) ∧ Y )\nµα n (((φ1 ∧ φ2) ∨X) ∧ Y ) → µ β n ((φ1 ∨X) ∧ (φ2 ∨X) ∧ Y )\n• If ∨-Decomposition is applied on α using a formula φ∨ψ and yielding two children β1 and β2:\nνα n (((φ1∨φ2)∨X)∧Y ) → ν β1 n ((φ1∨(φ2∨X))∧Y )·ν β2 n (µβ1 n ((φ1∨(φ2∨X))∧Y )∧Y )\nµα n (((φ1 ∨ φ2) ∨X) ∧ Y ) → µ β2 n (µβ1 n ((φ1 ∨ (φ2 ∨X)) ∧ Y ) ∧ Y )\n• If the Purity rule is applied on α, on a formula φ, yielding a node β:\nνα n ((φ ∨X) ∧ Y ) → νβ n (Y ) µα n ((φ ∨X) ∧ Y ) → µβ n (Y )\n• If the Loop Detection rule is applied on α, using a layer β:\nνα n (X) → νβ n (X) µα n (X) → µα n (X)\n• If the Explosion rule is applied on α, yielding two children β1 and β2, corresponding to the cases n ← 0 and n ← n+ 1 respectively:\nνα0 (X) → ν β1 0 (X) ν α n+1(X) → ν β1 n (X) µ α 0 (X) → µ β2 0 (X) µ α n+1(X) → µ β2 n (X)\n✸\nNote that all the symbols φ, φ1,φ2 denote meta-variables, and not ∆- variables (hence they cannot be instantiated during rewriting, in contrast to X , Y ,. . . ).\nBefore establishing the properties of R(T ), we show an example of application:\nExample 12 Consider the proof tree of Example 7. The reader can check that R(T ) contains the following rules:\nν1n ((p0 ∨X) ∧ (¬p0 ∨ Y ) ∧ Z) → (p0 ∨X) · (¬p0 ∨ Y ) · (X ∨ Y ) µ1n((p0 ∨X) ∧ (¬p0 ∨ Y ) ∧ Z) → X ∨ Y ν2n ((pn+1 ∨X) ∧ (¬pn+1 ∨ Y ) ∧ Z) → (pn+1 ∨X) · (¬pn+1 ∨ Y ) · (X ∨ Y ) µ2n((pn+1 ∨X) ∧ (¬pn+1 ∨ Y ) ∧ Z) → X ∨ Y ν3n (X) → ν 7 n (X) µ3n(X) → µ 7 n(X) ν4n ((¬pn+1 ∨X) ∧ Y ) → ν 3 n (Y ) µ4n((¬pn+1 ∨X) ∧ Y ) → µ 3 n(Y ) ν5n (((¬pn ∨ pn+1) ∨X) ∧ Y ) → ν 2 n (((pn+1) ∨ (¬pn ∨X)) ∧ Y )\n·ν4n (µ 2 n((pn+1 ∨ (¬pn ∨X)) ∧ Y ) ∧ Y )\nµ5n(((¬pn ∨ pn+1) ∨X) ∧ Y ) → µ 4 n(µ 2 n((pn+1 ∨ (¬pn ∨X)) ∧ Y ) ∧ Y ) ν6n ((υn+1 ∨X) ∧ Y ) → ν 5 n (((¬pn ∨ pn+1) ∨X) ∧ υn ∧ Y ) µ6n((υn+1 ∨X) ∧ Y ) → µ 5 n(((¬pn ∨ pn+1) ∨X) ∧ υn ∧ Y ) ν70(X) → ν 1 0(X) µ70(X) → µ 1 0(X) ν7n+1(X) → ν 6 n (X) µ7n+1(X) → µ 6 n(X)\nThe ∆-expression ν7 n ((p0 ∨⊥)∧ (¬pn ∨⊥)∧ (υn ∨⊥)) denotes a refutation of p0∧¬pn∧υn. This rewrite system is complex and hardly readable, fortunately it can be simplified by instantiating the arguments when possible and by statically evaluating the derivations that do no depend on the value of the parameter n. For instance the ∆-symbol ν7\nn is only called on the formula Tn = (p0 ∨ ⊥) ∧\n(¬pn ∨ ⊥) ∧ (υn ∨ ⊥). Thus the rule ν 7 n (X) → ν10(X) may be simplified by instantiating X by T0 and evaluating the right-hand side: ν 7 0(T0) → p0 · ¬p0 · ⊥\nSimilarly, the rule ν7 n+1(X) → ν 6 n (X) can be replaced by the following rule (in this case only a partial evaluation is possible since some parts of the derivation depend on the value of n): ν7\nn+1(Tn+1) → (¬pn ∨ pn+1) · ¬pn+1 · ¬pn · ν 7 n (Tn)\nThe obtained system (only containing the two previous rules) is obviously much simpler than the original one, in particular it is propositional (no schema variables occur in it). To improve readability, the expression ν7\nn (Tn) could be\nsimply replaced by a fresh symbol ν7 ′\nn (with no argument). ♣\nWe define the following relation ≺T on the nodes in a tableau T .\nDefinition 13 Let T be a tableau. ≺T is the least transitive relation such that α ≺T β if one of the following conditions hold:\n1. Either α is a child of β, but α does not correspond to the “n ← n + 1” branch of an Explosion rule. This is written α ≺1T β.\n2. Or the Loop Detection rule has been applied on the node β, using the layer α. This is written α ≺2T β. ✸\nProposition 14 Let T be a tableau. ≺T is a strict partial order.\nProof. By definition, T has been obtained by a sequence of application of the Expansion rules in Section 2. If α and β are two non-leaf nodes in T , we write α✁β if the expansion rule on α has been applied before the one of β during this derivation, in chronological order (of course several derivations are possible, we choose one of them arbitrarily). ✁ is obviously an ordering. Furthermore, if we have α ≺2T β then by the application condition of the Loop Detection rule we must have α ✁ β, since when the rule is applied on β the node α cannot be a leaf, thus an expansion rule must already have been applied on it.\nAssume that ≺T is not an ordering. By definition ≺T is transitive, thus it must be reflexive, i.e. there is a node α such that α ≺T α. By definition of ≺T this means that there exists a sequence of nodes β1, . . . , βk such that β1 = βk = α and for every i ∈ [1, k− 1], βi ≺ ǫ T βi+1 (with ǫ = 1, 2). If for every i ∈ [1, k − 1] we have βi ≺ 1 T βi+1 then for all i ∈ [1, k − 1] βi is a child of βi+1 which implies that there is a (non trivial) path in the tableau from α to α. This is impossible. Thus there is at least one node βi+1 such that the Loop Detection rule is applied on βi+1. W.l.o.g. we can assume that i + 1 = k. If for every i ∈ [1, k− 1] we have βi ≺ 2 T βi+1 we have βi✁βi+1, hence by transitivity α✁α, which is impossible. Let j the greatest index in [1, k− 1] such that βj 6≺ 2 T βj+1. We have βj ≺ 1 T βj+1 ≺ 2 T βj+2 ≺ 2 T . . . ≺ 2 T βk.\nSince βj+1 ≺ 2 T βj+2, βj+1 must be a layer, thus the only rule that can be applied on βj+1 is the Explosion rule. Since βj ≺ 1 T βj+1 βj cannot correspond to the branch n ← n + 1 of the Explosion rule. Thus it corresponds to the branch n ← 0. But then the nodes βj , βj−1, . . . , β1 cannot possibly contain n (since no rule can introduce an occurrence of n in the tableau, and since by the application condition, the Loop Detection rule cannot be applied between a leaf not containing n and a layer containing n). Since β1 = βk this means that βk, . . . , βj+1 contains no occurrence of n. But in this case the Explosion rule cannot be applied on βj+1, a contradiction.\nLemma 15 Let T be a tableau. R(T ) is convergent.\nProof. We extend the ordering ≺T to the ∆-symbols as follows: ν α ≺T ν β and µα ≺T µ β if α ≺T β. By definition of ≺T , it is easy to check that all the rules above – except the n+1-rewrite rule corresponding to the Explosion rule – strictly decrease the value of the symbols να and µα. Furthermore, they do not increase the value of the indices. The Explosion rule may increase the value of these symbols but strictly decreases their indices. Thus termination is obvious. Confluence is immediate: indeed, since each node is labeled by a set (and not a multiset), the system is necessarily orthogonal (note that we assume that the semantic properties of the logical connectives are not taken into account for the matching, except the AC-properties of the ∧ occurring at root level).\nFor any ∆-expression T , we denote by T ↓R(T ) the normal form of T . We now state the soundness of our algorithm.\nLemma 16 states that the rewrite system R(T ) indeed fulfils the desired property.\nLemma 16 Let T be a closed tableau. Let α be a node in T . Let k ∈ N. Let T (α) = {φ1, . . . , φn}. Let X1,. . . ,Xn be a set of pairwise distinct variables in V. Let U = (φ1 ∨X1)∧ . . .∧ (φn ∨Xn). Then ν α k (U)↓R(T ) is a derivation from U↓R of µ α(U)↓R(T ).\nProof. The proof is by induction on the pair (α, k), using the lexicographic extension of the ordering ≺T on the nodes in T and of the usual ordering on natural numbers (this ordering is obviously well-founded since T is finite). We distinguish several cases, according to the expansion rule that is applied on α.\n• If no rule is applied on α then T (α) must contain ⊥. W.l.o.g., we assume that φ1 = ⊥. By Definition 11, we have ν α k (U) ↓R(T )= X1 and\nµα(U)↓R(T )= X1, thus the proof is immediate (since X1 is obviously a derivation of X1).\n• If the closure rule is applied on α then T (α) must contain two schemata ψ and ¬ψ. W.l.o.g., we assume that φ1 = ψ and φ2 = ¬ψ. By Definition 11, we have ναk (U)↓R(T )= (ψ ∨X1) · (¬ψ ∨X2) · (X1 ∨X2) and µ\nα(U)↓R(T )= (X1∨X2) hence the proof is completed, since (ψ∨X1)·(¬ψ∨X2)·(X1∨X2) is a derivation of X1 ∨X2.\n• Assume that ∧-Decomposition is applied on a schema ψ1 ∧ ψ2. W.l.o.g., we assume that φ1 = (ψ1 ∧ ψ2). Let β be the child of α. Let U\n′ = (φ2 ∨X2) ∧ . . . ∧ (φn ∨Xn), i.e. we have U = ((ψ1 ∧ ψ2) ∨X1) ∧ U ′. By Definition 11, we have ναk (U)↓R(T )= ν β k ((ψ1 ∨X1)∧ (ψ2 ∧X2)∧U\n′)↓R(T ) and µα(U)↓R(T )= µ β((ψ1 ∨ X1) ∧ (ψ2 ∧ X2) ∧ U ′)↓R(T ). Thus, by the induction hypothesis, ναk ((ψ1 ∨X1) ∧ (ψ2 ∨X2) ∧ U)↓R(T ) is a derivation from (ψ1 ∨X1) ∧ (ψ2 ∧X2) ∧ U ′↓R of µ β(U)↓R(T )= µ α(U)↓R(T ). Hence it is also a derivation from U↓R since U and (ψ1 ∨X1) ∧ (ψ2 ∧X2) ∧ U ′ share the same clausal forms.\n• Assume that ∨-Decomposition is applied on a schema ψ1 ∨ ψ2. W.l.o.g., we assume that φ1 = (ψ1 ∨ ψ2). Let β1 and β2 be the children of α (corresponding to the schemata ψ1 and ψ2 respectively). Let U\n′ = (φ2 ∨ X2) ∧ . . . ∧ (φn ∨ Xn), i.e. we have U = ((ψ1 ∨ ψ2) ∨ X1) ∧ U ′. By Definition 11, we have ναk (U)↓R(T )= ν β1 k (U)↓R(T ) ·ν β2 k (µ β1 k (U)∧U\n′)↓R(T ) and µαk (U)↓R(T )= µ β2 k (µ β1 k (U) ∧ U ′)↓R(T ). By the induction hypothesis, νβ1k (U)↓R(T ) is a derivation from U ↓R of µ β1 k (U) ↓R(T ). Then, again by the induction hypothesis, ν β2 k (µ β1 k (U) ∧ U ′)↓R(T ) is a derivation from µ β1 k (U) ∧ U ′↓R of µ β2(µβ1k (U) ∧ U\n′)↓R(T ) i.e. of µαk (U)↓R(T ). Consequently, ν α k (U)↓R(T ) is a derivation from U↓R of µαk (U)↓R(T ).\n• Assume that the Loop Detection rule is applied on α, using a node β. R(T ) contains the rule να\nn (X) → νβ n (X) and µα n (X) → µα n (X). Then the\nproof is straightforward, by the induction hypothesis.\n• Assume that the Purity rule is applied on α, yielding a node β. Since T (α) ⊃ T (β), the proof is immediate (a derivation from a set S is also a derivation from S ∪ S′).\n• Assume that Explosion is applied on α, yielding two nodes β1 and β2 (corresponding respectively to the case n ← 0 and n ← n + 1). We distinguish two cases, according to the value of k.\n– If k = 0 then we have ναk (U)↓R(T )= ν β1 0 (U)↓R(T ) and µ α k (U)↓R(T )=\nµ β1 0 (U)↓R(T ). By the induction hypothesis, ν β1 0 (U)↓R(T ) is a derivation from U of µβ10 (U)↓R(T ) hence the proof is completed.\n– If k > 0 then ναk (U) ↓R(T )= ν β1 k−1(U) ↓R(T ) and µ α k (U) ↓R(T )=\nµ β1 k−1(U) ↓R(T ). By the induction hypothesis, ν β1 k−1(U) ↓R(T ) is a derivation from U of µβ1k−1(U)↓R(T ) hence the proof is completed.\nNote that (contrarily to all the other cases) we may have β1 ≻T α, but we are using the induction hypothesis on νβ1k−1. This is possible since k − 1 < k.\nFurthermore, we have the following:\nLemma 17 Let T be a closed tableau. Let α be a node in T . Let T (α) = {φ1, . . . , φn}. µ\nα((φ1 ∨X1)∧ . . .∧ (φn ∨Xn))↓R(T ) is a disjunction of formulæ in X1, . . . , Xn.\nProof. By an immediate induction on µαk .\nThus in the case in which X1 = . . . Xn = ⊥, ν α k (Φ) denotes a refutation of T (α), which entails the following theorem, showing the soundness of our algorithm (and entailing in particular the completeness of the tableau calculus).\nTheorem 18 Let T be a closed tableau containing a node α. Let n be the parameter of T (α). Let T (α) = {φ1, . . . , φn} and let Φ = (φ1∨⊥)∧. . .∧(φn∨⊥).\nFor any k ∈ N, ναk (Φ{n ← k})↓R(T ) is a refutation of Φ{n ← k}↓R. Thus T (α) is unsatisfiable.\nProof. By Lemma 16, ναk (Φ{n ← k})↓R(T ) is a derivation from Φ{n ← k}↓R (hence also from Φ{n ← k} ↓R) of µ α k (Φ{n ← k}) ↓R(T ). By Lemma 17, µαk (Φ{n ← k})↓R(T )= ⊥.\nNote that the size of the rewrite system R(T ) is clearly linear w.r.t. the one of the tableau T .\nThe simplification phase used in Example 12 can be applied in a systematic way. However, it is not always sufficient to reduce the rewrite system into a propositional one. Actually, it is not difficult to see that as soon as a node α exists in the tableau on which the ∨-Decomposition rule is applied, yielding two branches β1 and β2 that are both looping on an ascendant of α, then the use of schema variables cannot be avoided.\nExample 19 Consider for instance the schema: φ : ¬p0 ∧ ¬q0 ∧ (pn ∨ qn) ∧ υn, where υ is defined by the rules: υi+1 → (qi ∨ ¬pi+1) ∧ (pi ∨ ¬qi+1) ∧ υi and υ0 → ⊤. The following tableau is constructed:\nφ\npn\np0\n⊥\npn+1\nqn\n⊥ (loop)\n¬pn+1\n⊥\nqn\nq0\n⊥\nqn+1\npn\n⊥ (loop)\n¬qn+1\n⊥\nThe corresponding rewrite system (after partial evaluation and simplification) is the following (ν1\nn corresponds to the refutation of φ):\nν1n (¬p0 ∧ ¬q0 ∧ (pn ∨ qn) ∧ υn) → ν2n (¬p0 ∧ ¬q0 ∧ (pn ∨ qn) ∧ υn) · ν 3 n (¬p0 ∧ ¬q0 ∧ qn ∧ υn) ν20(¬p0 ∧ (p0 ∨X) ∧ Y ) → ¬p0 · (p0 ∨X) ·X ν2n+1(¬p0 ∧ ¬q0 ∧ (pn+1 ∨X) ∧ υn+1) →\n(pn+1 ∨X) · (qn ∨ ¬pn+1) · (qn ∨X) · ν 3 n (¬p0 ∧ ¬q0 ∧ (qn ∨X) ∧ υn)\nν30(¬p0 ∧ (q0 ∨X) ∧ Y ) → ¬q0 · (q0 ∨X) ·X ν3n+1(¬p0 ∧ ¬q0 ∧ (qn+1 ∨X) ∧ υn+1) →\n(qn+1 ∨X) · (pn ∨ ¬qn+1) · (pn ∨X) · ν 2 n (¬p0 ∧ ¬q0 ∧ (pn ∨X) ∧ υn)\nThe system still contains ∆-variables, although some of them have been removed by static evaluation. Note that it could be further simplified (for instance by moving the axioms such as ¬p0 outside the inductive definitions), but the use of ∆-variables cannot be avoided. ♣\nWe now focus on an alternative approach that has the advantage that only propositional rewrite systems are generated."
    }, {
      "heading" : "4 Globally looping tableaux",
      "text" : "Compared to the previous approach, the second algorithm generates much simpler rewrite systems, but it has the drawback that a more restrictive version of the Loop Detection rule must be used to prune the tableaux into finite ones. At a very high and informal level: in the first approach, we were building mutually inductive proofs of several lemmata, whereas, in the second approach, we manage to have one single invariant proved by a single induction.\nWe first need to introduce some additional terminology. A node α is of rank k in a tableau T of root β if there are exactly k applications of the Explosion rule between β and α (including β, but not α). Leaves(T , α) denotes the set of non-closed leaves below α in T , Layers(T , k) denotes the set of layers of rank k\nin T and Layers(T , k, α) denotes the set of layers of rank k in T that occur below α. For any set of formulæ Φ, we denote by ∧ Φ the conjunction ∧ φ∈Φ φ. If T is a tableau and N is a set of nodes in T , then T [N ] denotes the disjunction∨ α∈N ∧ T (α). We write cnf(φ) for a (subsumption-minimal) clausal form of φ↓R.\nDefinition 20 A tableau T is globally looping (w.r.t. two natural numbers k and n) iff the following conditions hold:\n1. n < k.\n2. T [Layers(T , k)] = T [Layers(T , n)] (modulo AC and idempotence).\n3. All non-closed leaves in T are of a rank greater or equal to k.\nThen the Global Loop Detection rule closes every node in Layers(T , k). ✸\nBy definition, after the Global Loop Detection rule is applied, all branches containing the parameter n are closed and the construction of the tableau is over (since no leaf can be expanded anymore). Note that the Global Loop Detection rule can be simulated by several applications of the Loop Detection rule introduced in Section 2. Indeed, assume that a pair of natural numbers (k, n) satisfying the conditions of Definition 20 exists. Then, by Condition 2, for every layer α of rank k, there exists a layer β of rank n such that T (α) = T (β). Thus the Loop Detection rule applies on α (w.l.o.g. we assume that the layers of rank n are constructed before those of rank k in all parallel branches, which is possible since n < k). However, it is easy to see that the converse does not hold: the Global Loop Detection rule is strictly less general than the looping rule. It is, however, powerful enough to ensure termination, provided that a fair strategy is used to expand the tableau, as stated by the following theorem:\nTheorem 21 Let (Ti)i∈N be an infinite sequence of tableaux such that, for every i ∈ N, Ti+1 is obtained from Ti by applying one of the Expansion rules of Section 2, other than the Loop Detection rule. Assume, moreover, that for every k ∈ N, there exists n ∈ N such that every non-closed leaf in Tn is of a rank greater than k (i.e. no branch is indefinitely “frozen”, the rank of the leaves increases indefinitely). There exists n ∈ N such that Tn is globally looping.\nProof. We have shown (see the proof of Theorem 5) that the number of sets Ti(α) where α is a leaf in Ti is finite. Thus the set of sets of nodes {Ti(α) | α ∈ Layers(Ti, n)} is also finite. Let k be a natural number that is strictly greater than the cardinality of this set. By the hypothesis of the theorem, there exists n ∈ N such that every leaf in Tn is of a rank greater than k. By the pigeonhole argument, there exist two natural numbers n′ < k′ such that T [Layers(Tn, n ′)] = T [Layers(Tn, k ′)]. Then Tn is globally looping.\nWe now show that from every tableau T , one can extract a resolution derivation from the root of T of the disjunction of the leaves of T . We first restrict ourselves to tableaux built without the Explosion and Loop Detection rules. We\nfocus on such tableaux because they correspond to the subtrees that are found “between” two layers in an tableau built without restriction on the rules. More precisely, take a layer α of some rank m in a tableau T (built without restriction on the rules). Then the subtree of T of root α and whose leaves are the layers of rank m+1 below α is indeed a tree built without Explosion nor Loop Detection (by definition of a layer).\nWe first build derivations for such subtrees, those derivations will then be used as the base elements for building the final schema of refutation. For such a tree T and a node α of T , the next definition introduces ∆(T , α), which is intended to be a derivation of cnf(T [Leaves(T , α)]) from cnf(T (α)).\nDefinition 22 Let T be a tableau constructed using the Expansion rules, except the Explosion and Loop Detection rules. Let α be a node in T . We define a derivation ∆(T , α) inductively, according to the rule that is applied on α:\n• If α is a leaf, then ∆(T , α) is defined as the sequence of clauses in cnf(T (α)).\n• If the Closure rule is applied on α, using two formulæ φ and ¬φ, then\n∆(T , α) def\n= φ · ¬φ · ⊥ (notice that since the formulæ are in NNF, φ must be an atom).\n• If the Normalisation, Purity or ∧-Decomposition rule is applied on α,\nyielding a node β then ∆(T , α) def = ∆(T , β).\n• Finally, assume that the ∨-Decomposition rule is applied on α yielding two nodes β1 and β2. Let Φ1 and Φ2 be the clausal forms of φ1 and φ2 respectively. For any C ∈ Φ2, let Λ\n′(C) be the derivation obtained from ∆(T , β1) by replacing every occurrence of a clause D ∈ Φ1 by D∨C (and by adding the disjunction ∨C to every descendant of D).\nFor any clause C′ in cnf(T [Leaves(T , β1)]), we construct a derivation Λ′′(C′) from ∆(T , β2) by replacing every occurrence of a clause D ∈ Φ2 by D ∨C′ (and by adding the disjunction ∨C′ to every descendant of D). Then ∆(T , α) is the concatenation of all the derivations Λ′(C) and Λ′′(C′) (with C ∈ Φ2 and C ′ ∈ cnf(T [Leaves(T , β1)])).\nOnly the case of disjunction is non-trivial. Informally, it does nothing more than building, for two sets of clauses S1 and S2, a derivation of cnf(S1 ∨ S2) from two derivations of S1 and S2.\nThe following lemma states that ∆(T , α) satisfies the desired property:\nLemma 23 Let T be a tableau, constructed by using the previous expansion rules, except the Explosion and Loop Detection rules. For all nodes α in T , ∆(T , α) is a derivation of cnf(T [Leaves(T , α)]) from cnf(T (α)).\nProof. The proof is by induction on the depth of T . We distinguish several cases, according to the rule applied on α.\n• If α is a leaf then Leaves(T , α) = {α}. Moreover, according to Definition 22, ∆(T , α) is the sequence of formulæ in cnf(T (α)), thus the proof is completed.\n• If the Normalisation or ∧-Decomposition rule is applied on α, yielding a node β, then we have cnf(T (α)) = cnf(T (β)). Moreover, since α has only one child, cnf(T [Leaves(T , α)]) = cnf(T [Leaves(T , β)]). Hence the proof is immediate, by the induction hypothesis.\n• If the Purity rule is applied on α, using a formula φ, yielding a node β, then by the induction hypothesis, ∆(T , β) is a derivation of cnf(T [Leaves(T , β)]) from cnf(T (β)). Since α has only one child, cnf(T [Leaves(T , α)]) = cnf(T [Leaves(T , β)]). Furthermore, cnf(T (α)) is of the form φ∧cnf(T (β)) thus ∆(T , β) is also a derivation from cnf(T (α)). Since, by Definition 22, ∆(T , α) = ∆(T , β), the proof is completed.\n• Finally, assume that the Disjunction rule is applied on α, using a formula φ1∨φ2. This yields two nodes β1 and β2, corresponding respectively to φ1 and φ2. Let Φ1 and Φ2 be a cnf of φ1 and φ2 respectively. By definition, cnf(T [Leaves(T , α)]) is the clausal form of the disjunction of cnf(T [Leaves(T , β1)]) and cnf(T [Leaves(T , β2)]), hence every clause occurring in cnf(T [Leaves(T , α)]) is of the form C1 ∨ C2 where Ci occurs in cnf(T [Leaves(T , βi)]) (i = 1, 2). By the induction hypothesis ∆(T , β1) is a derivation of cnf(T [Leaves(T , β1)]) from cnf(T (β1)). Thus in particular, for every C ∈ Φ2, Λ\n′(C) (see Definition 22 for the notations) is a derivation from cnf(T (α)) of either C1 or C1 ∨ C. In the first case, the formula φ1 is not needed for deriving C1, thus actually, C1 also occurs in cnf(T [Leaves(T , β2)]). Since C1 ∨ C2 is subsumption-minimal, we must have actually C1 = C2 and the proof is completed. In the second case, by the induction hypothesis ∆(T , β2) is a derivation of C2 from cnf(T (β2)), thus Λ′′(C1) is a derivation of C1∨C2 from cnf(T (α))∪{C1∨D | D ∈ Φ2}. Hence ∆(T , α) is a derivation of C1 ∨ C2 from cnf(T (α)).\nThus the function T (α) → ∆(T , α) allows us to build derivations from subtrees of a whole tableau. Intuitively, the next step is to put together those derivations according to the positions of the corresponding subtrees in the main tableau. Consider a rank m in a tableau T . One can apply the function ∆ to all the (parallel) subtrees whose root is a layer of rank m. Then we can do the same at rank m + 1, append every resulting derivation to the derivation obtained from the parent tree, and go on at rank m + 2, etc. This intuitively gives the structure of a rewrite system where n decreases each time we go to the next rank. However this gives us a tree-like structure (to every derivation corresponding to a subtree U we append the derivations corresponding to all the leaves of U , and go on with the trees below those leaves) similar to the rewrite systems presented in Section 3. Instead we would like a more linear structure. So we will consider at once all the layers of a given rank and get only\none derivation corresponding to those nodes. For this, we need a way to apply ∆ to all the subtrees at once. This is actually done by building a new tableau from the subtrees.\nLet T be a tableau of root α. Assume that T is globally looping w.r.t. n and k, with n < k. Let m < k. We denote by U(T ,m) a tableau whose root is labeled by a formula T [Layers(T ,m)] (note that we take all the layers of rankm at a time), and obtained by applying the ∨ and ∧-Decomposition and Closure rules (and only these rules) until irreducibility. By definition, since the root formula of U(T ,m) is the disjunction of the labels of the layers in Layers(T ,m), every non-closed leaf β of U(T ,m) is labeled by a set of formulæ of the form T (γβ), where γβ ∈ Layers(T ,m). Furthermore, for every γ ∈ Layers(T ,m), there exists a leaf β of U(T ,m) such that γβ = γ. Since m < k and since by Definition 20 the leaves of T must be of a rank greater or equal to k, the node γβ cannot be a leaf of T . This implies that some rule is applied on γβ . But the only rule that is applicable on a layer (beside the Global Loop Detection rule that cannot be applied on layers of a rank distinct from k) is the Explosion rule. Hence T necessarily contains two subtableaux, written T 0β and T 1 β , of roots T (γβ){n ← 0} and T (γβ){n ← n + 1} respectively. Then V 0(T ,m) and V1(T ,m) denote respectively the tableaux obtained from U(T ,m){n ← 0} and U(T ,m){n ← n+ 1} by:\n• Replacing every leaf β by T 0β and T 1 β respectively.\n• Removing, in the obtained tableau, all applications of the Explosion rule3\n(and all the nodes that occur below such an application).\nBy definition, the leaves of V0(T ,m) and V1(T ,m) are layers. They correspond either to the leaves of T or to the nodes in T on which Explosion is applied (these nodes are of rank m+ 1 in T ).\nProposition 24 Let T be a tableau that is globally looping w.r.t. two numbers n < k. Let m < k. For any non closed leaf β of U(T ,m), T 0β is closed and Layers(T 1β , 0) = Layers(T ,m+ 1, γβ).\nProof. By definition, all leaves not containing n in T must be closed. Thus T 0β is closed. Furthermore, by definition, the layers of rank 0 in T 1 β are the first layers of every branch, i.e. the first layer after γβ in T . Since γβ is a layer of rank m in T , such layers are of rank m+ 1.\nCorollary 25 Let T be a tableau that is globally looping w.r.t. two numbers n < k. Let m < k. Let β and β′ be the roots of V0(T ,m) and V1(T ,m) respectively. cnf(T [Leaves(V0(T ,m), β)]) = ⊥ and cnf(T [Leaves(V1(T ,m), β)]) = cnf(T [Layers(T ,m+ 1)]).\n3Note that, although no application of the Explosion rule occurs in U(T , m), some applications of this rule may occur in T 1\nβ .\nProof. The first point stems directly from Proposition 24. For the second point, we only have to remark that by definition a node occurs in Layers(T ,m+ 1) iff it occurs in some set Layers(T ,m + 1, γβ), where β is a leaf of U(T ,m) (since the leaves of U(T ,m) are exactly the layers of rank m in T ).\nBy applying the above function ∆(T , α) on the two tableaux V1(T ,m) and V0(T ,m), we define the following derivations (where α denotes the root of V1(T ,m) and V0(T ,m)):\nΛ1(T ,m) def = ∆(V1(T ,m), α) Λ0(T ,m) def = ∆(V0(T ,m), α)\nThe following lemma states essential properties of Λ1(T ,m) and Λ0(T ,m):\nLemma 26 Let T be a tableau that is globally looping w.r.t. two numbers n < k. Let m < k.\n• Λ0(T ,m) is a refutation of cnf(T [Layers(T ,m)]){n ← 0}.\n• If m < k−1 then Λ1(T ,m) is a derivation from cnf(T [Layers(T ,m)]){n ← n+ 1} of cnf(T [Layers(T ,m+ 1)]).\n• Λ1(T , k − 1) is a derivation from cnf(T [Layers(T ,m)]){n ← n + 1} of cnf(T [Layers(T , n)]).\nProof. Let β and β′ be the roots of V1(T , k) and V0(T , k) respectively. By Lemma 23, Λ1(T ,m) is a derivation from cnf(V1(T ,m)(β)) of cnf(T [Leaves(V1(T ,m), β)]). By definition of V1(T ,m), the root of V1(T ,m) is labeled by Φ{n ← n + 1}, where Φ is the root of U(T ,m). By definition of U(T ,m), Φ = T [Layers(T ,m)]. Hence Λ1(T , k) is a derivation from cnf(T [Layers(T ,m)]){n ← n + 1}. Similarly, Λ0(T ,m) is a derivation from cnf(T [Layers(T ,m)]){n ← 0}.\nBy Corollary 25, cnf(T [Leaves(V1(T ,m), β)]) = cnf(T [Layers(T ,m + 1)]). Furthermore, if m = k − 1, then since T is globally looping we have cnf(T [Layers(T ,m+ 1)]) = cnf(T [Layers(T , n)]).\nSimilarly, cnf(T [Leaves(V1(T ,m), β)]) = ⊥.\nLet T be a tableau that is globally looping w.r.t. two numbers n < k. We associate to each natural number m < k a symbol γm. Let R⋆(T ) the system containing the following rules. Note that V0(T ,m) and V1(T ,m) are defined only w.r.t. the rank m, but not w.r.t. a particular node. Thus, contrarily to the transformation of Section 3, there is not one derivation per node, but rather one derivation per rank.\nγm0 → Λ 0(T ,m) γmn+1 → Λ 1(T ,m) · γm+1n (if m+ 1 < k) γ k−1 n+1 → Λ 1(T , k) · γnn\nIntuitively, we are appending the derivations, rank after rank, until we reach the rank k where the Global Loop Detection applies. In this case we get back at\nthe rank of looping n. Thus we can see the use of grouping the derivations by rank (instead of node) as it allows to benefit from the simplified form of looping induced by the Global Loop Detection rule. In the end, the resulting rewrite system is indeed much simpler.\nProposition 27 R⋆(T ) is convergent.\nProof. Termination is easy to obtain since the rules inR⋆(T ) strictly decreases the value of the indices of the symbols γk. Furthermore, R⋆(T ) is obviously orthogonal.\nNote that, by definition, R⋆(T ) is always propositional (unlike R(T )).\nTheorem 28 Let T be a tableau of root α that is globally looping w.r.t. two numbers n, k, with n < k. Let m < k. For all i ∈ N, γmi ↓R⋆(T ) is a refutation of cnf(T [Layers(T ,m)]){n ← i}↓R. Thus in particular, if α is a layer, γ 0 i ↓R⋆(T ) is a refutation of T (α){n ← i}↓R.\nProof. This follows by induction on i. If i = 0 then we have, by definition of the rules in R⋆(T ): γmi ↓R⋆(T )= Λ\n0(T ,m)↓R. By Lemma 26 (first point), Λ0(T ,m)↓R is a refutation of cnf(T [Layers(T ,m)]){n ← 0}↓R.\nIf i > 0 then we have γmi ↓R⋆(T )= Λ 1(T ,m) ↓R {n ← i} · γ m+1 i−1 ↓R⋆(T ). If m < k − 1, then by Lemma 26 (second point), Λ1(T ,m) is a derivation from cnf(T [Layers(T ,m)]){n ← n + 1} of cnf(T [Layers(T ,m + 1)]), hence Λ1(T , i − 1) ↓R is a derivation from cnf(T [Layers(T ,m)]){n ← i} ↓R of cnf(T [Layers(T ,m + 1)]){n ← i − 1} ↓R. Then by the induction hypothesis, γm+1i−1 ↓R⋆(T ) is a refutation of cnf(T [Layers(T ,m+ 1)])α{n ← i− 1}↓R.\nIfm = k−1, then by Lemma 26 (second point), Λ1(T ,m) is a derivation from cnf(T [Layers(T ,m)]){n ← n+1} of cnf(T [Layers(T , n)]), hence Λ1(T , i−1)↓R is a derivation from cnf(T [Layers(T ,m)]){n ← i}↓R of cnf(T [Layers(T , n)]){n ← i − 1} ↓R. Then by the induction hypothesis, γ n i−1 ↓R⋆(T ) is a refutation of cnf(T [Layers(T , n)])α{n ← i− 1}↓R.\nWhen α is not a layer, the rewrite system is easily adapted by prepending the derivation obtained by applying ∆ to the subtree of T whose leaves are the layers of rank 0.\nExample 29 Consider the tableau of Example 19. This tableau is actually globally looping. The following rewrite system is constructed (after partial evaluation and simplification):\nγ0 → p0 ∨ q0 · ¬p0 · q0 · ¬q0 · ⊥ γn+1 → (pn+1 ∨ qn+1) · (qn ∨ ¬pn+1) · (qn ∨ qn+1) · (pn ∨ ¬qn+1) · (qn ∨ pn) · γn\nCompared with the system produced by the previous method (see Example 19), these rules are obviously simpler (no schema variable are needed, and only linear recursion is used). Furthermore, it is easy to check that they generate much shorter derivations. ♣"
    }, {
      "heading" : "5 Conclusion",
      "text" : "Two distinct algorithms have been designed for extracting schemata of resolution proofs from closed tableaux. This work is motivated by the fact that such refutations are needed for some natural applications of schemata calculus (unsatisfiability detection is not always sufficient). In particular, the explicit generation of the proofs (even in the form of proof schemata) makes possible the certification of the results produced by the provers. The first algorithm tackles the tableau calculus in its full generality, but it yields very complex representations of the derivations (which will make them less usable in practice, in particular they are not very informative for a human user). The second one uses a less powerful calculus, but it generates schemata of refutations in a much simpler format (propositional rewrite systems are obtained).\nThere is thus a natural trade-off between the two presented methods: none of them is uniformly superior to the other. The choice between the two algorithms should be made according to the considered applications, and/or to the form of the constructed tableaux. In some cases, as shown by the examples in Section 3, the first approach generates a propositional rewrite system. In this case it should of course be preferred. Future work includes the implementation of the two methods and the precise evaluation of the complexity of the second algorithm. One could also wonder whether a polynomial algorithm generating propositional derivations exists for the general case. We conjecture that the use of ∆-variables cannot be avoided in general."
    } ],
    "references" : [ {
      "title" : "A schemata calculus for propositional logic",
      "author" : [ "V. Aravantinos", "R. Caferra", "N. Peltier" ],
      "venue" : "TABLEAUX 09 (International Conference on Automated Reasoning with Analytic Tableaux and Related Methods), volume 5607 of LNCS, pages 32– 46. Springer",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "A Decidable Class of Nested Iterated Schemata",
      "author" : [ "V. Aravantinos", "R. Caferra", "N. Peltier" ],
      "venue" : "IJCAR 2010 (International Joint Conference on Automated Reasoning), LNCS, pages 293–308. Springer",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Decidability and undecidability results for propositional schemata",
      "author" : [ "V. Aravantinos", "R. Caferra", "N. Peltier" ],
      "venue" : "Journal of Artificial Intelligence Research, 40:599– 656",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Cut-elimination and Redundancy-elimination by Resolution",
      "author" : [ "M. Baaz", "A. Leitsch" ],
      "venue" : "Journal of Symbolic Computation, 29(2):149–176",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Towards understanding and harnessing the potential of clause learning",
      "author" : [ "P. Beame", "H. Kautz", "A. Sabharwal" ],
      "venue" : "Journal of Artificial Intelligence Research, 22:319–351",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "A simple and flexible way of computing small unsatisfiable cores in SAT modulo theories",
      "author" : [ "A. Cimatti", "A. Griggio", "R. Sebastiani" ],
      "venue" : "SAT, LNCS, pages 334–339. Springer",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "The resolution calculus",
      "author" : [ "A. Leitsch" ],
      "venue" : "Springer. Texts in Theoretical Computer Science",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "Automatic abstraction without counterexamples",
      "author" : [ "K.L. McMillan", "N. Amla" ],
      "venue" : "Proceedings of TACAS’03, pages 2–17. Springer-Verlag",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Proof theory in the USSR 1925-1969",
      "author" : [ "G. Mints" ],
      "venue" : "J. Symb. Log., 56(2):385–424",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "First-Order Logic",
      "author" : [ "R.M. Smullyan" ],
      "venue" : "Springer",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 1968
    }, {
      "title" : "Optimization and translation of tableau-proofs into resolution",
      "author" : [ "A. Wolf" ],
      "venue" : "Journal of Information Processing and Cybernetics, 30(5/6):311–325",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "Validating SAT Solvers Using an Independent Resolution- Based Checker: Practical Implementations and Other Applications",
      "author" : [ "L. Zhang", "S. Malik" ],
      "venue" : "DATE, pages 10880–10885. IEEE Computer Society",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2003
    } ],
    "referenceMentions" : [ {
      "referenceID" : 2,
      "context" : "Two distinct algorithms are presented to extract (schemata of) resolution proofs from closed tableaux for propositional schemata [4].",
      "startOffset" : 129,
      "endOffset" : 132
    }, {
      "referenceID" : 0,
      "context" : "In [2, 4] a tableau calculus (called Stab) is presented for reasoning on schemata of propositional problems.",
      "startOffset" : 3,
      "endOffset" : 9
    }, {
      "referenceID" : 2,
      "context" : "In [2, 4] a tableau calculus (called Stab) is presented for reasoning on schemata of propositional problems.",
      "startOffset" : 3,
      "endOffset" : 9
    }, {
      "referenceID" : 1,
      "context" : "A related algorithm, called Dpll and based on an extension of the Davis-Putnam-Logemann-Loveland procedure, is presented in [3].",
      "startOffset" : 124,
      "endOffset" : 127
    }, {
      "referenceID" : 6,
      "context" : "More precisely, we present an algorithm that, given a closed tableau T for a schema φn, returns a schema of a refutation of φn in the resolution calculus [9].",
      "startOffset" : 154,
      "endOffset" : 157
    }, {
      "referenceID" : 8,
      "context" : "In the usual propositional case, it is well-known that algorithms exist to extract resolution proofs from closed tableaux constructed either by the usual structural rules [11, 13] or by the DPLL algorithm [7, 6].",
      "startOffset" : 171,
      "endOffset" : 179
    }, {
      "referenceID" : 10,
      "context" : "In the usual propositional case, it is well-known that algorithms exist to extract resolution proofs from closed tableaux constructed either by the usual structural rules [11, 13] or by the DPLL algorithm [7, 6].",
      "startOffset" : 171,
      "endOffset" : 179
    }, {
      "referenceID" : 4,
      "context" : "In the usual propositional case, it is well-known that algorithms exist to extract resolution proofs from closed tableaux constructed either by the usual structural rules [11, 13] or by the DPLL algorithm [7, 6].",
      "startOffset" : 205,
      "endOffset" : 211
    }, {
      "referenceID" : 11,
      "context" : "The resolution proofs are used in various applications, for instance for certification [14], for abstraction-refinement [10] or for explanations generation [8].",
      "startOffset" : 87,
      "endOffset" : 91
    }, {
      "referenceID" : 7,
      "context" : "The resolution proofs are used in various applications, for instance for certification [14], for abstraction-refinement [10] or for explanations generation [8].",
      "startOffset" : 120,
      "endOffset" : 124
    }, {
      "referenceID" : 5,
      "context" : "The resolution proofs are used in various applications, for instance for certification [14], for abstraction-refinement [10] or for explanations generation [8].",
      "startOffset" : 156,
      "endOffset" : 159
    }, {
      "referenceID" : 3,
      "context" : "Indeed, the algorithm used for cut-elimination, called CERES [5], explicitly relies",
      "startOffset" : 61,
      "endOffset" : 64
    }, {
      "referenceID" : 3,
      "context" : "2 in [5]).",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 0,
      "context" : "The definitions used in the present paper differ from the previous ones, but the considered logic is equivalent to the class of regular schemata considered in [2] (it is thus strictly less expressive than general schemata, for which the satisfiability problem is undecidable).",
      "startOffset" : 159,
      "endOffset" : 162
    }, {
      "referenceID" : 0,
      "context" : "The procedure is similar to the one presented in [2] and based on propositional block tableaux [12].",
      "startOffset" : 49,
      "endOffset" : 52
    }, {
      "referenceID" : 9,
      "context" : "The procedure is similar to the one presented in [2] and based on propositional block tableaux [12].",
      "startOffset" : 95,
      "endOffset" : 99
    }, {
      "referenceID" : 0,
      "context" : "Note that the notion of pure literal is much simpler here than in [2].",
      "startOffset" : 66,
      "endOffset" : 69
    }, {
      "referenceID" : 1,
      "context" : "The Dpll procedure in [3] can be simulated by the previous expansion rules, simply by adding for each propositional symbol p ∈ Ω, a defined symbol υ with two rules: υ i+1 → ((pi∨¬pi)∧υ p i ) and υ 0 → ⊤.",
      "startOffset" : 22,
      "endOffset" : 25
    }, {
      "referenceID" : 6,
      "context" : "It is well-known [9] that every unsatisfiable set of (propositional) clauses has a refutation.",
      "startOffset" : 17,
      "endOffset" : 20
    }, {
      "referenceID" : 1,
      "context" : "This “trick” does not actually simulate the full procedure in [3], because the latter handles schemata that are more complex than the ones considered in the present paper, possibly containing nested iterations.",
      "startOffset" : 62,
      "endOffset" : 65
    } ],
    "year" : 2017,
    "abstractText" : "Two distinct algorithms are presented to extract (schemata of) resolution proofs from closed tableaux for propositional schemata [4]. The first one handles the most efficient version of the tableau calculus but generates very complex derivations (denoted by rather elaborate rewrite systems). The second one has the advantage that much simpler systems can be obtained, however the considered proof procedure is less efficient. In [2, 4] a tableau calculus (called Stab) is presented for reasoning on schemata of propositional problems. This proof procedure is able to test the validity of logical formulæ built on a set of indexed propositional symbols, using generalized connectives such as ∨ n i=1 or ∧ n i=1, where i, n are part of the language (n denotes a parameter, i.e. an existentially quantified variable). A schema is unsatisfiable iff it is unsatisfiable for every value of n. Stab combines the usual expansion rules of propositional logic with some delayed instantiation schemes that perform a case-analysis on the value of the parameter n. Termination is ensured for a specific class of schemata, called regular, thanks to a loop detection rule which is able to prune infinite tableaux into finite ones, by encoding a form a mathematical induction (by “descente infinie”). A related algorithm, called Dpll and based on an extension of the Davis-Putnam-Logemann-Loveland procedure, is presented in [3]. In the present work, we show that resolution proofs can be automatically extracted from the closed tableaux constructed by Stab or Dpll on unsatisfiable schemata. More precisely, we present an algorithm that, given a closed tableau T for a schema φn, returns a schema of a refutation of φn in the resolution calculus [9]. In the usual propositional case, it is well-known that algorithms exist to extract resolution proofs from closed tableaux constructed either by the usual structural rules [11, 13] or by the DPLL algorithm [7, 6]. The resolution proofs are used in various applications, for instance for certification [14], for abstraction-refinement [10] or for explanations generation [8]. The present paper extends these techniques to propositional schemata. Beside the previously mentioned applications, this turned out to be particularly important in the context of the ASAP project [1] in which schemata calculi are applied to the formalisation and analysis of mathematical proofs via cut-elimination. Indeed, the algorithm used for cut-elimination, called CERES [5], explicitly relies on the existence of a resolution proof of the so-called characteristic clause set extracted from the initial proof. The cut-free proof is reconstructed from this refutation, by replacing the clauses occurring in this set by some “projections” of the original proof. While Stab and Dpll are able to detect the unsatisfiability of characteristic clause sets, as such this is completely useless since actually it is known that those sets are always unsatisfiable (see Proposition 3.2 in [5]). It is thus essential to be able to generate explicitly a representation of the resolution proof. This is precisely the aim of the present paper. Since the initial formula depends on a parameter n, its proof will also depend on n (except in very particular and trivial cases), i.e. it must be a schema of resolution proof (which will be encoded by recursive definitions). The rest of the paper is structured as follows. In Section 1 we introduce the basic notions and notations used throughout our work, in particular the logic of propositional schemata (syntax and semantics). In Section 2 we define a tableau-based proof procedure for this logic. This calculus simulates both Stab and Dpll (for the specific class of schemata considered in the present paper). In Section 3 we provide an algorithm to extract resolution proofs from closed tableaux. Similarly to the formulæ themselves, the constructed derivations are represented by rewrite systems. In Section 4 we introduce a second algorithm which generates simpler derivations but that requires that one of the closure rules defined in Section 2 (the so-called Loop Detection rule) be replaced by a less powerful rule, called the Global Loop Detection rule. Section 5 briefly concludes our work. 1 Propositional schemata The definitions used in the present paper differ from the previous ones, but the considered logic is equivalent to the class of regular schemata considered in [2] (it is thus strictly less expressive than general schemata, for which the satisfiability problem is undecidable). We consider three disjoint sets of symbols: a set of arithmetic variables V , a set of propositional variables Ω and a set of defined symbols Υ. Let ≺ be a total well-founded ordering on the symbols in Υ. An index expression is either a natural number or of the form n + k, where n is an arithmetic variable and k is a natural number. Let I be a set of index expressions. The set F(I) of formulæ built on I is inductively defined as follows: if p ∈ Ω ∪ Υ and α ∈ I then pα ∈ F(I); ⊤,⊥ ∈ F(I); and if φ, ψ ∈ F(I) then ¬φ, φ ∨ ψ, φ ∧ ψ, φ ⇒ ψ and φ ⇔ ψ are in F(I). Definition 1 We assume that each element υ ∈ Υ is mapped to two rewrite rules ρυ and ρ 0 υ that are respectively of the form υi+1 → φ (inductive case) and υ0 → ψ (base case), where φ ∈ F({i+ 1, i, 0}), ψ ∈ F({0}) and: 1. For every atom τα occurring in φ such that τ ∈ Υ we have either τ ≺ υ and α ∈ {i+ 1, i, 0} or τ = υ and α ∈ {0, i}. 2. For every atom τα occurring in ψ such that τ ∈ Υ we have τ ≺ υ and α = 0. ✸ We denote by R the rewrite system: {ρυ, ρ 0 υ | υ ∈ Υ}. The rules ρ 1 υ and ρ 0 υ are provided by the user, they encode the semantics of the defined symbols. Proposition 2 R is convergent. Proof. By Conditions 1 and 2 in Definition 1, the rules in R either strictly decrease the values of the defined symbols occurring in the formula w.r.t. ≺ or do not increase the value of these symbols but strictly decreases the value of their indices. Thus termination is obvious. Confluence is then immediate since the system is orthogonal. For every formula φ, we denote by φ↓R the unique normal form of φ. A schema (of parameter n) is an element of F({0, n, n+ 1}). We denote by φ{n ← k} the formula obtained from φ by replacing every occurrence of n by k. Obviously for any schema φ, φ{n ← k} ∈ F({0, k, k + 1}). A propositional formula is a formula φ ∈ F(N) containing no defined symbols. Notice that if φ ∈ F(N) then φ↓R is a propositional formula. Proposition 3 If φ ∈ F(N) then φ↓R is a propositional formula. Proof. By definition ofR, φ↓R∈ F(N). Furthermore, if φ↓R contains a defined symbol υ then either ρυ or ρ 0 υ applies, which is impossible. An interpretation is a function mapping every arithmetic variable n to a natural number and every atom of the form pk (where k ∈ N) to a truth value true or false. An interpretation I validates a propositional formula φ iff one of the following conditions holds: φ is of the form pk and I(pk) = true; φ is of the form ¬ψ and I does not validate ψ; or φ is of the form ψ1 ∨ ψ2 (resp. ψ1 ∧ ψ2) and I validates ψ1 or ψ2 (resp. ψ1 and ψ2). I validates a schema φ (written I |= φ) iff I validates φ{n ← I(n)}↓R. We write φ |= ψ if every interpretation I validating φ also validates ψ and φ ≡ ψ if φ |= ψ and ψ |= φ. Example 4 The schema p0∧ ∧ n i=1(pi−1 ⇒ pi)∧¬pn is encoded by p0∧υn∧¬pn, where υ is defined by the rules: υi+1 → (¬pi ∨ pi+1) ∧ υi and υ0 → ⊤. The schema ∨ n i=1 pi ∧ ∧ n i=1 ¬pi is encoded by τn ∧ τ ′ n , where τ and τ ′ are defined by the rules: τi+1 → pi+1 ∨ τi, τ0 → ⊥, τ ′ i+1 → ¬pi+1 ∧ τ ′ i and τ ′ 0 → ⊤. Both schemata are obviously unsatisfiable. The schema (pn ⇔ (pn−1 ⇔ (. . . (p1 ⇔ p0) . . .))) is defined by υ ′ n , where: υ i+1 → (pi+1 ⇔ υ ′ i ) and υ 0 → p0. ♣",
    "creator" : "LaTeX with hyperref package"
  }
}