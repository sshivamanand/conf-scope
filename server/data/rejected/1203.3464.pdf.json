{
  "name" : "1203.3464.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Gibbs Sampling in Open-Universe Stochastic Languages",
    "authors" : [ "Nimar S. Arora", "Rodrigo de Salvo Braz" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "Languages for open-universe probabilistic models (OUPMs) can represent situations with an unknown number of objects and identity uncertainty. While such cases arise in a wide range of important real-world applications, existing general purpose inference methods for OUPMs are far less efficient than those available for more restricted languages and model classes. This paper goes some way to remedying this deficit by introducing, and proving correct, a generalization of Gibbs sampling to partial worlds with possibly varying model structure. Our approach draws on and extends previous generic OUPM inference methods, as well as auxiliary variable samplers for nonparametric mixture models. It has been implemented for BLOG, a well-known OUPM language. Combined with compile-time optimizations, the resulting algorithm yields very substantial speedups over existing methods on several test cases, and substantially improves the practicality of OUPM languages generally."
    }, {
      "heading" : "1 Introduction",
      "text" : "General purpose probabilistic modelling languages aim to facilitate the development of complex models while providing effective, general inference methods so that the model-builder need not write model-specific inference code for each application from scratch. For example, BUGS (Spiegelhalter et al., 1996) can represent directed graphical models over indexed sets of random variables and uses MCMC inference (in particular, Gibbs sampling where this is possible).\nAs the expressive power of modelling languages increases, the range of representable problems also\ngrows. The class of first-order, open-universe probabilistic languages, including BLOG (Milch et al., 2005a) and Church (Goodman et al., 2008), handles cases in which the number of objects (in BUGS, the index set) is unknown and perhaps unbounded, and object identity is uncertain. It is still possible to write a complete inference algorithm for BLOG, based on MCMC over partial worlds; each such world is constructed from the minimal self-supporting set of variables relevant to the evidence and query variables. Generality has a price, however: BLOG’s default Metropolis–Hastings inference engine samples each variable conditioned only on its parents (Milch & Russell, 2006). This approach leads to unacceptably slow mixing rates for many standard models, in which evidence from child variables is highly informative.\nOur goal is to remedy this situation, primarily by extending the range of situations in which Gibbs sampling from the full, conditional posterior can be used within BLOG. Section 2 of this paper introduces the terminology of contingent Bayesian networks (CBNs), which we will use as the propositional “abstract machine” for open-universe stochastic languages. Section 3 surveys previous work related to general purpose sampling of CBNs and describes its limitations. Section 4 then describes our novel Gibbs sampling algorithm for CBNs which addresses these limitations; its implementation for BLOG is described in Section 5. Finally, we present experimental results on various models in Section 6, demonstrating substantial speedups over existing methods."
    }, {
      "heading" : "2 Contingent Bayesian Networks",
      "text" : "This section repeats, and in some cases generalizes, definitions proposed by Milch et al. (2005b). A contingent Bayesian network (CBN) consists of a set of random variables V, and for each variable X ∈V, a domain dom(X) and decision tree TX . The decision tree is a directed binary tree, where each node is a predi-\ncate on some subset of V. Each leaf of TX encodes a probability distribution parameterized by a subset of V, and defined on dom(X). Example 1. An aircraft of unknown WingType – Helicopter or FixedWingPlane – is detected on a radar. Helicopters have an unknown RotorLength, and depending on this length they might produce a characteristic pattern called a BladeFlash (Tait, 2009) in the returned radar signal. A FixedWingPlane might also produce a BladeFlash. As summarized in Figure 1,\nTWingType = F1 TRotorLength = { F2 if WingType = Helicopter null otherwise\nTBladeFlash = { F3(RL) if WingType = Helicopter F4 otherwise\nwhere RL is an abbreviation for RotorLength.\nAn instantiation σ is an assignment of values to a subset of V. We write vars(σ) for the set of variables to which σ assigns values, and σX for the value that σ assigns to a variable X. σX=a is a modified instantiation which agrees with σ except for setting X to a. An instantiation σ is said to be finite if vars(σ) is finite. An instantiation σ supports X if all the variables needed to evaluate TX are present in σ. In Example 1, [WingType=FixedWing] supports BladeFlash, but [WingType=Helicopter] does not.\nWe write σTX for the minimal subset of σ needed to evaluate TX , and pX(· | σTX ) for the resulting distribution of X. The parents of X in σ are vars(σTX ), while the children of X in σ are\nΛ(σ,X) = {Y | Y ∈ vars(σ), X ∈ vars(σTY )}. (1)\nThe subset of vars(σTX ) which were used to evaluate internal nodes of TX (rather than the leaf) are the\nswitching parents of X in σ. Intuitively, changes in the values of switching parents can switch the distribution of X, as well as its set of parents. A switching variable in σ is a switching parent for one or more variables in σ. For the CBN of Example 1, the instantiation [ WingType=Helicopter, RotorLength=6, BladeFlash=true ] makes WingType a switching parent of both RotorLength and BladeFlash.\nAn instantiation σ is self-supporting if it supports all variables in σ. Assuming that the CBN is well-defined (Milch et al., 2005b), we can define the probability of a self-supporting instantiation as follows:\np(σ) = ∏\nX ∈ vars(σ)\npX(σX | σTX ) (2)\nAn instantiation σ is feasible if p(σ) > 0."
    }, {
      "heading" : "3 Related Work",
      "text" : "Milch and Russell (2006) have previously shown that the state space for Markov chain Monte Carlo (MCMC) inference in CBNs may consist of minimal partial instantiations that support the evidence, E, and query variables, Q. This idea has been exploited to build the current, default inference engine for BLOG. Standard sampling algorithms for nonparametric, Dirichlet process mixture models use a related representation: they instantiate parameters for those mixture components which support the evidence, as well as a few auxiliary components (Neal, 2000). Our new algorithm builds on both of these methods."
    }, {
      "heading" : "3.1 Parent-Conditional Sampling",
      "text" : "In the absence of a model-specific, user supplied proposal distribution, BLOG’s existing inference engine relies on a parent-conditional proposal. This algorithm picks a variable, X, at random from all non-evidence variables in the current instantiation σ, V (σ) = vars(σ)−E, and proposes a new instantiation σ′ with the value of X drawn from pX(· | σTX ). If X was a switching variable in σ, we may then need to instantiate new variables, and uninstantiate unneeded ones, to make σ′ minimal and self-supporting over Q ∪ E. All new variables are instantiated with values drawn from their parent-conditional distribution.\nWe say that any σ′ constructed by this procedure is reachable from σ via X, or σ X σ′. The following properties are easily seen to be true of reachability. Proposition 1. A minimal self-supporting feasible instantiation σ′ is reachable from an instantiation σ via X if and only if X ∈ vars(σ) ∩ vars(σ′), and σ and σ′ agree on all other variables in vars(σ) ∩ vars(σ′).\nProposition 2. If σ X σ′, then there does not exist Y ∈ V (σ), Y 6= X, such that σ Y σ′.\nThe nature of this proposal distribution q(σ → σ′) makes it quite simple to compute the acceptance ratio for the Metropolis–Hastings (MH) method (Andrieu et al., 2003), which takes the following form:\nα(σ → σ′) = min {\n1, p(σ′)q(σ′ → σ) p(σ)q(σ → σ′)\n} (3)\nFor any σ′ reachable from σ via X, the unique way of proposing this transition is to select X from V (σ), propose the value σ′X for it, and finally propose corresponding values for all new variables in σ′. Thus,\nq(σ → σ′) = pX(σ′X | σTX ) |V (σ)| ∏ Y ∈vars(σ′)−vars(σ) pY (σ′Y | σ′TY ) (4)\nFrom Equations (2) and (4), the terms corresponding to vars(σ′) − vars(σ) cancel in p(σ′)/q(σ → σ′). Similarly, terms in vars(σ) − vars(σ′) cancel in q(σ′ → σ)/p(σ). Further, it is easy to see that for variables Y ∈ vars(σ) ∩ vars(σ′)− Λ(σ,X) ∩ Λ(σ′, X), σTY = σ ′ TY . Hence, pY (· | σTY ) = pY (· | σ ′ TY ) and the terms for all such variables Y , including X, cancel out. Finally, the acceptance ratio α(σ → σ′) reduces to:\nmin 1, |V (σ)||V (σ′)| ∏ Y ∈Λ(σ,X)∩Λ(σ′,X) pY (σ′Y |σ′TY ) pY (σY |σTY )  (5) Note the dependence on those variables which are children of X in both σ and σ′. The overall algorithm is summarized in Figure 2."
    }, {
      "heading" : "3.2 Gibbs Sampling",
      "text" : "Equation (5) summarizes the main problem with parent-conditional sampling: if the proposed value for the sampled variable X does not assign high probability to the children of X, the move will be rejected. To avoid undue assumptions, hierarchical Bayesian statistical models often use dispersed or “vague” priors, so that such parent-conditional proposals have extremely low acceptance probabilities.\nThe Gibbs sampler addresses this issue by directly sampling X from its full conditional distribution, pX(· | σV−X), rather than its parent-conditional prior pX(· | σTX ). This method was originally proposed by Geman and Geman (1984) for inference in undirected Markov random fields, and later popularized as a general Bayesian inference method by Gelfand and\nSmith (1990). For discrete variablesX, the Gibbs sampler computes a weight w(a) for each a∈ dom(X):\nw(a) = pX(a | σTX ) ∏\nY ∈Λ(σ,X)\npY (σY | σX=aTY ) (6)\nA new value σ′X is then sampled from a normalized distribution with mass proportional to these non-negative weights. Viewed as a Metropolis-Hastings proposal, the acceptance probability for the Gibbs sampler always equals one; Gibbs moves are never rejected.\nThe Gibbs sampler can be consistently applied to variables with finite, countable, or even uncountable domains, so long as the full conditional posterior can be tractably normalized and sampled from. For models specified via languages like BUGS, Gibbs sampling has proven quite successful. However, most existing applications and analysis of the Gibbs sampler implicitly assume a closed universe model, and instantiate the full, finite set of variables at all iterations. If this algorithm were naively applied to a CBN, then for some switching variables X and configurations a ∈ dom(X), σX=a might not support some children of X. For such inconsistent model configurations, the normal Gibbs weight w(a) cannot be evaluated.\nOne possible solution, proposed in the context of Dirichlet process (DP) mixture models by Neal (2000), augments σ with auxiliary variables chosen so that σX=a is self-supporting for all a∈ dom(X). This augmented σ, which is now no longer minimal, is used to construct the Gibbs weights; following the move any remaining non-supported variables are discarded.\ndom(X) = {0, 1, 2} X ∼ Categorical(.1, .6, .3)\ndom(Yi) = {0, 1} for all i∈N Yi ∼ {\nBernoulli( 11+X ) if (X + i) mod 2 ≡ 0 Bernoulli( 11+X+Yi+1 ) otherwise\nEvidence: Y1 = true. Query: X.\nFigure 3: A CBN which requires infinitely many auxiliary variables for standard Gibbs sampling approaches.\nSuch auxiliary variables are always sampled conditioned on σ, given the current value of X. For example, if σX = a and if σ was augmented with a variable Z needed to support σX=b for some b∈ dom(X) − a, then we would sample Z from pZ(· | σX=aTZ ). This can lead to poor mixing rates, or an inconsistent sampler if pZ(· | σX=aTZ ) and pZ(· | σ X=b TZ ) have non-overlapping support. Note that this issue doesn’t arise with the DP mixture sampler, since TZ had no dependence on X, and pZ(· | σX=aTZ ) = pZ(· | σ X=b TZ ) for any a, b.\nTo further illustrate this issue, consider the model of Example 1 and a minimal instantiation, σ = [ WingType = FixedWingPlane, BladeFlash = True ]. If we were to apply a typical auxiliary variable method to do MCMC sampling in this model, we would first instantiate RotorLength given WingType = FixedWingPlane, and then construct Gibbs weights for WingType = FixedWingPlane and Helicopter. However, the only value of RotorLength that can be sampled given WingType = FixedWingPlane is null, and this value has probability 0 with WingType = Helicopter. The resulting chain will not mix to the true posterior.\nIn fact, there are cases when the auxiliary variable method is not well defined, because we may need an unbounded number of auxiliary variables. Consider the rather artificial but instructive CBN in Figure 3, and an instantiation σ = [X = 0, Y1 = 1, Y2 = 1]. To augment σ such that it is self-supporting for all values of X, we certainly need to add Y3, since Y2 depends on Y3 when X = 1. But Y3 depends on Y4 when X = 0, and so we need to add Y4, and so on. Ultimately, we would need to instantiate Yi for all i ≥ 1."
    }, {
      "heading" : "4 Gibbs Sampling in Contingent Bayesian Networks",
      "text" : "We now develop a general-purpose extension of standard Gibbs samplers, which is applicable to arbitrary switching variables with finite domains. The proposal for a switching variable, X, will proceed in three steps. First, the instantiation, σ, is reduced to a subset of variables, core(σ,X), that is guaran-\nteed to exist in a minimal, self-supporting instantiation constructed from σX=a, for any a∈ dom(X). Second, we construct minimal self-supporting instantiations σi, i = 1, . . . , |dom(X)| − 1, for each value in dom(X)−{σX}. These instantiations agree with σ on core(σ,X), but assign different values to X. Any remaining variables in these σi configurations are sampled from their parent-conditional priors. For notational simplicity, we define σ0 = σ. Finally, we assign weights to these σi, i = 0, . . . , |dom(X)|−1, and make a transition proportional to these weights.\nIt may seem counter-intuitive to first reduce the instantiation, and then extend it. After all, the pair of algorithms described in Section 3, parent-conditional sampling and auxiliary variable Gibbs sampling, first extended the current instantiation before reducing it. The motivation for our approach is simple: variables whose existence depends on the value of X should be sampled in a world with the appropriate value of X.\nConsider again, for example, the model in Figure 3, and three partial instantiations illustrated in Figure 4. Now, starting from σ0 (in which X = 0), we could have fixed the value of Y2 when constructing σ2 (in which X = 2). However, the distribution of Y2 given X = 2 is quite different from that given X = 0, and fixing the value of Y2 could lead to low probability instantiations. The resampling of non-core variables like Y2 also simplifies the detailed balance equations discussed later. In particular, our algorithm is designed so that the distribution of σ2 does not depend on whether we start from σ0 or σ1. Thus, when demonstrating detailed balance between pairs of instantiations, we need\nnot reason about other instantiations which might be involved in the transition. This last observation relies on the fact that core(σ0, X) = core(σ1, X). We will first prove this in general. Definition 1. For an instantiation σ and variables X,Y, Z ∈ vars(σ), if TZ refers to X and Y , and the first reference to X precedes the first reference to Y , the edge linking Y to Z is said to be contingent on X. Definition 2. Let core(σ,X) denote the subset of variables in vars(σ) − {X} which have a path (possibly of length zero) consisting of parent-child edges, excluding edges contingent on X, to some variable in Q ∪ E.\nNote that we have left X out of core(σ,X) mainly for simplifying the subsequent text. However, it is not hard to see that there is a path from X to Q ∪ E not contingent uponX. For example, consider the shortest path from X to Q∪E and let this path start with the X → Y edge. Now, the edge X → Y is not contingent upon X (by definition) and if some other edge, W → Z, along this path is contingent upon X then we can find a shorter path starting with X → Z. It should be further noted that all the ancestors of X have a path to X not contingent upon X (otherwise, a cyclic instantiation would make the CBN not well-formed). Hence all the ancestors of X are in core(σ,X). Definition 3. For an instantiation σ and variable X ∈ vars(σ), let Υ(σ,X) 4= Λ(σ,X) ∩ core(σ,X) denote the children of X also contained in core(σ,X). Proposition 3. For any pair of minimal selfsupporting instantiations, σ and σ′, and variable X common to them, if σ and σ′ agree on core(σ,X) then core(σ,X) = core(σ′, X) and Υ(σ,X) = Υ(σ′, X).\nProof. Let Y ∈ core(σ,X), then either Y ∈Q ∪ E or there exists a path of edges not contingent on X from Y to Q∪E. Clearly, if Y ∈Q∪E then Y ∈ core(σ′, X). Otherwise, let Z be the first child in such a path. Since X is not referenced before Y in TZ , X is also not referenced before any W referenced before Y in TZ . Such a variable W must also be in core(σ,X) since W has the same path to Q∪E via Z as Y . But σ and σ′ agree on core(σ,X) and hence on W . Since σ and σ′ agree on all the variables referred before Y in TZ it follows that the evaluation of TZ up to Y is identical in σ and σ′. Hence, the Y to Z edge is not contingent on X in σ′. By induction, the path from Y to Q ∪ E in σ′ is not contingent on X, which implies that Y ∈ core(σ′, X).\nNow, suppose core(σ,X) ⊂ core(σ′, X). For any element in core(σ′, X)− core(σ,X) there must be a path of edges not contingent upon X in σ′ to Q ∪ E via some variables in core(σ,X) ∪ {X} (trivially, since Q∪E ⊆ core(σ,X)∪ {X}). Let Y and Z be one such parent-child pair in σ′ s.t. Y ∈ core(σ′, X)−core(σ,X)\nand Z ∈ core(σ,X) ∪ {X}. Now, all the variables referred in TZ up to the first reference of X (if any) would also be in core(σ,X) since they have an edge to Z which is not contingent on X. Since σ and σ′ agree on core(σ,X), the evaluation of TZ would follow an identical path in σ and σ′ up to the first reference of X. Therefore, since Y is not referred to after X while evaluating TZ in σ′, it follows that Y ∈ core(σ,X).\nLet Y ∈Υ(σ,X), i.e. Y is a child of X in σ and Y ∈ core(σ,X). From the above result Y ∈ core(σ′, X) and we will next show that Y is a child ofX in σ′. Consider the evaluation path of TY in σ. All the variables that are referred before X are also in core(σ,X) by definition. Since these variables will have the same value in σ′, it follows that the evaluation of TY in σ′ will lead to X being referred. In other words, X is a parent of Y in σ′ which implies that Υ(σ,X) ⊆ Υ(σ′, X). By symmetry, Υ(σ′, X) ⊆ Υ(σ,X)\nProposition 4. For any two minimal self-supporting instantiations, σ and σ′, there is at most one variable X common to them such that σ and σ′ agree on core(σ,X), but differ on X.\nProof. Assume to the contrary that there exist two such variables X and Y . Now, since σ and σ′ agree on core(σ,X) but differ on Y , it follows that Y 6∈ core(σ,X). Hence Y cannot be in Q ∪ E. But since σ is a minimal instantiation, Y must have a path to Q∪E. Now consider the shortest path of Y to Q∪E. Some edge, W → Z, in this path must be contingent on X. Hence we can construct a path from X to Q∪E via Z which can’t be contingent on Y (otherwise, Y would have a shorter path to Q ∪ E). This implies that X ∈ core(σ, Y ), but then σ and σ′ agree on X, a contradiction.\nFor each value in dom(X), the corresponding partial instantiation σi is assigned the following weight:\nw(σi) = pX(σiX | σiTX ) |V (σi)| ∏ Y ∈Υ(σ,X) pY (σiY | σiTY )\n(7) Up to a multiplicative constant, this expression reduces to Equation 6 if X is not a switching variable. The complete pseudo-code is given in Figure 5. Note that if X is not a switching variable then core(σ,X) = vars(σ) −X and the algorithm reduces to regular Gibbs sampling.\nIt only remains to show that detailed balance holds between any two minimal instantiations σ0 and σ1. It follows from Propositions 3 and 4 that there is at most one shared variable X such that a transition is possible between σ0 and σ1 by sampling X. Thus, the only way for this transition to occur from\nσ0 is to first select X for sampling with probability 1 |V (σ0)| . Next, the new variables in σ1, ψ(σ0, X, σ1) = vars(σ1) − core(σ0, X) − {X}, must be sampled with probability ∏ Y ∈ψ(σ0,X,σ1) pY (σ1Y |σ1TY ). Finally, we must select σ1 out of all the other random instantiations, with probability w(σ1)w(σ0)+...+w(σn−1) . Now, the instantiations σ2, . . . , σn−1 are random variables and hence the overall transition probability, q(σ0 → σ1), depends on the expected value of this last probability under the distribution of these random variables:\n1 |V (σ0)| ∏ Y ∈ψ(σ0,X,σ1) pY (σ1Y | σ1TY )E [ w(σ1)∑n−1 i=0 w(σi) ]\nWe can construct a similar expression for the reverse move probability, and note that the numerator in the expectation is a constant, and the rest of the expectation doesn’t depend on which of σ0 or σ1 we start out with. Thus, q(σ0→σ1)q(σ1→σ0) is:\n|V (σ1)| |V (σ0)| w(σ1) w(σ0) ∏ Y ∈ψ(σ0,X,σ1) pY (σ1Y | σ1TY )∏ Y ∈ψ(σ1,X,σ0) pY (σ0Y | σ0TY )\nSubstituting for w(σ1) and w(σ0):\nq(σ0 → σ1) q(σ1 → σ0)\n= ∏\nY ∈Υ(σ,X)\npY (σ1Y | σ1TY ) pY (σ0Y | σ0TY )\npX(σ1X | σ1TX ) pX(σ0X | σ0TX ) · ∏ Y ∈ψ(σ0,X,σ1) pY (σ1Y | σ1TY )∏ Y ∈ψ(σ1,X,σ0) pY (σ0Y | σ0TY )\nObserve that the only terms missing from p(σ1)p(σ0) above are those for variables in core(σ,X) − Υ(σ,X). However, if Y ∈ core(σ,X) then σY = σ′Y and further if Y 6∈ Λ(σ,X) all the parents of Y are also in core(σ,X) and hence have the same values in σ and σ′. Thus these variables have identical values and distributions in σ0 and σ1 and their terms cancel out. Finally,\nq(σ0 → σ1) q(σ1 → σ0) = p(σ1) p(σ0)"
    }, {
      "heading" : "5 BLOG Compiler",
      "text" : "We have implemented our algorithm in a new implementation of the BLOG language, which we will refer to as blogc1. The broad outline of our implementation is similar to Milch’s public-domain MetropolisHastings version, except in two significant aspects.\nFirst, for variables with (possibly unknown) finite domain, we always use Gibbs sampling. By statically analyzing the structure of the model we can determine which variables are switching variables, which ones need to be resampled for each transition, etc. Based on the analysis, appropriate code is generated that does the actual sampling and reporting.\nConsider, as an example, the BLOG model in Figure 6. This model describes the prior distribution of two types of aircraft – fixed-wing planes and helicopters. These planes may produce an arbitrary number of blips on the radar (the fact that plane a produces a blip b is represented by setting Source(b) = a). Further, helicopters due to the interaction of their rotor with the radar beam can produce blade-flashes in the radar blip. In this model, the variable RotorLength(a) for all aircraft a can easily be Gibbs sampled. If WingType(a) =Helicopter then RotorLength(a) can be either Short or Long, otherwise it can only be null (as per BLOG semantics for a missing else clause). While compiling the model we can detect that the children variables of WingType(a) in any instantiation are all the BladeFlash(b) variables such that Source(b) = a. In order to speed up the computation of the Gibbs weights at runtime, we maintain a list, for each object a of type Aircraft, of all objects b of type Blip such that Source(b) = a.\n1blogc is available for download from: http://code.google.com/p/blogc/\nThe variable WingType(a) is more interesting. It can only take two possible values, but since it is a switching variable, care has to be taken when sampling it. In particular, the variable RotorLength(a) has to be uninstantiated. This is because all the children edges from RotorLength(a) are contingent on the value of WingType(a). Note that Source(b) for all objects b of type Blip is also a switching variable. However, in this case the decision to uninstantiate a variable WingType(a) such that Source(b) = a depends on whether there exists another object b′ such that Source(b′) = a.\nThe second major difference in our implementation is the handling of number variables. Instead of directly sampling the number variables, our implementation proposes birth and death moves. In the radar example, for each object w of type WingType, we generate an Aircraft object that has no blips assigned to it. The death move kills off such objects with no blips. In order to get faster mixing, we allow some extra flexibility in the birth and death move during an “initialization” phase. During this phase, birth and death moves ignore the probability of child variables. To understand the motivation, assume for a moment that the expected number of blips for a given aircraft was one million. Now, a birth move which proposes an aircraft with 0 blips would be almost certainly rejected. By allowing such birth moves during initialization, we give the inference engine an opportunity to later attach blips to the aircraft."
    }, {
      "heading" : "6 Experimental Results",
      "text" : "We have compared the convergence speed and accuracy of blogc against the existing generic MetropolisHastings inference engine provided with BLOG, which we will refer to as BLOG-MH. Since a Gibbs and a MH sampler perform different amount of work in each sample we felt that it was more appropriate to compare the two inference engines with respect to time. In order to control for the compiler optimizations in blogc we have implemented a version of BLOG-MH in blogc which we will refer to as blogc-MH. For some of the other experiments we have also implemented a version of Gibbs sampling that doesn’t uninstantiate and resample variables not in the core, which we shall refer to as blogc-noblock.\nIn the following three models each inference engine is run for a varying number of samples, where a sample is as defined by that inference engine. For each number of samples, inference is repeated 20 times with a different random seed and the mean and variance of a query variable is plotted against the average elapsed time (in seconds).\nFirst, we evaluate on the Alarm network of (Beinlich et al., 1989) available from the Bayes Network Repository2 (Friedman et al., 1997). This is a Bayes Net with 37 discrete random variables of which we observe 9. The results are summarized in Figure 7. The important thing to note is that the variance achieved by blogc in less than 2 seconds is much better than that achieved by blogc-MH in 15 seconds and by BLOGMH in 40 seconds. The compiler optimizations are clearly giving a big boost but the Gibbs sampling is helping considerably as well.\nNext, we consider the model in Figure 8 which is the urns-and-balls example of (Milch et al., 2005a) with a slight twist. Balls have a weight instead of a discrete color. Figure 9 shows that blogc converges significantly faster than BLOG-MH. However, all the improvement here is being driven by the compiler optimizations as evidenced by the fact that blogc-MH is keeping pace with blogc. This similarity is likely due to the fact that our current blogc implementation does not resample the TrueWeight variables from their full posterior. This shortcoming arises because blogc does not yet support Gibbs updates for continuous variables, and is not a limitation of the proposed Gibbs sampler for switching variables. Nevertheless, the example demonstrates the soundness of the blogc-MH implementation in addition to the compiler optimizations.\nOur final result is on the radar example of Figure 6. For this model we experimented running blogc without the logic which detects that RotorLen(a) must be uninstantiated when sampling WingType(a). This mode is labeled as blogc-noblock in Figure 10. In this experiment we are querying the probability that\n2http://www.cs.huji.ac.il/site/labs/compbio/Repository/\nWingType(Source(b1)) = Helicoper. Given that BladeF lash(b1) = true we expect this probability to be quite high. blogc converges to the true probability in less than a second. However, neither BLOG-MH nor blogc-noblock are able to come close to the true probability even after 30 seconds. This is explained by the fact that these two samplers are unable to directly sample the WingType(a) variables. The fact that they are able to make any progress at all is due to the birth move which creates new aircraft for each WingType and samples their RotorLen variable. Later, the move which resamples Source(b) for each blip has the opportunity to select this new aircraft. These two moves thus compensate for the fact that the move which attempts to sample WingType(a) is always rejected.\nIn follow-on work, we plan to demonstrate inference\nperformance comparable to model-specific inference code for a number of widely used statistical models."
    }, {
      "heading" : "7 Conclusions",
      "text" : "We have demonstrated a significant improvement in inference performance for models written in the BLOG language. Our Gibbs sampling algorithm for CBNs and our compiler techniques for generating efficient inference code are generally applicable to all openuniverse stochastic languages."
    }, {
      "heading" : "Acknowledgements",
      "text" : "This work wouldn’t have been possible without the considerable assistance provided by Brian Milch to make the models presented here work in BLOG-MH. Matthew Can provided a translation of the Alarm Bayes Net to BLOG. Finally, the first author wishes to thank his family for their boundless patience and support during this work."
    } ],
    "references" : [ {
      "title" : "An introduction to MCMC for machine learning",
      "author" : [ "C. Andrieu", "N. de Freitas", "A. Doucet", "M.I. Jordan" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "Andrieu et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Andrieu et al\\.",
      "year" : 2003
    }, {
      "title" : "The alarm monitoring system: A case study with two probabilistic inference techniques for belief networks",
      "author" : [ "I. Beinlich", "G. Suermondt", "R. Chavez", "G. Cooper" ],
      "venue" : "Proc. 2’nd European Conf. on AI and Medicine. Springer-Verlag,",
      "citeRegEx" : "Beinlich et al\\.,? \\Q1989\\E",
      "shortCiteRegEx" : "Beinlich et al\\.",
      "year" : 1989
    }, {
      "title" : "Challenge: Where is the impact of Bayesian networks in learning? IJCAI",
      "author" : [ "N. Friedman", "M. Goldszmidt", "D. Heckerman", "S. Russell" ],
      "venue" : null,
      "citeRegEx" : "Friedman et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Friedman et al\\.",
      "year" : 1997
    }, {
      "title" : "Samplingbased approaches to calculating marginal densities",
      "author" : [ "A.E. Gelfand", "A.F.M. Smith" ],
      "venue" : null,
      "citeRegEx" : "Gelfand and Smith,? \\Q1990\\E",
      "shortCiteRegEx" : "Gelfand and Smith",
      "year" : 1990
    }, {
      "title" : "Stochastic relaxation, Gibbs distributions, and the Bayesian restoration of images",
      "author" : [ "S. Geman", "D. Geman" ],
      "venue" : "IEEE Trans. on Pattern Analysis and Machine Intelligence,",
      "citeRegEx" : "Geman and Geman,? \\Q1984\\E",
      "shortCiteRegEx" : "Geman and Geman",
      "year" : 1984
    }, {
      "title" : "Church: a language for generative models. UAI",
      "author" : [ "N. Goodman", "V. Mansinghka", "D. Roy", "K. Bonawitz", "J. Tenenbaum" ],
      "venue" : null,
      "citeRegEx" : "Goodman et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Goodman et al\\.",
      "year" : 2008
    }, {
      "title" : "BLOG: Probabilistic models with unknown objects",
      "author" : [ "B. Milch", "B. Marthi", "S.J. Russell", "D. Sontag", "D.L. Ong", "A. Kolobov" ],
      "venue" : "IJCAI (pp",
      "citeRegEx" : "Milch et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Milch et al\\.",
      "year" : 2005
    }, {
      "title" : "Approximate inference for infinite contingent Bayesian networks",
      "author" : [ "B. Milch", "B. Marthi", "D. Sontag", "S. Russell", "D.L. Ong", "A. Kolobov" ],
      "venue" : "In Proc. 10th AISTATS (pp. 238–245)",
      "citeRegEx" : "Milch et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Milch et al\\.",
      "year" : 2005
    }, {
      "title" : "General-purpose MCMC inference over relational structures",
      "author" : [ "B. Milch", "S. Russell" ],
      "venue" : "Proceedings of the Proceedings of the Twenty-Second Conference Annual Conference on Uncertainty in Artificial Intelligence",
      "citeRegEx" : "Milch and Russell,? \\Q2006\\E",
      "shortCiteRegEx" : "Milch and Russell",
      "year" : 2006
    }, {
      "title" : "Markov chain sampling methods for dirichlet process mixture models",
      "author" : [ "R.M. Neal" ],
      "venue" : "Journal of Computational and Graphical Statistics,",
      "citeRegEx" : "Neal,? \\Q2000\\E",
      "shortCiteRegEx" : "Neal",
      "year" : 2000
    }, {
      "title" : "BUGS: Bayesian inference using gibbs sampling, version",
      "author" : [ "D. Spiegelhalter", "A. Thomas", "N. Best", "W. Gilks" ],
      "venue" : null,
      "citeRegEx" : "Spiegelhalter et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "Spiegelhalter et al\\.",
      "year" : 1996
    }, {
      "title" : "Introduction to radar target recognition. The Institution of Engineering and Technology, United Kingdom",
      "author" : [ "P. Tait" ],
      "venue" : null,
      "citeRegEx" : "Tait,? \\Q2009\\E",
      "shortCiteRegEx" : "Tait",
      "year" : 2009
    } ],
    "referenceMentions" : [ {
      "referenceID" : 10,
      "context" : "For example, BUGS (Spiegelhalter et al., 1996) can represent directed graphical models over indexed sets of random variables and uses MCMC inference (in particular, Gibbs sampling where this is possible).",
      "startOffset" : 18,
      "endOffset" : 46
    }, {
      "referenceID" : 5,
      "context" : ", 2005a) and Church (Goodman et al., 2008), handles cases in which the number of objects (in BUGS, the index set) is unknown and perhaps unbounded, and object identity is uncertain.",
      "startOffset" : 20,
      "endOffset" : 42
    }, {
      "referenceID" : 6,
      "context" : "This section repeats, and in some cases generalizes, definitions proposed by Milch et al. (2005b). A contingent Bayesian network (CBN) consists of a set of random variables V, and for each variable X ∈V, a domain dom(X) and decision tree TX .",
      "startOffset" : 77,
      "endOffset" : 98
    }, {
      "referenceID" : 11,
      "context" : "Helicopters have an unknown RotorLength, and depending on this length they might produce a characteristic pattern called a BladeFlash (Tait, 2009) in the returned radar signal.",
      "startOffset" : 134,
      "endOffset" : 146
    }, {
      "referenceID" : 9,
      "context" : "Standard sampling algorithms for nonparametric, Dirichlet process mixture models use a related representation: they instantiate parameters for those mixture components which support the evidence, as well as a few auxiliary components (Neal, 2000).",
      "startOffset" : 234,
      "endOffset" : 246
    }, {
      "referenceID" : 0,
      "context" : "The nature of this proposal distribution q(σ → σ′) makes it quite simple to compute the acceptance ratio for the Metropolis–Hastings (MH) method (Andrieu et al., 2003), which takes the following form:",
      "startOffset" : 145,
      "endOffset" : 167
    }, {
      "referenceID" : 4,
      "context" : "This method was originally proposed by Geman and Geman (1984) for inference in undirected Markov random fields, and later popularized as a general Bayesian inference method by Gelfand and 1.",
      "startOffset" : 39,
      "endOffset" : 62
    }, {
      "referenceID" : 9,
      "context" : "One possible solution, proposed in the context of Dirichlet process (DP) mixture models by Neal (2000), augments σ with auxiliary variables chosen so that σ is self-supporting for all a∈ dom(X).",
      "startOffset" : 91,
      "endOffset" : 103
    }, {
      "referenceID" : 1,
      "context" : "First, we evaluate on the Alarm network of (Beinlich et al., 1989) available from the Bayes Network Repository (Friedman et al.",
      "startOffset" : 43,
      "endOffset" : 66
    }, {
      "referenceID" : 2,
      "context" : ", 1989) available from the Bayes Network Repository (Friedman et al., 1997).",
      "startOffset" : 52,
      "endOffset" : 75
    } ],
    "year" : 2010,
    "abstractText" : "Languages for open-universe probabilistic models (OUPMs) can represent situations with an unknown number of objects and identity uncertainty. While such cases arise in a wide range of important real-world applications, existing general purpose inference methods for OUPMs are far less efficient than those available for more restricted languages and model classes. This paper goes some way to remedying this deficit by introducing, and proving correct, a generalization of Gibbs sampling to partial worlds with possibly varying model structure. Our approach draws on and extends previous generic OUPM inference methods, as well as auxiliary variable samplers for nonparametric mixture models. It has been implemented for BLOG, a well-known OUPM language. Combined with compile-time optimizations, the resulting algorithm yields very substantial speedups over existing methods on several test cases, and substantially improves the practicality of OUPM languages generally.",
    "creator" : "TeX"
  }
}