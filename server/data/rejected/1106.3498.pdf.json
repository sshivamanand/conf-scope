{
  "name" : "1106.3498.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "On the expressive power of unit resolution",
    "authors" : [ "Olivier Bailleux" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n10 6.\n34 98\nv1 [\ncs .A\nI] 1\n7 Ju\nn 20\n11"
    }, {
      "heading" : "1 Introduction and motivations",
      "text" : "Unit resolution is a key feature of state of the art sat solvers [13] [7] [5], where it speeds up the search for solutions and inconsistencies.\nIt is well known that different cnf representations of a given problem do not always allow unit resolution to deduce the same information. For example, the cnf encoding for pseudo Boolean constraints proposed in [3] allows unit resolution to restore generalized arc consistency. This is not the case with the encoding proposed in [16], which does not allow unit resolution to deduce as much information as the former encoding does. As a manner of speaking, the expressive power of unit resolution is best exploited using the encoding proposed in [3], with notable consequences on the resolution time.\nTwo important related questions are \"What information can be deduced by unit resolution?\" and \"Which clauses are required in order to allow this information to be deduced?\"\nThese questions are strongly connected to the characterization of the application field of sat solvers: \"Which problems can be solved as efficiently using a sat solver as using a specialized solver?\" and \"How to encode these problems into cnf formulae for optimal resolution time?\"\nIn this paper, we are interested in the functions that can be calculated by means of unit resolution. Studying the expressive power of unit resolution requires characterizing these functions, which will be called propagatable functions, and specifying the size of the formulae required to compute them.\nSection 2 presents the three main research directions related to the expressive power of unit resolution. Section 3 introduces the concept of propagators and propagatable functions as a formal framework where unit resolution is a computing model. This section also presents theoretical results that will be used in section 4, where the expressive power of unit resolution is compared to the one of monotone Boolean circuits. Section 5 ends the paper with a synthesis of the results, which highlight their implications regarding the efficiency of unit resolution as a filtering technique in SAT solvers."
    }, {
      "heading" : "2 Related works",
      "text" : "There are at least three research directions related to the study of the expressive power of unit resolution.\nThe first one aims to identify the classes of formulae for which unit resolution is a complete refutation procedure in the sense that it produces the empty clause if and only if the input formula is not satisfiable. For example, this property holds for the formulae containing only Horn clauses [9]. This approach differs from that proposed in this paper since it considers the formulae as input data instead of computing systems.\nThe second direction aims to characterize the complexity of determining whether a given formula can be refuted by unit resolution or not. This decision problem denoted unit is known to be p-complete, meaning that for any problem π with polynomial time complexity, there exists a log space reduction from π to unit [10]. Circuit value and monotone circuit value, which consist to determine the output value of a Boolean circuit (monotone Boolean circuit, respectively), given its input values, are both p-complete too [8]. Regarding the complexity theory, unit, circuit value and monotone circuit value have then the same expressive power. In the present paper, a different point of view is adopted. The cnf formula is not the input data of a program, but the program itself. The input data is a partial truth assignment encoded in a natural way, i.e., each input variable can be either assigned to true, assigned to false, or not assigned. Similarly, the Boolean circuits are not considered as inputs of a program, but as a programs by themselves. In this context, circuit value and monotone circuit value have not the same expressive power for at least two reasons : (1) monotone circuits can only compute monotone Boolean functions, while any Boolean function can be computed using a general Boolean circuit, and (2) there exist monotone Boolean functions which can be computed by polynomially sized Boolean circuits, but requiring an exponential number of gates to be computed using monotone circuits [15]. One of our results is that used as a computation model, unit resolution with natural input encoding has the same expressive power as monotone Boolean circuits, then less expressive power than general Boolean circuits. Obviously, the input encoding plays a central role is this result since by the use of another encoding where all input variables are assigned, unit resolution can easily simulate any Boolean circuit. Nevertheless, the natural encoding is the one used internally in the sat solvers.\nThe third line is related to the search for efficient cnf encodings of various problems in order to solve them thanks to a sat solver. Because unit resolution is implemented efficiently in sat solvers, many works aim to find encoding schemes which allow unit resolution to make as many deductions as possible. In [6], a cnf encoding for enumerative constraints is proposed, which allows unit propagation to make the same deductions on the resulting formula as restoring arc consistency on the initial constraints does. This work was innovative because with the previously known encodings, unit propagation had less inference power than restoring arc consistency, which is the basic filtering method used in constraint solvers. It has been followed by various similar works on other kinds of constraints such as Boolean cardinality constraints [2] and pseudo-Boolean constraints [4], while in [1], a general way to construct such an encoding for any constraint is proposed. Today, it has become customary, when a new encoding is proposed, to address the question of the behavior of unit resolution on the obtained sat instances. The problem is that some of these encodings produce a prohibitive number of clauses. This is why some authors seek a trade-off between the size of the formulae and the inference power of unit resolution and other deduction rules implemented in sat solvers, such as the failed literal rule [11]. For example, this approach is developed in [14] and [12] in the context of Boolean cardinality constraints."
    }, {
      "heading" : "3 Propagatable functions",
      "text" : ""
    }, {
      "heading" : "3.1 Unit resolution",
      "text" : "This section recalls the terminology and the principles involved in unit resolution, and introduces the notations that will be used in the rest of the paper.\nA literal is either a propositional variable or a negated propositional variable. A cnf formula is\ndefined as a conjunction c1 ∧ . . . ∧ ck of clauses, where each clause ci = li,1 ∨ . . . ∨ li,|ci| is a disjunction of literals. The size of a cnf formula is its number of literal occurrences.\nA truth assignment on a set of propositional variables is a function mapping some of the variables in this set to truth values, i.e., true or false. These variables are said to be fixed to true or false. If a truth assignment does not fix all the variables, it is said to be partial ; else it is said to be complete. In this paper, a truth assignment will be represented as a set of literals. Given a propositional formula φ and a truth assignment I, φ|I denotes φ ∧\nl∈I(l). Any cnf formula φ is said to be satisfied (falsified, respectively) by a truth assignment I if and only if I causes φ to evaluate to true (false, respectively) in the standard way. A cnf formula φ is said to be satisfiable if and only if there exists a truth assignment that satisfy φ. Any complete truth assignment satisfying a cnf formula φ is called a model of φ.\nFor convenience, a clause can be represented as a set of literals and a cnf formula can be represented as a set of clauses.\nExample 1. The cnf formula (a ∨ b̄) ∧ (ā ∨ b) can be represented as {{a, b̄}, {ā, b}}.\nUnit resolution is an inference technique which aims either to detect an inconsistency or to assign some variables, so as to simplify a cnf formula. As described in a standard way by Algorithm 1, until there is no empty clause and there is at least one unit clause (w) in the input formula, all the occurrences of the literal w and all the clauses containing the literal w are removed.\ninput : φ [cnf formula]; output: (φ,E) [(cnf formula, set of literals)] or ⊥;\nE ← {}; while {} /∈ φ and ∃{l} ∈ φ do\nφ← φ \\ {c : c ∈ φ, l ∈ c} \\ {c : c ∈ φ, l̄ ∈ c} ∪ {c \\ {l̄} : c ∈ φ, l̄ ∈ c}; E ← E ∪ {l};\nend if {} ∈ φ then return ⊥ else return (φ,E) end\nAlgorithm 1: The standard algorithm for unit resolution\nIn the following, we will consider another algorithm (Algorithm 3) that will be called the alternative algorithm for unit resolution. This alternative algorithm return ⊥ if and only if the standard algorithm return ⊥, else it returns the same truth assignment as the standard algorithm does. But contrary to the standard algorithm, it does not modify the input formula.\nThe alternative algorithm repeat n+1 propagation stages, where n is the number of variables in the input formula. Each of these propagation stage is performed by the procedure propagation (Algorithm 2).\nThe standard and the alternative algorithms are strictly equivalent. The first one produces a literal w if there is a unit clause (w) in the simplified formula, that is if there is a clause (l1 ∨ · · · ∨ lq ∨ w) in the input formula such that the literals l̄1, . . . , l̄q are previously produced. The second one produces the same literal in the same conditions, with the only difference that it does not modify the input formula. The standard algorithm return ⊥ when an empty clause is produced. This occurs when there is some unit clause (w) and the opposite clause (w̄) in the simplified formula. In the same situation, the alternative algorithm does not stop, but adds both the literals w and w̄ in the set E. As the standard algorithm, it will return ⊥ at the end of its execution.\ninput : φ,E [(cnf formula, set of literals)]; output: F [set of literals];\nF ← {}; foreach literal w in φ such that w /∈ E do\nforeach clause (l1 ∨ · · · ∨ lk ∨ w) of φ such that l̄1, . . . , l̄k ∈ E do F ← F ∪ {w} end\nend return F ;\nAlgorithm 2: The procedure propagation, which performs a propagation stage of the alternative algorithm for unit resolution.\ninput : φ [cnf formula]; output: E [set of literals] or ⊥;\nE ← {}; n← the number of variables in φ; repeat n+ 1 times\nE ← E ∪ propagation(φ,E); end if there exists v such that v, v̄ ∈ E then return ⊥ else return E end\nAlgorithm 3: The alternative algorithm for unit resolution\nOf course, the alternative algorithm could be optimized in such a way that it stops if the last propagation stage did not modify the set E, or if there are a literal w and its opposite w̄ in E. One of these two events necessarily occurs during the first n+ 1 propagation stages, because if E contains n+1 literals, it necessarily contains two opposite literals. This optimization has not been done because this algorithm is not intended to be implemented. It is only a way to prove some theoretical results which will be presented later.\nIn the following of the paper, given any cnf formula φ with n variables and any integer 1 ≤ k ≤ n+1,\n• Uk(φ) will denote the set of literals produced at the k th propagation stage of algorithm 3;\n• U1..k(φ) will denote ∪ k i=1Ui(φ);\n• U(φ) will denote the result of unit propagation applied to φ, i.e., either ⊥ or U1..n+1(φ).\nExample 2. With φ = (a∨ b̄)∧ (b)∧ (ā∨ c∨ d̄) as input, both algorithms 1 and 3 return U(φ) = {b, a}. Regarding algorithm 3, U1(φ) = {b} and U2(φ) = {a}."
    }, {
      "heading" : "3.2 Reified formulae",
      "text" : "This section introduces the notion of reified cnf formula, which will be subsequently used as a tool to prove several results.\nInformally speaking, the reified counterpart of any cnf formula φ, is a satisfiable cnf formula σ = reif(φ) such that applying unit resolution on σ simulates all the inferences produced by applying unit resolution on φ.\nLet var(φ) denote the set of the variables occurring in φ.\nDefinition 1 (reified formula). Let φ be a cnf formula with n variables. The reified counterpart of φ is the formula σ = reif(φ) obtained as follows:\n• There are 2n(n+ 2) variables in σ, namely\nvar(σ) = ∪v∈var(φ){v + 0 , v − 0 , . . . , v + n+1, v − n+1}\nGiven any propositional variable v ∈ var(σ), let δ(v) denotes v+ and δ(v) denotes v−.\n• σ consists of the following clauses:\n(1) for any unary clause (w) of φ, (δ(w)0)∧ (δ(w)0 ∨ δ(w)1) 1, which will be called initialization\nclauses of rank 0 and 1,\n(2) for any stage 2 ≤ i ≤ n+ 1, and any variable v of φ, (v+i−1 ∨ v + i ) ∧ (v − i−1 ∨ v − i ), which will be\ncalled propagation clauses of rank i,\n(3) for any stage 2 ≤ i ≤ n+ 1, and for any non-unary clause q of φ, ∧\nw∈q χ(q, i, w), where\nχ(q, i, w) = δ(w)i ∨ ∨\nt∈q,t6=w\nδ(t)i−1,\nwhich will be called deduction clauses of rank i.\nFor convenience, in the following of the paper, each time that a formula φ and it reified counterpart σ = reif(φ) will be considered, the propagation stages on φ will be numbered from 1, while the propagation stages on σ will be numbered from 0.\nExample 3. Let φ = (a)∧(a∨b). The reified counterpart of φ can be decomposed as σ = σ(1)∧σ(2)∧σ(3), where:\nσ(1) = (a + 0 ) ∧ (a + 0 ∨ a + 1 )\nσ(2) = (a + 1 ∨ a + 2 ) ∧ (a − 1 ∨ a − 2 ) ∧ (b + 1 ∨ b + 2 ) ∧ (b − 1 ∨ b − 2 ) ∧ (a + 2 ∨ a + 3 ) ∧ (a − 2 ∨ a − 3 ) ∧ (b + 2 ∨ b + 3 ) ∧ (b − 2 ∨ b − 3 )\nσ(3) = (a + 1 ∨ b + 2 ) ∧ (b − 1 ∨ a − 2 ) ∧ (a + 2 ∨ b + 3 ) ∧ (b − 2 ∨ a − 3 )\nThe stage 1 of unit resolution fixes a to true in φ. Accordingly, thanks to the initialization clauses, the stages 0 and 1 of unit resolution fix a+0 and a + 1 to true in σ.\nAt the stage 2, unit resolution fixes b to true in φ. Accordingly, at the stage 2 of unit resolution of\nσ, the variable b+2 is fixed to true thanks to the deduction clause (a + 1 ∨ b + 2 ), and the variable a + 2 is fixed to true thanks to the propagation clause (a+1 ∨ a + 2 ).\nAt the stage 3, unit resolution fixes no new variable in φ. Thanks to the propagation clauses (a+2 ∨a + 3 )\nand (b+2 ∨ b + 3 ), the stage 3 of unit resolution on σ fixes a + 3 and b + 3 to true.\nThis example shows the roles of the three kind of clauses. The initialization clauses simulate the first stage of unit resolution, which consists to fix the variables occurring in unit clauses. The propagation clauses allow unit resolution to propagate the values that where previously assigned. For example, if the variable a is fixed to true in φ at stage 1, i.e., a+1 is fixed to true in σ, then the clause (a + 1 ∨ a + 2 ) ensures that a+2 is fixed to true in σ at stage 2. The deduction clauses allow unit resolution to simulates in σ the deductions that are made in φ. For example, if at stage 1, the variable a is fixed to true in φ,\n1(δ(w)1) would have the same effect in only one propagation stage, but the reified formula is intentionally tailored in such a way that the variables v+\ni and v− i are fixed at the (i+ 1)th propagation stage.\nand if there is a clause (ā ∨ b) in φ, then the clause (a+1 ∨ b + 2 ) of σ allows unit resolution to fix b + 2 to true, which indicates that unit resolution fixes b to true in φ. Note that the proposed model of reified formula is not optimal in the sense that it usually involves redundant clauses and useless clauses. Our purpose is to provide a tool for proving theoretical results which will be presented in the following of the paper. In this context, the relevant property of the reified counterpart of a formula φ is that its size is polynomially related to the size of φ. Namely, if there are n variables and k clauses of size at most p in φ, then there are O(n2k) clauses of size at most p in the reified counterpart σ of φ, because for any of the O(n) propagation stages, σ contains O(n) propagation clauses and O(kn) deduction clauses2, and because the number of literals in any clause of σ cannot exceed the size of the longest clause of φ.\nDefinition 2 (reified formula with injected variables). Let φ be any cnf formula with n variables and V ⊆ var(φ) be a set of propositional variables. The formula\nreif(φ, V ) = reif(φ) ∧ ( ∧\nv∈V\n((v ∨ v+1 ) ∧ (v ∨ v − 1 )))\nis said to be the reified counterpart of φ with injected variables V . The clauses added to reif(φ) will be called injection clauses.\nLemma 1. Let φ be any cnf formula with n variables. Let σ = reif(φ) and i be any integer such that 0 ≤ i ≤ n+1. For any variable v ∈ var(φ), applying unit resolution on σ can fix v+i and/or v − i only at the propagation stage i, and only to true.\nProof. This property can be proved by induction on i. The only variables which can be fixed at the first propagation stage, i.e. i=0, are in {v+0 , v − 0 , v ∈ var(φ)}, because no other variables are in unary clauses, and these variables can only be fixed to true, because they occur positively. Now, given any 1 ≤ i ≤ n + 1, let us suppose the the property hold until the (i − 1)th propagation stage (which implies that no variable in {v+i , v − i , 0 ≤ i ≤ i − 1, v ∈ var(φ)} has been fixed negatively). The only way for unit resolution to fix variables in {v+i , v − i , v ∈ var(φ)} is through clauses involving variables in {v+i−1, v − i−1, v ∈ var(φ)}, which, by induction hypothesis, can only be fixed at the propagation stage i − 1. Because the variables in {v+i−1, v − i−1, v ∈ var(φ)} occur positively in these clauses, they can be only fixed to true.\nTheorem 1. Let φ be any cnf formula with n variables and σ = reif(φ) be the reified counterpart of φ. The following properties hold:\n1. σ is satisfiable.\n2. For any variable v ∈ var(φ), and any integer 1 ≤ k ≤ n+ 1, the two following properties hold:\n(a) v+k ∈ Uk(σ) if and only if v ∈ U1..k(φ); (b) v−k ∈ Uk(σ) if and only if v̄ ∈ U1..k(φ).\nProof. The first property arises because each clause of σ contains at least one positive literal. The second property can be proved by induction on k. For sake of brevity, let us reformulate it as follows: for any variable v ∈ var(φ), any integer 1 ≤ k ≤ n+1, and any literal w ∈ {v, v}, δk(w) ∈ Uk(σ) if and only if w ∈ U1..k(φ).\nClearly, the property holds for k = 1 because there is a clause (w) in φ if and only if there is a clause (δ0(w)) and a clause (δ0(w) ∨ δ1(w)) in σ. Now let us suppose that the property holds until the propagation stage k − 1, k > 1.\n2Because each of the n variables occurs at most in k clauses.\n⇒ Let us suppose that δk(w) ∈ Uk(σ). Then, according to the lemma 1, one of the two following conditions hold:\n1. There is a propagation clause (δk−1(w) ∨ δk(w)) in σ and δk−1(w) ∈ Uk(σ). By induction hypothesis, w ∈ U1..k−1(φ), then w ∈ U1..k(φ).\n2. There is a deduction clause (δk−1(l̄1)∨· · ·∨δk−1(l̄q)∨δk(w)) in σ and δk−1(l̄1), . . . , δk−1(l̄q) ∈ Uk−1(σ). This means that there is a clause (l1∨· · ·∨lq∨w) in φ, and, by induction hypothesis, l̄1, . . . , l̄q ∈ U1..k−1(φ). Then w ∈ U1..k(φ).\n⇐\nLet us suppose that w ∈ U1..k(φ). Then, according to the principle of unit resolution, one of the two conditions hold:\n1. There is a clause (w) in φ. Then, as shown in the first part of this proof, δ1(w) ∈ U1(σ). Thanks to the propagation clauses (δ1(w) ∨ δ2(w)), . . . , (δk−1(w) ∨ δk(w)), δk(w) ∈ Uk(σ).\n2. There is a clause (l1 ∨ · · · ∨ lq ∨ w) in φ and an integer 1 ≤ i ≤ k − 1 such that l̄1, . . . , l̄q ∈\nU1..i(φ). By construction of σ, there is a deduction clause (δi(l̄1) ∨ · · · ∨ δi(l̄q) ∨ δi+1(w)) in σ, and by induction hypothesis, δi(l̄1), . . . , δi(l̄q) ∈ Ui(σ). Then δi+1(w) ∈ Ui+1(σ). Either because i+1 = k or thanks to the propagation clauses (δi(w)∨δi+1(w)), . . . , (δk−1(w)∨δk(w)), δk(w) ∈ Uk(σ).\nAs an interesting corollary of Theorem 1, the failed literal rule [11], which is a speed up technique implemented in some modern sat solver, can be simulated by unit propagation. Given a formula σ and a literal l, the failed literal rule aims to test if l must be fixed. Unit resolution is applied to σ ∧ (l̄) (σ ∧ (l), respectively). If an inconsistency is detected then l (l̄, respectively) is fixed to true. The same result can be obtained by applying unit resolution on reif(φ ∧ (l)) ∧ ∧\nv∈var(φ)(v + n+1 ∨ v − n+1 ∨ l)\n(reif(φ ∧ (l)) ∧ ∧\nv∈var(φ)(v + n+1 ∨ v − n+1 ∨ l), respectively).\nTheorem 2. Let φ be any cnf formula, V ⊆ var(φ) be a set of propositional variables, and I ∈ IV a truth assignment. U((reif(φ, V ))|I) = U(reif(φ|I)), i.e., unit resolution have the same effect on U((reif(φ, V ))|I) as it does on U(reif(φ|I)).\nProof. For any literal v ∈ I (v̄ ∈ I, respectively), the two first stages of unit resolution applied to (reif(φ, V ))|I produces the literals v + 1 (v − 1 , respectively), which are the literals produced from the clauses (v+0 ∨ v + 1 ), (v + 0 ) ((v − 0 ∨ v − 1 ), (v − 0 ), respectively) of reif(φ|I). The other stages of unit resolution behave similarly in the two formulae, because the same clauses are involved."
    }, {
      "heading" : "3.3 Computing with unit resolution",
      "text" : "This section explains how unit resolution can be used to compute functions."
    }, {
      "heading" : "3.3.1 Definitions and terminology",
      "text" : "Definition 3 (Propagator). Let φ be a cnf formula, var(φ) be the set of propositional variables occurring in φ, V ⊆ var(φ) a set of propositional variables, and s ∈ V a propositional variable. The triplet P = 〈φ, V, s〉 is called a propagator. The size of P is the size of the formula φ.\nA propagator 〈φ, V, s〉 can act as a computer in the following way:\n• the input data is a partial truth assignment I of the variables in V , i.e., some variables are assigned to true, some are assigned to false, and the other are not assigned,\n• the output can take four possible values according to the result of applying unit resolution:\n– fail if U(φ|I) = ⊥,\n– true if U(φ|I) 6= ⊥ and s ∈ U(φ|I),\n– false if U(φ|I) 6= ⊥ and s̄ ∈ U(φ|I),\n– na if U(φ|I) 6= ⊥ and s̄ /∈ U(φ|I) and s /∈ U(φ|I).\nFormally, 〈φ, V, s〉 computes a function f with domain IV and codomain {fail, true, false, na}, where IV denotes the set of all the consistent partial assignments on V , i.e., {I ⊂ V ∪ {v, v ∈ V },∀l ∈ I, l̄ /∈ I}.\nConversely, given a set V of propositional variables and any function f with domain D ⊆ IV and codomain {fail, true, false, na}, the following issues can be addressed:\n1. Can f be computed by a propagator ?\n2. If yes, how many clauses are required to compute f using unit resolution ?\nThese questions are important because in a sat solver, unit resolution is used both for detecting inconsistencies (the fail answer) and for inferring new information (the true or false answers), with the effect of accelerating the resolution. It is then useful to use concise cnf encodings which allow unit resolution to achieve as many deductions as possible.\nDefinition 4 (reified propagator). Let P = 〈φ, V, s〉 be a propagator. The reified counterpart of P is reif(P ) = 〈ψ, V, strue, sfalse, sfail〉, such that strue is the variable s+n+1, s false is the variable s−n+1, s fail is new fresh variable, and\nψ = reif(φ, V ) ∧ ( ∧\nu∈var(φ)\n(u+n+1 ∧ u − n+1 ∧ s fail))\nBy construction of the formula ψ, given any I ∈ IV , applying unit resolution to ψ|I never returns ⊥ and simulates unit resolution on φ|I in the following sense:\n• unit resolution on φ|I returns ⊥ if and only if unit resolution on ψ|I produces s fail (i.e. fixes to\nsfail to true);\n• unit resolution on φ|I produces s if and only if unit resolution on ψ|I produces s true;\n• unit resolution on φ|I produces s̄ if and only if unit resolution on ψ|I produces s false.\nDefinition 5 (filtering function). Let V be a set of propositional variables. Any function f with domain D ⊆ IV and codomain {fail, true, false, na} is called a filtering function.\nDefinition 6 (matching function). Let V be a set of propositional variables. Any function f with domain D ⊆ IV and codomain {yes, no} is called a matching function.\nAny filtering function can be specified with three matching functions in the following way:\nDefinition 7 (matching functions related to a filtering function). Let f be a filtering function with domain D ⊆ IV , V ∈ {v1, . . . , vn}. The three matching functions related to f are defined as follows:\n• f fail with domain D and codomain {yes, no}, such that for any I ∈ D, f fail(I) = yes if and only if f(I) = fail,\n• f true with domain D′ = {I ∈ D, f(I) 6= fail}, such that for any I ∈ D′, f true(I) = yes if and only if f(I) = true,\n• f false with domain D′ = {I ∈ D, f(I) 6= fail}, such that for any I ∈ D′, f false(I) = yes if and only if f(I) = false.\nDefinition 8 (monotone matching function). Given the order relation no ≤M yes, any matching function f with domain D is said to be monotone if for any I, J ∈ D such that I ⊆ J , f(I) ≤M f(J).\nNow we will formally define the filtering and the matching functions that are computable using unit resolution.\nDefinition 9 (propagatable filtering function). Any filtering function f is said to be propagatable if and only if there exists a propagator which computes f .\nNow, two ways will be considered to compute matching functions with unit resolution. The first one consists in using a variable as output under the assumption that ⊥ is never returned. The second one consists in considering that the output value yes when ⊥ is returned.\nDefinition 10 (propagatable matching function). Any matching function f with domain D ⊆ IV is said to be propagatable if there exists a propagator 〈φ, V, s〉 such that for any I ∈ D, the two following conditions hold:\n1. U(φ|I) 6= ⊥,\n2. f(I) = yes if and only if s ∈ U(φ|I).\nDefinition 11 (ν-propagatable matching function, ν-propagator). Any matching function f with domain D ⊆ IV is said to be ν-propagatable if there exists a cnf formula φ such that for any I ∈ D, f(I) = true if and only if U(φ|I) = ⊥. The couple 〈V, φ〉 is said to be a ν-propagator computing f .\nTo end this necessary sequence of definitions, let us address the notion of space complexity of propagatable functions.\nDefinition 12 (polynomially propagatable functions). Let F be a family of filtering functions or a family of matching functions. F is said to be polynomially propagatable (or polynomially ν-propagatable, if applicable) if and only if any function f ∈ F with domain D ⊆ I{v1,...,vn} can be computed using a cnf formula of size polynomially related to n."
    }, {
      "heading" : "3.3.2 Propagability versus ν-propagability",
      "text" : "In this section, we will show that propagatable and ν-propagatable matching functions have the same expressive power and similar space complexities.\nTheorem 3. Let f be a matching function. f is propagatable if and only if f is ν-propagatable.\nTheorem 4. Let f be a propagatable matching function. f is polynomially propagatable if and only if f is polynomially ν-propagatable.\nProof.\n1. propagatable ⇒ ν-propagatable.\nLet f be a propagatable matching function with domain D, and P = 〈φ, V, s〉 be a propagator which computes f . Clearly, for any partial truth assignment I ∈ D, applying unit resolution to the formula (φ ∧ (s))|I returns ⊥ if and only if f(I) = yes.\n2. ν-propagatable ⇒ propagatable.\nLet f be a ν-propagatable function with domain D ⊂ IV and φ a cnf formula including n variables, such that for any I ∈ D, applying unit resolution to φ|I returns ⊥ if and only if f(I) = yes.\nOur aim is to build a new formula ψ such that for any I ∈ D, applying unit resolution to ψ|I does not return ⊥ but fixes a variable s to true if and only if applying unit resolution to φ|I returns ⊥, in such a way that the propagator 〈ψ, V, s〉 computes f .\nThe formula ψ can be obtained as follows:\nψ = reif(φ, V ) ∧ ( ∧\nu∈var(φ)\n(u+n+1 ∧ u − n+1 ∧ s))\nThe variable s will be fixed to true if and only if unit resolution on φ fixes both a variable u+i and a variable u−i to true. According to the theorems 1 and 2, this occurs if and only if applying unit resolution to φ|I returns ⊥. Then, 〈ψ, V, s〉 is a propagator which computes f .\nBecause the two transformations have polynomial space complexity, both theorems 4 and 3 hold."
    }, {
      "heading" : "3.3.3 Filtering functions versus matching functions",
      "text" : "In this section, we will show that without loss of generality, studying the space complexity of propagatable filtering functions reduces to studying the space complexity of propagatable matching functions.\nTheorem 5. Any filtering function f is propagatable if and only if the three related matching functions f true, f false, and f fail are propagatable.\nTheorem 6. Any filtering function f is polynomially propagatable if and only if the three related matching functions f true, f false, and f fail are polynomially propagatable.\nProof.\n1. filtering ⇒ matching\nLet f be a propagatable filtering function and f true, f false, and f fail the related matching functions. Because f is propagatable, there exists a propagator 〈φ, V, s〉 that computes f . Then f true, f false, and f fail can be computed with the following propagators, respectively:\n(a) 〈φ, V, s〉 (which computes f true);\n(b) 〈φ ∧ (s ∨ t), V, t〉 (which computes f false);\n(c) 〈ψ, V, sfail〉, where 〈ψ, V, strue, sfalse, sfail〉 is the reified counterpart of 〈φ, V, s〉.\nClearly, f true, f false, and f fail are propagatable. Now, because the size of ψ is polynomially related to the size of φ, if f is polynomially propagatable then f true, f false, and f fail are polynomially propagatable too.\n2. matching ⇒ filtering\nLet f be a filtering function with domain D ⊂ IV , V ∈ {v1, . . . , vn} and f true, f false, and f fail the related matching functions. Suppose that f true, f false, and f fail are propagatable (polynomially propagatable, respectively). Now let us consider the three following propagators (with formulae of size polynomially related to n, respectively):\n(a) 〈φ1, V, s1〉, which computes f true; (b) 〈φ2, V, s2〉, which computes f false; (c) 〈φ3, V, s3〉, which computes f fail.\nLet 〈ψ1, V, s true 1 , s false 1 , s fail 1 〉, 〈ψ2, V, s true 2 , s false 2 , s fail 2 〉, 〈ψ3, V, s true 3 , s false 3 , s fail 3 〉 be the reified counterparts of these propagators. Without loss of generality, let us suppose that, except for the input variables in V , the formulae ψ1, ψ2, ψ3 have no common variable.\nThe function f can be computed (in polynomial space, respectively) using the following propagator:\nP = 〈ψ1 ∧ ψ2 ∧ ψ3 ∧ (strue1 ∨ s) ∧ (s false 2 ∨ s) ∧ (s fail 3 ), V, s〉\nClearly, P computes f , which is then propagatable (polynomially propagatable, respectively)."
    }, {
      "heading" : "3.3.4 Boolean representations",
      "text" : "Given V = {v1, . . . , vn} a set of propositional variables, D ⊆ IV a set of partial truth assignments of V , f any matching function with domain D, and I any partial assignment in D, let us define:\n• the Boolean representation of I as IB = (x1, . . . , xn, y1, . . . , yn) ∈ {0, 1} n such as for any 1 ≤ i ≤ n,\nxi = 1 if and only if vi ∈ I, and yi = 1 if and only if vi ∈ I,\n• the Boolean representation of D as DB = {IB, I ∈ D},\n• the Boolean representation of f as fB : DB 7→ {0, 1}, such that for any I ∈ D, fB(IB) = 1 if and only if f(I) = yes.\nExample 4. The following table gives an example of a matching function f and its Boolean counterpart fB.\nI IB f(I) fB(IB) {v1, v2} (0, 0, 1, 1) no 0 {v1, v2} (0, 1, 1, 0) yes 1 {v1} (0, 0, 1, 0) no 0 {v1, v2} (1, 0, 0, 1) yes 1 {v1, v2} (1, 1, 0, 0) yes 1 {v1} (1, 0, 0, 0) yes 1 {v2} (0, 0, 0, 1) no 0 {v2} (0, 1, 0, 0) yes 1 {} (0, 0, 0, 0) no 0\n〈(v̄1 ∨ s) ∧ (v̄2 ∨ s), {v1, v2}, s〉 is a propagator for f .\nExample 5. The following table gives a matching function g which is not propagatable, and its Boolean counterpart gB.\nI IB g(I) gB(IB) {v} (0, 1) yes 1 {v} (1, 0) no 0 {} (0, 0) yes 1\nThere is no propagator for g because for any formulae φ1 ⊆ φ2, if U(φ2) 6= ⊥ then any variable fixed by unit resolution on φ1 will be fixed on φ2 as well. It follows that the third line of the table is not consistent with the second one."
    }, {
      "heading" : "3.4 Synthesis",
      "text" : "In this section, we first introduced the notion of filtering function as a general model of functions that can be computed by unit resolution. We then showed that any filtering function reduces to three matching functions, which are functions with binary codomain ({yes,no} without loss of generality) that can either be computed by unit resolution in two different ways: (1) unit resolution detects an inconsistency when the output value is yes, (2) it fixes a predefined output variable to true when the output value is yes. The main result of this section is that without loss of generality, studying the expressive power of unit resolution can be reduced to studying the tractability and the complexity of computing matching functions with unit resolution. As a corollary, in the sequel of the paper, only propagatable matching functions will be considered."
    }, {
      "heading" : "4 Expressive power of propagators",
      "text" : "Using a complete truth assignment as input values, unit resolution has the same expressive power as Boolean circuits, because elementary gates can be directly translated into clauses. In this section, we will show that if some input variables are not fixed, the expression power of unit resolution fall down to the expression power of monotone Boolean circuits, i.e., circuits with only or / and gates."
    }, {
      "heading" : "4.1 Boolean circuits",
      "text" : "A Boolean circuit is a directed acyclic graph representing a Boolean formula. It is said to be monotone when it contains only and and or gates.\nIn the following, a Boolean circuit will be represented by a triplet 〈L,G,w〉, where L is a set of input labels, w is the output label, and G is a set of gates. A or gate (and gate, respectively) is denoted or(E, t) (and(E, t), respectively), where E is the set of input labels and t is the output label of the gate. A not gate is denoted not(q, t), where q is the input label of the gate and t is its output label.\nGiven a Boolean circuit C = 〈{e1, . . . , en}, G,w〉 and any x = (x1, . . . , xn) ∈ {0, 1} n, let C(x) denote the output value of C under the assumption that its input values are x1, . . . , xn. Formally, C(x) can be defined as val(w) such that for any 1 ≤ i ≤ n, val(ei) = xi, for any gate or(E, t) ∈ G, val(t) = ∨\ne∈E val(e), for any gate and(E, t) ∈ G, val(t) = ∧\ne∈E val(e), and for any gate not(q, t) ∈ G, val(t) = ¬val(q).\nFor convenience, an additional gate tie(q, t) will be used to connect two nodes q and t in such a way that val(t) = val(q).\nGiven any Boolean function f with domain D ⊆ {0, 1}n and codomain {0, 1}, any Boolean circuit C with n inputs is said to compute f if and only if for any x ∈ D, C(x) = f(x)."
    }, {
      "heading" : "4.2 Circuits computing propagatable functions",
      "text" : "Because the Boolean counterpart of any matching function is a Boolean function, it can be computed by a Boolean circuit. In this section, we will show that any matching function is propagatable if and only if its Boolean counterpart can be computed using a monotone circuit. Furthermore, we will establish a relationship between space complexity of propagatable matching functions and monotone circuit complexity.\nTheorem 7. For any matching function f , if there exists a monotone circuit with n gates, each of them with at most k inputs, which computes fB, then there exists a propagator with O(nk) clauses, which computes f .\nProof. Let us consider any matching function f with domain D ⊆ IV , V = {v1, . . . , vn}, and any monotone circuit Q = 〈L,G, uk〉 computing fB.\nWithout loss of generality, let us suppose that\n• the set of input labels of Q is L = {e1, . . . , e2n},\n• the set of the output labels of the gates of Q is {u1, . . . , uk}.\nLet τ be a function that maps the labels of Q to propositional literals such that \n\n τ(ei) = vi, 1 ≤ i ≤ n τ(ei) = vi−n, n+ 1 ≤ i ≤ 2n τ(ui) = vn+i, 1 ≤ i ≤ k − 1 τ(uk) = s\nFor any gate g = and({α1, . . . , αm}, t) ∈ G, let π(g) = (τ(α1) ∨ · · · ∨ τ(αm) ∨ τ(t)). For any gate g = or({α1, . . . , αm}, t) ∈ G, let π(g) = ∧m i=1 (τ(αi) ∨ τ(t)). Let φ = ∧\ng∈G\nπ(g).\nNow let us show by induction on the number k of gates in Q that the propagator P = 〈φ, V, s〉 computes f .\nThe property holds for k = 0 because if the circuit Q has no gate, the output label is one of the input labels ei or ei+n related to the input variable vi ∈ V . If the input label is ei then the propagator 〈{}, V, vi〉 computes f . If the input label is ei+n then the propagator 〈(vi ∨ s), V, s〉, where s is a new fresh variable, computes f .\nNow, let us suppose the the property holds for any circuit with less than k clauses, k > 0. Let Q = 〈L,G, u〉 be any k-gates monotone Boolean circuit which computes the Boolean counterpart fB of f with input variables {v1, . . . , vn}. Let g be the output gate of Q. Let α1, . . . , αm be the input labels of g. For any 1 ≤ i ≤ m, let Qi = 〈L,G\\{g}, αi〉. By induction hypothesis, each Qi computes the Boolean counterpart fBi of the matching function fi computed by the propagator Pi = 〈φ \\ π(g), V, τ(αi)〉.\nLet us consider two cases:\n1. The output gate of Q is g = and({α1, . . . , αm}, u).\nBecause of the nature of g, for any I ∈ IV , fB(I) = 1 if and only if for any 1 ≤ i ≤ m, fi(IB) = 1. Because of the nature of π(g), f(I) = yes if and only if for any 1 ≤ i ≤ m, τ(αi) ∈ U((φ\\π(g))|I ). Then f(I) = yes if and only if fB(IB) = 1.\n2. The output gate of Q is g = or({α1, . . . , αm}, u).\nBecause of the nature of g, for any I ∈ IV , fB(I) = 1 if and only there exists 1 ≤ i ≤ m, such as fi(IB) = 1. Because of the nature of π(g), f(I) = yes if and only if there exists 1 ≤ i ≤ m, such that τ(αi) ∈ U((φ \\ π(g))|I ). Then f(I) = yes if and only if fB(IB) = 1.\nExample 6. The circuit of the figure 1 can be translated into a cnf formula φ in the following way:\n- the gate and({e1, e2}, u1) produces the clause (v̄1 ∨ v̄2 ∨ v3);\n- the gate or({u1, e4}, u2) produces the clauses (v̄3 ∨ s) and (v2 ∨ s).\nThis circuit computes the Boolean counterpart fB of the function f computed by the propagator 〈φ, {v1, v2}, s〉.\nTheorem 8. For any matching function f , if there exists a propagator 〈φ, V, s〉 computing f , then there exists a monotone circuit with O(n2k) gates computing fB, where n is the number of variables and k the number of clauses in φ.\nProof. Let 〈φ, V, s〉 be a propagator computing a matching function f . Clearly, the propagator P = 〈ψ = reif(φ, V ), V, s+n+1〉 computes f too. According to Lemma 1 and Theorem 1, ψ can be decomposed as ψ0 ∧ ψ1 ∧ · · · ∧ ψn+1 such that\n• ψ0 contains the initialization clauses of rank 0 of the reified counterpart of φ,\n• ψ1 contains the initialization clauses of rank 1 as well as the injection clauses,\n• for any 2 ≤ i ≤ i, ψi contains both the propagation clauses and the deduction clauses of rank i.\nThe corresponding circuit Q will contain the following nodes:\n• two input nodes ⋄t and ⋄t̄ related to each input variable t ∈ V , with the convention that ⋄t = 1 if and only if t is assigned to true, and ⋄t̄ = 1 if and only if t is assigned to false;\n• one major node ⋄v related to any variable v ∈ var(ψ) that can be assigned to true by unit resolution, with the convention that ⋄v = 1 if and only if unit resolution fixes v to true;\n• some additional nodes, if applicable;\nMajor nodes and additional nodes can be constant, i.e. permanently assigned either to 0 or 1. The constant nodes are not explicitly represented in the circuit but are referenced in the sets U0 and U1, respectively.\nThe circuit Q consists of several layers Q1, . . . , Qn+1, where each Qi simulates the stage i of unit resolution on ψ|I for any I ∈ IV .\nAt the first step of the construction, U0 is initialized with the nodes ⋄v + 0 (⋄v − 0 , respectively) for any variable v ∈ var(φ) such that (v+0 ) ((v − 0 ), respectively) does not occur in ψ0, and U1 is initialized with the nodes ⋄v+0 (⋄v − 0 , respectively) for any variable v + 0 (v − 0 , respectively) such that the clause (v + 0 ) ((v−0 ), respectively) occurs in ψ0.\nEach of the next steps builds Qi in such a way that it simulates the effect of unit resolution applied to ψi. This is done as follows:\nFor each variable v of φ and for each variable u ∈ {v+i , v − i }, let C be the set of clauses of ψi containing u, simplified by removing the clauses containing a literal w̄ such that ⋄w ∈ U0 and removing any literal w̄ such that ⋄w ∈ U1 from the other clauses.\nIf the set C is empty, which means that unit resolution cannot fix u, then ⋄u is added to U0. If C contains a clause (u), which means that unit resolution will always fix u to true, then ⋄u is added to U1. If C contains only one clause (w̄∨u), meaning that u is fixed to true if and only if w is previously fixed to true, the connection tie(⋄w, ⋄u) is produced. If C contains only one clause with more than two literals like (w1 ∨ · · · ∨ wk ∨ u), meaning that u is fixed to true if and only if w1 and ... and wk are previously fixed to true, the gate and({⋄w1, · · · , ⋄wk}, ⋄u) is produced.\nIn the other cases, i.e., when there are several clauses which can allow unit resolution to fix u, an additional node αc is created for each clause c ∈ C. For any binary clause (w̄ ∨ u) ∈ C, the gate tie(⋄w,αc) is produced. For any other clause (w1 ∨ · · · ∨wk ∨ u), the gate and({⋄w1, · · · , ⋄wk}, αc) is produced. Then the gate or({αc, c ∈ C}, ⋄u) is produced, in such a way that val(⋄u) = 1 if and only if unit resolution fixes u to true.\nBecause each sub-circuit Qi simulates exactly the effect of unit resolution on the corresponding formula ψi, the value of the output node ⋄s + n+1 will reflect the value of the output variable s + n+1 after all propagation stages on ψ have been made. The number of gates in the circuit is linearly related to the number of clauses in the reified counterpart of φ, which is O(n2k).\nExample 7. Let us consider the propagator 〈 (a ∨ b ∨ c), {a, b}, c 〉 . At the first stage of the construction, U0 = {⋄c + 0 , ⋄c − 0 }, and U1 = {} because ψ0 is empty. The input nodes of the circuit are ⋄a, ⋄a, ⋄b, and ⋄b. The first layer of the circuit is based on:\nψ1 =\ninjection clauses ︷ ︸︸ ︷ (a ∨ a+1 ) ∧ (a ∨ a − 1 ) ∧ (b ∨ b + 1 ) ∧ (b ∨ b − 1 )\nIt consists in the connections tie(⋄a, ⋄a+1 ), tie(⋄a, ⋄a − 1 ), tie(⋄b, ⋄b + 1 ), tie(⋄b, ⋄b − 1 ). The variables\n⋄c+1 and ⋄c − 1 are added to U0.\nThe second layer is based on:\nψ2 =\npropagation clauses ︷ ︸︸ ︷ (a+1 ∨ a + 2 ) ∧ (a − 1 ∨ a − 2 ) ∧ (b + 1 ∨ b + 2 ) ∧ (b − 1 ∨ b − 2 ) ∧ (c + 1 ∨ c + 2 ) ∧ (c − 1 ∨ c − 2 )∧\ndeduction clauses ︷ ︸︸ ︷ (a−1 ∨ b + 1 ∨ c + 2 ) ∧ (a − 1 ∨ c − 1 ∨ b − 2 ) ∧ (b + 1 ∨ c − 1 ∨ a + 2 )\nThe two last propagation clauses and the two last deduction clauses are ignored because ⋄c+1 and ⋄c−1 are in U0. The four first propagation clauses are translated into tie(⋄a + 1 , ⋄a + 2 ), tie(⋄a − 1 , ⋄a − 2 ), tie(⋄b+1 , ⋄b + 2 ), tie(⋄b − 1 , ⋄b − 2 ). The first deduction clause is translated into the gate and({a − 1 , b + 1 }, c + 2 ). c−2 is added to U0. The third layer is based on:\nψ3 =\npropagation clauses ︷ ︸︸ ︷ (a+2 ∨ a + 3 ) ∧ (a − 2 ∨ a − 3 ) ∧ (b + 2 ∨ b + 3 ) ∧ (b − 2 ∨ b − 3 ) ∧ (c + 2 ∨ c + 3 ) ∧ (c − 2 ∨ c − 3 )∧\ndeduction clauses ︷ ︸︸ ︷ (a−2 ∨ b + 2 ∨ c + 3 ) ∧ (a − 2 ∨ c − 2 ∨ b − 3 ) ∧ (b + 2 ∨ c − 2 ∨ a + 3 )\nThe propagation clause (c+2 ∨c + 3 ) is translated into the connection tie(⋄c + 2 , α1), the deduction clause\n(a−2 ∨ b + 2 ∨ c + 3 ) is translated into the gate and({a − 2 , b + 2 }, α2), and the clause or({α1, α2}, ⋄c + 3 ) is added, in such a way that ⋄c+3 is set to 1 either if ⋄c + 2 is set to 1 or if both ⋄a − 2 and ⋄b + 2 are set to 1, i.e., if at stage 2 of unit resolution, either c is fixed to true or a and b are fixed to false and true, respectively... A part of the corresponding circuit is given Figure 2. (Recall that this circuit is obtained from a reified formula, which, as mentioned above, presents some redundancies.)\nTheorem 9. Let f be any matching function with domain D. f is propagatable if and only if it is monotone.\nProof. Recall that any Boolean function h with domain Dh is said to be monotone if for any z, t ∈ Dh, if z ≤B t then h(z) ≤B h(t), where the ordering relation ≤B is defined as follows: 0 ≤B 1, 0 ≤B 0, 1 ≤B 1, (z1, . . . zn) ≤B (t1, . . . tn) if and only if zi ≤B ti, 1 ≤ i ≤ n.\nNow, given any matching function f with domain D, because for any I, J ∈ D, I ⊆ J if and only if IB ≤B JB, fB is monotone on DB if and only if f is monotone on D.\nLet f be any monotone matching function with domain D. Because fB is monotone, it can be computed by a monotone circuit. It follows from Theorem 7 that f is propagatable.\nNow let us consider any propagatable matching function f with domain D. It follows from Theorem 8 that fB can be computed by a monotone circuit, which implies that fB is monotone. Then f is monotone.\nTheorem 10. Any family F of propagatable functions is propagatable in polynomial space if and only if the family of the Boolean counterparts of F has polynomial space monotone circuit complexity, i.e., these functions can be calculated by monotone circuits with a polynomial number of gates.\nProof. The proof of theorem 7 shows how to create a propagator from a monotone circuit. Each and gate with n inputs is translated into one n-ary clause, and each or gate with n inputs is translated into n binary clauses.\nThe proof of theorem 8 shows how to create a monotone circuit from a propagator P = 〈φ, V, s〉. This circuit is based on the reified counterpart ψ of the formula φ. Each clause of ψ with n literals is involved in at most n and gates, and each literal is involved in at most one or gate."
    }, {
      "heading" : "5 Synthesis and perspectives",
      "text" : "Altogether, the results given in this paper provide important information about the expressive power of unit resolution. In particular, we can show that there exist polynomial time complexity propagatable functions that admit only propagators with an exponential number of clauses.\nAs an example, let us consider the Boolean functions pm(n), like perfect matching, such that for any n-bits Boolean encoding g of a graph G, pm(n)(g) = 1 if and only if there exists a perfect matching for G, that is a set of edges that covers each vertex exactly once.\nNext, let us consider the variants vpm(n) such that\n• the domain Dvpm(n) of vpm (n) is the set {(x1, . . . , xn, 0, . . . , 0), (x1, . . . , xn) ∈ Dpm(n)}, where\nDpm(n) is the domain of pm (n),\n• for any b = (x1, . . . , xn, 0, . . . , 0) ∈ Dvpm(n) , vpm (n)(b) = 1 if and only if pm(n)(x1, . . . , xn) = 1.\nNow, let fpm(n) denote the matching functions related to vpm(n). It is known that pm(n), then vpm(n), have polynomial time computational complexity but exponential monotone circuit complexity [15]. It follows from theorem 8 that fpm(n) are filtering functions requiring an exponential number of clauses to be computed using unit resolution.\nThis means that although unit resolution has the same expression power as Boolean circuits regarding Boolean functions, it has a lower expression power, namely the expression power of monotone circuits, regarding filtering functions.\nThis is both very interesting and annoying, because in sat solvers unit propagation operates on filtering functions rather than Boolean functions. Maybe this potential weakness of unit resolution can be compensated for by other speed-up technologies. As a research perspective, this has to be verified. Meanwhile, in the field of encoding constraints into cnf, it would be very relevant to determine which problems can be solved as efficiently using a simple sat solver, under cnf encoding, as using a dedicated constraint solver maintaining generalized arc consistency. This supposes knowing the complexity of the related filtering functions regarding unit resolution.\nAt least two research directions follow from the ideas presented in this paper. The first one is to characterize the expression power of some other speed-up techniques used in modern sat solvers, like clause learning. The second one consists in the research of deduction techniques that can polynomially compute any cnf encoded polynomial time complexity filtering functions."
    } ],
    "references" : [ {
      "title" : "GAC via unit propagation",
      "author" : [ "Fahiem Bacchus" ],
      "venue" : "Notes in Computer Science,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2007
    }, {
      "title" : "Efficient cnf encoding of boolean cardinality constraints",
      "author" : [ "Olivier Bailleux", "Yacine Boufkhad" ],
      "venue" : "In Proceedings of the 9th International Conference on Principles and Practice of Constraint Programming",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2003
    }, {
      "title" : "A translation of pseudo boolean constraints to sat",
      "author" : [ "Olivier Bailleux", "Yacine Boufkhad", "Olivier Roussel" ],
      "venue" : "Journal on Satisfiability, Boolean Modeling and Computation,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2006
    }, {
      "title" : "New encodings of pseudo-boolean constraints into cnf",
      "author" : [ "Olivier Bailleux", "Yacine Boufkhad", "Olivier Roussel" ],
      "venue" : "In Theory and Applications of Satisfiability Testing - SAT 2009 (SAT’09),",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2009
    }, {
      "title" : "An extensible sat-solver",
      "author" : [ "Niklas Eén", "Niklas Soörensson" ],
      "venue" : "In Proceedings of SAT",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2003
    }, {
      "title" : "Arc consistency in sat",
      "author" : [ "Ian P. Gent" ],
      "venue" : "In Proceedings of ECAI 2002,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2002
    }, {
      "title" : "Berkmin: A fast and robust sat solver",
      "author" : [ "E. Goldberg", "Y. Novikov" ],
      "venue" : "In Proc. of DATE",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2002
    }, {
      "title" : "The monotone and planar circuit value problems are log space complete for p",
      "author" : [ "Leslie M. Goldschlager" ],
      "venue" : "SIGACT News,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 1977
    }, {
      "title" : "Unit refutations and horn sets",
      "author" : [ "L. Henschen", "L. Wos" ],
      "venue" : "J. ACM,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1974
    }, {
      "title" : "Complete problems for deterministic polynomial time",
      "author" : [ "Neil D. Jones", "William T. Laaser" ],
      "venue" : "Theoretical Computer Science,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1976
    }, {
      "title" : "Look-ahead versus look-back for satisfiability problems",
      "author" : [ "Chu Li", "Anbulagan" ],
      "venue" : null,
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 1997
    }, {
      "title" : "Towards robust cnf encodings of cardinality constraints",
      "author" : [ "Joao Marques-Silva", "Inês Lynce" ],
      "venue" : "In Proceedings of the 13th International Conference on Principles and Practice of Constraint Programming",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2007
    }, {
      "title" : "Chaff: Engineering an efficient sat solver",
      "author" : [ "M. Moskewicz", "C. Madigan", "Y. Zhao", "L. Zhang", "S. Malik" ],
      "venue" : "In 39th Design Automation Conference,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2001
    }, {
      "title" : "Towards an optimal cnf encoding of boolean cardinality constraints",
      "author" : [ "Carsten Sinz" ],
      "venue" : "In Proceedings of the 10th International Conference on Principles and Practice of Constraint Programming",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2005
    }, {
      "title" : "The gap between the monotone and non monotone circuit complexity is exponential",
      "author" : [ "E. Tardos" ],
      "venue" : null,
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 1988
    }, {
      "title" : "A linear-time transformation of linear inequalities into conjunctive normal form",
      "author" : [ "J.P. Warners" ],
      "venue" : "Information Processing Letters,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 1998
    } ],
    "referenceMentions" : [ {
      "referenceID" : 12,
      "context" : "Unit resolution is a key feature of state of the art sat solvers [13] [7] [5], where it speeds up the search for solutions and inconsistencies.",
      "startOffset" : 65,
      "endOffset" : 69
    }, {
      "referenceID" : 6,
      "context" : "Unit resolution is a key feature of state of the art sat solvers [13] [7] [5], where it speeds up the search for solutions and inconsistencies.",
      "startOffset" : 70,
      "endOffset" : 73
    }, {
      "referenceID" : 4,
      "context" : "Unit resolution is a key feature of state of the art sat solvers [13] [7] [5], where it speeds up the search for solutions and inconsistencies.",
      "startOffset" : 74,
      "endOffset" : 77
    }, {
      "referenceID" : 2,
      "context" : "For example, the cnf encoding for pseudo Boolean constraints proposed in [3] allows unit resolution to restore generalized arc consistency.",
      "startOffset" : 73,
      "endOffset" : 76
    }, {
      "referenceID" : 15,
      "context" : "This is not the case with the encoding proposed in [16], which does not allow unit resolution to deduce as much information as the former encoding does.",
      "startOffset" : 51,
      "endOffset" : 55
    }, {
      "referenceID" : 2,
      "context" : "As a manner of speaking, the expressive power of unit resolution is best exploited using the encoding proposed in [3], with notable consequences on the resolution time.",
      "startOffset" : 114,
      "endOffset" : 117
    }, {
      "referenceID" : 8,
      "context" : "For example, this property holds for the formulae containing only Horn clauses [9].",
      "startOffset" : 79,
      "endOffset" : 82
    }, {
      "referenceID" : 9,
      "context" : "This decision problem denoted unit is known to be p-complete, meaning that for any problem π with polynomial time complexity, there exists a log space reduction from π to unit [10].",
      "startOffset" : 176,
      "endOffset" : 180
    }, {
      "referenceID" : 7,
      "context" : "Circuit value and monotone circuit value, which consist to determine the output value of a Boolean circuit (monotone Boolean circuit, respectively), given its input values, are both p-complete too [8].",
      "startOffset" : 197,
      "endOffset" : 200
    }, {
      "referenceID" : 14,
      "context" : "In this context, circuit value and monotone circuit value have not the same expressive power for at least two reasons : (1) monotone circuits can only compute monotone Boolean functions, while any Boolean function can be computed using a general Boolean circuit, and (2) there exist monotone Boolean functions which can be computed by polynomially sized Boolean circuits, but requiring an exponential number of gates to be computed using monotone circuits [15].",
      "startOffset" : 456,
      "endOffset" : 460
    }, {
      "referenceID" : 5,
      "context" : "In [6], a cnf encoding for enumerative constraints is proposed, which allows unit propagation to make the same deductions on the resulting formula as restoring arc consistency on the initial constraints does.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 1,
      "context" : "It has been followed by various similar works on other kinds of constraints such as Boolean cardinality constraints [2] and pseudo-Boolean constraints [4], while in [1], a general way to construct such an encoding for any constraint is proposed.",
      "startOffset" : 116,
      "endOffset" : 119
    }, {
      "referenceID" : 3,
      "context" : "It has been followed by various similar works on other kinds of constraints such as Boolean cardinality constraints [2] and pseudo-Boolean constraints [4], while in [1], a general way to construct such an encoding for any constraint is proposed.",
      "startOffset" : 151,
      "endOffset" : 154
    }, {
      "referenceID" : 0,
      "context" : "It has been followed by various similar works on other kinds of constraints such as Boolean cardinality constraints [2] and pseudo-Boolean constraints [4], while in [1], a general way to construct such an encoding for any constraint is proposed.",
      "startOffset" : 165,
      "endOffset" : 168
    }, {
      "referenceID" : 10,
      "context" : "This is why some authors seek a trade-off between the size of the formulae and the inference power of unit resolution and other deduction rules implemented in sat solvers, such as the failed literal rule [11].",
      "startOffset" : 204,
      "endOffset" : 208
    }, {
      "referenceID" : 13,
      "context" : "For example, this approach is developed in [14] and [12] in the context of Boolean cardinality constraints.",
      "startOffset" : 43,
      "endOffset" : 47
    }, {
      "referenceID" : 11,
      "context" : "For example, this approach is developed in [14] and [12] in the context of Boolean cardinality constraints.",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 10,
      "context" : "As an interesting corollary of Theorem 1, the failed literal rule [11], which is a speed up technique implemented in some modern sat solver, can be simulated by unit propagation.",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 14,
      "context" : "It is known that pm(n), then vpm(n), have polynomial time computational complexity but exponential monotone circuit complexity [15].",
      "startOffset" : 127,
      "endOffset" : 131
    } ],
    "year" : 2013,
    "abstractText" : "This preliminary report addresses the expressive power of unit resolution regarding input data encoded with partial truth assignments of propositional variables. A characterization of the functions that are computable in this way, which we propose to call propagatable functions, is given. By establishing that propagatable functions can also be computed using monotone circuits, we show that there exist polynomial time complexity propagable functions requiring an exponential amount of clauses to be computed using unit resolution. These results shed new light on studying cnf encodings of np-complete problems in order to solve them using propositional satisfiability algorithms. A paper is being drafted, which aims to present the concepts introduced in the present report and the underlying scientific issues in a more simple way.",
    "creator" : "LaTeX with hyperref package"
  }
}