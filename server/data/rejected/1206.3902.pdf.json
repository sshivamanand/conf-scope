{
  "name" : "1206.3902.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "On the Complexity of Existential Positive Queries",
    "authors" : [ "Hubie Chen" ],
    "emails" : [ "hubie.chen@upf.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n20 6.\n39 02\nv2 [\ncs .L\nO ]\n5 J\nul 2\n01 2"
    }, {
      "heading" : "1 Introduction",
      "text" : "Background. Model checking, the computational problem of deciding if a logical sentence holds on a structure, is a fundamental task that is ubiquitous throughout computer science. Witness its appearance in areas such as logic, artificial intelligence, database theory, constraint satisfaction, and computational complexity. It is well-known to be intractable in general: for first-order logic on finite structures it is PSPACE-complete. Indeed, the natural bottom-up algorithm for evaluating a first-order sentence φ on a finite structure B can require time |B|m(φ), where |B| is the size of the universe of B, and m(φ) denotes the maximum number of free variables over subformulas of φ. This general intractability, coupled with the natural exponential dependence on the sentence, prompts the pursuit of restricted classes of sentences on which model checking is tractable.\nCertainly, one can pursue such tractable fragments with respect to the classical and wellestablished notion of polynomial-time tractability. However, as has been articulated in the literature, the typical situation in practical database settings is the evaluation of a short query against a large database, or, in logical parlance, evaluating a short formula on a large relational structure (see for example the discussion of Grohe, Schwentick, and Segoufin [14]). This suggests that one might relax the definition of polynomial-time tractability by requiring the running time to exhibit a polynomial dependence solely on the database, and allowing arbitrary dependence on the formula. Relaxing polynomial-time tractability so that arbitrary dependence in some parameter is tolerated yields, in essence, the notion of fixed-parameter tractability. This notion is the base tractability notion of parameterized complexity theory, an alternative framework for classifying the complexity of problems.\nWithin relational first-order logic, there is currently a mature understanding of model checking on primitive positive logic, which consists of the first-order formulas built from atoms, conjunction, and existential quantification. Let F be a set of primitive positive sentences having bounded arity, by which is meant that there is a constant upper bounding the arity of all relation symbols appearing in the sentences. It is known that model checking on F is tractable, for either of the tractability notions discussed, if and only if there exists a constant k ≥ 1 such that each sentence\nF is logically equivalent to a sentence using k (or fewer) variables. This result is due to Dalmau, Kolaitis, and Vardi [9] and Grohe [13], and is proved under typical complexity-theoretic assumptions. This tractability condition is clearly related to and can be viewed as an extension of Vardi’s classic observation [22] on the tractability of bounded-variable first-order logic: for each k ≥ 1, model checking on first-order logic limited to k variables is polynomial-time tractable, via the natural bottom-up evaluation algorithm. Note that there are many possible ways to represent the relations of structures; in the case of bounded arity, reasonable representations will be equivalent, but when the arity is unbounded, the complexity of a sentence set may be sensitive to the representation used. (See Chen and Grohe [8] and Marx [20,19] for work on model checking primitive positive sentences having unbounded arity, with respect to various representations.)\nIn this article, we study the complexity of model checking in existential positive logic, by which we mean the extension of primitive positive logic where disjunction is permitted: a formula is existential positive if it is built from atoms, conjunction, disjunction, and existential quantification. This is a natural restriction of first-order logic which is/has been of primary interest in a number of studies. For instance, it is reported by Abiteboul, Hull, and Vianu [1] that so-called unions of conjunctive queries, also known as select-project-join-union queries, are the most common queries to databases; these queries are semantically equivalent to existential positive formulas. Also, existential positive logic has been the subject of focused investigation in finite model theory in connection with understanding the status of the homomorphism preservation theorem on (classes of) finite structures; see for example [4,21] and the references therein. To the best of our knowledge, there has not previously been any systematic study of the complexity of model checking fragments of existential positive logic; this state of affairs is surprising, given the level of attention that this logic has received in other settings. We here aim to remedy this gap in the literature.\nOverview of results. We now turn to give an overview of our results; the reader is advised to refer to the technical sections of the paper for precise statements. First, we identify the notion of a usable representation of structures; this notion requires some very mild assumptions to hold on the representation. We show that, relative to a fixed usable representation of structures, a classification of the sets of existential positive sentences that are fixed-parameter tractable can be derived from a classification of the sets of primitive positive sentences that are fixed-parameter tractable (Theorem 9). In essence, for each usable representation, we reduce the classification of fixed-parameter tractable fragments of existential positive logic to the corresponding classification for primitive positive logic. This allows us to deduce a classification in the case of bounded arity, whose statement is virtually identical to the corresponding statement for primitive positive logic: let F be a set of existential positive sentences having bounded arity; model checking on F is fixed-parameter tractable if and only if there exists a constant k ≥ 1 such that each sentence in F is logically equivalent to a k-variable sentence (Theorem 10 and Proposition 11). As before, this is under typical complexity-theoretic assumptions, and one can again appreciate the reminiscence of Vardi’s observation.\nHaving obtained a description of the fixed-parameter tractable sentence sets, under bounded arity, we then study sentence sets using the lens of classical complexity. (For ease of discussion, let us assume here and in the rest of this introduction that sentence refers to an existential positive sentence.) We show that there are fixed-parameter tractable sentence sets that are NP-complete; in particular, we show NP-completeness for the set of sentences that are logically equivalent to 2-variable sentences (Proposition 12). We thus observe a divergence between fixedparameter tractability and polynomial-time tractability that does not occur in primitive positive logic.\nFor a sentence set witnessing this divergence, that is, a sentence set F that is fixed-parameter tractable but NP-complete, each sentence therein has a logically equivalent, bounded-variable sentence, but this equivalent sentence must be in general hard to compute; for, if it was easily (polynomial-time) computable, model checking on F would be in polynomial time by Vardi’s observation–a contradiction! It is worthwhile to diagnose this situation by investigating why the equivalent bounded-variable sentences are hard to compute, given their computational usefulness and their potential as a target format in which to preprocess queries. We carry out such a diagnosis\nand demonstrate that, with respect to various signatures, two dramatically different reasons can underlie the divergence (Theorem 14 and Corollary 15).\n– On a signature consisting of finitely many unary relation symbols, we show that each sentence has an equivalent bounded-variable sentence of constant length. – On all other signatures, we prove that there exists a sentence set F (witnessing the divergence) such that there is no translation from a sentence in F to an equivalent bounded-variable sentence of polynomial length. That is, there is no way to preprocess the F -sentences into bounded-variable sentences without increasing their length superpolynomially.\nIntuitively speaking, in the first case, short bounded-variable sentences exist, but they are difficult to compute; in the second case, short (polynomial-length) bounded-variable sentences do not exist, so there is no sense in even asking about computing them in polynomial time. The latter result is proved in a general form that implies that there is no polynomial-length translation to any format that allows for polynomial-time query evaluation (see the statement of Theorem 14), and gives a formal limit on the extent to which the original sentences can be preprocessed/compiled. This result is proved by using notions and techniques from the theory of compilability developed by Cadoli et al. [5], and is proved under the assumption that the polynomial hierarchy does not collapse. Although this result is proved under a complexity-theoretic assumption, we believe that it constitutes an interesting formula size lower bound and can be taken as a contribution to the literature on formula size lower bounds (see for example [3,12]).\nOur study thus yields a fundamental understanding of the complexity of model checking existential positive logic. We make a methodological contribution by employing the theory of compilability to link classical complexity with parameterized complexity, in particular, to gain an understanding of the sentence sets that are simultaneously fixed-parameter tractable and NP-complete; this linking could be of independent interest and of utility for analyzing other computational problems. Overall, the tools, concepts, and results of our work set the stage for the future consideration of the complexity of model checking on more expressive logics."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "Structures. In this paper, we consider only relational structures. A signature is a set of relation symbols ; each relation symbol has associated to it a finite arity k ≥ 1. A relation symbol of arity 1 is said to be unary. A structure B over a signature σ consists of a universe B, which is a non-empty set denoted with the letter of its structure in non-bold typeface, and a relation RB ⊆ Bk for each relation symbol R; here, k denotes the arity of R.\nA collection of structures is said to be similar if they share the same signature. Let A,B be similar structures on the signature σ. A homomorphism from A to B is a mapping h : A → B such that for each symbol R ∈ σ, it holds that h(RA) ⊆ RB, by which is meant that for each tuple (a1, . . . , ak) ∈ RA, one has (h(a1), . . . , h(ak)) ∈ RB. We will sometimes simply write A → B to indicate that there exists a homomorphism from A to B. We say that A and B are homomorphically equivalent if A → B and B → A both hold. The structure B is a substructure of the structure A if B ⊆ A and RB ⊆ RA for all relation symbols R. When B is a substructure of A, there exists a homomorphism h from A to B, and h fixes each element b ∈ B, the mapping h is said to be a retraction from A to B; when there exists a retraction from A to B, it is said that A retracts to B. A core of the structure A is a structure C such that A retracts to C, but A does not retract to any proper substructure of C. We will make use of the following wellknown facts on cores [15]: (1) each finite structure has a core; (2) all cores of a finite structure are isomorphic. From these facts, it is reasonable to speak of the core of a finite structure, which we do, and we use core(A) to denote a representative from the set of all cores of a finite structure A. The product of A and B, denoted by A×B, is the structure with universe A× B and where RA×B = {((a1, b1), . . . , (ak, bk)) | (a1, . . . , ak) ∈ RA, (b1, . . . , bk) ∈ RB} for each symbol R. We will make use of the following well-known fact concerning products.\nProposition 1. Let A, B, and B′ be similar structures. There are homomorphisms A → B and A → B′ if and only if there is a homomorphism A → B×B′.\nFormulas. In this paper, we study relational first-order logic and fragments thereof. An atom (over signature σ) is an equality of variables x = y or a predicate application R(x1, . . . , xk), where R ∈ σ and R has arity k. A formula (over signature σ) is built from atoms (over σ), negation, conjunction, disjunction, existential quantification, and universal quantification. An existential positive formula is a formula built from atoms, conjunction, disjunction, and existential quantification. A primitive positive formula is a formula built from atoms, conjunction, and existential quantification. We use FO to denote the set of all first-order formulas, EP to denote the set of all existential positive formulas, PP to denote the set of all primitive positive formulas, and ∨ PP to denote the set of all formulas that are disjunctions of primitive positive formulas. For each k ≥ 1, we use FOk to denote the subset of FO containing formulas that use k (or fewer) variables, and we define EPk, PPk, and ( ∨ PP)k analogously. For a signature σ, we add a σ subscript to the notation for a set of formulas to indicate a restriction to those formulas over σ; for instance, FOkσ denotes the formulas in FOk that are over signature σ. A sentence is a formula having no free variables.\nEach structure A naturally induces a primitive positive sentence: letting {a1, . . . , an} denote the elements of A, we define the sentence Q[A], called the canonical query of A, to be\n∃a1 . . . ∃an ∧\nR∈σ\n∧\n(a1,...,ak)∈RA\nR(a1, . . . , ak).\n(Note that if the quantifier-free part is empty, one can insert an equality a = a for some a ∈ A to make it non-empty.) We have the following classical theorem.\nTheorem 2. (Chandra-Merlin [6]) Let A,B be similar finite structures. The following are equivalent:\n– There is a homomorphism A → B. – B |= Q[A]. – Q[B] |= Q[A].\nOne can also naturally pass from a primitive positive sentence to a structure, as follows. Convert the primitive positive sentence ψ to prenex normal form. Then, eliminate equalities as follows: an equality a = a on a single variable is simply removed; for an equality a = a′ on distinct variables, replace all instances of a′ with a in the quantifier-free part, and then follow the removal process for an equality on a single variable. Define C[ψ] to be the structure having a universe element for each existentially quantified variable in the resulting object, and where, for each R ∈ σ, the relation RC[ψ] contains (a1, . . . , ak) if and only if R(a1, . . . , ak) appears in the quantifier-free part of the resulting object. It is straightforward to verify that each any primitive positive sentence ψ is logically equivalent to Q[C[ψ]], although these sentences may be syntactically different, due to the elimination of equalities in the just-described conversion. Similarly, it can be verified that each finite structure A is homomorphically equivalent to C[Q[A]]. One can then derive consequences of Theorem 2 such as that for any primitive positive sentence ψ and any structure B, the condition B |= ψ is equivalent to the condition C[ψ] → B. We will make use of such consequences.\nWe have the following basic proposition on existential positive sentences.\nProposition 3. There exists a computable mapping M that associates, to each existential positive sentence φ, a non-empty finite set M(φ) of primitive positive sentences such that the following properties hold.\n– The sentence φ is logically equivalent to the sentence ∨ ψ∈M(φ) ψ. – For any two distinct sentences ψ, ψ′ ∈M(φ), it holds that ψ 6|= ψ′.\nProof. We describe the action ofM . First, the sentence φ is converted to a disjunction φ′ of primitive positive sentences by induction, via the syntactic transformations ∃x( ∨ i αi) ❀ ∨ i(∃xαi) and\n( ∨ i αi) ∧ ( ∨ j βj) ❀ ∨ i,j(αi ∧ βj). We define an equivalence relation on primitive positive sentences appearing in φ′ (as disjuncts): two such sentences α, β are equivalent if and only if they are logically equivalent. Note that this equivalence relation can be computed, since by Theorem 2 and\nthe surrounding discussion, α, β are logically equivalent if and only if C[α] and C[β] are homomorphically equivalent; the latter condition is clearly computable. Let us say that an equivalence class F is extremal if when α ∈ F and β is a primitive positive sentence in φ′, it holds that α |= β implies β ∈ F . Again, by Theorem 2, it can be computed if an equivalence class is extremal. Define M(φ) to be a set that contains one representative from each extremal equivalence class. It is straightforward to verify that M(φ) has the desired properties. ⊓⊔\nTreewidth. A tree decomposition of a structure B is a pair (T, β) consisting of a tree T and a map β : V T → ℘(B) that associates each vertex t of T with a non-empty subset β(t) of B, called the bag of t, such that the following conditions hold:\n– For each b ∈ B, the vertices {t | b ∈ β(t)} form a connected subtree of T . – For each tuple (b1, . . . , bk) appearing in a relation of B, there exists a vertex t ∈ V T such that\n{b1, . . . , bk} ⊆ β(t).\nThe width of a tree decomposition (T, β) is defined as (maxt∈V T |β(t)|) − 1. The treewidth of a structure B, denoted by tw(B), is the minimum width over all tree decompositions of B. We have the following theorem relating the treewidth of a structure to bounded-variable primitive positive logic.\nTheorem 4. (follows from [9, Theorem 12]) Let A be a structure, and let k ≥ 1. The following are equivalent:\n– It holds that tw(core(A)) < k. – The primitive positive sentence Q[A] is logically equivalent to a sentence in PPk.\nParameterized complexity. We overview the elements of parameterized complexity that will be used in the paper, and refer the reader to the book by Flum and Grohe [10] for more information.\nThroughout the paper, we use Σ to denote an alphabet used to encode objects. A parameterization is a polynomial-time computable mapping κ that maps each string x ∈ Σ∗ to a parameter κ(x). A parameterized problem is a pair (Q, κ) consisting of a decision problem Q ⊆ Σ∗ and a parameterization κ.\nA mapping g defined on Σ∗ is said to be non-uniformly fixed-parameter tractable (nuFPT) with respect to a parameterization κ if there exist a function f and a polynomial p (both over the natural numbers) such that for every parameter k, there exists an algorithm Ak that computes g on {x ∈ Σ∗ | κ(x) = k} in time bounded above by f(κ(x))p(|x|). A mapping g defined on Σ∗ is said to be fixed-parameter tractable (FPT) with respect to a parameterization κ if there exists a single algorithm A that can, for every k, play the role of Ak in the definition of nuFPT. A decision problem (Q, κ) is in nuFPT if the characteristic function of Q is nuFPT with respect to κ, and is in FPT if the characteristic function of Q is FPT with respect to κ.\nLet (Q, κ), (Q′, κ′) be parameterized problems. An nuFPT (respectively, FPT) reduction from (Q, κ) to (Q′, κ′) is an nuFPT (respectively, FPT) mapping g such that (1) for all x ∈ Σ∗, it holds that x ∈ Q if and only if g(x) ∈ Q′, and (2) for each k, the set κ′(g({x | κ(x) = k})) is finite. A FPT Turing reduction from (Q, κ) to (Q′, κ′) is an FPT mapping g that can pose oracle queries to Q′ such that (1) g computes the characteristic function of Q, and (2) for each k, the set κ′(O({x | κ(x) = k})) is finite, where O(x) denotes the set of oracle queries to Q′ made by g on input x.\nWe will make use of the following facts.\nProposition 5. The composition of an nuFPT reduction from (Q, κ) to (Q′, κ′) and an nuFPT reduction from (Q′, κ′) to (Q′′, κ′′) is an nuFPT reduction from (Q, κ) to (Q′′, κ′′).\nProposition 6. The class FPT is closed under FPT Turing reductions.\nThe parameterized complexity class W[1] is often said to be the analog of NP in the world of parameterized complexity, and it is widely believed that W[1] is not contained in FPT.\nComputational problems. In this paper, we study model checking problems, which involve deciding if a sentence is true on a structure. There are different ways that structures can be represented, in particular, there are different ways that their relations can be represented, and the representation used can impact the complexity of model checking [8]. We will show a classification result that holds on a wide class of representations. Formally, by a representation, we mean a map r from Σ∗ to the class of finite structures. One representation that we will study is the explicit representation, where a relation is represented by an explicit listing of the tuples that it contains; we refer the reader to [11] for a discussion of such a representation. Note that when the arity is bounded, reasonable representations will be equivalent under polynomial-time translations to the explicit representation, and hence also to each other.\nLet r be a representation, and let F be a set of formulas. We define EP-MCr(F) to be the problem of deciding, given a pair (φ, x) consisting of an existential positive sentence φ ∈ F and a string x representing a finite structure r(x) = B over the signature of φ, whether or not B |= φ. (Note that when we discuss a problem of the form EP-MCr(F), typically, all formulas in F will be existential positive.) The problem PP-MCr(F) is defined similarly, but with respect to the primitive positive sentences in F . Finally, the problem FO-MCr(F) is defined with respect to all sentences in F . Omission of the r subscript, for example, the notation EP-MC(F), denotes the respective problem under the explicit representation. We will sometimes view these problems as parameterized problems; such viewing is always respect to the parameterization κ(φ, x) = φ.\nWe have the following previous results on the complexity of the problems PP-MC(F).\nTheorem 7. (Dalmau, Kolaitis, and Vardi [9]) Let F be a set of primitive positive sentences such that the set of structures {core(C[ψ]) | ψ ∈ F} has bounded treewidth. Then, the problem PP-MC(F) is polynomial-time decidable, and hence fixed-parameter tractable.\nTheorem 8. (Grohe [13]) Let F be a set of primitive positive sentences having bounded arity such that the set of structures {core(C[ψ]) | ψ ∈ F} has unbounded treewidth. Then, the problem PP-MC(F) is W[1]-hard under nuFPT reductions."
    }, {
      "heading" : "3 Parameterized Complexity Classification",
      "text" : "In this section, we give a general theorem that, with respect to certain representations, allows one to derive a parameterized complexity classification of the problems EP-MCr(F) from a corresponding classification of the problems PP-MCr(F). This general theorem will be established under mild assumptions on the representation, formalized by the following definition. We say that a representation r is usable if the following two conditions hold.\n– There exists a computable mapping t : Σ∗ → Σ∗ where for each string x ∈ Σ∗ representing a structure A in the explicit representation, the string t(x) represents A under r, that is, r(t(x)) = A. – There exists a mapping p : Σ∗ × Σ∗ → Σ∗ that is FPT with respect to the parameterization π1(x, y) = x such that for all strings x, y ∈ Σ∗, it holds that the structure r(p(x, y)) is equal to the product structure r(x) × r(y).\nThe first condition posits the existence of a translation from the explicit representation to the representation r, and the second condition asserts the existence of a product mapping that maps two input strings to a string that represents the product of the structures represented by the input strings. It is straightforward to verify that the explicit representation is usable; we now turn to look at another example representation.\nExample 1. Previous work [8] studied a representation of relations called the generalized DNF (GDNF) representation. A GDNF representation of a relation T ⊆ Bk is an expression of the form ⋃m i=1(Pi1 × · · · × Pik) where each Pij is a subset of B. This representation is readily seen to be a natural generalization of the DNF representation of relations on the Boolean domain. We let g denote the representation of structures where relations are presented in GDNF form.\nWe briefly verify that the representation g is usable. A relation {(b11, . . . , b1k), . . . , (bm1, . . . , bmk)} presented in the explicit representation can be readily translated to the GDNF representation⋃m i=1({bi1}× · · · × {bik}). Given two relations ⋃m i=1(Pi1 × · · · ×Pik), ⋃n j=1(Qj1 × · · · ×Qjk) in the GDNF representation, their product is equal to the relation represented by\nm⋃\ni=1\nn⋃\nj=1\n((Pi1 ×Qj1)× · · · × (Pik ×Qjk)).\nThis GDNF representation of the product can be computed in time polynomial in the sum of the two input representations’ lengths, and hence computing this product has the desired FPT property. (One can note, indeed, that when the first input relation is fixed, the product representation has length linear in the length of the second input relation’s representation.)\nIt is known that, for a set F of primitive positive sentences, the problem PP-MCg(F) is FPT if the structures corresponding to F (that is, the set of structuresC[F ]) have bounded incidence width modulo homomorphic equivalence, and that this problem is W[1]-hard under nuFPT reductions otherwise. This follows from results in [8], to which we refer the reader for more details. This classification result, along with the theorem that follows, allows one to obtain a full FPT/W[1]hard classification of the problems having the form EP-MCg(F). ⊓⊔\nThe following is our parameterized complexity classification theorem; M denotes the mapping that is the subject of Proposition 3.\nTheorem 9. Let r be a representation. For each set F of existential positive sentences, the set F ′ = ⋃ φ∈F M(φ) of primitive positive sentences has the following properties.\n– The problem EP-MCr(F) FPT Turing reduces to the problem PP-MCr(F ′). – The problem PP-MCr(F ′) nuFPT reduces to the problem EP-MCr(F), under the assumption\nthat r is usable.\nProof. For the first property, we make use of Proposition 3. The FPT Turing reduction, given an instance of EP-MCr(F) representing the query B |= φ, computes M(φ), and then, for each ψ ∈M(φ), queries the problem PP-MCr(F ′) to determine if B |= ψ. The reduction answers yes if and only if one of the queries was answered yes.\nFor the second property, let ψ ∈ F ′; we define an algorithm Aψ as follows. Fix φ ∈ F such that ψ ∈ M(φ). Given an instance (ψ, x) where x represents B, the algorithm Aψ computes an instance (φ, y) where y representsC[ψ]×B. In particular, the string y is computed as p(t(C[ψ]), x), where the structure C[ψ] is passed to t in the explicit representation. By the definition of usable representation, the ensemble of algorithms {Aψ} is nuFPT.\nWe verify the correctness of the reduction as follows. We will make appeals to Chandra-Merlin, by which we mean Theorem 2 and the surrounding discussion. First, we claim that if ψ′ ∈ M(φ) and ψ′ 6= ψ, then C[ψ]×B 6|= ψ′. We prove this by contradiction; suppose that C[ψ]×B |= ψ′. By Chandra-Merlin, it follows that there is a homomorphism C[ψ′] → C[ψ]×B. From Proposition 1, it follows that there is a homomorphism C[ψ′] → C[ψ]; we obtain ψ |= ψ′ by Chandra-Merlin, which contradicts the description ofM(φ) (Proposition 3). We then have the following equivalences and justifications:\nC[ψ]×B |= φ⇔ C[ψ]×B |= ψ (just-established claim)\n⇔ C[ψ] → C[ψ]×B (Chandra-Merlin)\n⇔ C[ψ] → B (Proposition 1 and C[ψ] → C[ψ])\n⇔ B |= ψ (Chandra-Merlin)\nThe reduction is thus correct. ⊓⊔\nWe now look at the explicit representation under bounded arity. Let us define the tractability condition on a set F of existential positive sentences to be the condition that the set of structures\n⋃\nφ∈F\n{core(C[ψ]) | ψ ∈M(φ)}\nhas bounded treewidth. Under the assumption of bounded arity, the tractability condition is the sole explanation for fixed-parameter tractability; this is shown by the following theorem, which gives a comprehensive classification of the sentence sets F such that EP-MC(F) is fixed-parameter tractable.\nTheorem 10. Let F be a set of existential positive sentences. If F satisfies the tractability condition, then EP-MC(F) is fixed-parameter tractable; otherwise, under the assumption that F has bounded arity, EP-MC(F) is W[1]-hard under nuFPT reductions.\nProof. We make use of Theorem 9 to establish both complexity results; let F ′ be as defined there. For tractability, it suffices to show that PP-MC(F ′) is FPT. This follows from the definition of the tractability condition and Theorem 7. For the hardness result, if the tractability condition does not hold, we have W[1]-hardness of PP-MC(F ′) under nuFPT reductions by Theorem 8, and so the result follows from Theorem 9. ⊓⊔\nWe now observe that the tractability condition can be alternatively characterized as logical equivalence to bounded-variable sets of formulas.\nProposition 11. Let F be a set of existential positive sentences. The following are equivalent:\n(1) The set F satisfies the tractability condition. (2) There exists k ≥ 1 such that each sentence in F is logically equivalent to a sentence in ( ∨ PP)k. (3) There exists k ≥ 1 such that each sentence in F is logically equivalent to a sentence in EPk.\nProof. The equivalence between (1) and (2) follows from Theorem 4. The implication (2) → (3) is immediate. To establish the implication (3) → (2), consider the conversion from existential positive sentences to disjunctions of primitive positive sentences given in the proof of Proposition 3; the syntactic transformations given there do not change the set of variables used. ⊓⊔"
    }, {
      "heading" : "4 Compilability",
      "text" : "We saw that, in the setting of bounded arity, equivalence of a sentence set to a bounded-variable fragment of existential positive logic is both necessary and sufficient for fixed-parameter tractability (of the sentence set). For each k ≥ 1, we use ≈EPk to denote the set that contains an existential positive sentence if and only if it is logically equivalent to a sentence in EPk. That is, ≈EPk is the closure of EPk under logical equivalence within the set of all existential positive sentences. Using this notation, the tractability condition on a sentence set F is equivalent to the condition that there exists k ≥ 1 such that F is contained in ≈EPk (by Proposition 11).\nWhat about the classical notion of polynomial-time tractability?While polynomial-time tractability and fixed-parameter tractability coincide in primitive positive logic (Theorems 7 and 8), the picture is markedly different in existential positive logic. Let σ be a signature; we now present a result that shows that, other than a degenerate case where the signature consists of one unary symbol, model checking the fragment ≈EP2σ is NP-hard; this contrasts with the fixed-parameter tractability of ≈EP2σ.\nProposition 12. Let σ be a non-empty signature.\n– If σ consists of one unary symbol, then EP-MC(EPσ) is polynomial-time decidable. – Otherwise, EP-MC(≈EP2σ) is NP-complete.\nProof. Suppose that σ = {R} consists of one unary symbol. Let (φ,B) be an instance of EP-MC(EPσ). If RB is empty, then the sentence φ is clearly false on B. Suppose RB is non-empty. In this case, fix a value b ∈ RB; setting all existentially quantified variables to b makes each atom true, and hence makes the sentence φ true (on B). Deciding if φ is true on B can thus be carried out by checking if RB is non-empty.\nSuppose that σ contains at least two symbols, and let T and F be symbols in σ. We show NP-hardness by reducing from Boolean CNF satisfiability; suppose we are given an instance φ of this problem with variables v1, . . . , vn. Define B to be a structure with universe B = {0, 1} such that TB = {(1, . . . , 1)} and FB = {(0, . . . , 0)}. For each clause C of φ, we can define a conjunction of atoms C′ over σ that has the same satisfying assignments (over B). For instance, the clause C ≡ (v1 ∨ ¬v2 ∨ v4) can be translated to C\n′ ≡ T (v1, . . . , v1) ∨ F (v2, . . . , v2) ∨ T (v4, . . . , v4). The resulting instance of EP-MC(≈EP2) is (φ′,B) where φ′ = ∃v1 . . .∃vn ∧ C C\n′; here, the conjunction is over each clause C of φ. We verify that φ′ is contained in ≈EP1 (and hence ≈EP2), as follows. Convert φ′ to the disjunction of primitive positive sentences using the syntactic transformations given in the proof of Proposition 3. Each resulting primitive positive sentence can be viewed as having the form ∃v1 . . . ∃vn(γ1 ∧ . . . ∧ γn) where γi is the (possibly empty) conjunction of atoms using just the variable vi. Such a sentence is logically equivalent to (∃v1γ1)∧ · · · ∧ (∃vnγn), which in turn is logically equivalent to a 1-variable sentence under renaming of variables.\nThe remaining case is that σ contains one symbol S of arity k ≥ 2. In this case, we define B to be the structure with universe B = {0, 1} and SB = {(0, 1, . . . , 1)}, where (0, 1, . . . , 1) denotes the tuple with one entry of 0 followed by (k−1) entries of 1. We use the reduction of the previous proof, but use ∃xS(x, v, . . . , v) in place of T (v, . . . , v) and ∃xS(v, x, . . . , x) in place of F (v, . . . , v). It was argued that each sentence used in the previous-case proof is logically equivalent, via syntactic transformation, to a boolean combination of primitive positive sentences each using one variable. By applying the same syntactic transformations to each sentence used in the present reduction, each such sentence is seen to be a boolean combination of primitive positive sentences, each of which uses two variables. ⊓⊔\nThe hardness result of Proposition 12 can be sharply contrasted with the observation, due to Vardi [22], that model checking a bounded-variable fragment of first-order logic is polynomialtime tractable. Here, tractability is obtained via the natural bottom-up evaluation algorithm that computes the satisfying assignments of each subformula; observe that each subformula has at most |B|k satisfying assignments when the formula is k-variable and |B| is the size of the structure’s universe.\nProposition 13. (Vardi [22]) For each k ≥ 1, the natural evaluation algorithm decides FO-MC(FOk) in polynomial time.\nA side-by-side comparison of Proposition 12 with Proposition 13 points to an intriguing state of affairs. For k ≥ 2, model checking ≈EPk is NP-hard; yet, each sentence φ in ≈EPk is logically equivalent to a sentence φ′ in EPk, a fragment on which model checking is polynomial-time tractable. This implies that such a translation φ → φ′ cannot be performed in polynomial time, for if it could, performing the translation and then employing Vardi’s observation (Proposition 13) would place model checking of ≈EPk in polynomial time!\nWhy, then, is this translation not polynomial-time computable? We can distinguish between two potential explanations. The first is a computational complexity explanation: for each sentence φ ∈≈EPk, there exists an equivalent sentence φ′ ∈ EPk having length polynomial in φ. That is, short equivalent sentences exist, but they are difficult to compute.1 The second explanation, based on formula length, is that no short equivalent sentences exist, that is, there is no polynomial-length translation φ → φ′ from ≈EPk to EPk. The following theorem shows that, overwhelmingly, the second explanation is the valid one. In particular, the theorem shows that this second explanation based on high formula length holds for all signatures other than those having finitely many unary symbols; this is proved in a general setting that shows that there is no translation from ≈EPk to any format that allows for polynomial-time query evaluation.\nTo formalize the theorem, we make use of a framework that allows one to discuss and relate the compilability of various problems. The framework that we use comes from the work of Cadoli et al. [5]; here, we give a self-contained presentation using slightly different terminology and notions. Let Q ⊆ Σ∗ × Σ∗ and Q′ ⊆ Σ∗ × Σ∗ be decision problems consisting of pairs. We say that Q\n1 This is the situation in primitive positive logic; this can be inferred from Theorem 4 and results in [17].\ncompiles to Q′ via the compilation c : Σ∗ → Σ∗ if for all pairs (x, y) ∈ Σ∗, it holds that (x, y) ∈ Q if and only if (c(x), y) ∈ Q′. We say that a map c has constant length if there exists a constant d ≥ 1 such that for all x ∈ Σ∗, it holds that |c(x)| ≤ d; and, we say that c has polynomial length if there exists a polynomial p on the natural numbers such that for all x ∈ Σ∗, it holds that |c(x)| ≤ p(|x|). We say that Q constant-length compiles to Q′ if there exists a constant-length map c : Σ∗ → Σ∗ such that Q compiles to Q′ via c, and similarly we say that Q polynomial-length compiles to Q′ if there exists a polynomial-length map c : Σ∗ → Σ∗ such that Q compiles to Q′ via c.\nTheorem 14. Let σ be a non-empty signature.\n– If σ consists of finitely many unary symbols, then EP-MC(EPσ) is constant-length compilable to EP-MC(EP1σ). – Otherwise, there exists k ≥ 1 such that EP-MC(≈EPkσ) is not polynomial-length compilable to a polynomial-time decidable problem (assuming that the polynomial hierarchy does not collapse). In particular, this holds for k = 1 on a signature having infinitely many unary symbols, and for k = 6 on a signature having a symbol of arity 2 or greater.\nAs a corollary to this theorem, we obtain that, in the case of a non-compilable signature σ (that is, a signature falling into the second case of the theorem) and for the k given by the theorem, there is no equivalence-preserving translation from ≈EPk to any bounded-variable fragment FOm of first-order logic. This is formalized as follows.\nCorollary 15. Let σ be a signature that does not consist of finitely many unary symbols, and assume that the polynomial hierarchy does not collapse. There exists k ≥ 1 such that for all m ≥ 1, the following holds: there does not exist a polynomial-length mapping f that gives, for each sentence φ in ≈EPkσ, a logically equivalent sentence f(φ) in FO m σ . In particular, this holds for the values of k described in the statement of Theorem 14.\nProof. Let k be as in the statement of Theorem 14, and let m ≥ 1. By Proposition 13, the problem FO-MC(FOmσ ) is polynomial-time decidable. So by Theorem 14, EP-MC(≈EP k σ) is not polynomiallength compilable to FO-MC(FOmσ ). The corollary follows. ⊓⊔\nOur decision to investigate the compilability properties of existential positive logic was partially inspired by the interesting discussion of Adler and Weyer [2]. Let ≈FOk denote the set containing each first-order sentence that is logically equivalent to a sentence in FOk. Adler and Weyer conjecture [2, Conjecture 7.1] that a non-elementary length increase is necessary for translating a certain fragment of ≈FOk (defined in their article) to logically equivalent sentences in FOk. While their conjecture concerns elementary versus non-elementary growth, here we have shown (Theorem 14 and Corollary 15) a dichotomy between constant growth and exponential growth for translating ≈EPk.\nWe devote the rest of this section to proving Theorem 14. The bulk of the effort goes into establishing the following theorem. Recall that the Directed Hamiltonian Circuit problem is the problem of deciding, given a directed graph (assumed here to have n ≥ 2 vertices), whether or not it has a directed Hamiltonian circuit, by which is meant an ordering u0, . . . , un−1 of the vertices of the graph such that for all i ∈ {0, . . . , n − 1}, the pair (ui, u(i+1) mod n) is a directed edge. This problem is well-known to be NP-complete.\nTheorem 16. Let σ be a signature containing a relation symbol E of arity m ≥ 2. There exists a sequence {Hn}n≥2 of sentences in ≈EP 6 σ such that Directed Hamiltonian Circuit many-one polynomial-time reduces to EP-MC({Hn}n≥2) via a reduction that (for all n ≥ 2) sends a directed graph with n vertices to an instance using Hn.\nWe focus on establishing this theorem in the case of a binary symbol E, and will later indicate how this case yields the general case. For each n ≥ 0, let σn be the signature {E,L1, . . . , Ln} where E is a binary symbol and the Li are unary symbols. We will call a structure over σ0 = {E} a digraph, and a structure over σn a labelled digraph when n ≥ 1.\nLet B be a labelled digraph over σn. We define a digraph B ∗ from the labelled digraph B as\nfollows. For each b ∈ B, we define a gadget digraph Gb which has universe\nGb = {b s, bc, bd, bs1, bt1, bs2, bt2, . . . , bsn, btn, bt} ∪ {bui | b ∈ LBi } ∪ {b vi | b ∈ LBi }\nand edge relation\nEGb = {(bc, bs), (bc, bd), (bs, bd), (bd, bs1)} ∪ {(bsi, bti) | i ∈ {1, . . . , n}}∪\n{(bti, bs(i+1)) | i ∈ {1, . . . , n− 1}} ∪ {(btn, bt)} ∪ {(bui, bsi), (bvi, bti), (bvi, bui) | b ∈ LBi }.\nWe now define the digraph B∗. The universe of this structure is\nB∗ = ⋃\nb∈B\nGb,\nand the edge relation is\nEB ∗ = ( ⋃\nb∈B\nEGb) ∪ {(bt, b′s) | (b, b′) ∈ EB}.\nThe following lemma gives a key feature of this construction: it gives a translation from labelled digraphs to digraphs that strongly preserves the homomorphism relation.\nLemma 17. Let A,B be labelled digraphs over σn. There exists a homomorphism A → B if and only if there exists a homomorphism A∗ → B∗.\nProof. We first show the forward direction. Suppose that h : A → B is a homomorphism. We define a mapping h∗ : A∗ → B∗ as follows. For each a ∈ A, the mapping h∗ is defined so as to map Ga to Gh(a) in the natural way, that is, h\n∗(as) = h(a)s, h∗(ac) = h(a)c, and so forth. Note that if for some i it holds that aui, avi ∈ Ga, then by the assumption that h is a homomorphism A → B, it also holds that h(a)ui, h(a)vi ∈ Gh(a). It is straightforward to verify that, for each a ∈ A, one has h∗(EGa) ⊆ EGh(a) . Now consider an edge (at, a′s) ∈ EA ∗\n. By definition of A∗, one has (a, a′) ∈ EA, implying that (h(a), h(a′)) ∈ EB, from which one has, by the definition of B∗, that (h(a)t, h(a′)s) ∈ EB ∗\n. We now show the backward direction. Suppose that h∗ : A∗ → B∗ is a homomorphism. We first establish the following claim: for all a ∈ A, there exists b ∈ B such that (h∗(as), h∗(ac), h∗(ad)) = (bs, bc, bd). Let a ∈ A. Observe that h∗ acts injectively on {as, ac, ad}, for if not, one would have distinct a, a′ ∈ {as, ac, ad} with h∗(a) = h∗(a′) and (a, a′) ∈ EA ∗\n, implying that B∗ contains a self-loop, a contradiction. The subgraph of B∗ induced by {h(as), h(ac), h(ad)} thus has three vertices and contains the three edges (h(ac), h(as)), (h(ac), h(ad)), (h(as), h(ad)); the claim follows by inspection of the definition of B∗.\nThe claim we just established allows us to naturally define, from h∗, a mapping h : A → B, where h(a) = b if and only if (h∗(as), h∗(ac), h∗(ad)) = (bs, bc, bd). We observe that when h(a) = b, theA∗-path ad, as1, at1, . . . , asn, atn, at is mapped under h∗ to theB∗-path bd, bs1, bt1, . . . , bsn, btn, bt. We have h∗(ad) = bd by the definition of h, and the other equivalences follow immediately from the assumption that h∗ is a homomorphism A∗ → B∗ along with the fact that in each of the two paths, each vertex other than the last has outdegree 1.\nWe now verify that h is a homomorphism A → B. Suppose that (a, a′) ∈ EA, and let (b, b′) = (h(a), h(a′)). By definition of A∗, we have (at, a′s) ∈ EA ∗\n, from which it follows that (bt, b′s) = (h∗(at), h∗(a′s)) ∈ EB ∗\n; by the definition of B∗, we have (b, b′) ∈ EB. Suppose that a ∈ LAi , and let b = h(a). We want to show that b ∈ LBi ; it suffices to show that b\nvi ∈ B∗. We demonstrate this by contradiction. Assume bvi /∈ B∗. Since avi has an edge to ati in A∗, we have h(avi) = bsi, as by assumption bsi is the only vertex having an edge to bti in B∗. But then, since avi, aui, asi is a length 2 path in A∗, it must be that h∗(avi) = bsi, h∗(aui), h∗(asi) = bsi is a length 2 path in B∗, contradicting that there is no length 2 path from bsi to itself in B∗. ⊓⊔\nWe define a sequence of existential positive sentences {Hn}n≥2, as follows. Let n ≥ 2. Let A be the labelled digraph on σn with universe {v1, . . . , vn} where EA = ∅ and where LAi = {vi} for all i ∈ {1, . . . , n}. Let Pnψn be the canonical query Q[A∗] of A∗, where Pn denotes the quantifier prefix and ψn the quantifier-free part. We define Hn to be the sentence\nPn(ψn ∧ n∧\ni=1\n(\nn∨\nj=1\nE(vti , v s j ))).\nWe useCn to denote the directed cycle on σn where all vertices have all labels, that is,Cn is the structure with universe Cn = {0, . . . , n− 1} where E\nCn = {(i, (i+1) mod n) | i ∈ {0, . . . , n− 1}} and where LCni = Cn for all i ∈ {1, . . . , n}.\nLemma 18. Let B be a labelled digraph over σn with n vertices where each vertex is given a unique label, that is, where LB1 ∪ · · · ∪ L B n is a partition of the universe B. The digraph (B,E\nB) has a directed Hamiltonian circuit if and only if it holds that (B×Cn)∗ |= Hn.\nProof. It is straightforward to verify that Hn is logically equivalent to the sentence\n∨\nf\nPn(ψn ∧ ∧\ni∈{1,...,n}\nE(vti , v s f(i)))\nwhere the disjunction is over all mappings f : {1, . . . , n} → {1, . . . , n}. This sentence is in turn straightforwardly verified to be equivalent to\n∨\nf\nQ[A∗f ]\nwhere Af is the labelled digraph on σn with universe {v1, . . . , vn} where E A = {(vi, vf(i)) | i ∈ {1, . . . , n}} and LAi = {vi} for all i ∈ {1, . . . , n}. We thus obtain that (B × Cn) ∗ |= Hn if and only if there exists a mapping f : {1, . . . , n} → {1, . . . , n} such that A∗f → (B×Cn) ∗; by appeal to Lemma 17, this latter condition holds if and only if there exists a mapping f : {1, . . . , n} → {1, . . . , n} such that Af → B×Cn. We make use of this last condition to establish the lemma.\nFor the sake of notation, we assume without loss of generality that the structure B has universe {v1, . . . , vn} and it holds that L B i = {vi} for all i ∈ {1, . . . , n}.\nSuppose that B contains a directed Hamiltonian circuit. Then, there exists an operation f : {1, . . . , n} → {1, . . . , n} such that EAf is a cycle and EAf ⊆ EB. The identity mapping on {v1, . . . , vn} is then a homomorphism Af → B, and since EAf is a cycle, there exists a homomorphism Af → Cn. By appeal to Proposition 1, we have Af → B×Cn.\nSuppose that there exists a mapping f : {1, . . . , n} → {1, . . . , n} such that Af → B×Cn. By Proposition 1, it holds that Af → B and Af → Cn. We claim that EAf is a length n cycle. We reason as follows. Fix a vertex w1 arbitrarily. Each vertex has outdegree 1 and hence exactly one successor. For i ∈ {1, . . . , n}, define wi+1 to be the successor of wi. If the sequence w1, . . . , wn is a listing of all n vertices in {v1, . . . , vn} and wn+1 = w1, then the claim is established. Otherwise, there exist values i, j with 1 ≤ i < j ≤ n + 1 and j − i < n such that wi = wj . Let i, j be two such values such that j − i is minimized. Then wi, . . . , wj is a simple cycle of length strictly less than n; its image under the homomorphism from Af to Cn must also be a simple cycle of length strictly less than n, contradicting that Cn is a directed cycle of length n. The claim is established. Let h be a homomorphism from Af to B. Due to the labels, h is the identity mapping, and so EAf ⊆ EB; since EAf is a length n cycle, we obtain that (B,EB) contains a directed Hamiltonian circuit. ⊓⊔\nWe now give a lemma that will help us measure the treewidth of a structure having the form B∗. We will make use of the following auxiliary structure. Let B be a labelled digraph over σn. We define a digraph B\n+ from B in the following way. The structure B+ has universe B+ = {bs, bt | b ∈ B} and edge relation EB + = {(bs, bt) | b ∈ B} ∪ {(bt, b′s) | (b, b′) ∈ EB}.\nLemma 19. Let B be a labelled digraph over σn. It holds that tw(B ∗) ≤ max(tw(B+), 5).\nProof. We first show that, for each b ∈ B, the gadget digraph Gb has a tree decomposition (Tb, βb) of width 5 where bs and bt are contained in every bag, and where Tb is a path. It suffices to show this under the assumption that b ∈ LBi for all i ∈ {1, . . . , n}, since removing b from the relations LBi translates to removing vertices and edges from Gb. In what follows, we list the bags of this tree decomposition in order, and for readability exclude bs and bt from each bag.\n{bc, bd}, {bd, bs1}, {bs1, bt1, bu1, bv1}, {bt1, bs2}, {bs2, bt2, bu2, bv2}, {bt2, bs3}, . . .\n{bsn, btn, bun, bvn}\nIt is straightforwardly verified that each edge of Gb is contained in a bag; since the largest bag has 6 elements, the tree decomposition has width 5.\nNow suppose that (T, β) is a tree decomposition of B+ of width tw(B+). We show how to augment this tree decomposition to obtain a tree decomposition of B∗. For each b ∈ B, since (bs, bt) ∈ EB +\n, there exists a vertex t of T such that {bs, bt} ⊆ β(t). We adjoin the tree decomposition (Tb, βb) to t by creating an edge between t and an arbitrary vertex of Tb. After having done this for each b ∈ B, we arrive at a pair (T ′, β′) which we claim is a tree decomposition of B∗. The pair (T ′, β′) satisfies the second condition in the definition of tree decomposition by the definitions of B+ and B∗, so we consider the first condition of connectivity. A B∗-vertex of the form bs or bt does not appear in the tree decomposition (Tc, βc) if c 6= b; since such a vertex appears in every bag of (Tb, βb), we obtain the connectivity condition from the connectivity condition holding in (T ′, β′) and by the way we adjoined (Tb, βb) to (T, β). Any other B\n∗-vertex has the form bX (with X /∈ {s, t}) and appears solely in the copy of (Tb, βb) adjoined to (T ′, β′); for such a vertex, the connectivity condition is thus inherited from the connectivity condition on (Tb, βb). Since each bag in (T ′, β′) is either a bag in (T, β) or a bag in (Tb, βb) for some b ∈ B, we have that the width of (T ′, β′) is equal to max(tw(B+), 5), yielding the lemma. ⊓⊔\nWith our measuring device (Lemma 19) in hand, we can now bound the number of variables needed to express the sentences {Hn}.\nLemma 20. Each existential positive sentence in the sequence {Hn}n≥2 is logically equivalent to a sentence in EP6.\nProof. We will make use of the discussion and notation in the first paragraph of the proof of Lemma 18. There, it is shown that Hn is logically equivalent to ∨ f Q[A ∗ f ] where the disjunction is over all mappings f : {1, . . . , n} → {1, . . . , n} and Af is a labelled digraph having the property that each vertex has outdegree exactly 1. It follows directly from the definition of A+f that each vertex in A+f also has outdegree 1. We now argue that any digraph whose vertices each have outdegree 1 has treewidth 2 (or less). We prove by induction on the number of vertices that such a digraph has a tree decomposition of width less than or equal to 2 where each vertex appears in a bag. Consider the number m of vertices having indegree 0. When m = 0, it is straightforward to verify that the digraph is the disjoint union of cycles, and has such a tree decomposition. When m > 0, we reason as follows. Let v be a vertex with indegree 0, and let v′ denote the unique vertex such that (v, v′) is an edge in the digraph. By induction, the digraph with v removed has a tree decomposition (T, β) of the described form; creating a new vertex u with bag {v, v′} and linking u to a vertex t ∈ T with v′ ∈ β(t), we obtain the desired tree decomposition.\nLet f : {1, . . . , n} → {1, . . . , n} be a mapping. From the just-given argument, we have that tw(A+f ) ≤ 2. By Lemma 19, we obtain that tw(A ∗ f ) ≤ 5. It follows that tw(core(A ∗ f )) ≤ 5, since the core of a structure is a substructure thereof and thus cannot have higher treewidth; by Theorem 4, the sentence Q[A∗f ] is logically equivalent to a sentence in PP 6. Since Hn is logically equivalent to ∨ f Q[A ∗ f ], it is thus logically equivalent to a sentence in EP 6. ⊓⊔\nProof. (Proof of Theorem 16) We first consider the case that σ contains a symbol E of arity 2. By Lemma 20, the sequence of sentences {Hn}n≥2 is in ≈EP 6 σ. By Lemma 18, the following is a manyone polynomial-time reduction from Directed Hamiltonian Circuit to EP-MC({Hn}n≥2): given a directed graph with n vertices, convert this graph to a labelled digraph B over σn where each vertex is given a unique label; then, output the pair (Hn, (B×Cn)∗).\nWe next consider the case that σ contains a symbol F of arity r > 2. For each n ≥ 2, let H ′n be the sentence obtained from Hn by replacing each predicate application E(x, y) with the predicate application F (x, y, . . . , y), where (x, y, . . . , y) denotes the tuple containing 1 entry of x followed by (r − 1) entries of y. Deciding whether or not B |= Hn for a structure B is then equivalent to deciding whether or not B′ |= H ′n, where B ′ is defined by FB ′\n= {(a, b . . . , b) | (a, b) ∈ EB}. With this observation, we derive the theorem in this case from the previous case. ⊓⊔\nProof. (Proof of Theorem 14) Assume that σ consists of finitely many unary symbols. Let φ be any existential positive sentence over σ. Convert φ to the disjunction of primitive positive sentences using the syntactic transformations given in the proof of Proposition 3. Each resulting primitive positive sentence can be viewed as having the form ∃v1 . . .∃vn(γ1∧. . .∧γn) where γi is the (possibly empty) conjunction of σ-predicate applications using just the variable vi. Such a sentence is logically equivalent to (∃v1γ1) ∧ · · · ∧ (∃vnγn). Each sentence (∃viγi) is a 1-variable primitive positive sentence that is determined by the σ-predicate applications that appear in γi; call such a sentence a little sentence. Note that a boolean combination of little sentences, by renaming of variables, is logically equivalent to a 1-variable sentence. We can upper bound the number of little sentences, up to logical equivalence, by 2|σ|. Up to logical equivalence, the number of conjunctions of little sentences can then be upper bounded by 22 |σ| , and then the number of disjunctions of conjunctions of little sentences can be upper bounded by 22 2|σ|\n. Hence, each existential positive sentence over σ is logically equivalent to a boolean combination of little sentences, of which there are finitely many, and the first item of the theorem is demonstrated.\nWe next consider the case that σ contains a symbol E of arity 2 or greater. Suppose that the problem EP-MC(≈EP6σ) compiles to a polynomial-time decidable problem Q\n′ ⊆ Σ∗ × Σ∗ via a polynomial-length compilation c; we will show that the polynomial hierarchy collapses. LetD ⊆ Σ∗ denote the Directed Hamiltonian Circuit problem under a standard encoding, and let n(x) denote the number of vertices in an instance x of D. Let p be a polynomial such that, for each instance x of D, it holds that n(x) ≤ p(|x|). Let s be the polynomial-time mapping such that an instance x of D is sent to the instance (Hn(x), s(x)) by the reduction of Theorem 16. We have that for any string x ∈ Σ∗, it holds that x ∈ D if and only if s(x) |= Hn(x), which in turn holds if and only if (c(Hn(x)), s(x)) ∈ Q\n′. There is thus a polynomial-time algorithm that, given an instance x of D and the advice strings c(H2), . . . , c(Hp(|x|)), decides if x ∈ D: the algorithm computes s(x) and then uses the polynomial-time algorithm for Q′ to decide if (c(Hn(x)), s(x)) ∈ Q\n′. The advice strings have a total length that is polynomial in x, implying that D is contained in P/poly. Since D is NP-complete, this implies that NP is contained in P/poly, which, by the Karp-Lipton theorem [16], implies that the polynomial hierarchy collapses.\nFinally, in the case that σ contains infinitely many unary symbols, we give an analog of Theorem 16. In particular, we argue that the NP-complete problem Boolean CNF Satisfiability manyone polynomial-time reduces to EP-MC({Smn }) where {S m n } is a family of existential positive sentences over σ, via a reduction that maps an instance having n variables and m clauses to an instance involving Smn . This suffices, as one can then use the same advice-based argument as in the previous case. For n,m ≥ 1, we define Smn to be the sentence ∃v1 . . . ∃vn ∧m i=1 ∨n j=1 R i j(vj), where the Rij are pairwise distinct unary relation symbols in σ. Given an instance φ of satisfiability on variables {v1, . . . , vn} and m clauses, the reduction outputs (Smn ,B) where B is the structure with B = {0, 1} and relations defined as follows. Define (Rij) B = {0} if ¬vi appears as a literal in the jth clause, (Rij) B = {1} if vi appears as a literal in the jth clause, and (Rij)\nB = ∅ otherwise. It is straightforward to verify that an assignment to the variables satisfies the instance of satisfiability if and only if it satisfies the quantifier-free part of Smn . ⊓⊔"
    }, {
      "heading" : "5 Discussion",
      "text" : "Our study of parameterized complexity yielded that, under the assumption of bounded arity, a set F of existential positive sentences is fixed-parameter tractable when the sentences are equivalent to bounded-variable sentences, and W[1]-hard otherwise. In first-order logic in general, equivalence of a set of sentences to bounded-variable sentences is sufficient to place model checking in nuFPT.\nObservation 21. Let F be a set of first-order sentences. If there exists k ≥ 1 such that each sentence φ ∈ F is logically equivalent to a sentence in FOk, then the problem FO-MC(F) is in nuFPT.\nProof. For each sentence φ ∈ F , let φ′ denote a logically equivalent sentence in FOk. One has inclusion of FO-MC(F) in nuFPT via the ensemble of algorithms {Aφ}φ∈F where Aφ, given an instance (φ,B) of FO-MC(F), evaluates φ′ onB using the natural bottom-up evaluation algorithm, as in Proposition 13. In particular, the algorithm Aφ, for each subformula ψ of φ\n′, computes a relation on B of arity less than or equal to k containing the satisfying assignments of ψ. ⊓⊔\nSuppose that F satisfies the assumption of the observation. The existence of an algorithm that passes from a sentence φ in a set F to an equivalent sentence in FOk (or, FOm for some fixed m > k) would permit one to improve the nuFPT upper bound in the observation to an FPT upper bound. We would like to suggest studying for which such sets F such an algorithm exists.\nAs borne out by this study as well as others [11,9,13,2,7], Observation 21 gives a unifying explanation for containment of model checking in nuFPT, under bounded arity. As a direction for future research, we would like to propose that this thus-far unifying explanation is the only possible explanation for containment in nuFPT in equality-free positive first-order logic.\nConjecture 22. Let F be a set of equality-free positive relational first-order sentences having bounded arity. If there does not exist k ≥ 1 such that each sentence φ ∈ F is logically equivalent to a sentence in FOk, then the problem FO-MC(F) is W[1]-hard or co-W[1]-hard under nuFPT reduction.\nAnother interesting research issue is whether or not it is possible to give a reasonable description of the existential positive queries (or, more generally, the first-order queries) that can be evaluated in polynomial time.2 For a set of sentences F contained in ≈EPk, if the passage from a sentence φ ∈ F to an equivalent sentence φ′ ∈ EPk can be performed in polynomial time, then EP-MC(F) is in polynomial time: perform the passage and then (as in Proposition 13) invoke bottom-up evaluation on the resulting EPk sentence. Also, when this passage is in polynomial time, each sentence φ is clearly equivalent to a polynomial size sentence φ′ ∈ EPk. We suggested that for bounded arity sentences F , inclusion of FO-MC(F) in nuFPT is governed by expressibility in bounded-variable logic; could inclusion of FO-MC(F) in polynomial time be related to expressibility in bounded-variable logic via polynomial size sentences?\nAcknowledgements. The author thanks Johan Thapper for useful comments."
    } ],
    "references" : [ {
      "title" : "Foundations of Databases",
      "author" : [ "S. Abiteboul", "R. Hull", "V. Vianu" ],
      "venue" : "Addison-Wesley,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Tree-width for first order formulae",
      "author" : [ "Isolde Adler", "Mark Weyer" ],
      "venue" : "Logical Methods in Computer Science,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2012
    }, {
      "title" : "An n! lower bound on formula size",
      "author" : [ "Micah Adler", "Neil Immerman" ],
      "venue" : "ACM Trans. Comput. Log.,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2003
    }, {
      "title" : "On preservation under homomorphisms and unions of conjunctive queries",
      "author" : [ "Albert Atserias", "Anuj Dawar", "Phokion G. Kolaitis" ],
      "venue" : "J. ACM,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2006
    }, {
      "title" : "Preprocessing of intractable problems",
      "author" : [ "Marco Cadoli", "Francesco M. Donini", "Paolo Liberatore", "Marco Schaerf" ],
      "venue" : "Information and Computation,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2002
    }, {
      "title" : "Optimal implementation of conjunctive queries in relational data bases",
      "author" : [ "Ashok K. Chandra", "Philip M. Merlin" ],
      "venue" : "In Proceddings of STOC’77,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1977
    }, {
      "title" : "Decomposing quantified conjunctive (or disjunctive) formulas",
      "author" : [ "Hubie Chen", "Vı́ctor Dalmau" ],
      "venue" : "In LICS,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2012
    }, {
      "title" : "Constraint satisfaction with succinctly specified relations",
      "author" : [ "Hubie Chen", "Martin Grohe" ],
      "venue" : "Journal of Computer and System Sciences,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2010
    }, {
      "title" : "Constraint Satisfaction, Bounded Treewidth, and Finite-Variable Logics",
      "author" : [ "Victor Dalmau", "Phokion G. Kolaitis", "Moshe Y. Vardi" ],
      "venue" : "In Constraint Programming",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2002
    }, {
      "title" : "Parameterized Complexity Theory",
      "author" : [ "J. Flum", "M. Grohe" ],
      "venue" : "Springer,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Query evaluation via tree-decompositions",
      "author" : [ "Jörg Flum", "Markus Frick", "Martin Grohe" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2002
    }, {
      "title" : "The succinctness of first-order logic on linear orders",
      "author" : [ "M. Grohe", "N. Schweikardt" ],
      "venue" : "Logical Methods in Computer Science, 1:125,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "The complexity of homomorphism and constraint satisfaction problems seen from the other side",
      "author" : [ "Martin Grohe" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2007
    }, {
      "title" : "When is the evaluation of conjunctive queries tractable",
      "author" : [ "Martin Grohe", "Thomas Schwentick", "Luc Segoufin" ],
      "venue" : null,
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2001
    }, {
      "title" : "The core of a graph",
      "author" : [ "P. Hell", "J. Nesetril" ],
      "venue" : "Discrete Math., 109:117–126,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 1992
    }, {
      "title" : "Turing machines that take advice",
      "author" : [ "R.M. Karp", "R.J. Lipton" ],
      "venue" : "L’Enseignement Mathématique, 28:191–209,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 1982
    }, {
      "title" : "Conjunctive-Query Containment and Constraint Satisfaction",
      "author" : [ "P. Kolaitis", "M. Vardi" ],
      "venue" : "Journal of Computer and System Sciences, 61:302–332,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Tractable hypergraph properties for constraint satisfaction and conjunctive queries",
      "author" : [ "Dániel Marx" ],
      "venue" : "CoRR, abs/0911.0801,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2009
    }, {
      "title" : "Tractable hypergraph properties for constraint satisfaction and conjunctive queries",
      "author" : [ "Dániel Marx" ],
      "venue" : "In Proceedings of the 42nd ACM Symposium on Theory of Computing,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2010
    }, {
      "title" : "Tractable structures for constraint satisfaction with truth tables",
      "author" : [ "Dániel Marx" ],
      "venue" : "Theory of Computing Systems,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2011
    }, {
      "title" : "Homomorphism preservation theorems",
      "author" : [ "Benjamin Rossman" ],
      "venue" : "J. ACM,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2008
    }, {
      "title" : "On the complexity of bounded-variable queries",
      "author" : [ "Moshe Y. Vardi" ],
      "venue" : "In PODS’95,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 1995
    } ],
    "referenceMentions" : [ {
      "referenceID" : 13,
      "context" : "However, as has been articulated in the literature, the typical situation in practical database settings is the evaluation of a short query against a large database, or, in logical parlance, evaluating a short formula on a large relational structure (see for example the discussion of Grohe, Schwentick, and Segoufin [14]).",
      "startOffset" : 317,
      "endOffset" : 321
    }, {
      "referenceID" : 8,
      "context" : "This result is due to Dalmau, Kolaitis, and Vardi [9] and Grohe [13], and is proved under typical complexity-theoretic assumptions.",
      "startOffset" : 50,
      "endOffset" : 53
    }, {
      "referenceID" : 12,
      "context" : "This result is due to Dalmau, Kolaitis, and Vardi [9] and Grohe [13], and is proved under typical complexity-theoretic assumptions.",
      "startOffset" : 64,
      "endOffset" : 68
    }, {
      "referenceID" : 21,
      "context" : "This tractability condition is clearly related to and can be viewed as an extension of Vardi’s classic observation [22] on the tractability of bounded-variable first-order logic: for each k ≥ 1, model checking on first-order logic limited to k variables is polynomial-time tractable, via the natural bottom-up evaluation algorithm.",
      "startOffset" : 115,
      "endOffset" : 119
    }, {
      "referenceID" : 7,
      "context" : "(See Chen and Grohe [8] and Marx [20,19] for work on model checking primitive positive sentences having unbounded arity, with respect to various representations.",
      "startOffset" : 20,
      "endOffset" : 23
    }, {
      "referenceID" : 19,
      "context" : "(See Chen and Grohe [8] and Marx [20,19] for work on model checking primitive positive sentences having unbounded arity, with respect to various representations.",
      "startOffset" : 33,
      "endOffset" : 40
    }, {
      "referenceID" : 18,
      "context" : "(See Chen and Grohe [8] and Marx [20,19] for work on model checking primitive positive sentences having unbounded arity, with respect to various representations.",
      "startOffset" : 33,
      "endOffset" : 40
    }, {
      "referenceID" : 0,
      "context" : "For instance, it is reported by Abiteboul, Hull, and Vianu [1] that so-called unions of conjunctive queries, also known as select-project-join-union queries, are the most common queries to databases; these queries are semantically equivalent to existential positive formulas.",
      "startOffset" : 59,
      "endOffset" : 62
    }, {
      "referenceID" : 3,
      "context" : "Also, existential positive logic has been the subject of focused investigation in finite model theory in connection with understanding the status of the homomorphism preservation theorem on (classes of) finite structures; see for example [4,21] and the references therein.",
      "startOffset" : 238,
      "endOffset" : 244
    }, {
      "referenceID" : 20,
      "context" : "Also, existential positive logic has been the subject of focused investigation in finite model theory in connection with understanding the status of the homomorphism preservation theorem on (classes of) finite structures; see for example [4,21] and the references therein.",
      "startOffset" : 238,
      "endOffset" : 244
    }, {
      "referenceID" : 4,
      "context" : "[5], and is proved under the assumption that the polynomial hierarchy does not collapse.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 2,
      "context" : "Although this result is proved under a complexity-theoretic assumption, we believe that it constitutes an interesting formula size lower bound and can be taken as a contribution to the literature on formula size lower bounds (see for example [3,12]).",
      "startOffset" : 242,
      "endOffset" : 248
    }, {
      "referenceID" : 11,
      "context" : "Although this result is proved under a complexity-theoretic assumption, we believe that it constitutes an interesting formula size lower bound and can be taken as a contribution to the literature on formula size lower bounds (see for example [3,12]).",
      "startOffset" : 242,
      "endOffset" : 248
    }, {
      "referenceID" : 14,
      "context" : "We will make use of the following wellknown facts on cores [15]: (1) each finite structure has a core; (2) all cores of a finite structure are isomorphic.",
      "startOffset" : 59,
      "endOffset" : 63
    }, {
      "referenceID" : 5,
      "context" : "(Chandra-Merlin [6]) Let A,B be similar finite structures.",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 9,
      "context" : "We overview the elements of parameterized complexity that will be used in the paper, and refer the reader to the book by Flum and Grohe [10] for more information.",
      "startOffset" : 136,
      "endOffset" : 140
    }, {
      "referenceID" : 0,
      "context" : "The parameterized complexity class W[1] is often said to be the analog of NP in the world of parameterized complexity, and it is widely believed that W[1] is not contained in FPT.",
      "startOffset" : 36,
      "endOffset" : 39
    }, {
      "referenceID" : 0,
      "context" : "The parameterized complexity class W[1] is often said to be the analog of NP in the world of parameterized complexity, and it is widely believed that W[1] is not contained in FPT.",
      "startOffset" : 151,
      "endOffset" : 154
    }, {
      "referenceID" : 7,
      "context" : "There are different ways that structures can be represented, in particular, there are different ways that their relations can be represented, and the representation used can impact the complexity of model checking [8].",
      "startOffset" : 214,
      "endOffset" : 217
    }, {
      "referenceID" : 10,
      "context" : "One representation that we will study is the explicit representation, where a relation is represented by an explicit listing of the tuples that it contains; we refer the reader to [11] for a discussion of such a representation.",
      "startOffset" : 180,
      "endOffset" : 184
    }, {
      "referenceID" : 8,
      "context" : "(Dalmau, Kolaitis, and Vardi [9]) Let F be a set of primitive positive sentences such that the set of structures {core(C[ψ]) | ψ ∈ F} has bounded treewidth.",
      "startOffset" : 29,
      "endOffset" : 32
    }, {
      "referenceID" : 12,
      "context" : "(Grohe [13]) Let F be a set of primitive positive sentences having bounded arity such that the set of structures {core(C[ψ]) | ψ ∈ F} has unbounded treewidth.",
      "startOffset" : 7,
      "endOffset" : 11
    }, {
      "referenceID" : 0,
      "context" : "Then, the problem PP-MC(F) is W[1]-hard under nuFPT reductions.",
      "startOffset" : 31,
      "endOffset" : 34
    }, {
      "referenceID" : 7,
      "context" : "Previous work [8] studied a representation of relations called the generalized DNF (GDNF) representation.",
      "startOffset" : 14,
      "endOffset" : 17
    }, {
      "referenceID" : 0,
      "context" : ") It is known that, for a set F of primitive positive sentences, the problem PP-MCg(F) is FPT if the structures corresponding to F (that is, the set of structuresC[F ]) have bounded incidence width modulo homomorphic equivalence, and that this problem is W[1]-hard under nuFPT reductions otherwise.",
      "startOffset" : 256,
      "endOffset" : 259
    }, {
      "referenceID" : 7,
      "context" : "This follows from results in [8], to which we refer the reader for more details.",
      "startOffset" : 29,
      "endOffset" : 32
    }, {
      "referenceID" : 0,
      "context" : "This classification result, along with the theorem that follows, allows one to obtain a full FPT/W[1]hard classification of the problems having the form EP-MCg(F).",
      "startOffset" : 98,
      "endOffset" : 101
    }, {
      "referenceID" : 0,
      "context" : "If F satisfies the tractability condition, then EP-MC(F) is fixed-parameter tractable; otherwise, under the assumption that F has bounded arity, EP-MC(F) is W[1]-hard under nuFPT reductions.",
      "startOffset" : 158,
      "endOffset" : 161
    }, {
      "referenceID" : 0,
      "context" : "For the hardness result, if the tractability condition does not hold, we have W[1]-hardness of PP-MC(F ) under nuFPT reductions by Theorem 8, and so the result follows from Theorem 9.",
      "startOffset" : 79,
      "endOffset" : 82
    }, {
      "referenceID" : 21,
      "context" : "The hardness result of Proposition 12 can be sharply contrasted with the observation, due to Vardi [22], that model checking a bounded-variable fragment of first-order logic is polynomialtime tractable.",
      "startOffset" : 99,
      "endOffset" : 103
    }, {
      "referenceID" : 21,
      "context" : "(Vardi [22]) For each k ≥ 1, the natural evaluation algorithm decides FO-MC(FO) in polynomial time.",
      "startOffset" : 7,
      "endOffset" : 11
    }, {
      "referenceID" : 4,
      "context" : "[5]; here, we give a self-contained presentation using slightly different terminology and notions.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 16,
      "context" : "1 This is the situation in primitive positive logic; this can be inferred from Theorem 4 and results in [17].",
      "startOffset" : 104,
      "endOffset" : 108
    }, {
      "referenceID" : 1,
      "context" : "Our decision to investigate the compilability properties of existential positive logic was partially inspired by the interesting discussion of Adler and Weyer [2].",
      "startOffset" : 159,
      "endOffset" : 162
    }, {
      "referenceID" : 15,
      "context" : "Since D is NP-complete, this implies that NP is contained in P/poly, which, by the Karp-Lipton theorem [16], implies that the polynomial hierarchy collapses.",
      "startOffset" : 103,
      "endOffset" : 107
    }, {
      "referenceID" : 0,
      "context" : "Our study of parameterized complexity yielded that, under the assumption of bounded arity, a set F of existential positive sentences is fixed-parameter tractable when the sentences are equivalent to bounded-variable sentences, and W[1]-hard otherwise.",
      "startOffset" : 232,
      "endOffset" : 235
    }, {
      "referenceID" : 10,
      "context" : "As borne out by this study as well as others [11,9,13,2,7], Observation 21 gives a unifying explanation for containment of model checking in nuFPT, under bounded arity.",
      "startOffset" : 45,
      "endOffset" : 58
    }, {
      "referenceID" : 8,
      "context" : "As borne out by this study as well as others [11,9,13,2,7], Observation 21 gives a unifying explanation for containment of model checking in nuFPT, under bounded arity.",
      "startOffset" : 45,
      "endOffset" : 58
    }, {
      "referenceID" : 12,
      "context" : "As borne out by this study as well as others [11,9,13,2,7], Observation 21 gives a unifying explanation for containment of model checking in nuFPT, under bounded arity.",
      "startOffset" : 45,
      "endOffset" : 58
    }, {
      "referenceID" : 1,
      "context" : "As borne out by this study as well as others [11,9,13,2,7], Observation 21 gives a unifying explanation for containment of model checking in nuFPT, under bounded arity.",
      "startOffset" : 45,
      "endOffset" : 58
    }, {
      "referenceID" : 6,
      "context" : "As borne out by this study as well as others [11,9,13,2,7], Observation 21 gives a unifying explanation for containment of model checking in nuFPT, under bounded arity.",
      "startOffset" : 45,
      "endOffset" : 58
    }, {
      "referenceID" : 0,
      "context" : "If there does not exist k ≥ 1 such that each sentence φ ∈ F is logically equivalent to a sentence in FO, then the problem FO-MC(F) is W[1]-hard or co-W[1]-hard under nuFPT reduction.",
      "startOffset" : 135,
      "endOffset" : 138
    }, {
      "referenceID" : 0,
      "context" : "If there does not exist k ≥ 1 such that each sentence φ ∈ F is logically equivalent to a sentence in FO, then the problem FO-MC(F) is W[1]-hard or co-W[1]-hard under nuFPT reduction.",
      "startOffset" : 151,
      "endOffset" : 154
    } ],
    "year" : 2012,
    "abstractText" : "We systematically investigate the complexity of model checking the existential positive fragment of first-order logic. In particular, for a set of existential positive sentences, we consider model checking where the sentence is restricted to fall into the set; a natural question is then to classify which sentence sets are tractable and which are intractable. With respect to fixed-parameter tractability, we give a general theorem that reduces this classification question to the corresponding question for primitive positive logic, for a variety of representations of structures. This general theorem allows us to deduce that an existential positive sentence set having bounded arity is fixed-parameter tractable if and only if each sentence is equivalent to one in bounded-variable logic. We then use the lens of classical complexity to study these fixed-parameter tractable sentence sets. We show that such a set can be NP-complete, and consider the length needed by a translation from sentences in such a set to bounded-variable logic; we prove superpolynomial lower bounds on this length using the theory of compilability, obtaining an interesting type of formula size lower bound. Overall, the tools, concepts, and results of this article set the stage for the future consideration of the complexity of model checking on more expressive logics.",
    "creator" : "LaTeX with hyperref package"
  }
}