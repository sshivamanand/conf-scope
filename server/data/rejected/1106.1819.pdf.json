{
  "name" : "1106.1819.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Knowledge Compilation Map",
    "authors" : [ "Adnan Darwiche", "Pierre Marquis" ],
    "emails" : [ "darwiche@cs.ucla.edu", "marquis@cril.univ-artois.fr" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "Knowledge compilation has emerged recently as a key direction of research for dealing with the computational intractability of general propositional reasoning (Darwiche, 1999; Cadoli & Donini, 1997; Boufkhad, Grégoire, Marquis, Mazure, & Säıs, 1997; Khardon & Roth, 1997; Selman & Kautz, 1996; Schrag, 1996; Marquis, 1995; del Val, 1994; Dechter & Rish, 1994; Reiter & de Kleer, 1987). According to this direction, a propositional theory is compiled off-line into a target language, which is then used on-line to answer a large number of queries in polytime. The key motivation behind knowledge compilation is to push as much of the computational overhead into the off-line phase, which is amortized over all on-line queries. But knowledge compilation can serve other important purposes as well. For example, target compilation languages and their associated algorithms can be very simple, allowing one to develop on-line reasoning systems for simple software and hardware platforms. Moreover, the simplicity of algorithms that operate on compiled languages help in streamlining the effort of algorithmic design into a single task: that of generating the smallest compiled representations possible, as that turns out to be the main computational bottleneck in compilation approaches.\nThere are three key aspects of any knowledge compilation approach: the succinctness of the target language into which the propositional theory is compiled; the class of queries that can be answered in polytime based on the compiled representation; and the class of transformations that can be applied to the representation in polytime. The AI literature has thus far focused mostly on target compilation languages which are variations on DNF and CNF formulas, such as Horn theories and prime implicates. Moreover, it has focused mostly on clausal entailment queries, with very little discussion of tractable transformations on compiled theories.\nThe goal of this paper is to provide a broad perspective on knowledge compilation by considering a relatively large number of target compilation languages and analyzing them according to their succinctness and the class of queries/transformations that they admit in polytime.\nc©2002 AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.\nInstead of focusing on classical, flat target compilation languages based on CNF and DNF, we consider a richer, nested class based on representing propositional sentences using directed acyclic graphs, which we refer to as NNF. We identify a number of target compilation languages that have been presented in the AI, formal verification, and computer science literature and show that they are special cases of NNF. For each such class, we list the extra conditions that need to be imposed on NNF to obtain the specific class, and then identify the set of queries and transformations that the class supports in polytime. We also provide cross-rankings of the different subsets of NNF, according to their succinctness and the polytime operations they support.\nThe main contribution of this paper is then a map for deciding the target compilation language that is most suitable for a particular application. Specifically, we propose that one starts by identifying the set of queries and transformations needed for their given application, and then choosing the most succinct language that supports these operations in polytime.\nThis paper is structured as follows. We start by formally defining the NNF language in Section 2, where we list a number of conditions on NNF that give rise to a variety of target compilation languages. We then study the succinctness of these languages in Section 3 and provide a cross-ranking that compares them according to this measure. We consider a number of queries and their applications in Section 4 and compare the different target compilation languages according to their tractability with respect to these queries. Section 5 is then dedicated to a class of transformations, their applications, and their tractability with respect to the different target compilation languages. We finally close in Section 6 by some concluding remarks. Proofs of all theorems are delegated to Appendix A.\n2. The NNF Language\nWe consider more than a dozen languages in this paper, all of which are subsets of the NNF language, which is defined formally as follows (Darwiche, 1999, 2001a).\nDefinition 2.1 Let PS be a denumerable set of propositional variables. A sentence in NNFPS is a rooted, directed acyclic graph (DAG) where each leaf node is labeled with true, false, X or ¬X, X ∈ PS; and each internal node is labeled with ∧ or ∨ and can have arbitrarily many children. The size of a sentence Σ in NNFPS, denoted | Σ |, is the number of its DAG edges. Its height is the maximum number of edges from the root to some leaf in the DAG.\nFigure 1 depicts a sentence in NNF, which represents the odd parity function (we omit reference to variables PS when no confusion is anticipated). Any propositional sentence can be represented as a sentence in NNF, so the NNF language is complete.\nIt is important here to distinguish between a representation language and a target compilation language. A representation language is one which we expect humans to read and write with some ease. The language of CNF is a popular representation language, and so is the language of Horn clauses (especially when expressed in rules form). On other hand, a target compilation language does not need to be suitable for human specification and interpretation, but should be tractable enough to permit a non-trivial number of polytime queries and/or transformations. We will consider a number of target compilation languages that do not qualify as representation languages from this perspective, as they are not suitable for humans to construct or interpret. We will also consider a number of representation languages that do not qualify as target compilation languages.1\nA formal characterization of representation languages is outside the scope of this paper. But for a language to qualify as a target compilation language, we will require that it permits a polytime clausal entailment test. Note that a polytime consistency test is not sufficient here, as only one consistency test on a given theory does not justify its compilation. Given this definition, NNF does\n1. It appears that when proposing target compilation languages in the AI literature, there is usually an implicit requirement that the proposed language is also a representation language. As we shall see later, however, the most powerful target compilation languages are not suitable for humans to specify or interpret directly."
    }, {
      "heading" : "Decomposability",
      "text" : "not qualify as a target compilation language unless P=NP (Papadimitriou, 1994), but many of its subsets do. We define a number of these subsets below, each of which is obtained by imposing further conditions on NNF.\nWe will distinguish between two key subsets of NNF: flat and nested subsets. We first consider flat subsets, which result from imposing combinations of the following properties:\n• Flatness: The height of each sentence is at most 2. The sentence in Figure 3 is flat, but the one in Figure 1 is not.\n• Simple-disjunction: The children of each or-node are leaves that share no variables (the node is a clause).\n• Simple-conjunction: The children of each and-node are leaves that share no variables (the node is a term). The sentence in Figure 3 satisfies this property.\nDefinition 2.2 The language f-NNF is the subset of NNF satisfying flatness. The language CNF is the subset of f-NNF satisfying simple–disjunction. The language DNF is the subset of f-NNF satisfying simple–conjunction.\nCNF does not permit a polytime clausal entailment test (unless P=NP) and, hence, does not qualify as a target compilation language. But its dual DNF does.\nThe following subset of CNF, prime implicates, has been quite influential in computer science:\nDefinition 2.3 The language PI is the subset of CNF in which each clause entailed by the sentence is subsumed by a clause that appears in the sentence; and no clause in the sentence is subsumed by another.\nA dual of PI, prime implicants IP, can also be defined.\nDefinition 2.4 The language IP is the subset of DNF in which each term entailing the sentence subsumes some term that appears in the sentence; and no term in the sentence is subsumed by another term.\nThere has been some work on representing the set of prime implicates of a propositional theory in a compact way, allowing an exponential number of prime implicates to be represented in polynomial space in certain cases—see for example the TRIE representation in (de Kleer, 1992), the ZBDD representation used in (Simon & del Val, 2001), and the implicit representation based on metaproducts, as proposed in (Madre & Coudert, 1992). These representations are different from the language PI in the sense that they do not necessarily support the same queries and transformations\nthat we report in Tables 5 and 7. They also exhibit different succinctness relationships than the ones we report in Table 3.\nHorn theories (and renamable Horn theories) represent another target compilation subset of CNF, but we do not consider it here since we restrict our attention to complete languages L only, i.e., we require that every propositional sentence is logically equivalent to an element of L.\nWe now consider nested subsets of the NNF language, which do not impose any restriction on the height of a sentence. Instead, these subsets result from imposing one or more of the following conditions: decomposability, determinism, smoothness, decision, and ordering. We start by defining the first three properties. From here on, if C is a node in an NNF, then Vars(C) denotes the set of all variables that label the descendants of node C. Moreover, if Σ is an NNF sentence rooted at C, then Vars(Σ) is defined as Vars(C).\n• Decomposability (Darwiche, 1999, 2001a). An NNF satisfies this property if for each conjunction C in the NNF, the conjuncts of C do not share variables. That is, if C1, . . . , Cn are the children of and-node C, then Vars(Ci) ∩ Vars(Cj) = ∅ for i 6= j. Consider the and-node marked in Figure 1(a). This node has two children, the first contains variables A,B while the second contains variables C,D. This and-node is then decomposable since the two children do not share variables. Each other and-node in Figure 1(a) is also decomposable and, hence, the NNF in this figure is decomposable.\n• Determinism (Darwiche, 2001b): An NNF satisfies this property if for each disjunction C in the NNF, each two disjuncts of C are logically contradictory. That is, if C1, . . . , Cn are the children of or-node C, then Ci ∧ Cj |= false for i 6= j. Consider the or-node marked in Figure 1(b), which has two children corresponding to sub-sentences ¬A ∧ B and ¬B ∧ A. The conjunction of these two sub-sentences is logically contradictory. The or-node is then deterministic and so are the other or-nodes in Figure 1(b). Hence, the NNF in this figure is deterministic.\n• Smoothness (Darwiche, 2001b): An NNF satisfies this property if for each disjunction C in the NNF, each disjunct of C mentions the same variables. That is, if C1, . . . , Cn are the children of or-node C, then Vars(Ci) = Vars(Cj) for i 6= j. Consider the marked or-node in Figure 1(c). This node has two children, each of which mentions variables A,B. This or-node is then smooth and so are the other or-nodes in Figure 1(c). Hence, the NNF in this figure is smooth.\nIt is hard to ensure decomposability. It is also hard to ensure determinism while preserving decomposability. Yet any sentence in NNF can be smoothed in polytime, while preserving decomposability and determinism. Preserving flatness, however, may blow-up the size of given NNF. Hence, smoothness is not that important from a complexity viewpoint unless we have flatness.\nThe properties of decomposability, determinism and smoothness lead to a number of interesting subsets of NNF.\nDefinition 2.5 The language DNNF is the subset of NNF satisfying decomposability; d-NNF is the subset satisfying determinism; s-NNF is the subset satisfying smoothness; d-DNNF is the subset satisfying decomposability and determinism; and sd-DNNF is the subset satisfying decomposability, determinism and smoothness.\nNote that DNF is a strict subset of DNNF (Darwiche, 1999, 2001a). The following decision property comes from the literature on binary decision diagrams (Bryant, 1986).\nDefinition 2.6 (Decision) A decision node N in an NNF sentence is one which is labeled with true, false, or is an or-node having the form (X ∧ α) ∨ (¬X ∧ β), where X is a variable, α and β are decision nodes. In the latter case, dVar(N) denotes the variable X.\nDefinition 2.7 The language BDD is the set of NNF sentences, where the root of each sentence is a decision node.\nThe NNF sentence in Figure 2 belongs to the BDD subset. The BDD language corresponds to binary decision diagrams (BDDs), as known in the formal verification literature (Bryant, 1986). Binary decision diagrams are depicted using a more compact notation though: the labels true and false are denoted by 1 and 0, respectively; and each decision\nnode X ¬Xα β and\nor\nand\nis denoted by α β\nX\n. The BDD sentence on the left of Figure 2 corresponds to the binary decision diagram on the right of Figure 2. Obviously enough, every NNF sentence that satisfies the decision property is also deterministic. Therefore, BDD is a subset of d-NNF.\nAs we show later, BDD does not qualify as a target compilation language (unless P=NP), but the following subset does.\nDefinition 2.8 FBDD is the intersection of DNNF and BDD.\nThat is, each sentence in FBDD is decomposable and satisfies the decision property. The FBDD language corresponds to free binary decision diagrams (FBDDs), as known in formal verification (Gergov & Meinel, 1994a). An FBDD is usually defined as a BDD that satisfies the read-once property: on each path from the root to a leaf, a variable can appear at most once. FBDDs are also known as read-once branching programs in the theory literature. Imposing the read-once property on a BDD is equivalent to imposing the decomposability property on its corresponding BDD sentence.\nA more influential subset of the BDD language is obtained by imposing the ordering property:\nDefinition 2.9 (Ordering) Let < be a total ordering on the variables PS. The language OBDD< is the subset of FBDD satisfying the following property: if N and M are or-nodes, and if N is an ancestor of node M , then dVar(N) < dVar(M).\nDefinition 2.10 The language OBDD is the union of all OBDD< languages.\nThe OBDD language corresponds to the well–known ordered binary decision diagrams (OBDDs) (Bryant, 1986).\nOur final language definition is as follows:\nDefinition 2.11 MODS is the subset of DNF where every sentence satisfies determinism and smoothness.\nFigure 3 depicts a sentence in MODS. As we show later, MODS is the most tractable NNF subset we shall consider (together with OBDD<). This is not surprising since from the syntax of a sentence in MODS, one can immediately recover the sentence models.\nThe languages we have discussed so far are depicted in Figure 4, where arrows denote set inclusion. Table 1 lists the acronyms of all of these languages, together with their descriptions. Table 2 lists the key language properties discussed in this section, together with a short description of each."
    }, {
      "heading" : "3. On the Succinctness of Compiled Theories",
      "text" : "We have discussed more than a dozen subsets of the NNF language. Some of these subsets are well known and have been studied extensively in the computer science literature. Others, such as DNNF (Darwiche, 2001a, 1999) and d-DNNF (Darwiche, 2001b), are relatively new. The question now is: What subset should one adopt for a particular application? As we argue in this paper, that depends\non three key properties of the language: its succinctness, the class of tractable queries it supports, and the class of tractable transformations it admits.\nOur goal in this and the following sections is to construct a map on which we place different subsets of the NNF language according to the above criteria. This map will then serve as a guide to system designers in choosing the target compilation language most suitable to their application. It also provides an example paradigm for studying and evaluating further target compilation languages. We start with a study of succinctness2 in this section (Gogic, Kautz, Papadimitriou, & Selman, 1995).\nDefinition 3.1 (Succinctness) Let L1 and L2 be two subsets of NNF. L1 is at least as succinct as L2, denoted L1 ≤ L2, iff there exists a polynomial p such that for every sentence α ∈ L2, there exists an equivalent sentence β ∈ L1 where |β| ≤ p(|α|). Here, |α| and |β| are the sizes of α and β, respectively.\nWe stress here that we do not require that there exists a function that computes β given α in polytime; we only require that a polysize β exists. Yet, our proofs in Appendix A contain specific algorithms for computing β from α in certain cases. The relation ≤ is clearly reflexive and transitive, hence, a pre-ordering. One can also define the relation <, where L1 < L2 iff L1 ≤ L2 and L2 6≤ L1.\nProposition 3.1 The results in Table 3 hold.\nAn occurrence of ≤ in the cell of row r and column c of Table 3 means that the fragment Lr given at row r is at least as succinct as the fragment Lc given at column c. An occurrence of 6≤ (or 6≤∗) means that Lr is not at least as succinct as Lc (provided that the polynomial hierarchy does not collapse in the case of 6≤∗). Finally, the presence of a question mark reflects our ignorance about whether Lr is at least as succinct as Lc. Figure 5 summarizes the results of Proposition 3.1 in terms of a directed acyclic graph.\nA classical result in knowledge compilation states that it is not possible to compile any propositional formula α into a polysize data structure β such that: α and β entail the same set of clauses, and clausal entailment on β can be decided in time polynomial in its size, unless NP ⊆ P/poly (Selman & Kautz, 1996; Cadoli & Donini, 1997). This last assumption implies the collapse of the polynomial hierarchy at the second level (Karp & Lipton, 1980), which is considered very unlikely. We use this classical result from knowledge compilation in some of our proofs of Proposition 3.1, which explains why some of its parts are conditioned on the polynomial hierarchy not collapsing.\nWe have excluded the subsets BDD, s-NNF, d-NNF and f-NNF from Table 3 since they do not qualify as target compilation languages (see Section 4). We kept NNF and CNF though given their importance. Consider Figure 5 which depicts Table 3 graphically. With the exception of NNF and CNF, all other languages depicted in Figure 5 qualify as target compilation languages. Moreover, with the exception of language PI, DNNF is the most succinct among all target compilation languages—we know that PI is not more succinct than DNNF, but we do not know whether DNNF is more succinct than PI.\nIn between DNNF and MODS, there is a succinctness ordering of target compilation languages:\nDNNF < d-DNNF < FBDD < OBDD < OBDD< < MODS.\nDNNF is obtained by imposing decomposability on NNF; d-DNNF by adding determinism; FBDD by adding decision; and OBDD and OBDD< by adding ordering (w.r.t. any total ordering on PS in the first case and a specific one in the second case). Adding each of these properties reduces language succinctness (assuming that the polynomial hierarchy does not collapse).\nOne important fact to stress here is that adding smoothness to d-DNNF does not affect its succinctness: the sd-DNNF and d-DNNF languages are equally succinct. It is also interesting to compare\n2. A more general notion of space efficiency (model preservation for polysize reductions) exists (Cadoli, Donini, Liberatore, & Schaerf, 1996), but we do not need its full generality here.\nsd-DNNF (which is more succinct than the influential FBDD, OBDD and OBDD< languages) with MODS, which is a most tractable language. Both sd-DNNF and MODS are smooth, deterministic and decomposable. MODS, however, is flat and obtains its decomposability from the stronger condition of simple-conjunction. Therefore, sd-DNNF can be viewed as the result of relaxing from MODS the flatness and simple-conjunction conditions, while maintaining decomposability, determinism and smoothness. Relaxing these conditions moves the language three levels up the succinctness hierarchy, although it compromises only the polytime test for sentential entailment and possibly the one for equivalence as we show in Section 4."
    }, {
      "heading" : "4. Querying a Compiled Theory",
      "text" : "In evaluating the suitability of a target compilation language to a particular application, the succinctness of the language must be balanced against the set of queries and transformations that it supports in polytime. We consider in this section a number of queries, each of which returns valuable information about a propositional theory, and then identify target compilation languages which provide polytime algorithms for answering such queries. We restrict our attention in this paper to the existence of polytime algorithms for answering queries, but we do not present the algorithms themselves. The interested reader is referred to (Darwiche, 2001a, 2001b, 1999; Bryant, 1986) for some of these algorithms and to the proofs of theorems in Appendix A for others.\nThe queries we consider are tests for consistency, validity, implicates (clausal entailment), implicants, equivalence, and sentential entailment. We also consider counting and enumerating theory models; see Table 4. One can also consider computing the probability of a propositional sentence, assuming that all variables are probabilistically independent. For the subsets we consider, however, this can be done in polytime whenever models can be counted in polytime.\nFrom here on, L denotes a subset of language NNF.\nDefinition 4.1 (CO, VA) L satisfies CO (VA) iff there exists a polytime algorithm that maps every formula Σ from L to 1 if Σ is consistent (valid), and to 0 otherwise.\nOne of the main applications of compiling a theory is to enhance the efficiency of answering clausal entailment queries:\nDefinition 4.2 (CE) L satisfies CE iff there exists a polytime algorithm that maps every formula Σ from L and every clause γ from NNF to 1 if Σ |= γ holds, and to 0 otherwise.\nA key application of clausal entailment is in testing equivalence. Specifically, suppose we have a design expressed as a set of clauses ∆d = ∧\ni αi and a specification expressed also as a set of clauses ∆s = ∧\nj βj , and we want to test whether the design and specification are equivalent. By compiling\neach of ∆d and ∆s to targets Γd and Γs that support a polytime clausal entailment test, we can test the equivalence of ∆d and ∆s in polytime. That is, ∆d and ∆s are equivalent iff Γd |= βj for all j and Γs |= αi for all i.\nA number of the target compilation languages we shall consider support a direct polytime equivalent test:\nDefinition 4.3 (EQ, SE) L satisfies EQ (SE) iff there exists a polytime algorithm that maps every pair of formulas Σ, Φ from L to 1 if Σ ≡ Φ (Σ |= Φ) holds, and to 0 otherwise.\nNote that sentential entailment (SE) is stronger than clausal entailment and equivalence. Therefore, if a language L satisfies SE, it also satisfies CE and EQ.\nFor completeness, we consider the following dual to CE:\nDefinition 4.4 (IM) L satisfies IM iff there exists a polytime algorithm that maps every formula Σ from L and every term γ from NNF to 1 if γ |= Σ holds, and to 0 otherwise.\nFinally, we consider counting and enumerating models:\nDefinition 4.5 (CT) L satisfies CT iff there exists a polytime algorithm that maps every formula Σ from L to a nonnegative integer that represents the number of models of Σ (in binary notation).\nDefinition 4.6 (ME) L satisfies ME iff there exists a polynomial p(., .) and an algorithm that outputs all models of an arbitrary formula Σ from L in time p(n,m), where n is the size of Σ and m is the number of its models (over variables occurring in Σ).\nTable 4 summarizes the queries we are interested in and their acronyms. The following proposition states what we know about the availability of polytime algorithms for\nanswering the above queries, with respect to all languages we introduced in Section 2.\nProposition 4.1 The results in Table 5 hold.\nThe results of Proposition 4.1 are summarized in Figure 4. One can draw a number of conclusions based on the results in this figure. First, NNF, s-NNF, d-NNF, f-NNF, and BDD fall in one equivalence class that does not support any polytime queries and CNF satisfies only VA and IM; hence, none of them qualifies as a target compilation language in this case. But the remaining languages all support polytime tests for consistency and clausal entailment. Therefore, simply imposing either of smoothness (s-NNF), determinism (d-NNF), flatness (f-NNF), or decision (BDD) on the NNF language does not lead to tractability with respect to any of the queries we consider—neither of these properties seem to be significant in isolation. Decomposability (DNNF), however, is an exception and leads immediately to polytime tests for both consistency and clausal entailment, and to a polytime algorithm for model enumeration.\nRecall the succinctness ordering DNNF < d-DNNF < FBDD < OBDD < OBDD< < MODS from Figure 5. By adding decomposability (DNNF), we obtain polytime tests for consistency and clausal entailment, in addition to a polytime model enumeration algorithm. By adding determinism to decomposability (d-DNNF), we obtain polytime tests for validity, implicant and model counting, which are quite significant. It is not clear, however, whether the combination of decomposability and determinism leads to a polytime test for equivalence. Moreover, adding the decision property on top of decomposability and determinism (FBDD) does not appear to increase tractability with respect to the given queries3, although it does lead to reducing language succinctness as shown in Figure 5. On the other hand, adding the ordering property on top of decomposability, determinism and decision, leads to polytime tests for equivalence (OBDD and OBDD<) as well as sentential entailment provided that the ordering < is fixed (OBDD<).\nAs for the succinctness ordering NNF < DNNF < DNF < IP < MODS from Figure 5, note that DNNF is obtained by imposing decomposability on NNF, while DNF is obtained by imposing flatness and simple-conjunction (which is stronger than decomposability). What is interesting is that DNF is less succinct than DNNF, yet does not support any more polytime queries; see Figure 4. However, the addition of smoothness (and determinism) on top of flatness and simple-conjunction (MODS) leads to five additional polytime queries, including equivalence and entailment tests.4\nWe close this section by noting that determinism appears to be necessary (but not sufficient) for polytime model counting: only deterministic languages, d-DNNF, sd-DNNF, FBDD, OBDD, OBDD< and MODS, support polytime counting. Moreover, polytime counting implies a polytime test of validity, but the opposite is not true."
    }, {
      "heading" : "5. Transforming a Compiled Theory",
      "text" : "A query is an operation that returns information about a theory without changing it. A transformation, on the other hand, is an operation that returns a modified theory, which is then operated on using queries. Many applications require a combination of transformations and queries.\nDefinition 5.1 (∧C,∨C) Let L be a subset of NNF. L satisfies ∧C (∨C) iff there exists a polytime algorithm that maps every finite set of formulas Σ1, . . . ,Σn from L to a formula of L that is logically equivalent to Σ1 ∧ . . . ∧ Σn (Σ1 ∨ . . . ∨ Σn).\nDefinition 5.2 (¬C) Let L be a subset of NNF. L satisfies ¬C iff there exists a polytime algorithm that maps every formula Σ from L to a formula of L that is logically equivalent to ¬Σ.\nIf a language satisfies one of the above properties, we will say that it is closed under the corresponding operator. Closure under logical connectives is important for two key reasons. First, it has implications on how compilers are constructed for a given target language. For example, if a clause can be easily compiled into some language L, then closure under conjunction implies that compiling a CNF sentence into L is easy. Second, it has implications on the class of polytime queries supported by the target language: If a language L satisfies CO and is closed under negation and conjunction, then it must satisfy SE (to test whether ∆ |= Γ, all we have to do, by the Refutation Theorem, is test whether ∆ ∧ ¬Γ is inconsistent). Similarly, if a language satisfies VA and is closed under negation and disjunction, it must satisfy SE by the Deduction Theorem.\n3. Deciding the equivalence of two sentences in FBDD, d-DNNF, or in sd-DNNF, can be easily shown to be in coNP. However, we do not have a proof of coNP-hardness, nor do we have deterministic polytime algorithms for deciding these problems. Actually, the latter case is quite unlikely as the equivalence problem for FBDD has been intensively studied, with no such algorithm in sight. Note, however, that the equivalence of two sentences in FBDD can be decided probabilistically in polytime (Blum, Chandra, & Wegman, 1980), and similarly for sentences in d-DNNF (Darwiche & Huang, 2002). 4. Given flatness, simple-conjunction and smoothness, we can obtain determinism by simply removing duplicated terms.\nIt is important to stress here that some languages are closed under a logical operator, only if the number of operands is bounded by a constant. We will refer to this as bounded closure.\nDefinition 5.3 (∧BC,∨BC) Let L be a subset of NNF. L satisfies ∧BC (∨BC) iff there exists a polytime algorithm that maps every pair of formulas Σ and Φ from L to a formula of L that is logically equivalent to Σ ∧ Φ (Σ ∨ Φ).\nWe now turn to another important transformation:\nDefinition 5.4 (Conditioning) (Darwiche, 1999) Let Σ be a propositional formula, and let γ be a consistent term. The conditioning of Σ on γ, noted Σ | γ, is the formula obtained by replacing each variable X of Σ by true (resp. false) if X (resp. ¬X) is a positive (resp. negative) literal of γ.\nDefinition 5.5 (CD) Let L be a subset of NNF. L satisfies CD iff there exists a polytime algorithm that maps every formula Σ from L and every consistent term γ to a formula from L that is logically equivalent to Σ | γ.\nConditioning has a number of applications, and corresponds to restriction in the literature on Boolean functions. The main application of conditioning is due to a theorem, which says that Σ∧ γ is consistent iff Σ | γ is consistent (Darwiche, 2001a, 1999). Therefore, if a language satisfies CO and CD, then it must also satisfy CE. Conditioning also plays a key role in building compilers that enforce decomposability. If two sentences ∆1 and ∆2 are both decomposable (belong to DNNF), their conjunction ∆1 ∧ ∆2 is not necessarily decomposable since the sentences may share variables. Conditioning can be used to ensure decomposability in this case since ∆1 ∧ ∆2 is equivalent to ∨\nγ(∆1 | γ) ∧ (∆2 | γ) ∧ γ, where γ is a term covering all variables shared by ∆1 and ∆2. Note that ∨\nγ(∆1 | γ) ∧ (∆2 | γ) ∧ γ must be decomposable since ∆1 | γ and ∆2 | γ do not mention variables in γ. The previous proposition is indeed a generalization to multiple variables of the well-known Shannon expansion in the literature on Boolean functions. It is also the basis for compiling CNF into DNNF (Darwiche, 1999, 2001a).\nAnother critical transformation we shall consider is that of forgetting (also referred to as marginalization, or elimination of middle terms (Boole, 1854)):\nDefinition 5.6 (Forgetting) Let Σ be a propositional formula, and let X be a subset of variables from PS. The forgetting of X from Σ, denoted ∃X.Σ, is a formula that does not mention any variable from X and for every formula α that does not mention any variable from X, we have Σ |= α precisely when ∃X.Σ |= α.\nTherefore, to forget variables from X is to remove any reference to X from Σ, while maintaining all information that Σ captures about the complement of X. Note that ∃X.Σ is unique up to logical equivalence.\nDefinition 5.7 (FO, SFO) Let L be a subset of NNF. L satisfies FO iff there exists a polytime algorithm that maps every formula Σ from L and every subset X of variables from PS to a formula from L equivalent to ∃X.Σ. If the property holds for singleton X, we say that L satisfies SFO.\nForgetting is an important transformation as it allows us to focus/project a theory on a set of variables. For example, if we know that some variables X will never appear in entailment queries, we can forget these variables from the compiled theory while maintaining its ability to answer such queries correctly. Another application of forgetting is in counting/enumerating the instantiations of some variables Y, which are consistent with a theory ∆. This query can be answered by counting/enumerating the models of ∃X.∆, where X is the complement of Y. Forgetting also has applications to planning, diagnosis and belief revision. For instance, in the SATPLAN framework,\ncompiling away fluents or actions amounts to forgetting variables. In model-based diagnosis, compiling away every variable except the abnormality ones does not remove any piece of information required to compute the conflicts and the diagnoses of a system (Darwiche, 2001a). Forgetting has also been used to design update operators with valuable properties (Herzig & Rifi, 1999).\nTable 6 summarizes the transformations we are interested in and their acronyms. The following proposition states what we know about the tractability of these transformations with respect to the identified target compilation languages.\nProposition 5.1 The results in Table 7 hold.\nOne can draw a number of observations regarding Table 7. First, all languages we consider satisfy CD and, hence, lend themselves to efficient application of the conditioning transformation. As for forgetting multiple variables, only DNNF, DNF, PI and MODS permit that in polytime. It is important to stress here that none of FBDD, OBDD and OBDD< permits polytime forgetting of multiple variables. This is noticeable since some of the recent applications of OBDD< to planning—within the so-called symbolic model checking approach to planning (A. Cimmati & Traverso, 1997)—depend crucially\non the operation of forgetting and it may be more suitable to use a language that satisfies FO in this case. Note, however, that OBDD and OBDD< allow the forgetting of a single variable in polytime, but FBDD does not allow even that. d-DNNF is similar to FBDD as it satisfies neither FO nor SFO.\nIt is also interesting to observe that none of the target compilation languages is closed under conjunction. A number of them, however, are closed under bounded conjunction, including OBDD<, DNF, IP and MODS.\nAs for disjunction, the only target compilation languages that are closed under disjunction are DNNF and DNF. The OBDD< and PI languages, however, are closed under bounded disjunction. Again, the d-DNNF, FBDD and OBDD languages are closed under neither.\nThe only target compilation languages that are closed under negation are FBDD, OBDD and OBDD<, while it is not known whether d-DNNF or sd-DNNF are closed under this operation. Note that d-DNNF and FBDD support the same set of polytime queries (equivalence checking is unknown for both) so they are indistinguishable from that viewpoint. Moreover, the only difference between the two languages in Table 7 is the closure of FBDD under negation, which does not seem to be that significant in light of no closure under either conjunction or disjunction. Note, however, that d-DNNF is more succinct than FBDD as given in Figure 5.\nFinally, OBDD< is the only target compilation language that is closed under negation, bounded conjunction, and bounded disjunction. This closure actually plays an important role in compiling propositional theories into OBDD< and is the basis of state-of-the-art compilers for this purpose (Bryant, 1986)."
    }, {
      "heading" : "6. Conclusion",
      "text" : "The main contribution of this paper is a methodology for analyzing propositional compilation approaches according to two key dimensions: the succinctness of the target compilation language, and the class of queries and transformations it supports in polytime. The second main contribution of the paper is a comprehensive analysis, according to the proposed methodology, of more than a dozen languages for which we have produced a knowledge compilation map, which cross-ranks these languages according to their succinctness, and the polytime queries and transformations they support. This map allows system designers to make informed decisions on which target compilation language to use: after the class of queries/transformations have been decided based on the application of interest, the designer chooses the most succinct target compilation language that supports such operations in polytime. Another key contribution of this paper is the uniform treatment we have applied to diverse target compilation languages, showing how they all are subsets of the NNF language. Specifically, we have identified a number of simple, yet meaningful, properties, including decomposability, determinism, decision and flatness, and showed how combinations of these properties give rise to different target compilation languages. The studied subsets include some well known languages such as PI, which has been influential in AI; OBDD<, which has been influential in formal verification; and CNF and DNF, which have been quite influential in computer science. The subsets also include some relatively new languages such as DNNF and d-DNNF, which appear to represent interesting, new balances between language succinctness and query/transformation tractability."
    }, {
      "heading" : "Acknowledgments",
      "text" : "This is a revised and extended version of the paper “A Perspective on Knowledge Compilation,” in Proceedings of the 17th International Joint Conference on Artificial Intelligence (IJCAI’01), pp. 175-182, 2001. We wish to thank Alvaro del Val, Mark Hopkins, Jérôme Lang and the anonymous reviewers for some suggestions and comments, as well as Ingo Wegener for his help with some of the issues discussed in the paper. This work has been done while the second author was a visiting researcher with the Computer Science Department at UCLA. The first author has been partly\nsupported by NSF grant IIS-9988543 and MURI grant N00014-00-1-0617. The second author has been partly supported by the IUT de Lens, the Université d’Artois, the Nord/Pas-de-Calais Région under the TACT-TIC project, and by the European Community FEDER Program."
    }, {
      "heading" : "Appendix A. Proofs",
      "text" : "To simplify the proofs of our main propositions later on, we have identified a number of lemmas that we list below. Some of the proofs of these lemmas are direct, but we include them for completeness.\nLemma A.1 Every sentence in d-DNNF can be translated to an equivalent sentence in sd-DNNF in polytime.\nProof: Let α = α1 ∨ . . .∨ αn be an or-node in a d-DNNF sentence Σ. Suppose that α is not smooth and let V = Vars(α). Consider now the sentence Σs obtained by replacing in Σ each such node by\n∨n i=1 αi ∧ ∧ v∈V \\Vars(αi) (¬v ∨ v). Then Σs is equivalent to Σ and is smooth. Moreover, Σs can be computed in time polynomial in the size of Σ and it satisfies decomposability and determinism. ✷\nLemma A.2 Every sentence in FBDD can be translated to an equivalent sentence in FBDD ∩ s-NNF in polytime.\nProof: Let Σ be a sentence in FBDD and let α be a node in Σ. We can always replace α with (Y ∧α)∨ (¬Y ∧ α), for some variable Y , while preserving equivalence and the decision property. Moreover, as long as the variable Y does not appear in α and is not an ancestor of α, then decomposability is also preserved (that is, the resulting sentence is in FBDD). Note here that “ancestor” is with respect to the binary decision diagram notation of Σ–see left of Figure 2.\nNow, suppose that (X ∧ α) ∨ (¬X ∧ β) is an or-node in Σ. Suppose further that the or-node is not smooth. Hence, there is some Y which appears in Vars(β) but not in Vars(α) (or the other way around). Since Σ is decomposable, then Y cannot be an ancestor of α (since in that case it would also be an ancestor of β, which is impossible by decomposability of Σ). Hence, we can replace α with (Y ∧ α) ∨ (¬Y ∧ α), while preserving equivalence, decision and decomposability. By repeating the above process, we can smooth Σ while preserving all the necessary properties. Finally, note that for every or-node (X ∧ α) ∨ (¬X ∧ β) in Σ, we need to repeat the above process at most | Vars(α) − Vars(β) | + | Vars(β) − Vars(α) | times. Hence, the smoothing operation can be performed in polytime. ✷\nLemma A.3 If a subset L of NNF satisfies CO and CD, then it also satisfies ME.\nProof: Let Σ be a sentence in L. First, we test if Σ is inconsistent (can be done in polytime). If it is, we return the empty set of models. Otherwise, we construct a decision-tree representation of the models of Σ. Given an ordering of the variables x1, . . . , xn of Vars(Σ), we start with a tree T consisting of a single root node. For i = 1 to n, we repeat the following for each leaf node α (corresponds to a consistent term) in T :\na. If Σ | α ∧ xi is consistent, we add xi as a child to α;\nb. If Σ | α ∧ ¬xi is consistent, we add ¬xi as a child to α.\nThe key points are:\n• Test (a) and Test (b) can be performed in time polynomial in the size of Σ (since L satisfies CO and CD).\n• Either Test (a) or Test (b) above must succeed (since Σ is consistent). Hence, the number of tests performed is O(mn), where m is the number of leaf nodes in the final decision tree (bounded by the number of models of Σ) and n is the number of variables of Σ. ✷\nLemma A.4 If a subset of NNF satisfies CO and CD, then it also satisfies CE.\nProof: To test whether sentence Σ entails non-valid clause α, Σ |= α, it suffices to test whether Σ | ¬α is inconsistent (Darwiche, 2001a). ✷\nLemma A.5 Let α and β be two sentences that share no variables. Then α∨β is valid iff α is valid or β is valid.\nProof: α∨ β is valid iff ¬α∧¬β is inconsistent. Since ¬α and ¬β share no variables, then ¬α∧¬β is inconsistent iff ¬α is inconsistent or ¬β is. This is true iff α is valid or β is valid. ✷\nLemma A.6 Let Σ be a sentence in d-DNNF and let γ be a clause. Then a sentence in d-DNNF which is equivalent to Σ ∨ γ can be constructed in polytime in the size of Σ and γ.\nProof: Let l1, . . . , ln be the literals that appear in clause γ. Then β = ∨n i=1(li ∧ ∧i−1 j=1 ¬lj) is equivalent to clause γ, is in d-DNNF, and can be constructed in polytime in size of γ. Now let α be the term equivalent to ¬γ. We have that Σ ∨ γ is equivalent to ((Σ | α) ∧ α) ∨ β. The last sentence is in d-DNNF and can be constructed in polytime in size of Σ and γ. ✷\nLemma A.7 If a subset of NNF satisfies VA and CD, then it also satisfies IM.\nProof: To test whether a consistent term α entails sentence Σ, α |= Σ, it suffices to test whether ¬α∨Σ is valid. This sentence is equivalent to ¬α∨(α∧Σ), to ¬α∨(α∧(Σ | α)), and to ¬α∨(Σ | α). Since ¬α and Σ | α share no variables, the disjunction is valid iff ¬α is valid or Σ | α is valid (by Lemma A.5). ¬α cannot be valid since α is consistent. Σ | α can be constructed in polytime since the language satisfies CD and its validity can be tested in polytime since the language satisfies VA. ✷\nLemma A.8 Every CNF or DNF formula can be translated to an equivalent sentence in BDD in polytime.\nProof: It is straightforward to convert a clause or term into an equivalent sentence in BDD. In order to generate a BDD sentence corresponding to the conjunction (resp. disjunction) of BDD sentences α and β, it is sufficient to replace the 1-sink (resp. 0-sink) of α with the root of β. ✷\nLemma A.9 If a subset of NNF satisfies EQ, then it satisfies CO and VA.\nProof: true and false belong to every NNF subset. Σ is inconsistent iff it is equivalent to false. Σ is valid iff it is equivalent to true. ✷\nLemma A.10 If a subset of NNF satisfies SE, then it satisfies EQ, CO and VA.\nProof: Sentences Σ1 and Σ2 are equivalent iff Σ1 |= Σ2 and Σ2 |= Σ1. EQ implies CO and VA (Lemma A.9). ✷\nLemma A.11 Let Σ be a sentence in d-DNNF and let γ be a clause. The validity of Σ ∨ γ can be tested in time polynomial in the size of Σ and γ.\nProof: Construct Σ ∨ γ in polytime as given in Lemma A.6 and check its validity, which can be done in polytime too. ✷\nLemma A.12 For every propositional formula Σ and every consistent term γ, we have Σ|γ is equivalent to ∃Vars(γ).(Σ ∧ γ).\nProof: Without loss of generality, assume that Σ is given by the disjunctively-interpreted set of its models (over Vars(Σ)). Conditioning Σ on γ leads (1) to removing every model of ¬γ, then (2) projecting the remaining models so that every variable of γ is removed. Conjoining Σ with γ leads exactly to (1), while forgetting every variable of γ in the resulting formula leads exactly to (2) (Lang, Liberatore, & Marquis, 2000). ✷\nLemma A.13 Each sentence Σ in f-NNF can be converted into an equivalent sentence Σ∗ in polynomial time, where Σ∗ ∈ CNF or Σ∗ ∈ DNF.\nProof: We consider three cases for the sentence Σ:\n1. The root node of Σ is an and-node. In this case, Σ can be turned into a CNF sentence Σ∗ in polynomial time by simply ensuring that each or-node in Σ is a clause (that is, a disjunction of literals that share no variables). Let C be an or-node in Σ. Since Σ is flat and its root is an and-node, C must be a child of the root of Σ and the children of C must be leaves. Hence, we can easily ensure that C is a clause as follows:\n• If we have one edge from C to some leaf X and another edge from C to ¬X (C is valid), we replace the edge from the root to C by an edge from the root to true.\n• If we have more than one edge from C to the same leaf node X, we keep only one of these edges and delete the rest.\n2. The root of Σ is an or-node. Σ can be turned into a DNF sentence Σ∗ in a dual way.5\n3. The root of Σ is a leaf node. Σ is already a CNF sentence.\n✷\nLemma A.14 α is a prime implicant (resp. an essential prime implicant) of sentence Σ iff ¬α is a prime implicate (resp. an essential prime implicate) of ¬Σ. 6\nProof: This is a folklore result, immediate from the definitions. ✷"
    }, {
      "heading" : "Proof of Proposition 3.1",
      "text" : "The proof of this proposition is broken down into eight steps. In each step, we prove a number of succinctness relationships between different languages, and then apply transitivity of the succinctness relation to infer even more relationships. Associated with each step of the proof is a table in which\nwe mark all relationships that are proved in that step–we don’t show these marks in the very first table though.\nTable 8: Follows immediately from the language inclusions reported in Figure 4. Table 9: We can prove both that DNF 6≤ PI and CNF 6≤ IP (this slightly generalizes the results\nDNF 6≤ CNF and CNF 6≤ DNF given in (Gogic et al., 1995)). Let us consider the CNF formula Σn = ∧n−1 i=0 (x2i ∨ x2i+1). This formula is in prime implicates form7 (and each clause in Σn is an essential prime implicate of it). Hence its negation ¬Σn is in prime implicants form (as an easy consequence of Lemma A.14).\nSince Quine’s early work (Quine, 1959), we know that the number of essential prime implicants (resp. prime implicates) of a formula is a lower bound of the number of terms (resp. clauses) that can be found in any DNF (resp. CNF) representation of it (indeed, any such representation must include the essential prime). Σn has 2\nn essential prime implicants. Indeed, this can be easily shown by induction on n given that (i) every literal occurring in Σn occurs only once, (ii) the set of prime implicants of any nontautological clause is the set of literals occurring in it (up to logical equivalence), and (iii) the distribution property for prime implicants (see e.g., (dual of) Proposition 40 in (Marquis, 2000)) which states that IP(α∧β) = max({PIα∧PIβ | PIα ∈ IP(α), PIβ ∈ IP(β)}, |=) (up to logical equivalence). Subsequently, ¬Σn has 2n essential prime implicates (cf. Lemma A.14). Accordingly, we obtain that both DNF 6≤ PI and CNF 6≤ IP. We also obtain PI 6≤ IP and IP 6≤ PI. Now, it is well–known that some DNF formulas have exponentially many prime implicants (see the proof of Proposition 5.1 where we show that IP does not satisfy SFO). Hence, their negations are CNF\n5. Note that f-NNF satisfies ¬C and that the negation of a CNF sentence (resp. DNF sentence) can be turned into a DNF (resp. CNF) in linear time. 6. A prime implicant (resp. a prime implicate) α of Σ is essential iff the disjunction (resp. conjunction) of all prime implicants (resp. prime implicates) of Σ except α is not equivalent to Σ. 7. The correctness of (the dual of) Quine’s consensus algorithm for computing prime implicants (Quine, 1955) ensures it, since no clause of Σn is subsumed by another clause and no consensi can be performed since there are no negated variables.\nformulas having exponentially many prime implicates. Subsequently IP 6≤ DNF and PI 6≤ CNF. The remaining results in this table follow from the transitivity of ≤.\nTable 10: The parity function On = ⊕n−1\ni=0 xi has linear size OBDD< representations (Bryant,\n1986) but only exponential size CNF and DNF representations. The reason is that On has 2 n essential prime implicants (resp. essential prime implicates) and the number of essential prime implicants (resp. essential prime implicates) of a formula is a lower bound of the size of any of its DNF (resp. CNF) representation. This easily shows that both CNF 6≤ OBDD and DNF 6≤ OBDD. The remaining results in this table follow from the language inclusions reported in Figure 4.\nTable 11: It is shown in (Darwiche, 2001b) that there is a sentence in d-DNNF which only has exponential FBDD representations. Accordingly, we have FBDD 6≤ d-DNNF. In (Gergov & Meinel, 1994a), it is shown that OBDD 6≤ FBDD. Finally, it is easy to show that OBDD< 6≤ OBDD (for instance, the formula Σn = ∧n i=1(xi ⇔ yi) has an OBDD< representation of size polynomial in n whenever < satisfies x1 < y1 < x2 < . . . < xn < yn, while it has an OBDD< representation of size exponential in n provided that < is s.t. x1 < x2 < . . . < xn < y1 < y2 < . . . < yn). The remaining results in this table follow from the language inclusions reported in Figure 4.\nTable 12: L’ 6≤∗ L means that L’ 6≤ L unless the polynomial hierarchy PH collapses. The results in this table follow since the existence of polysize knowledge compilation functions for clausal entailment implies the collapse of the polynomial hierarchy PH (Selman & Kautz, 1996; Cadoli & Donini, 1997). Now, if DNNF ≤ CNF, then for each sentence Σ in CNF there exists a polysize equivalent sentence Γ in DNNF. Therefore, we can test whether a clause is entailed by Σ in polytime by testing whether the clause is entailed by Γ. This proves the existence of polysize knowledge compilation functions for clausal entailment, leading to the collapse of the polynomial hierarchy PH. The same is true for d-DNNF and sd-DNNF since all these languages support a polytime clausal entailment test (see Proposition 4.1).\nTable 13: In (Wegener, 1987) (Theorem 6.2 pp. 436), a family of n2-variable boolean functions Σ is pointed out. Provided that every interpretation I over these n2 variables represents a n-vertices digraph (for every 1 ≤ i, j ≤ n, we have I(xi,j) = 1 iff (i, j) is an arc of the digraph), Σ(I) = 1 iff the\ndigraph represented by I contains a k-clique of a special kind (k is a parameter of the family). It is shown that for certain values of k (depending on n), every FBDD representation of Σ has exponential size. Moreover, it is shown that Σ has only a cubic number of prime implicants. This shows that FBDD 6≤ IP, hence FBDD 6≤ DNF. Because FBDD satisfies ¬C (see Proposition 5.1),8 it cannot be the case that ¬Σ has a polynomial size FBDD. Since ¬Σ has only a cubic number of prime implicates, we obtain that FBDD 6≤ PI, hence FBDD 6≤ CNF. The remaining results in this table follow since FBDD≤ OBDD ≤ OBDD<.\nTable 14: Assume that d-DNNF ≤ DNF holds. As a consequence, every sentence Σ in DNF can be compiled into an equivalent d-DNNF sentence Σ∗ of polynomial size. Now, checking whether a clause γ is entailed by the CNF sentence Σ is equivalent to checking whether the DNF sentence ¬Σ ∨ γ is valid. Checking whether (¬Σ)∗∨γ is valid—when (¬Σ)∗ is a d-DNNF sentence and γ is a clause—can be achieved in polynomial time by Lemma A.11. Therefore, (¬Σ)∗ is a polysize compilation of the\n8. That is, a sentence in FBDD can be negated in polytime to yield a sentence in FBDD too.\nL NNF DNNF d-DNNF FBDD OBDD OBDD< DNF CNF PI IP MODS sd-DNNF\nNNF ≤ ≤ ≤ ≤ ≤ ≤ ≤ ≤ ≤ ≤ ≤ ≤ DNNF 6≤∗ ≤ ≤ ≤ ≤ ≤ ≤ 6≤∗ ≤ ≤ ≤\nd-DNNF 6≤∗ 6≤∗ ≤ ≤ ≤ ≤ 6≤∗ 6≤∗ ≤ ≤ FBDD 6≤ 6≤ 6≤ ≤ ≤ ≤ 6≤ 6≤ 6≤ 6≤ 6≤ OBDD 6≤ 6≤ 6≤ 6≤ ≤ ≤ 6≤ 6≤ 6≤ 6≤ 6≤ OBDD< 6≤ 6≤ 6≤ 6≤ 6≤ ≤ 6≤ 6≤ 6≤ 6≤ 6≤ DNF 6≤ 6≤ 6≤ 6≤ 6≤ 6≤ ≤ 6≤ 6≤ ≤ ≤ 6≤ CNF 6≤ 6≤ 6≤ 6≤ 6≤ 6≤ 6≤ ≤ ≤ 6≤ 6≤ PI 6≤ 6≤ 6≤ 6≤ 6≤ 6≤ 6≤ 6≤ ≤ 6≤ 6≤ IP 6≤ 6≤ 6≤ 6≤ 6≤ 6≤ 6≤ 6≤ 6≤ ≤ 6≤ MODS ≤ sd-DNNF 6≤∗ 6≤∗ ≤ ≤ ≤ ≤ 6≤∗ 6≤∗ ≤ ≤\nTable 14:\nCNF sentence Σ, allowing clausal entailment to be achieved in polynomial time. The existence of such (¬Σ)∗ for every CNF sentence Σ implies the collapse of the polynomial hierarchy (Selman & Kautz, 1996; Cadoli & Donini, 1997). Hence, we obtain that d-DNNF 6≤∗ DNF. As a consequence, we also have d-DNNF 6≤∗ DNNF. Finally, since every d-DNNF sentence can be turned in polynomial time into an equivalent sd-DNNF sentence by Lemma A.1, we have sd-DNNF ≤ d-DNNF. Moreover, since d-DNNF ≤ sd-DNNF, we obtain sd-DNNF 6≤∗ DNF, sd-DNNF 6≤∗ DNNF, sd-DNNF ≤ FBDD, sd-DNNF ≤ OBDD, sd-DNNF ≤ OBDD<, FBDD 6≤ sd-DNNF, OBDD< 6≤ sd-DNNF, DNF 6≤ sd-DNNF, CNF 6≤ sd-DNNF, PI 6≤ sd-DNNF and IP 6≤ sd-DNNF.\nTable 15: Let us now show that MODS is not less succinct than PI, IP, sd-DNNF and OBDD. First, let us consider the formula Σ = ∨n i=1 xi. Σ can be represented by PI, IP, sd-DNNF and OBDD formulas of size polynomial in n. Contrastingly, Σ cannot be represented by a MODS formula of size polynomial in n since Σ has 2n − 1 models over Vars(Σ). Now, it is well-known that the old good Quine-McCluskey’s algorithm for generating prime implicants from a MODS representation of a propositional formula Σ runs in time polynomial in the number of models of Σ (Wegener, 1987). This shows that IP ≤ MODS. As to CNF and OBDD<, it is obvious that a decision tree (or Shannon tree) for Σ that respects a given total ordering over Vars(Σ) can be generated in polynomial time from a MODS representation of Σ. Such a decision tree has m 1-leaves where m is the number of models of Σ over Vars(Σ). Accordingly, it has at most n ∗m 0-leaves where n = |Vars(Σ)|. Since the set of all paths from the root of the tree to any 0-leaf can be read as a CNF representation of Σ, we obtain that CNF ≤ MODS. On the other hand, since reducing a decision tree to derive a corresponding OBDD< can be done in polynomial time, it follows that an OBDD< representation of Σ can also be generated from a MODS representation of it. Hence, OBDD< ≤ MODS. The remaining results in this table follow from the language inclusions reported in Figure 4. ✷"
    }, {
      "heading" : "Proof of Proposition 4.1",
      "text" : "The proof of this proposition is broken down into twelve steps. In each step, we prove a number of results. Associated with each step of the proof is a table in which we mark all results that are proved in that step. The table of the last step includes all results declared by this proposition.\nTable 16: Every classical CNF or DNF formula can be translated in a straightforward way into an equivalent f-NNF sentence (with a tree structure) in polytime. Moreover, every NNF sentence can be translated into an equivalent s-NNF sentence in polytime (Lemma A.1). Given that CO is NP-hard (resp. VA is coNP-hard) for classical CNF (resp. DNF) sentences, and the inclusion between the various NNF subsets reported in Figure 4, we obtain the table.\nTable 17: SE implies both CO and VA (Lemma A.10). Moreover, since CT implies both CO and VA, IM implies VA (valid term), and CE implies CO (inconsistent clause), we obtain the table.\nTable 18: A sentence Σ is consistent (resp. valid) iff it has a model (resp. 2n models, where n = |Vars(Σ)|). Moreover, the number of models of Σ is given by the number of edges outgoing from the or-node in any MODS representation of Σ. Accordingly, CO, VA and CT can be achieved in polynomial time when Σ is given by a MODS formula which gives us the table.\nTable 19:Because DNNF satisfies CE (Darwiche, 2001a), CE implies CO and MODS ⊆ DNF ⊆ DNNF, IP⊆ DNF and sd-DNNF ⊆ d-DNNF ⊆ DNNF, we obtain the table.\nObviously enough, any query concerning OBDD is equivalent to the corresponding query concerning OBDD< provided that only one DAG is brought into play. Together with the above results, we conclude that OBDD satisfies CO, VA and CT. Since this fragment satisfies CD as well, it satisfies CE, IM and ME in addition. It also satisfies EQ (see Theorem 8.11 from (Meinel & Theobald, 1998)) but does not satisfy SE (unless P = NP). Indeed, it is known that checking the consistency of two OBDD< formulas α and β (based on two different variable orderings <) is NP-complete (Lemma 8.14 from (Meinel & Theobald, 1998)). Since OBDD satisfies ¬C and since α ∧ β is consistent iff α 6|= ¬β, checking sentential entailment for OBDD formulas is coNP-complete.\nThese results lead to the table. Table 21: It is known that IM is satisfied by classical CNF formulas (hence, PI) (in order to check whether a non-valid clause is implied by a consistent term, it is sufficient to test that they share a literal). CNF (hence, PI) is also known to satisfy VA. We then obtain the table.\nTable 22: Every sentence in CNF or DNF can be turned into an equivalent sentence in BDD in polytime (Lemma A.8). Hence, a ◦ in a CNF or DNF cell implies a ◦ in the corresponding BDD cell. Similarly, since BDD ⊆ d-NNF, a ◦ in a BDD cell implies a ◦ in the corresponding d-NNF cell. This leads to the table.\nTable 23: Since EQ implies CO and VA (Lemma A.9), a ◦ in a CO or VA cell implies a ◦ in the corresponding EQ cell. This leads to the table.\nTable 24: By definition, PI satisfies CE and IP satisfies IM. Since PI ⊆ CNF and IP ⊆ DNF, this implies that both PI and IP satisfy SE. Now, SE implies EQ, hence both PI and IP satisfy EQ (actually, two equivalent formulas share the same prime implicates and the same prime implicants (both forms are canonical ones, provided that one representative per equivalence class is considered,\nonly)). Since PI satisfies CE, it also satisfies CO. Since it satisfies CD as well (cf. Proposition 5.1), it also satisfies ME (Lemma A.3). Contrastingly, the models counting problem for monotone Krom formulas (i.e. conjunctions of clauses containing at most two literals and only positive literals) is #P-complete (Roth, 1996). Such formulas can easily be turned into prime implicates form in polynomial time (Marquis, 2000), hence PI does not satisfy CT. Now, since the negation of a formula Σ in prime implicates form is a formula in prime implicants form (cf. Lemma A.14), and since the number of models of ¬Σ over Vars(Σ) is 2|Vars(Σ)| minus the number of models of Σ over Vars(Σ), we necessarily have that IP does not satisfy CT. This also imply that IP satisfies VA, leading to the table.\nTable 25: In the proof of Proposition 3.1, we have shown that the prime implicants of Σ can be computed in polytime from a MODS representation of Σ. As an immediate consequence, since IP satisfies IM, EQ and SE, we obtain that MODS satisfies IM, EQ and SE, leading to the table.\nTable 26: Since d-DNNF satisfies CT (Darwiche, 2001b), it also satisfies VA. Since it satisfies CD (Proposition 5.1), it also satisfies IM as well (Lemma A.7). Since sd-DNNF ⊆ d-DNNF, these results follow for sd-DNNF. Hence, we obtain the table.\nTable 27: It is known that determining whether the conjunction of two FBDD formulas α1 and α2 is consistent is NP-complete (Gergov & Meinel, 1994b) Moreover, FBDD satisfies ¬C. Since α1 ∧ α2 is inconsistent iff α1 |= ¬α2, we can reduce the consistency test into an entailment test. Hence, FBDD does not satisfy SE. Since FBDD ⊆ d-DNNF, d-DNNF does not satisfy SE either. Finally, since every d-DNNF can be translated into an equivalent sd-DNNF sentence in polytime (Lemma A.1), sd-DNNF does not satisfy SE either. This leads to the final table above. ✷"
    }, {
      "heading" : "Proof of Proposition 5.1",
      "text" : "The proof of this proposition is broken down into eight steps. Each step corresponds to one of the transformations, where we prove all results pertaining to that transformation.\n• CD. To show that a language L satisfies CD, we want to show that for any sentence Σ ∈ L and any consistent term γ, we can construct in polytime a sentence which belongs to L and is equivalent to Σ | γ.\n– NNF, f-NNF, CNF and DNF. The property is trivially satisfied by these languages: If Σ belongs to any of these languages, then replacing the literals of γ by a Boolean constant in Σ results a sentence in the same language. In the case of DNF (resp. CNF), some inconsistent terms (valid clauses) may result through conditioning, but these can be removed easily in polynomial time.\n– DNNF. It is sufficient to prove that conditioning preserves decomposability. For every propositional sentences α, β and every consistent term γ, if α and β do not share variables, then α|γ and β|γ do not share variables either since Vars(α|γ) ⊆ Vars(α) and Vars(β|γ) ⊆ Vars(β).\n– d-NNF and d-DNNF. Since NNF and DNNF satisfy CD, it is sufficient to prove that conditioning preserves determinism, i.e. for every propositional formulas α, β and every consistent term γ, if α ∧ β |= false, then (α|γ) ∧ (β|γ) |= false. If α ∧ β |= false, then for every term γ, we have (α ∧ β) ∧ γ |= false. Since (α ∧ β) ∧ γ ≡ ((α ∧ β)|γ) ∧ γ, this implies that ((α∧β)|γ)∧γ |= false. Since γ is consistent and share no variable with (α∧β)|γ, it must be the case that (α∧β)|γ is inconsistent. This is equivalent to state that (α|γ)∧ (β|γ) |= false.\n– s-NNF and sd-DNNF. Since NNF satisfies CD, and since conditioning preserves decomposability and determinism, all we have to show is that conditioning also preserves smoothness. This follows immediately since for two propositional sentences α, β and a consistent term γ, we have Vars(α) = Vars(β) only if Vars(α | γ) = Vars(β | γ).\n– BDD, FBDD, OBDD and OBDD<. It is well–known that BDD satisfies CD—the conditioning operation on binary decision diagrams is known as the restrict operation (Bryant, 1986). To condition a sentence Σ in BDD on a consistent term γ, we replace every node labeled by a variable in γ by one of its two children, according to the sign of the variable in γ. The resulting sentence is also a BDD and is equivalent to Σ | γ. The same applies to FBDD, OBDD and OBDD<. – PI. The prime implicates of Σ ∧ γ can be computed in polytime when Σ is in prime implicates form and γ is a term (see Proposition 36 in (Marquis, 2000)). Moreover, since\nPI satisfies FO (see below), the prime implicates of ∃Vars(γ).(Σ∧γ) can be computed in polytime. But these are exactly the prime implicates of Σ | γ according to Lemma A.12.\n– IP. Let Σ = ∨n\ni=1 γi be a formula in prime implicants form. It is clear that the formula ( ∨n\ni=1 γi) | γ is a DNF formula equivalent to Σ | γ. Now, our claim is that the formula Σ∗ obtained by keeping only the logically weakest terms γi | γ among ( ∨n i=1 γi) | γ is a prime implicants formula equivalent to Σ | γ. Removing such terms clearly is truth-preserving. Since generating Σ∗ requires only O(n2) entailment tests among terms, and since such tests can be easily achieved in polynomial time, we obtain that IP satisfies CD. Now, how to prove that Σ∗ is in prime implicants form? Since any pair of different terms of Σ∗ cannot be compared w.r.t. logical entailment, the correctness of Quine’s consensus algorithm for generating prime implicants shows that it is sufficient to prove that every consensus among two terms of Σ∗ is inconsistent or entails another term of Σ∗. Let’s recall that consensus is to DNF formulas what resolution is to CNF formulas. Since Σ is in prime implicants form, every consensus among two terms of Σ is inconsistent or entails another term of Σ. What happens to the terms (here, the prime implicants) of Σ when conditioned by γ? All those containing the negation of a literal of γ are removed and the remaining ones are shortened by removing from them every literal of γ. Hence, for every pair of terms γ1, γ2 of Σ, if there is no consensus between γ1 and γ2, then there is no consensus between γ1|γ and γ2|γ: conditioning cannot create new consensus. Now, it remains to prove that no unproductive consensus between terms of Σ can be rendered productive through conditioning. Formally, let γ1 = γ ′ 1 ∧ l and γ2 = γ′2 ∧ ¬l be two prime implicates of Σ s.t. l (resp. ¬l) does not appear in γ′1 (resp. γ′2). There is a consensus γ′1∧γ′2 between γ1 and γ2. Let us assume that both γ1 and γ2 have survived the conditioning: this means that both γ1|γ and γ2|γ are consistent. Especially, l belongs to γ1|γ and ¬l belongs to γ2|γ. Accordingly, there is a consensus between γ1|γ and γ2|γ. By construction, this consensus is equivalent to (γ′1|γ)∧(γ′2|γ), hence equivalent to (γ′1∧γ′2)|γ. Now, if γ′1 ∧ γ′2 is inconsistent, then (γ′1 ∧ γ′2)|γ is inconsistent as well and we are done. Otherwise, let us assume that there exists a prime implicant γ3 of Σ s.t. γ ′ 1 ∧ γ′2 |= γ3 holds. Necessarily, γ3 is preserved by the conditioning of Σ by γ. Otherwise, γ3 would contain the negation of a literal of γ, but since every literal of γ3 is a literal of γ1 or a literal of γ2, γ2 and γ3 would not have both survived the conditioning. Since γ ′ 1∧γ′2 |= γ3\nholds, we necessarily have (γ′1 ∧ γ′2)|γ |= γ3|γ. This completes the proof. – MODS. Direct consequence of Lemma A.12 and the fact that MODS satisfies ∧BC and FO\n(see below).\n• FO.\n– DNNF and DNF. It is known that DNNF satisfies FO (Darwiche, 2001a). It is also known that DNF satisfies FO (Lang et al., 2000).\n– NNF, s-NNF, f-NNF, d-NNF, BDD and CNF. Let Σ be a sentence in CNF. We now show that if any of the previous languages satisfies FO, then we can test the consistency of Σ in polytime. Since CNF does not satisfy CO (see Proposition 4.1), it then follows that none of the previous languages satisfy FO unless P = NP. First, we note that Σ must also belong to NNF and f-NNF. Moreover, Σ can be turned into a sentence in BDD in polytime (Lemma A.8) or a sentence in s-NNF in polytime (see the proof of Lemma A.1). We also have that Σ can be turned into a sentence in d-NNF in polytime since BDD ⊆ d-NNF. Suppose now that one of the previous languages, call it L, satisfy FO. We can test the consistency of Σ in polytime as follows:\n∗ Convert Σ into a sentence Σ∗ in L in polytime (as shown above). ∗ Compute ∃Vars(Σ∗).Σ∗, which can be done in polytime by assumption.\n∗ Test the validity of ∃Vars(Σ∗).Σ∗, which can be done in polytime since the sentence contains no variables—all we have to do is check whether the sentence evaluates to true.\nFinally, note that the definition of forgetting implies that a sentence Γ is consistent iff ∃Vars(Γ).Γ is valid, which completes the proof.\n– d-DNNF and sd-DNNF. Follows immediately since none of these languages satisfies SFO unless P = NP (see below).\n– IP. Follows immediately since IP does not satisfy SFO.\n– FBDD, OBDD and OBDD<. We will show that if FBDD (resp. OBDD, OBDD<) satisfies FO, then for every sentence Γ in DNF, there must exist an equivalent sentence Σ in FBDD (resp. OBDD, OBDD<), which size is polynomial in the size of Γ. This contradicts the fact that FBDD (resp. OBDD, OBDD<) 6≤ DNF—see Table 3. Given a DNF Γ consisting of terms γ1, ..., γn, we can convert each of these terms into equivalent FBDD (resp. OBDD, OBDD<) sentences α1, . . . , αn in polytime. Let {v1, . . . , vn−1} be a set of variables that do not belong to PS. Construct a new set of variables PS′ = PS ∪ {v1, . . . , vn−1}. In case of OBDD and OBDD<, we also assume that these new variables are earlier than variables PS in the ordering. Consider now the sentence Σ = ∃{v1, . . . , vn−1}.∆1, with respect to variables PS′, where ∆i is inductively defined by:\n∗ ∆i = αi, for i = n, and ∗ ∆i = (αi ∧ vi) ∨ (∆i+1 ∧ ¬vi), for i = 1, . . . , n − 1.\nClearly enough, an FBDD (resp. OBDD, OBDD<) sentence equivalent to ∆ 1 can be computed in time polynomial in the input size. Moreover, we have Σ ≡ ∨ni=1 αi ≡ ∨n\ni=1 γi ≡ Γ. Hence, if FBDD (resp. OBDD, OBDD<) satisfies FO, then we can convert the DNF sentence Γ into an equivalent FBDD (resp. OBDD, OBDD<) which size is polynomial in the size of the given DNF. This is impossible in general.\n– PI. It is known that the prime implicates of ∃X.Σ are exactly the prime implicates of Σ that do not contain any variable from X (see Proposition 55 in (Marquis, 2000)). Hence, such prime implicates can be computed in time polynomial in the input size when Σ is in prime implicates form.\n– MODS. Given a MODS formula Σ and a subset X of PS, the formula obtained by removing every leaf node (and the corresponding incoming edges) of Σ labeled by a literal x or ¬x s.t. x ∈ X is a MODS representation of ∃X.Σ—this is an easy consequence of Propositions 18 and 20 from (Lang et al., 2000). See also the polytime operation of forgetting on DNNF, as defined in (Darwiche, 2001a), which applies to MODS, since MODS ⊆ DNNF, and which can be easily modified so it guarantees that the output is in MODS when the input is also in MODS.\n• SFO.\n– DNNF, DNF, PI and MODS. Immediate from the fact that each of these languages satisfies FO (see above).\n– NNF, d-NNF, s-NNF, f-NNF, BDD, OBDD< and CNF. Direct from the fact that ∃x.Σ ≡ (Σ|x)∨ (Σ|¬x) holds and the fact that any of these fragments satisfies CD and ∨BC.\n– OBDD. Direct from the fact that only one OBDD sentence is considered in the transformation and OBDD< satisfies SFO.\n– d-DNNF, sd-DNNF and FBDD. Let α1 and α2 be two FBDD formulas. Let x be a variable not included in Vars(α1) ∪ Vars(α2). The formula Σ = (x ∧ α1) ∨ (¬x ∧ α2) is a FBDD\nformula since decomposability and decision are preserved by this construction. Since ∃x.Σ is equivalent to α1 ∨ α2, if FBDD would satisfy SFO, it would satisfy ∨BC as well, but this is not the case unless P = NP (see below). The same conclusion can be drawn for d-DNNF. Hence, FBDD and d-DNNF do not satisfy SFO unless P = NP. Since every d-DNNF formula can be turned in polynomial time into an equivalent sd-DNNF formula, we obtain that sd-DNNF does not satisfy SFO unless P = NP.\n– IP. Let us show that the number of prime implicants of ∃x.Σ can be exponentially greater than the number of prime implicants of Σ. Let Σ′ be the following DNF formula:\nΣ′ =\n\n\nk ∨\ni=1\nm ∨\nj=1\n(pi ∧ qi,j)\n  ∨ k ∧\ni=1\n¬pi.\nΣ′ has (m + 1)k + mk primes implicants (Chandra & Markowsky, 1978). Now, let Σ be the formula:\nΣ =\n\n\nk ∨\ni=1\nm ∨\nj=1\n(x ∧ pi ∧ qi,j)\n  ∨ (¬x ∧ k ∧\ni=1\n¬pi).\nSince Σ′ can be obtained from Σ by removing in every term of Σ every occurrence of x and ¬x, Σ′ is equivalent to ∃{x}.Σ (see (Lang et al., 2000)). Now, Σ has only mk + 1 prime implicants; indeed, every term of it is a prime implicant, and the converse holds since every term is maximal w.r.t. logical entailment and every consensus of two terms is inconsistent. This completes the proof.\n• ∧C.\n– NNF, s-NNF, d-NNF, CNF. The property is trivially satisfied by these languages since determinism and smoothness are only concerned with or-nodes. Hence, if α1, . . . , αn belong to one of these languages, so is α1 ∧ . . . ∧ αn.\n– BDD. It is well–known that the conjunction of two BDDs α and β can be easily computed by connecting the 1-sink of α to the root of β (see proof of Lemma A.8). The size of the resulting BDD is just the sum of the sizes of the respective BDDs of α and β. Accordingly, we can repeat this operation n times in time polynomial in the input size.\n– f-NNF. Direct from the fact that f-NNF does not satisfy ∧BC. – FBDD, OBDD, OBDD<, DNF, PI and IP. It is straightforward to convert a clause into an\nequivalent formula in any of these languages in polynomial time. In the proof of Proposition 3.1, we show specific CNF formulas which cannot be turned into an equivalent FBDD (resp. OBDD, OBDD<, DNF, PI and IP) formulas in polynomial space (see Tables 9 and 10). Hence, such conversion cannot be accomplished in polynomial time either. This implies that none of FBDD, OBDD, OBDD<, DNF, PI and IP satisfies ∧C.\n– DNNF, d-DNNF and sd-DNNF. Direct from the fact that none of these languages satisfy ∧BC unless P = NP.\n– MODS. Let Σ = ∧n i=1 Σi, where Σi = (xi,1 ∨ xi,2), i ∈ 1..n. Each Σi has 3 models over Vars(Σi). Since Σ has 3\nn models, it does not have a MODS representation of size polynomial in the input size.\n• ∧BC.\n– NNF, s-NNF, d-NNF, BDD and CNF. Immediate since each of these languages satisfy ∧C (see above).\n– DNNF, d-DNNF, sd-DNNF, FBDD and OBDD. Checking whether the conjunction of two OBDD< formulas α1 and α2 (w.r.t. two different variable orderings <) is consistent is NP-complete (see Lemma 8.14 in (Meinel & Theobald, 1998)). Since OBDD satisfies CO, it cannot satisfy ∧BC unless P = NP. Since OBDD ⊆ FBDD ⊆ d-DNNF ⊆ DNNF, and d-DNNF and DNNF satisfy CO, none of them can satisfy ∧BC unless P = NP. Finally, since every d-DNNF formula can be turned in polynomial time into an equivalent smoothed d-DNNF formula and since sd-DNNF satisfies CO, it cannot be the case that sd-DNNF satisfy ∧BC unless P = NP.\n– OBDD<. Well-known fact (Bryant, 1986). – f-NNF. Let α1 = ∧n−1 i=0 (x2i ∨ x2i+1) be a CNF formula and α2 = ∨n−1 i=0 (x ′ 2i ∧ x′2i+1) a DNF\nformula. α1 has 2 n essential prime implicants and n essential prime implicates (see the proof of Proposition 3.1, Table 9). By duality, α2 has n essential prime implicants and 2 n essential prime implicates. Now, α1 and α2 are two f-NNF formulas. By Lemma A.13, we know that every f-NNF formula β can be turned in polynomial time into a CNF formula or a DNF formula. If f-NNF would satisfy ∧BC, then a f-NNF formula β s.t. β ≡ α1∧α2 could be computed in time polynomial in the input size. Hence, either a CNF formula equivalent to α1 ∧ α2 or a DNF formula equivalent to α1 ∧ α2 could be computed in polytime. But this is impossible since α1 ∧ α2 has n + 2n essential prime implicates and n ∗ 2n essential prime implicants. Hence every CNF (resp. DNF ) formula equivalent to α1 ∧ α2 has a size exponential in |α1| + |α2|. Note that in the case where the two f-NNF formulas α1 and α2 into consideration can be turned in polynomial time into either two CNF formulas or two DNF formulas, then a f-NNF formula equivalent to α1 ∧ α2 can be computed in time polynomial in the input size (this is obvious when two CNF formulas are considered and the next item of the proof shows how this can be achieved when two DNF formulas are considered).\n– DNF and MODS. If α1 and α2 are sentences in one of these languages L, then we can construct a sentence in L which is equivalent to α1∧α2 by simply taking all the conjunctions of one term from α1 and one term from α2, while removing redundant literals in the resulting terms and removing any inconsistent terms in the result. The disjunction of all the resulting terms is a sentence from L equivalent to α1 ∧ α2 and it has been computed in polynomial time.\n– PI. Let α1 = ∨k i=1 pi and α2 = ∧k i=1 ∧m j=1(¬pi∨qi,j). Sentence α1 has one prime implicate\nand α2 has m ∗ k prime implicates. But α1 ∧ α2 has (m + 1)k + m ∗ k prime implicates (Chandra & Markowsky, 1978).\n– IP. Let IP(α) be the set of prime implicants for α. We have IP(α1 ∧ α2) = max({β1 ∧ β2 | β1 ∈ IP(α1), β2 ∈ IP(α2)}, |=) (up to logical equivalence). See e.g., (dual of) Proposition 40 in (Marquis, 2000).\n• ∨C.\n– NNF, s-NNF, DNNF and DNF. The property is trivially satisfied by these languages since decomposability is only concerned with and-nodes, and since every NNF formula can be turned in polynomial time into an equivalent smoothed NNF formula.\n– d-NNF and BDD. Direct consequence from the fact that d-NNF and BDD satisfies both ∧C and ¬C. Especially, it is well-known that the disjunction of two BDDs α and β can be easily computed by connecting the 0-sink of α to the root of β (see the proof of Lemma A.8). The size of the resulting BDD is just the sum of the sizes of the respective BDDs of α and β. Accordingly, we can repeat this operation n times in time polynomial in the input size.\n– f-NNF. Since f-NNF does not satisfy ∧C but satisfies ¬C, it cannot satisfy ∨C (due to De Morgan’s laws).\n– FBDD, OBDD, OBDD<, CNF, PI, IP and MODS. It is straightforward to convert any term into an equivalent formula from any of the previous languages in polynomial time. In the proof of Proposition 3.1, we show specific DNF formulas which cannot be turned into equivalent FBDD (resp. OBDD, OBDD<, CNF , PI, IP and MODS) formulas in polynomial space (see Tables 9, 10 and 15). Hence, the conversion cannot be accomplished in polynomial time either. This implies that none of FBDD, OBDD, OBDD<, CNF, PI, IP and MODS satisfies ∨C.\n– d-DNNF and sd-DNNF. Immediate form the fact that none of these classes satisfies ∨BC unless P = NP (see below).\n• ∨BC.\n– NNF, d-NNF, DNNF, s-NNF, BDD and DNF. Immediate since each of these languages satisfies ∨C.\n– OBDD<. Well-known fact (Bryant, 1986).\n– OBDD, FBDD, d-DNNF and sd-DNNF. Checking whether the conjunction of two OBDD< formulas α1 and α2 (w.r.t. two different variable orderings <) is consistent is NP-complete (see Lemma 8.14 in (Meinel & Theobald, 1998)). Now, α1 ∧ α2 is inconsistent iff ¬α1 ∨ ¬α2 is valid. Since OBDD satisfies ¬C, an OBDD formula equivalent to ¬α1 (resp. ¬α2) can be computed in time polynomial in |α1| (resp. |α2|). Since OBDD ⊆ FBDD ⊆ d-DNNF, the resulting formulas are also FBDD and d-DNNF formulas. If OBDD (resp. FBDD, d-DNNF) would satisfy ∨BC, then an OBDD (resp. FBDD, d-DNNF) formula equivalent to ¬α1 ∨ ¬α2 could be computed in time polynomial in |α1| + |α2|. But since d-DNNF satisfies VA, this is impossible unless P = NP. Finally, since every d-DNNF formula can be turned in polynomial time into an equivalent sd-DNNF formula, sd-DNNF cannot satisfy ∨BC unless P = NP.\n– f-NNF. Since f-NNF does not satisfy ∧BC but satisfies ¬C, it cannot satisfy ∨BC (due to De Morgan’s laws).\n– CNF. If α1 and α2 are two CNF sentences, then we can construct a CNF sentence which is equivalent to α1 ∨ α2 by simply taking all the disjunctions of one clause from α1 and one clause from α2, while removing redundant literals inside the resulting clauses and removing any valid clause in the result. The conjunction of all the resulting clauses is a CNF sentence equivalent to α1 ∨ α2, and it has been computed in polynomial time. – PI. Let PI (α) be the set of prime implicates for sentence α. We have PI (α1 ∨ α2) = min({β1 ∨ β2 | β1 ∈ PI (α1), β2 ∈ PI (α2)}, |=). See Proposition 40 in (Marquis, 2000).\n– IP. Let α1 = ∧k i=1 pi and α2 = ∨k i=1 ∨m j=1(¬pi∧qi,j). Sentence α1 has one prime implicant\nand α2 has m ∗ k prime implicants. But α1 ∨ α2 has (m + 1)k + m ∗ k prime implicants (Chandra & Markowsky, 1978).\n– MODS. Let α1 = ∧n\ni=1 xi and α2 = y. Sentence α1 has 1 model over Vars(α1) and α2 has 1 model over Vars(α2). But α1 ∨ α2 has 2n + 1 models over Vars(α1) ∪ Vars(α2).\n• ¬C.\n– NNF, s-NNF, f-NNF, BDD, FBDD, OBDD and OBDD<. The property is obviously satisfied by NNF. s-NNF also satisfies ¬C since every NNF formula can be turned in polynomial time into an equivalent s-NNF formula. f-NNF satisfies ¬C since applying De Morgan’s laws on a f-NNF formula results in a f-NNF formula. Finally, for all the forms of BDDs, it is sufficient to switch the labels of the sinks to achieve negation (Bryant, 1986).\n– CNF. Because the negation of a DNF formula is a CNF formula that can be computed in polynomial time, if CNF would satisfy ¬C, then it would be possible to turn any DNF formula into an equivalent CNF formula in polynomial time (by involution of negation). But we know that it is not possible in polynomial space since CNF 6≤ DNF(see the proof of Proposition 3.1). Hence, CNF does not satisfy ¬C.\n– DNF. Dual of the proof just above (just replace CNF by DNF and vice-versa).\n– PI. The formula Σn = ∧n−1 i=0 (x2i ∨ x2i+1) is in prime implicates form (see the proof of Proposition 3.1, Table 9). This formula has exponentially many prime implicants, that are just the negations of the prime implicates of ¬Σn. Since ¬Σn has exponentially many prime implicates, it cannot be the case that PI satisfies ¬C.\n– IP. We just have to take the dual of the above proof (prime implicates case). The formula\nΣn = ∨n−1 i=0 (x2i∧x2i+1) is in prime implicants form. This formula has exponentially many prime implicates, that are just the negations of the prime implicants of ¬Σn. Since ¬Σn has exponentially many prime implicants, it cannot be the case that IP satisfies ¬C.\n– DNNF. The negation of any CNF formula can be computed in polynomial time as a DNF formula, hence as a DNNF formula. If DNNF would satisfy ¬C, then it would be possible to turn a CNF formula into an equivalent DNNF one (by involution of negation). Because DNNF satisfies CO, we would have P = NP.\n– d-NNF. Following is a procedure for negating a d-NNF sentence ∆:9\n∗ Traverse nodes in the DAG of ∆, visiting the children of a node before you visit the node itself. When visiting a node, construct its negation as follows:\n· true is the negation of false. · false is the negation of true. · ∧(N ′1, . . . , N ′k) is the negation of ∨(N1, . . . , Nk). Here, N ′i is the node representing\nthe negation of Ni.\n· ∨(∧(N ′1,M1), . . . ,∧(N ′k,Mk)) is the negation of ∧(N1, . . . , Nk). Here, N ′i is the node representing the negation of Ni, and Mi is a node representing the conjunction N1 ∧ . . . ∧ Ni−1. ∗ Return the negation of the root of d-NNF ∆. We can implement the above four steps so that we when we visit a node with k children, we only construct O(k) nodes and O(k) edges.10 Hence, the procedure complexity is\n9. Mark Hopkins pointed us to this procedure. 10. We assume that any or-node (resp. and-node) with less than two children is removed and replaced by its unique\nchild or by false (resp. true) if it has no children. This simplification process is equivalence-preserving and it can be achieved in time linear in the size of the input DAG.\nlinear in the size of the original d-NNF. It is easy to check that the result is equivalent to the negation of the given d-NNF sentence and is also in d-NNF.\n– sd-DNNF and d-DNNF. Unknown. – MODS. Σ = ∧n\ni=1 xi has only one model over ⋃n i=1{xi} but its negation ¬Σ has 2n − 1 models over\n⋃n i=1{xi}. Hence MODS cannot satisfy ¬C. ✷"
    } ],
    "references" : [ {
      "title" : "Planning via model checking: a decision procedure for AR",
      "author" : [ "A. Cimmati", "F.G.E. Giunchiglia", "P. Traverso" ],
      "venue" : "In Proceedings of the 4 European Conference on Planning",
      "citeRegEx" : "Cimmati et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Cimmati et al\\.",
      "year" : 1997
    }, {
      "title" : "Equivalence of free Boolean graphs can be decided probabilistically in polynomial time",
      "author" : [ "M. Blum", "A.K. Chandra", "M.N. Wegman" ],
      "venue" : "Information Processing Letters,",
      "citeRegEx" : "Blum et al\\.,? \\Q1980\\E",
      "shortCiteRegEx" : "Blum et al\\.",
      "year" : 1980
    }, {
      "title" : "An investigation of the laws of thought",
      "author" : [ "G. Boole" ],
      "venue" : "Walton and Maberley, London.",
      "citeRegEx" : "Boole,? 1854",
      "shortCiteRegEx" : "Boole",
      "year" : 1854
    }, {
      "title" : "Tractable cover compilations",
      "author" : [ "Y. Boufkhad", "E. Grégoire", "P. Marquis", "B. Mazure", "L. Säıs" ],
      "venue" : "In Proc. of the 15 International Joint Conference on Artificial Intelligence",
      "citeRegEx" : "Boufkhad et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Boufkhad et al\\.",
      "year" : 1997
    }, {
      "title" : "Graph-based algorithms for Boolean function manipulation",
      "author" : [ "R.E. Bryant" ],
      "venue" : "IEEE Transactions on Computers, C-35, 677–691.",
      "citeRegEx" : "Bryant,? 1986",
      "shortCiteRegEx" : "Bryant",
      "year" : 1986
    }, {
      "title" : "Symbolic Boolean manipulation with ordered binary decision diagrams",
      "author" : [ "R.E. Bryant" ],
      "venue" : "ACM Computing Surveys, 24 (3), 293–318.",
      "citeRegEx" : "Bryant,? 1992",
      "shortCiteRegEx" : "Bryant",
      "year" : 1992
    }, {
      "title" : "A survey on knowledge compilation",
      "author" : [ "M. Cadoli", "F. Donini" ],
      "venue" : "AI Communications,",
      "citeRegEx" : "Cadoli and Donini,? \\Q1997\\E",
      "shortCiteRegEx" : "Cadoli and Donini",
      "year" : 1997
    }, {
      "title" : "Comparing space efficiency of propositional knowledge representation formalisms",
      "author" : [ "M. Cadoli", "F. Donini", "P. Liberatore", "M. Schaerf" ],
      "venue" : "In Proc. of the 5 International Conference on Knowledge Representation and Reasoning",
      "citeRegEx" : "Cadoli et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "Cadoli et al\\.",
      "year" : 1996
    }, {
      "title" : "On the number of prime implicants",
      "author" : [ "A. Chandra", "G. Markowsky" ],
      "venue" : "Discrete Mathematics,",
      "citeRegEx" : "Chandra and Markowsky,? \\Q1978\\E",
      "shortCiteRegEx" : "Chandra and Markowsky",
      "year" : 1978
    }, {
      "title" : "Compiling knowledge into decomposable negation normal form",
      "author" : [ "A. Darwiche" ],
      "venue" : "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI’99), pp. 284–289. Morgan Kaufmann, California.",
      "citeRegEx" : "Darwiche,? 1999",
      "shortCiteRegEx" : "Darwiche",
      "year" : 1999
    }, {
      "title" : "Decomposable negation normal form",
      "author" : [ "A. Darwiche" ],
      "venue" : "Journal of the ACM, 48 (4), 608–647.",
      "citeRegEx" : "Darwiche,? 2001a",
      "shortCiteRegEx" : "Darwiche",
      "year" : 2001
    }, {
      "title" : "On the tractability of counting theory models and its application to belief revision and truth maintenance",
      "author" : [ "A. Darwiche" ],
      "venue" : "Journal of Applied Non-Classical Logics, 11 (1-2), 11–34.",
      "citeRegEx" : "Darwiche,? 2001b",
      "shortCiteRegEx" : "Darwiche",
      "year" : 2001
    }, {
      "title" : "Testing equivalence probabilistically",
      "author" : [ "A. Darwiche", "J. Huang" ],
      "venue" : "Tech. rep. D–123,",
      "citeRegEx" : "Darwiche and Huang,? \\Q2002\\E",
      "shortCiteRegEx" : "Darwiche and Huang",
      "year" : 2002
    }, {
      "title" : "An improved incremental algorithm for generating prime implicates",
      "author" : [ "J. de Kleer" ],
      "venue" : "In Proc. of the 10 National Conference on Artificial Intelligence",
      "citeRegEx" : "Kleer,? \\Q1992\\E",
      "shortCiteRegEx" : "Kleer",
      "year" : 1992
    }, {
      "title" : "Directional resolution: the Davis-Putnam procedure, revisited",
      "author" : [ "R. Dechter", "I. Rish" ],
      "venue" : "In Proceedings of the Fourth International Conference on Principles of Knowledge Representation and Reasoning",
      "citeRegEx" : "Dechter and Rish,? \\Q1994\\E",
      "shortCiteRegEx" : "Dechter and Rish",
      "year" : 1994
    }, {
      "title" : "Tractable databases: How to make propositional unit resolution complete through compilation",
      "author" : [ "A. del Val" ],
      "venue" : "In Proceedings of the International Conference on Principles of Knowledge Representation and Reasoning",
      "citeRegEx" : "Val,? \\Q1994\\E",
      "shortCiteRegEx" : "Val",
      "year" : 1994
    }, {
      "title" : "Efficient analysis and manipulation of obdds can be extended to fbdds",
      "author" : [ "J. Gergov", "C. Meinel" ],
      "venue" : "IEEE Transactions on Computers,",
      "citeRegEx" : "Gergov and Meinel,? \\Q1994\\E",
      "shortCiteRegEx" : "Gergov and Meinel",
      "year" : 1994
    }, {
      "title" : "On the complexity of analysis and manipulation of Boolean functions in terms of decision diagrams",
      "author" : [ "J. Gergov", "C. Meinel" ],
      "venue" : "Information Processing Letters,",
      "citeRegEx" : "Gergov and Meinel,? \\Q1994\\E",
      "shortCiteRegEx" : "Gergov and Meinel",
      "year" : 1994
    }, {
      "title" : "The comparative linguistics of knowledge representation",
      "author" : [ "G. Gogic", "H. Kautz", "C. Papadimitriou", "B. Selman" ],
      "venue" : "In Proc. of the 14 International Joint Conference on Artificial Intelligence",
      "citeRegEx" : "Gogic et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Gogic et al\\.",
      "year" : 1995
    }, {
      "title" : "Propositional belief base update and minimal change",
      "author" : [ "A. Herzig", "O. Rifi" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Herzig and Rifi,? \\Q1999\\E",
      "shortCiteRegEx" : "Herzig and Rifi",
      "year" : 1999
    }, {
      "title" : "Some connections between non-uniform and uniform complexity classes",
      "author" : [ "R. Karp", "R. Lipton" ],
      "venue" : "In Proc. of the 12 ACM Symposium on Theory of Computing",
      "citeRegEx" : "Karp and Lipton,? \\Q1980\\E",
      "shortCiteRegEx" : "Karp and Lipton",
      "year" : 1980
    }, {
      "title" : "Learning to reason",
      "author" : [ "R. Khardon", "D. Roth" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "Khardon and Roth,? \\Q1997\\E",
      "shortCiteRegEx" : "Khardon and Roth",
      "year" : 1997
    }, {
      "title" : "Propositional independence—Part I: formula–variable independence and forgetting",
      "author" : [ "J. Lang", "P. Liberatore", "P. Marquis" ],
      "venue" : null,
      "citeRegEx" : "Lang et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Lang et al\\.",
      "year" : 2000
    }, {
      "title" : "A new method to compute prime and essential prime implicants of boolean functions",
      "author" : [ "J.C. Madre", "O. Coudert" ],
      "venue" : "In Advanced research in VLSI and parallel systems, Proceedings of the Brown/MIT conference,",
      "citeRegEx" : "Madre and Coudert,? \\Q1992\\E",
      "shortCiteRegEx" : "Madre and Coudert",
      "year" : 1992
    }, {
      "title" : "Consequence finding algorithms, Vol",
      "author" : [ "P. Marquis" ],
      "venue" : "5 of Handbook of Defeasible Reasoning and Uncertainty Management Systems: Algorithms for Uncertain and Defeasible Reasoning. Kluwer Academic Publishers.",
      "citeRegEx" : "Marquis,? 2000",
      "shortCiteRegEx" : "Marquis",
      "year" : 2000
    }, {
      "title" : "Knowledge compilation using theory prime implicates",
      "author" : [ "P. Marquis" ],
      "venue" : "Proc. International Joint Conference on Artificial Intelligence (IJCAI’95), pp. 837–843. Morgan Kaufmann Publishers, Inc., San Mateo, California.",
      "citeRegEx" : "Marquis,? 1995",
      "shortCiteRegEx" : "Marquis",
      "year" : 1995
    }, {
      "title" : "Algorithms and Data Structures in VLSI Design: OBDD Foundations and Applications",
      "author" : [ "C. Meinel", "T. Theobald" ],
      "venue" : null,
      "citeRegEx" : "Meinel and Theobald,? \\Q1998\\E",
      "shortCiteRegEx" : "Meinel and Theobald",
      "year" : 1998
    }, {
      "title" : "Computational complexity",
      "author" : [ "C. Papadimitriou" ],
      "venue" : "Addison–Wesley.",
      "citeRegEx" : "Papadimitriou,? 1994",
      "shortCiteRegEx" : "Papadimitriou",
      "year" : 1994
    }, {
      "title" : "A way to simplify truth functions",
      "author" : [ "W. Quine" ],
      "venue" : "American Mathematical Monthly, 52, 627–631.",
      "citeRegEx" : "Quine,? 1955",
      "shortCiteRegEx" : "Quine",
      "year" : 1955
    }, {
      "title" : "On cores and prime implicants of truth functions",
      "author" : [ "W. Quine" ],
      "venue" : "American Mathematical Monthly, 66, 755–760.",
      "citeRegEx" : "Quine,? 1959",
      "shortCiteRegEx" : "Quine",
      "year" : 1959
    }, {
      "title" : "Foundations of assumption-based truth maintenance systems: Preliminary report",
      "author" : [ "R. Reiter", "J. de Kleer" ],
      "venue" : "In Proceedings of the Fifth National Conference on Artificial Intelligence (AAAI),",
      "citeRegEx" : "Reiter and Kleer,? \\Q1987\\E",
      "shortCiteRegEx" : "Reiter and Kleer",
      "year" : 1987
    }, {
      "title" : "On the hardness of approximate reasoning",
      "author" : [ "D. Roth" ],
      "venue" : "Artificial Intelligence, 82 (1-2), 273–302. Schrag, R. (1996). Compilation for critically constrained knowledge bases. In Proc. of the 13 National Conference on Artificial Intelligence (AAAI’96), pp. 510–515, Portland, Oregan.",
      "citeRegEx" : "Roth,? 1996",
      "shortCiteRegEx" : "Roth",
      "year" : 1996
    }, {
      "title" : "Knowledge compilation and theory approximation",
      "author" : [ "B. Selman", "H. Kautz" ],
      "venue" : "Journal of the Association for Computing Machinery,",
      "citeRegEx" : "Selman and Kautz,? \\Q1996\\E",
      "shortCiteRegEx" : "Selman and Kautz",
      "year" : 1996
    }, {
      "title" : "The complexity of boolean functions",
      "author" : [ "I. Wegener" ],
      "venue" : "Wiley-Teubner, Stuttgart.",
      "citeRegEx" : "Wegener,? 1987",
      "shortCiteRegEx" : "Wegener",
      "year" : 1987
    } ],
    "referenceMentions" : [ {
      "referenceID" : 9,
      "context" : "Introduction Knowledge compilation has emerged recently as a key direction of research for dealing with the computational intractability of general propositional reasoning (Darwiche, 1999; Cadoli & Donini, 1997; Boufkhad, Grégoire, Marquis, Mazure, & Säıs, 1997; Khardon & Roth, 1997; Selman & Kautz, 1996; Schrag, 1996; Marquis, 1995; del Val, 1994; Dechter & Rish, 1994; Reiter & de Kleer, 1987).",
      "startOffset" : 172,
      "endOffset" : 397
    }, {
      "referenceID" : 25,
      "context" : "Introduction Knowledge compilation has emerged recently as a key direction of research for dealing with the computational intractability of general propositional reasoning (Darwiche, 1999; Cadoli & Donini, 1997; Boufkhad, Grégoire, Marquis, Mazure, & Säıs, 1997; Khardon & Roth, 1997; Selman & Kautz, 1996; Schrag, 1996; Marquis, 1995; del Val, 1994; Dechter & Rish, 1994; Reiter & de Kleer, 1987).",
      "startOffset" : 172,
      "endOffset" : 397
    }, {
      "referenceID" : 27,
      "context" : "not qualify as a target compilation language unless P=NP (Papadimitriou, 1994), but many of its subsets do.",
      "startOffset" : 57,
      "endOffset" : 78
    }, {
      "referenceID" : 11,
      "context" : "• Determinism (Darwiche, 2001b): An NNF satisfies this property if for each disjunction C in the NNF, each two disjuncts of C are logically contradictory.",
      "startOffset" : 14,
      "endOffset" : 31
    }, {
      "referenceID" : 11,
      "context" : "• Smoothness (Darwiche, 2001b): An NNF satisfies this property if for each disjunction C in the NNF, each disjunct of C mentions the same variables.",
      "startOffset" : 13,
      "endOffset" : 30
    }, {
      "referenceID" : 4,
      "context" : "The following decision property comes from the literature on binary decision diagrams (Bryant, 1986).",
      "startOffset" : 86,
      "endOffset" : 100
    }, {
      "referenceID" : 4,
      "context" : "The BDD language corresponds to binary decision diagrams (BDDs), as known in the formal verification literature (Bryant, 1986).",
      "startOffset" : 112,
      "endOffset" : 126
    }, {
      "referenceID" : 4,
      "context" : "The OBDD language corresponds to the well–known ordered binary decision diagrams (OBDDs) (Bryant, 1986).",
      "startOffset" : 89,
      "endOffset" : 103
    }, {
      "referenceID" : 11,
      "context" : "Others, such as DNNF (Darwiche, 2001a, 1999) and d-DNNF (Darwiche, 2001b), are relatively new.",
      "startOffset" : 56,
      "endOffset" : 73
    }, {
      "referenceID" : 4,
      "context" : "The interested reader is referred to (Darwiche, 2001a, 2001b, 1999; Bryant, 1986) for some of these algorithms and to the proofs of theorems in Appendix A for others.",
      "startOffset" : 37,
      "endOffset" : 81
    }, {
      "referenceID" : 9,
      "context" : "4 (Conditioning) (Darwiche, 1999) Let Σ be a propositional formula, and let γ be a consistent term.",
      "startOffset" : 17,
      "endOffset" : 33
    }, {
      "referenceID" : 2,
      "context" : "Another critical transformation we shall consider is that of forgetting (also referred to as marginalization, or elimination of middle terms (Boole, 1854)):",
      "startOffset" : 141,
      "endOffset" : 154
    }, {
      "referenceID" : 10,
      "context" : "In model-based diagnosis, compiling away every variable except the abnormality ones does not remove any piece of information required to compute the conflicts and the diagnoses of a system (Darwiche, 2001a).",
      "startOffset" : 189,
      "endOffset" : 206
    }, {
      "referenceID" : 4,
      "context" : "This closure actually plays an important role in compiling propositional theories into OBDD< and is the basis of state-of-the-art compilers for this purpose (Bryant, 1986).",
      "startOffset" : 157,
      "endOffset" : 171
    }, {
      "referenceID" : 10,
      "context" : "Proof: To test whether sentence Σ entails non-valid clause α, Σ |= α, it suffices to test whether Σ | ¬α is inconsistent (Darwiche, 2001a).",
      "startOffset" : 121,
      "endOffset" : 138
    }, {
      "referenceID" : 18,
      "context" : "Table 9: We can prove both that DNF 6≤ PI and CNF 6≤ IP (this slightly generalizes the results DNF 6≤ CNF and CNF 6≤ DNF given in (Gogic et al., 1995)).",
      "startOffset" : 130,
      "endOffset" : 150
    }, {
      "referenceID" : 29,
      "context" : "Since Quine’s early work (Quine, 1959), we know that the number of essential prime implicants (resp.",
      "startOffset" : 25,
      "endOffset" : 38
    }, {
      "referenceID" : 24,
      "context" : ", (dual of) Proposition 40 in (Marquis, 2000)) which states that IP(α∧β) = max({PIα∧PIβ | PIα ∈ IP(α), PIβ ∈ IP(β)}, |=) (up to logical equivalence).",
      "startOffset" : 30,
      "endOffset" : 45
    }, {
      "referenceID" : 28,
      "context" : "The correctness of (the dual of) Quine’s consensus algorithm for computing prime implicants (Quine, 1955) ensures it, since no clause of Σn is subsumed by another clause and no consensi can be performed since there are no negated variables.",
      "startOffset" : 92,
      "endOffset" : 105
    }, {
      "referenceID" : 4,
      "context" : "Table 10: The parity function On = ⊕n−1 i=0 xi has linear size OBDD< representations (Bryant, 1986) but only exponential size CNF and DNF representations.",
      "startOffset" : 85,
      "endOffset" : 99
    }, {
      "referenceID" : 11,
      "context" : "Table 11: It is shown in (Darwiche, 2001b) that there is a sentence in d-DNNF which only has exponential FBDD representations.",
      "startOffset" : 25,
      "endOffset" : 42
    }, {
      "referenceID" : 33,
      "context" : "Table 13: In (Wegener, 1987) (Theorem 6.",
      "startOffset" : 13,
      "endOffset" : 28
    }, {
      "referenceID" : 33,
      "context" : "Now, it is well-known that the old good Quine-McCluskey’s algorithm for generating prime implicants from a MODS representation of a propositional formula Σ runs in time polynomial in the number of models of Σ (Wegener, 1987).",
      "startOffset" : 209,
      "endOffset" : 224
    }, {
      "referenceID" : 10,
      "context" : "Table 19:Because DNNF satisfies CE (Darwiche, 2001a), CE implies CO and MODS ⊆ DNF ⊆ DNNF, IP⊆ DNF and sd-DNNF ⊆ d-DNNF ⊆ DNNF, we obtain the table.",
      "startOffset" : 35,
      "endOffset" : 52
    }, {
      "referenceID" : 5,
      "context" : "It is well-known that FBDD satisfies CO, VA and CT, and that OBDD< satisfies (in addition) EQ (Gergov & Meinel, 1994a; Bryant, 1992).",
      "startOffset" : 94,
      "endOffset" : 132
    }, {
      "referenceID" : 31,
      "context" : "conjunctions of clauses containing at most two literals and only positive literals) is #P-complete (Roth, 1996).",
      "startOffset" : 99,
      "endOffset" : 111
    }, {
      "referenceID" : 24,
      "context" : "Such formulas can easily be turned into prime implicates form in polynomial time (Marquis, 2000), hence PI does not satisfy CT.",
      "startOffset" : 81,
      "endOffset" : 96
    }, {
      "referenceID" : 11,
      "context" : "Table 26: Since d-DNNF satisfies CT (Darwiche, 2001b), it also satisfies VA.",
      "startOffset" : 36,
      "endOffset" : 53
    }, {
      "referenceID" : 4,
      "context" : "It is well–known that BDD satisfies CD—the conditioning operation on binary decision diagrams is known as the restrict operation (Bryant, 1986).",
      "startOffset" : 129,
      "endOffset" : 143
    }, {
      "referenceID" : 24,
      "context" : "The prime implicates of Σ ∧ γ can be computed in polytime when Σ is in prime implicates form and γ is a term (see Proposition 36 in (Marquis, 2000)).",
      "startOffset" : 132,
      "endOffset" : 147
    }, {
      "referenceID" : 10,
      "context" : "It is known that DNNF satisfies FO (Darwiche, 2001a).",
      "startOffset" : 35,
      "endOffset" : 52
    }, {
      "referenceID" : 22,
      "context" : "It is also known that DNF satisfies FO (Lang et al., 2000).",
      "startOffset" : 39,
      "endOffset" : 58
    }, {
      "referenceID" : 24,
      "context" : "Σ are exactly the prime implicates of Σ that do not contain any variable from X (see Proposition 55 in (Marquis, 2000)).",
      "startOffset" : 103,
      "endOffset" : 118
    }, {
      "referenceID" : 22,
      "context" : "Σ—this is an easy consequence of Propositions 18 and 20 from (Lang et al., 2000).",
      "startOffset" : 61,
      "endOffset" : 80
    }, {
      "referenceID" : 10,
      "context" : "See also the polytime operation of forgetting on DNNF, as defined in (Darwiche, 2001a), which applies to MODS, since MODS ⊆ DNNF, and which can be easily modified so it guarantees that the output is in MODS when the input is also in MODS.",
      "startOffset" : 69,
      "endOffset" : 86
    }, {
      "referenceID" : 22,
      "context" : "Σ (see (Lang et al., 2000)).",
      "startOffset" : 7,
      "endOffset" : 26
    }, {
      "referenceID" : 4,
      "context" : "Well-known fact (Bryant, 1986).",
      "startOffset" : 16,
      "endOffset" : 30
    }, {
      "referenceID" : 24,
      "context" : ", (dual of) Proposition 40 in (Marquis, 2000).",
      "startOffset" : 30,
      "endOffset" : 45
    }, {
      "referenceID" : 4,
      "context" : "Well-known fact (Bryant, 1986).",
      "startOffset" : 16,
      "endOffset" : 30
    }, {
      "referenceID" : 24,
      "context" : "See Proposition 40 in (Marquis, 2000).",
      "startOffset" : 22,
      "endOffset" : 37
    }, {
      "referenceID" : 4,
      "context" : "Finally, for all the forms of BDDs, it is sufficient to switch the labels of the sinks to achieve negation (Bryant, 1986).",
      "startOffset" : 107,
      "endOffset" : 121
    } ],
    "year" : 2011,
    "abstractText" : "We propose a perspective on knowledge compilation which calls for analyzing different compilation approaches according to two key dimensions: the succinctness of the target compilation language, and the class of queries and transformations that the language supports in polytime. We then provide a knowledge compilation map, which analyzes a large number of existing target compilation languages according to their succinctness and their polytime transformations and queries. We argue that such analysis is necessary for placing new compilation approaches within the context of existing ones. We also go beyond classical, flat target compilation languages based on CNF and DNF, and consider a richer, nested class based on directed acyclic graphs (such as OBDDs), which we show to include a relatively large number of target compilation languages.",
    "creator" : "dvips(k) 5.86 Copyright 1999 Radical Eye Software"
  }
}