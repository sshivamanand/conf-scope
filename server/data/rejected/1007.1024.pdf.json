{
  "name" : "1007.1024.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Model Counting in Product Configuration",
    "authors" : [ "A.J. Kübler", "C. Zengler", "W. Küchlin", "Andreas J. Kübler", "Christoph Zengler", "Wolfgang Küchlin" ],
    "emails" : [ "kuebler@informatik.uni-tuebingen.de", "zengler@informatik.uni-tuebingen.de", "kuechlin@informatik.uni-tuebingen.de" ],
    "sections" : [ {
      "heading" : null,
      "text" : "I. Lynce and R. Treinen (eds.): Workshop on Logics for Component Configuration (LoCoCo 2010) EPTCS 29, 2010, pp. 44–53, doi:10.4204/EPTCS.29.5\nc© A.J. Kübler, C. Zengler, W. Küchlin\nModel Counting in Product Configuration\nAndreas J. Kübler Christoph Zengler Wolfgang Küchlin\nSymbolic Computation Group, Wilhelm Schickard Institute for Computer Science,\nUniversität Tübingen, Germany http://www-sr.informatik.uni-tuebingen.de\n{kuebler,zengler,kuechlin}@informatik.uni-tuebingen.de\nWe describe how to use propositional model counting for a quantitative analysis of product configuration data. Our approach computes valuable meta information such as the total number of valid configurations or the relative frequency of components. This information can be used to assess the severity of documentation errors or to measure documentation quality. As an application example we show how we apply these methods to product documentation formulas of the Mercedes-Benz line of vehicles. In order to process these large formulas we developed and implemented a new model counter for non-CNF formulas. Our model counter can process formulas, whose CNF representations could not be processed up till now."
    }, {
      "heading" : "1 Introduction",
      "text" : "Since R1/XCON [15] was used by DEC to support computer system configuration and assembly, product configuration systems have been among the most prominent and successful applications of AI methods in practice [19]. As a result computer aided configuration systems have been used in managing complex software, hardware or network settings. Another application area of these configuration systems is the automotive industry. Here they helped to realize the transition from the mass production paradigm to present-day mass customization.\nModel counting is a technique to count the number of different satisfying variable assignments of a formula in propositional logic. Up to now model counting has mostly been used within bayesian networks [22, 1] and planning problems [17, 14]. In contrast, our work aims at using propositional model counting for a quantitative analysis of comprehensive product configuration setups.\nTo demonstrate the applicability of our novel methods, we provide examples within a well-studied car configuration context. The German automobile industry follows a build-to-order strategy based on an exceedingly large product variety. This makes it possible, especially for the manufacturers of luxury cars, to offer each customer their unique tailor-made car, and it differentiates the model lines from the mass market. Pil and Holweg [18] have discussed the interconnection of product variety and order-fulfillment strategies.\nIn this context it is interesting for the management to know precisely how much variety there is in the product line. For the automobile industry, this question is surprisingly difficult to answer. In particular, sales options cannot simply be multiplied out because of complex interdependencies (e.g. automatic transmission being standard on U.S. exports, and not available on European cars with small engines). Pil and Holweg published data for the year 2002, based on an analysis of company material, about customer selectable variations. In summary, numbers range from the order of 103 for the smallest Peugeot and Nissan models to the order of 108 or 109 for the GM Astra and Corsa or the Ford Focus. In the luxury sector, the BMW 3-Series was estimated at 6 · 1016, and the Mercedes C-Class at 1021. Finally, for the\nMercedes E-Class, 2 body styles, 15 power trains, 285 paint-and-trim options, and 70 other factory-fitted options could be combined to variations on the order of 3 ·1024. It gets even worse: Variations induced by sales to countries outside Europe (due to different emission standards, fuel grades etc.) apparently were not considered by Pil and Holweg. And customer visible variations are only a subset of the variations afforded by technical and legal restrictions.\nNew technology options, such as hybridization, are a continuous source of new variability, and therefore the issue of rising complexity must have the ongoing attention of management. Since we work with our industrial partner Mercedes-Benz on the symbolic verification of configuration problems [13], such as whether a given configuration is valid or not, or which part is required in which configurations, we were able to investigate how many valid configurations there are for one specific car line. Obviously, there are a number of useful questions associated with this number. Some of these are: How does the complexity evolve over time? Which change in complexity would result from adding or canceling an equipment option? What is the complexity of each body style? Of each engine or power train configuration? In each country on Earth? For which percentage of the total variations is a particular part needed? In practice, detailed questions such as the above can only be answered precisely if the number of variations can be computed automatically from the manufacturer’s configuration data. This was not possible up to now, which also means that the above numbers were not verified independently so far.\nThis paper covers only the first steps towards using model counting in configuration and manufacturing problems. Clearly, some kind of additional information about the expected or observed frequency of chosen options in the real product should be included in the model counts. E.g. an option can be allowed in 90% of all valid configurations, but is chosen only in 10% of actual orders. Still, to the best of our knowledge our results represent the first cases where exact model counts were obtained directly and automatically from the internal manufacturer configuration data of a current highly complex product line. We are certain that more ways will be found in which our methods can be used for computing management information. Also, more extensive data sets will certainly be produced in the future.\nThe plan of this paper as follows: In Section 2 we summarize the theory of model counting and give a short overview of current algorithmic approaches. Section 3 presents possible application fields for model counting in configuration problems. In Section 4 we discuss the specific application of our new methods in the customer order process at Mercedes-Benz. We give a short description of our new nonCNF model counter ncnt and present benchmarks of configuration problems used in the current product line. Section 5 finally summarizes our contributions and points at some future research directions."
    }, {
      "heading" : "2 Model Counting",
      "text" : "Let ϕ be a formula in propositional logic, and let vars(ϕ) denote the finite set of variables occurring in the formula ϕ . An assignment α for ϕ is a partial function α : vars(ϕ) → {⊤,⊥} mapping variables to truth values ⊤ and ⊥. We follow the convention to write α |= ϕ when some formula ϕ holds with respect to α . Propositional model counting or #SAT is the problem of computing the number of all full assignments α for which ϕ holds, i.e. |{α | α |= ϕ}|.\nAnalogous to SAT, which is the canonical NP-complete problem, #SAT is the canonical #P- complete problem. The complexity class #P is the class of all problems p for which there exists a non-deterministic polynomial-time bound Turing machine M(p) such that for each instance I(p) of p there exist exactly as many computation paths of M(p) as solutions for I(p). Intuitively #P is the class of counting problems for polynomial-time decidable problems. According to [25] even the counting problems for polynomialtime solvable problems like 2-SAT, Horn-SAT, or DNF-SAT can be #P-complete.\nIn this paper we only deal with exact model counting (in contrast to approximative counting). We distinguish between two different approaches for exact counting: (1) DPLL-like exhaustive search and (2) knowledge compilation.\nThe vast majority of successful SAT solvers uses the DPLL approach [10, 9]. DPLL is basically a complete search in the search space of all 2n variable assignments with early cuts in the search tree when an unsatisfiable branch is detected. DPLL-style model counters like CDP [4], RelSat [2], or Cachet [20] are extensions to existing SAT solvers and require an input formula in CNF. If a formula ϕ with n variables is not satisfiable, the output is 0. If a satisfying (and possible partial) assignment α is found, the number of models for this α is computed with 2n−|α | and the algorithm proceeds to explore the rest of the search tree. There are two important improvements of this DPLL-based approach. The first one is component analysis [2] where one identifies different components C1, . . . ,Cn in the constraint graph G of a CNF formula ϕ . Let ϕ1, ...,ϕn be the sub-formulas of ϕ corresponding to the components C1, . . . ,Cn. Then the model count #SAT (ϕ) is equal to #SAT (ϕ1)×·· ·×#SAT(ϕn), thus we can calculate the model count of each component independently. This identification of components can be performed dynamically while descending into the search tree. The second improvement is the #SAT correspondence to clause learning in SAT: component caching [20, 24]. Since during the counting process we often compute counts for the same sub-formulas multiple times, we cache signatures of sub-formulas and their model count according to certain caching schemes. Variable selection heuristics as known from SAT have to be adjusted for #SAT wrt. component analysis and caching: While in SAT one tries to narrow down the search to one specific solution by intelligently choosing the branching variables, in #SAT we try to choose variables where the according constraint graph is decomposed in various components [21].\nIn the knowledge compilation based approach we convert the formula ϕ into another logical representation such that #SAT (ϕ) can be computed in polynomial time. One well known approach for this is the compilation of ϕ into a binary decision diagram (BDD) [5]. Once we have the BDD, we can count all paths from the root node to the ⊤ labeled node to get the model count of the formula at hand. Narodytska and Walsh discussed this approach for configuration problems [16]. However our own experiments with the formulas presented in Section 4 showed that for these large formulas, which emerge in our industrial automotive project, the compilation into BDDs is not feasible. Another logical representation for propositional formulas, which is used e.g. in the system c2d [8], is the deterministic decomposable negation normal form (d-DNNF) [7]. A DNNF is an extension of a negation normal form where for each conjunction ∧n i=0 fi with sub-formulas f0, . . . , fn it must hold that vars( fi)∩vars( f j) = /0 for all 0 ≤ i < j ≤ n. In a d-DNNF we have the additional condition that for each disjunction ∨n\ni=0 gi with sub-formulas G = {g0, . . . ,gn} it must hold that for each α we have |{gi ∈ G | α |= gi}| ≤ 1, i.e. no sub-formulas share the same satisfying assignment. Once we have the d-DNNF ϕ ′ of a formula ϕ we can count all models by these two rules:\n#SAT ( n∧\ni=0\nfi) = n\n∏ i=0\n#SAT ( fi) , #SAT ( n∨\ni=0\ngi) = n\n∑ i=0 #SAT (gi).\nIt turns out that a d-DNNF representation is closer to the original CNF formula and therefore is easier to compute."
    }, {
      "heading" : "3 Applications in Product Configuration",
      "text" : "In this section we will point out possible fields of applications for model counting in product configuration. We use the definition of a configuration problem as given in [11, Definition 1]: a configuration\nproblem is a triple (V ,D,Ψ) where V is a set of variables x1,x2, . . . ,xn, D is a set of their finite domains D1,D2, . . . ,Dn and Ψ = {ψ1,ψ2, . . . ,ψm} is a set of propositional formulas over atomic propositions xi = v where v ∈ Di, specifying conditions that the variable assignments have to satisfy. For each formula ψ ∈ Ψ we have vars(ψ) ⊆ V . A valid configuration is an assignment α with dom(α) = V such that α |= ∧ ψ∈Ψ ψ .\nIn this paper we consider the special case where we have only propositional variables in V and hence Di = {⊤,⊥} for all 1 ≤ i ≤ n. The set O is the finite set of all configuration options for a product. Each variable xo ∈ V represents a configuration option o ∈ O . The variable xo is assigned to ⊤ if the option o is chosen, otherwise it is assigned to ⊥. Following this course, the resulting formulas ψ ∈ Ψ are propositional formulas and hence ϕ = ∧ ψ∈Ψ ψ is a propositional formula describing all valid configurations. We will also refer to ϕ as product overview formula (POF) [13]. Remark. The restriction of the variables x ∈ V to propositional variables does not limit the expressiveness of our problem description. Since the domains Di are finite and we only allow atomic propositions of the form x = v, we can use a reduction [6] from equality logic to propositional logic."
    }, {
      "heading" : "3.1 Number of Valid Configurations",
      "text" : "The first question which naturally arises is the total number of valid product configurations v= #SAT (ϕ). Obviously 2|V | is an upper bound for v, but in most cases v ≪ 2|V |. Nevertheless this number v can often demonstrate the sheer complexity of a given product. Subsection 4.2 supports this claim by presenting some of these numbers for the car lines of Mercedes-Benz.\nOne can also count valid configurations of a product under certain preconditions. E.g. we can force options P ⊂ O to be chosen before performing #SAT (ϕ). This can be achieved by computing #SAT (ϕ ∧∧\np∈P xp). This method can yield important information about the influence of certain options o on the number of valid configurations. This information again can be used for special domain-specific variable heuristics for the SAT solving process of formulas of the application area at hand. The main idea of state-of-the-art SAT solvers is to narrow down the search space as fast as possible. Thus when we know a set of variables X ⊆ V representing configuration options P ⊂ O which reduce the number of models of a given formula to a great extent, we can give these variables x ∈ X high activity in the SAT solving process of formulas representing configuration problems of the same product line.\nPreselecting a certain option can also be used to compute the relative frequency of this option in valid configurations. We compute the frequency f (o) of a given option o with\nf (o) = #SAT (ϕ ∧ xo)\n#SAT (ϕ) .\nf (o) can be used as additional information to statistical data about the frequency of options for demand estimation or process optimization."
    }, {
      "heading" : "3.2 Rating Errors",
      "text" : "Quite important issues arise when reporting errors. Observations from formal methods in software verification [3] tell us that the more bugs you report, the smaller the probability gets that they will eventually be fixed. Developers as well as product documentation engineers tend to get overwhelmed quite quickly by extensive error reports leaving them uncertain where to start correcting defects.\nModel counting might help classifying errors according to their severity. We consider scenarios in which satisfiability of the input formula ϕ indicates error situations — hence any satisfying assignment may be interpreted as a counterexample. In configuration problems such situations mostly arise\nwhen checking mutually exclusive component inclusion. Let c1,c2 ∈ vars(ϕ) denote binary flags for the inclusion of two mutually exclusive components. Each assignment satisfying ϕ ∧ c1 ∧ c2 may be interpreted as a product featuring both mutually exclusive components at the same time, thus computing #SAT (ϕ ∧ c1 ∧ c2) results in the total number of invalid configurations w.r.t. c1,c2. Formulas yielding many such “counterexamples” intuitively tend to fail more likely in practice than formulas yielding only negligible numbers. However, if there are very few models for a given error, we assume that this error is more intricate than others.\nMeasuring error severity using model counters as proposed may however turn out not to be applicable in every domain. Think of Boolean encodings of configuration options where each option o is assigned to a value of a finite integer domain D and a consistency assertion a(o) fixing o to a specific integer value i. If checking the Boolean encoding w.r.t. a(o) yields that o is not restricted to i but may instead take an arbitrary value of D, model counting will consequently return some large number of invalid configurations. In case o is some exotic configuration option, using the computed number as a measure of severity might be misleading."
    }, {
      "heading" : "3.3 Measuring Documentation Quality",
      "text" : "Often the individual constraints ψ ∈ Ψ are reflected in a product documentation. This product documentation is either automatically produced or manually maintained by experts. For complex products with thousands of options this documentation evolves over years. This fact can be observed in the development of the numbers of valid configurations of different versions of the documentation for the same product. We made observations where for the same product the number of valid configurations went down from a magnitude of 1034 to a magnitude of 1010 due to a better and more detailed documentation (c.f. Subsection 4.2).\nModel counting can also be used interactively by the documentation engineer. One can immediately see the impact of adding or changing certain constraints in terms of valid configurations. E.g. when adding a new constraint does not change the number of valid configurations it can be redundant and therefore can be omitted."
    }, {
      "heading" : "4 Example: Automotive Product Configuration",
      "text" : "In this section we give examples how to apply propositional model counting to formulas as used in constructibility checking of customer orders at Mercedes-Benz. Therefore we first give a brief introduction of the notions used in the product documentation and of the configuration system used in the mass production of individually configured, personalized cars."
    }, {
      "heading" : "4.1 Formula Semantics",
      "text" : "For the Mercedes lines of cars, product documentation is done based on propositional logic. For each vehicle class, there are about 1.500 variables which represent the configuration options. Processing of customer orders at Mercedes-Benz is organized as a three-staged process [13]:\n1. The customer’s choice of configuration options P ⊂O with P = {xo1 , . . . ,xo|P|} is compiled into an initial assignment α = {xo1 ←⊤, . . . ,xo|P| ←⊤}. We refer to propositional variables representing an option o ∈ O also as codes.\n2. The assignment α computed in Step 1 is iteratively extended using so called supplementary rules. A supplementary rule S(x) → x consists of a conditional part S(x) in propositional logic and a supplementary code x. If α |= S(x) for the current assignment α we extend α = α ∪{x ←⊤}.\n3. For each code x there is a constructibility condition in propositional logic of the form x → C(x). The initial assignment α of Step 1, supplemented in Step 2, is finally checked for constructibility in this third step. If α |= ∧ x∈dom(α)C(x) holds, the customer order is constructible otherwise it will\nbe refused.\nLet X be the set of all allowed codes for a given line of vehicles, then the afore mentioned POF is defined as follows\nPOF(X) = ∧\nx∈X\n(S(x)→ x)∧ (x →C(x)).\nExample. Consider as a toy example a vehicle where the configuration options are three different engines with codes e1, e2, e3, two different gearboxes g1, g2 and three additional features a1, a2, a3. Engine e1 must be combined with gearbox g1 (sr1), e2 must be combined with g2 (sr2). In a car with e3 and g1 also a2 has to be chosen (sr3), in a car with e3 and g2, we must choose a3 (sr4). The resulting supplementary rules are\nsr1 = e1 → g1, sr2 = e2 → g2, sr3 = e3 ∧g1 → a2, sr4 = e3 ∧g2 → a3.\nThere is exactly one engine in a vehicle (cc1–cc4) and exactly one gearbox (cc5–cc7). There is also the condition, that feature a2 must not be combined with a3 (cc8). The resulting constructibility conditions are\ncc1 =⊤→ e1 ∨ e2 ∨ e3, cc2 = e1 →¬e2 ∧¬e3, cc3 = e2 →¬e1 ∧¬e3, cc4 = e3 →¬e1 ∧¬e2\ncc5 =⊤→ g1 ∨g2, cc6 = g1 →¬g2, cc7 = g2 →¬g1, cc8 = a2 →¬a3\nThe POF is the conjunction of all constructibility conditions and supplementary rules:\nPOF = 8∧\ni=1\ncci∧ 4∧\nj=1\nsr j .\nThe solutions of the POF represent exactly those customer orders (as a set of configuration options) which can be built under the configuration constraints. Hence any model α of the POF (i.e. α |= POF) describes a single valid configuration. Based on the notion of the POF, several consistency tests such as finding necessary codes, detecting redundant parts or intersections may be performed quite naturally using SAT solvers [13].\nGiven the variability described above, it is no longer possible to store separate parts lists (bills of material – BOM) for each possible order. Therefore, there is a single BOM for the model line (e.g. EClass), where each part p is associated with a selection condition P(p) in propositional logic. For each customer order, given as the supplemented assignment α , every part whose selection condition evaluates to true under α is pulled into the order specific BOM. Hence the set of all parts p occurring in the BOM is defined as {p | α |= P(p)}.\nThe BOM is actually structured into so-called positions, each of them grouping together a set of parts which may be alternatively selected for installation at the same geometric position of the car (e.g. the\nset of available radios). In addition, there is one fictitious (null-)part which represents the ”‘nothing-toinstall”’ case. Counting the models of the selection formulas for each part may give an indication of the relative frequency of the parts, and of the frequency of the null-case, which often represents some kind of exception."
    }, {
      "heading" : "4.2 Model Counting in the Mercedes-Benz Scenario",
      "text" : "In the rest of this paper, we will present some results as described in Section 3 gathered by model counting product documentation formulas in use at Mercedes-Benz. As those formulas are originally non-CNF, we developed a new exact propositional model counter that operates directly upon the raw formulas without prior normalization. It is based upon a reimplementation of the non-CNF SAT solver introduced by Thiffault et al. [23] and uses the DPLL-style approach to model counting with connected component detection and caching.\nRemark. When converting a non-CNF formula ϕ into a CNF formula ϕ ′ in order to utilize a CNF model counter, it is important to use a transformation method which preserves the number of models of ϕ , i.e. |{α | α |= ϕ}| = |{α | α |= ϕ ′}|. Consider e.g. the original formula ϕ = a∨ (b∧ c). To get an equisatisfiable formula ϕ ′ in CNF we can use the Tseitin transformation with either implications (T→(ϕ)) or equivalences (T↔(ϕ)):\nT→(ϕ) = for ∧ ( for → a∨ fand)∧ ( fand → b∧ c) = for ∧ (¬ for ∨a∨ fand)∧ (¬ fand ∨b)(¬ fand ∨ c) T↔(ϕ) = for ∧ ( for ↔ a∨ fand)∧ ( fand ↔ b∧ c) = for ∧ (¬ for ∨a∨ fand)∧ ( for ∨¬a)∧ ( for ∨¬ fand)∧\n(¬ fand ∨b)∧ (¬ fand ∨ c)∧ ( fand ∨¬b∨¬c)\nWe can now compare the number of models for each formula: #SAT (ϕ) = 5, #SAT (T→(ϕ)) = 6, and #SAT (T↔(ϕ)) = 5. We see that only T↔(ϕ) preserves the number of models."
    }, {
      "heading" : "4.2.1 Number of Valid Configurations",
      "text" : "Model counting pure PO formulas without any extensions (i.e. computing #SAT (POF), the number of different valid orders) demonstrates the vast multitude of constructible vehicles due to customer choices: We have been able to compute results of 5.9×1010 up to 9.9×10103 constructible orders for the E-class line of Mercedes-Benz cars (cf. Tab. 1). C212 A, C212 B, and C212 C indicate different body styles of the same car line. Those impressive numbers additionally provide an invaluable aid in arguing for formal methods use in large configuration settings. Our non-CNF model counter has directly been applied to the non-normalized POFs whereas Cachet and c2d have been given Tseitin transformed (T↔) CNF versions as input. Our comparison states that preserving formula structure by directly reasoning over the input without prior normalization pays off in scenarios featuring large input: Cachet timed out after 6 hours on C212 C respectively exited abnormally on C212 B, c2d has been manually aborted (as it is lacking a timeout option) after 6 hours returning no results.\nIn table 2 we summarize some computations we performed in order to analyze the number of valid orders including individual parts of the BOM, i.e. #SAT (POF∧P(p)). Each row identifies a position variant (e.g. a certain device in the set of available radios), i.e. a part that might be installed at one single position in the car. As simultaneously installing different parts at the same position poses a physical impossibility, position variants need to be mutually exclusive in order to preserve product documentation consistency. Using table 2 one may compute inclusion probabilities for each part depending on the\n1Environment: Linux (2.6.23), 3.4 GHz Intel Pentium D, 2 GB memory\ncorresponding POF. One can clearly see that for the few variants we computed, variant 20 dominates the others. These numbers might serve as a basis in applications estimating future requirements in purchasing parts or for speeding up SAT solving."
    }, {
      "heading" : "4.2.2 Rating Errors",
      "text" : "In practice it is highly desirable to rank the findings of an automated verifier. In the real world, nothing is perfect, and every corrective action has a price. If we have an error condition, which is represented by a formula ϕ being satisfiable, then #SAT(ϕ) may give an indication, how many cars are potentially affected by the error.\nAs an example consider physically overlapping parts p1, p2: If, due to the POF, there is a constructible order featuring both, p1 and p2, any assignment α with α |= POF∧P(p1)∧P(p2) describes an erroneously constructible order. Thus computing #SAT (POF∧P(p1)∧P(p1)) will return the total number of erroneously constructible orders wrt. p1 and p2. Using those numbers retrieved by model counting one may intuitively classify errors as follows: Overlaps leading to a high number of constructible orders (thus being more likely to actually occur in production) are intuitively more severe than overlaps featuring a negligible number. Experts concerned with fixing documentary flaws may thus prioritize their work using results produced by model counting."
    }, {
      "heading" : "4.2.3 Measuring Documentation Quality",
      "text" : "Exact model counts also give rise to questions about the appropriate product documentation language and method. We are currently engaged in introducing symbolic verification methods to detect and help\n2Environment: Mac OS X (10.5), 2×4 Core Intel Xeon (2.8 GHz each), 32 GB memory, using 1 core\navoid documentation errors. Knowing the exact model count gives some indication (at least on the level of management decisions) of the complexity of detecting errors. E.g. in order to prove that a part is no longer needed in a 2002 model line, it must be verified that none of the 1024 cars needs the part.\nOur results furthermore indicate that model counting POFs might serve as a measure of product documentation maturity (cf. Subsection 3.3): Model counting an early developer’s version of C212 A resulted in 2.9×1034 models whereas the version in productive use at Mercedes-Benz yields only 5.9×1010."
    }, {
      "heading" : "5 Conclusion & Future Work",
      "text" : "In this paper we introduced new methods for the quantitative analysis of configuration formulas using model counting. We described methods for gaining additional information like the total number of valid configurations, the relative frequency of options in valid configurations, or the severity of errors. This information can be used to speed up future SAT solving processes of similar formulas, illustrate the complexity of the problem, or measuring the documentation quality. Using our non-CNF model counter ncnt we have been able to compute results for formulas whose CNF representations are too large for recent model counters to cope with. Our results give proof of the applicability of our newly introduced analysis methods to industrial-scale configuration problems.\nAs our benchmarks show, model counting for large propositional formulas is still a quite timeconsuming job to do. In d-DNNF compilation static heuristics based upon hypergraph decomposition have been successfully used to generate good variable orders for decomposing large and complex formulas [12]. To our knowledge this approach has not yet been used in non-compilation based settings. Such heuristics should be introduced in DPLL-style model counting to speed up decomposition.\nMoreover, decomposing problems into independent connected components quite naturally suggests to harness multithreaded CPU architectures by parallelizing propositional model counting."
    }, {
      "heading" : "6 Acknowledgement",
      "text" : "We would like to thank Matthias Sauter (formerly STZ OIT) for providing us with helpful remarks, advice, and support."
    } ],
    "references" : [ {
      "title" : "Algorithms and Complexity Results for #SAT and Bayesian Inference",
      "author" : [ "Fahiem Bacchus", "Shannon Dalmao", "Toniann Pitassi" ],
      "venue" : "Proceedings of the FOCS ’03,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2003
    }, {
      "title" : "Counting Models Using Connected Components",
      "author" : [ "Roberto J. Bayardo", "Jr.", "Joseph Daniel Pehoushek" ],
      "venue" : "Proceedings of the 17th National Conference on Artificial Intelligence and 12th Conference on Innovative Applications of Artificial Intelligence,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2000
    }, {
      "title" : "A Few Billion Lines Of Code Later: Using Static Analysis to Find Bugs in the Real World",
      "author" : [ "Al Bessey", "Ken Block", "Ben Chelf", "Andy Chou", "Bryan Fulton", "Seth Hallem", "Charles Henri-Gros", "Asya Kamsky", "Scott McPeak", "Dawson Engler" ],
      "venue" : null,
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2010
    }, {
      "title" : "The Good Old Davis-Putnam Procedure Helps Counting Models",
      "author" : [ "Elazar Birnbaum", "Eliezer L. Lozinskii" ],
      "venue" : "Journal of Artificial Intelligence Research",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 1999
    }, {
      "title" : "Graph-Based Algorithms for Boolean Function Manipulation",
      "author" : [ "Randal E. Bryant" ],
      "venue" : "IEEE Transactions on Computers",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 1986
    }, {
      "title" : "Boolean Satisfiability with Transitivity Constraints",
      "author" : [ "Randal E. Bryant", "Miroslav N. Velev" ],
      "venue" : "Computer Aided Verification,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2000
    }, {
      "title" : "On the Tractable Counting of Theory Models and its Application to Truth Maintenance and Belief Revision",
      "author" : [ "Adnan Darwiche" ],
      "venue" : "Journal of Applied Non-Classical Logics",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2001
    }, {
      "title" : "New Advances in Compiling CNF to Decomposable Negational Normal Form",
      "author" : [ "Adnan Darwiche" ],
      "venue" : "Proceedings of the ECAI",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2004
    }, {
      "title" : "A Machine Program for Theorem-Proving",
      "author" : [ "Martin Davis", "George Logemann", "Donald Loveland" ],
      "venue" : "Communications of the ACM",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1962
    }, {
      "title" : "A Computing Procedure for Quantification Theory",
      "author" : [ "Martin Davis", "Hilary Putnam" ],
      "venue" : "Journal of the ACM",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1960
    }, {
      "title" : "Fast Backtrack Free Product Configuration using Precompiled Solution Space Representations",
      "author" : [ "Tarik Hadzic", "Subbarayan Sathiamoorthy", "Rune M. Jensen", "Henrik R. Andersen", "Jesper Møller", "Henrik Hulgaard" ],
      "venue" : "Proceedings of the International Conference on Economic,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2004
    }, {
      "title" : "A Structure-Based Variable Ordering Heuristic for SAT",
      "author" : [ "Jinbo Huang", "Adnan Darwiche" ],
      "venue" : "Proceedings of the IJCAI’03,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2003
    }, {
      "title" : "Proving Consistency Assertions for Automotive Product Data Management",
      "author" : [ "Wolfgang Küchlin", "Carsten Sinz" ],
      "venue" : "Journal of Automated Reasoning",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2000
    }, {
      "title" : "A Model Counting Characterization of Diagnoses",
      "author" : [ "T.K. Satish Kumar" ],
      "venue" : "Proceedings of the DX-02,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2002
    }, {
      "title" : "A Rule-Based Configurer of Computer Systems",
      "author" : [ "John McDermott" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 1982
    }, {
      "title" : "Constraint and Variable Ordering Heuristics for Compiling Configuration Problems",
      "author" : [ "Nina Narodytska", "Toby Walsh" ],
      "venue" : "Proceedings of the IJCAI’07,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2007
    }, {
      "title" : "Pruning Conformant Plans by Counting Models on Compiled D-DNNF Representations",
      "author" : [ "Héctor Palacios", "Blai Bonet", "Adnan Darwiche", "Héctor Geffner" ],
      "venue" : "editors: Proceedings of the ICAPS",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2005
    }, {
      "title" : "Linking Product Variety to Order-Fulfillment Strategies",
      "author" : [ "Frits K. Pil", "Matthias Holweg" ],
      "venue" : "Interfaces",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2004
    }, {
      "title" : "Product Configuration Frameworks-A Survey",
      "author" : [ "Daniel Sabin", "Rainer Weigel" ],
      "venue" : "IEEE Intelligent Systems",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 1998
    }, {
      "title" : "Combining Component Caching and Clause Learning for Effective Model Counting",
      "author" : [ "Tian Sang", "Fahiem Bacchus", "Paul Beame", "Henry Kautz", "Toniann Pitassi" ],
      "venue" : "Proceedings of the SAT",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2004
    }, {
      "title" : "Heuristics for Fast Exact Model Counting",
      "author" : [ "Tian Sang", "Paul Beame", "Henry Kautz" ],
      "venue" : "editors: Theory and Applications of Satisfiability Testing - SAT",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2005
    }, {
      "title" : "Performing Bayesian Inference by Weighted Model Counting",
      "author" : [ "Tian Sang", "Paul Beame", "Henry Kautz" ],
      "venue" : "Proceedings of the AAAI’05,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2005
    }, {
      "title" : "sharpSAT — Counting Models with Advanced Component Caching and Implicit BCP. In: Theory and Applications of Satisfiability Testing - SAT",
      "author" : [ "Marc Thurley" ],
      "venue" : null,
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2006
    }, {
      "title" : "The Complexity of Computing the Permanent",
      "author" : [ "G. Leslie" ],
      "venue" : "Valiant",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 1979
    } ],
    "referenceMentions" : [ {
      "referenceID" : 14,
      "context" : "Since R1/XCON [15] was used by DEC to support computer system configuration and assembly, product configuration systems have been among the most prominent and successful applications of AI methods in practice [19].",
      "startOffset" : 14,
      "endOffset" : 18
    }, {
      "referenceID" : 18,
      "context" : "Since R1/XCON [15] was used by DEC to support computer system configuration and assembly, product configuration systems have been among the most prominent and successful applications of AI methods in practice [19].",
      "startOffset" : 209,
      "endOffset" : 213
    }, {
      "referenceID" : 21,
      "context" : "Up to now model counting has mostly been used within bayesian networks [22, 1] and planning problems [17, 14].",
      "startOffset" : 71,
      "endOffset" : 78
    }, {
      "referenceID" : 0,
      "context" : "Up to now model counting has mostly been used within bayesian networks [22, 1] and planning problems [17, 14].",
      "startOffset" : 71,
      "endOffset" : 78
    }, {
      "referenceID" : 16,
      "context" : "Up to now model counting has mostly been used within bayesian networks [22, 1] and planning problems [17, 14].",
      "startOffset" : 101,
      "endOffset" : 109
    }, {
      "referenceID" : 13,
      "context" : "Up to now model counting has mostly been used within bayesian networks [22, 1] and planning problems [17, 14].",
      "startOffset" : 101,
      "endOffset" : 109
    }, {
      "referenceID" : 17,
      "context" : "Pil and Holweg [18] have discussed the interconnection of product variety and order-fulfillment strategies.",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 12,
      "context" : "Since we work with our industrial partner Mercedes-Benz on the symbolic verification of configuration problems [13], such as whether a given configuration is valid or not, or which part is required in which configurations, we were able to investigate how many valid configurations there are for one specific car line.",
      "startOffset" : 111,
      "endOffset" : 115
    }, {
      "referenceID" : 23,
      "context" : "According to [25] even the counting problems for polynomialtime solvable problems like 2-SAT, Horn-SAT, or DNF-SAT can be #P-complete.",
      "startOffset" : 13,
      "endOffset" : 17
    }, {
      "referenceID" : 9,
      "context" : "The vast majority of successful SAT solvers uses the DPLL approach [10, 9].",
      "startOffset" : 67,
      "endOffset" : 74
    }, {
      "referenceID" : 8,
      "context" : "The vast majority of successful SAT solvers uses the DPLL approach [10, 9].",
      "startOffset" : 67,
      "endOffset" : 74
    }, {
      "referenceID" : 3,
      "context" : "DPLL-style model counters like CDP [4], RelSat [2], or Cachet [20] are extensions to existing SAT solvers and require an input formula in CNF.",
      "startOffset" : 35,
      "endOffset" : 38
    }, {
      "referenceID" : 1,
      "context" : "DPLL-style model counters like CDP [4], RelSat [2], or Cachet [20] are extensions to existing SAT solvers and require an input formula in CNF.",
      "startOffset" : 47,
      "endOffset" : 50
    }, {
      "referenceID" : 19,
      "context" : "DPLL-style model counters like CDP [4], RelSat [2], or Cachet [20] are extensions to existing SAT solvers and require an input formula in CNF.",
      "startOffset" : 62,
      "endOffset" : 66
    }, {
      "referenceID" : 1,
      "context" : "The first one is component analysis [2] where one identifies different components C1, .",
      "startOffset" : 36,
      "endOffset" : 39
    }, {
      "referenceID" : 19,
      "context" : "The second improvement is the #SAT correspondence to clause learning in SAT: component caching [20, 24].",
      "startOffset" : 95,
      "endOffset" : 103
    }, {
      "referenceID" : 22,
      "context" : "The second improvement is the #SAT correspondence to clause learning in SAT: component caching [20, 24].",
      "startOffset" : 95,
      "endOffset" : 103
    }, {
      "referenceID" : 20,
      "context" : "component analysis and caching: While in SAT one tries to narrow down the search to one specific solution by intelligently choosing the branching variables, in #SAT we try to choose variables where the according constraint graph is decomposed in various components [21].",
      "startOffset" : 265,
      "endOffset" : 269
    }, {
      "referenceID" : 4,
      "context" : "One well known approach for this is the compilation of φ into a binary decision diagram (BDD) [5].",
      "startOffset" : 94,
      "endOffset" : 97
    }, {
      "referenceID" : 15,
      "context" : "Narodytska and Walsh discussed this approach for configuration problems [16].",
      "startOffset" : 72,
      "endOffset" : 76
    }, {
      "referenceID" : 7,
      "context" : "in the system c2d [8], is the deterministic decomposable negation normal form (d-DNNF) [7].",
      "startOffset" : 18,
      "endOffset" : 21
    }, {
      "referenceID" : 6,
      "context" : "in the system c2d [8], is the deterministic decomposable negation normal form (d-DNNF) [7].",
      "startOffset" : 87,
      "endOffset" : 90
    }, {
      "referenceID" : 12,
      "context" : "We will also refer to φ as product overview formula (POF) [13].",
      "startOffset" : 58,
      "endOffset" : 62
    }, {
      "referenceID" : 5,
      "context" : "Since the domains Di are finite and we only allow atomic propositions of the form x = v, we can use a reduction [6] from equality logic to propositional logic.",
      "startOffset" : 112,
      "endOffset" : 115
    }, {
      "referenceID" : 2,
      "context" : "Observations from formal methods in software verification [3] tell us that the more bugs you report, the smaller the probability gets that they will eventually be fixed.",
      "startOffset" : 58,
      "endOffset" : 61
    }, {
      "referenceID" : 12,
      "context" : "Processing of customer orders at Mercedes-Benz is organized as a three-staged process [13]:",
      "startOffset" : 86,
      "endOffset" : 90
    }, {
      "referenceID" : 12,
      "context" : "Based on the notion of the POF, several consistency tests such as finding necessary codes, detecting redundant parts or intersections may be performed quite naturally using SAT solvers [13].",
      "startOffset" : 185,
      "endOffset" : 189
    }, {
      "referenceID" : 11,
      "context" : "In d-DNNF compilation static heuristics based upon hypergraph decomposition have been successfully used to generate good variable orders for decomposing large and complex formulas [12].",
      "startOffset" : 180,
      "endOffset" : 184
    } ],
    "year" : 2010,
    "abstractText" : "We describe how to use propositional model counting for a quantitative analysis of product configuration data. Our approach computes valuable meta information such as the total number of valid configurations or the relative frequency of components. This information can be used to assess the severity of documentation errors or to measure documentation quality. As an application example we show how we apply these methods to product documentation formulas of the Mercedes-Benz line of vehicles. In order to process these large formulas we developed and implemented a new model counter for non-CNF formulas. Our model counter can process formulas, whose CNF representations could not be processed up till now.",
    "creator" : "LaTeX with hyperref package"
  }
}