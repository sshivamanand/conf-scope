{
  "name" : "1201.0564.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "The RegularGcc Matrix Constraint",
    "authors" : [ "Ronald de Haan", "Nina Narodytska" ],
    "emails" : [ "Haan@mailbox.tu-dresden.de,", "nina.narodytska@nicta.com.au", "toby.walsh@nicta.com.au" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n20 1.\n05 64\nv1 [\ncs .A\nI] 3\nJ an"
    }, {
      "heading" : "1 Introduction",
      "text" : "Global constraints can be used to model and reason about commonly found substructures. Many such models contain matrices of decision variables [1–3]. Matrix constraints are global constraints that apply to such matrices [4]. For example, the RegularGcc matrix constraint can be used to model rostering problems. It ensures each row of the matrix satisfies a Regular constraint (representing the shift rules) and each column satisfies a Gcc constraint (representing the required capacities for each shift). We prove here that propagating the RegularGcc constraint is costly, even under very severe restrictions. Therefore, as in [5], we look for partial methods that only enforce a limited level of consistency. These methods are based on necessary conditions that improve propagation over the decomposition into separate Regular constraints on the rows and separate Gcc constraints on the columns. These necessary conditions depend on extracting several string properties from the rows. We enforce these necessary conditions by constraining the rows with additional automaton constraints. Unfortunately, when the number of columns increases, these automata increase in size quite drastically. By using weighted automata, we show that we can limit the increase in size. Finally, we show that this approach can be used in a more general setting where we have a matrix with multicostRegular and Gcc constraints."
    }, {
      "heading" : "2 Intractable cases",
      "text" : "We first prove that propagating the RegularGcc matrix constraint is intractable even under strong conditions. More precisely, we show that enforcing bound consistency (BC) is NP-hard. This justifies why we later look for partial propagation methods based on some necessary (but not sufficient) conditions.\nTheorem 1. Enforcing BC on RegularGcc is NP-hard, already for Regular constraints given by a DFA of size 4, Gcc constraints specifying only an upper bound on the number of occurrences of one particular value, and just 3 values.\nProof: Reduction from 3-SAT. Let ϕ = γ1 ∧ · · · ∧ γC be a Boolean formula in CNF on propositional variables p1, . . . , pR. We construct an R × C matrix M of decision variables taking their values from {−1, 0, 1}, where each row 1 ≤ r ≤ R corresponds to a propositional variable pr and each column 1 ≤ c ≤ C corresponds to a clause γc.\nTo initialize the domain of variables in the matrix, we do the following for each clause γi = l i 1∨ l i 2∨ l i 3. We set Mr,i = 0 for all propositions pr not occurring in γi. For j ∈ {1, 2, 3} we set Mi,k ∈ {0, 1} if l i j = pk and we set Mi,k ∈ {0,−1} if lij = ¬pk. On each column we put the Gcc constraint that states that the value 0 occurs at most R − 1 times. On each row we put the Regular constraint that states that besides 0’s either only 1’s or only −1’s occur.\nWe show that this instance of RegularGcc has a solution iff ϕ is satisfiable. (⇒) We create a satisfying assignment I for ϕ as follows. For each pr, if in row r occurs at least one 1, we let I(pr) = ⊤, otherwise we let I(pr) = ⊥ (the choice of I(pr) when only 0’s occur in row r is arbitrary). Since in each column c there occur only R− 1 many 0’s, we know that there exists some pi for which Mi,c 6= 0 and thus I(lci ) = ⊤. Therefore I |= γc.\n(⇐) Let I be an assignment satisfying ϕ. We can instantiate M as follows. For each clause γc = l c 1 ∨ l c 2 ∨ l c 3, for j ∈ {1, 2, 3} we do the following. If l c j = pk and I(pk) = ⊤, we let Mk,c = 1. If lcj = ¬pk and I(pk) = ⊥, we let Mk,c = −1. Otherwise, we let Mk,c = 0. Since I is functional each Regular constraint on the rows is satisfied. Also, since at least one literal is satisfied in each clause, each column contains at least one value that is not 0, so the Gcc constraints are satisfied.\nAutomaton A in Fig. 1 witnesses that this Regular constraint can be enforced by a DFA of size 4. Note that this proof also works for any other restriction on Regular constraints that can enforce that, for two given values, in any word at most one of these values occurs.\nIn fact, since we only bound the number of one particular value in the Gcc constraint, the above proof also works for the RegularAmong constraint.\nA common type of Regular constraint in aRegularGccmatrix constraint is a Stretch constraint. This constrains the length of any stretch of values (e.g. there are at most 3 night shifts in a row) and the possible transitions (e.g. a night\nshift can only be followed by a day off). Unfortunately, even this special case is intractable to propagate.\nTheorem 2. Enforcing BC on StretchGcc is NP-hard, already for just 3 values.\nProof: Reduction from the Exact Cover problem. We are given F = {S1, . . . , Sn} with ⋃\ni Si = U . We ask if there is some subset C ⊆ F with ⋃\nc∈C c = U and c ∩ c ′ = ∅ for all distinct c, c′ ∈ C. W.l.o.g. we assume U contains the integers 1 to |U |. We construct a |F | × |U | matrix M, of decision variables taking their value in {−1, 0, 1}. For each row 1 ≤ r ≤ |F | and each value 1 ≤ i ≤ |U | we do the following. If i ∈ Sr, we let Mr,i ∈ {0, 1}. If i 6∈ Sr, we let Mr,i ∈ {−1, 0}.\nOn each column we put the Gcc constraint that states that the value 1 occurs exactly once. On each row we put the Stretch constraint stating that each stretch of 0’s must have a length of at least |U |.\nWe show that this instance of StretchGcc has a solution iff there exists an exact cover.\n(⇒) Take a solution for our instance. We let C be the set of all Ur for which row r in the solution contains only −1’s and 1’s. Obviously C ⊆ F . In order to show that ⋃\nc∈C = U , it suffices to show that U ⊆ ⋃\nc∈C . Take an arbitrary i ∈ U . Since our solution contains at least one 1 in each column, we know there is some c ∈ C such that i ∈ c. We also show that all distinct c, c′ ∈ C are disjoint. Take arbitrary c, c′ ∈ C such that c 6= c′. Assume j ∈ c∩ c′. This means that column j in the solution would contain two 1’s, which contradicts the Gcc constraints on the columns.\n(⇐) Let C ⊆ F be an exact cover. We fill M as follows. For each row 1 ≤ r ≤ |F |, we do the following. If Sr ∈ C, fill the row with −1’s and 1’s (this can be done only in one way). Otherwise, fill row r with only 0’s. Obviously, the Stretch constraints on the rows are satisfied. Also, since C is an exact cover, we know that for each 1 ≤ i ≤ |U | there is exactly one row r such that Mr,i = 1. Thus the Gcc constraints on the columns are satisfied.\nThis proof also works for the Regular constraint accepting only words that contain either only 0’s or only −1’s and 1’s, and therefore for any restriction on Regular constraints that can enforce permitted (or forbidden) words of length two (such as the meta constraint Slide).\nCorollary 1. Enforcing BC on SlideGcc is NP-hard, already for Slide constraints based on constraints of arity 2 and just 3 values.\nAnother common type of Regular constraint in a RegularGcc matrix constraint is a Sequence constraint. This limits the number of values of a particular type that occur in each sequence (e.g. at most 3 shifts in every 7 can be night shifts). This case is unfortunately also intractable to propagate. We prove that both enforcing domain consistency (DC) and enforcing bound consistency (BC) are NP-hard even if the matrix has just a few columns.\nTheorem 3. Enforcing DC on SequenceGcc is NP-hard, already for just 5 columns.\nProof: Reduction from the 3D Matching problem. The proof is inspired by [6]. Given are three pair-wise disjoint sets W , Z, Y of equal size q and a set M ⊆ W × Z × Y , |M | = m. The question is if there exists M ′ ⊆ M such that |M ′| = q and no two different elements of M ′ agree in any coordinate.\nAssume M = {s1, . . . , sm}. We create a m × 5 matrix M of decision variables taking their value in {0, t, w1, . . . , wq, z1, . . . , zq, y1, . . . , yq}. For each (wi, zi, yi) = si we let Mi,1 ∈ {0, wi}, Mi,2 ∈ {0, t}, Mi,3 ∈ {0, zi}, Mi,4 ∈ {0, t}, and Mi,5 ∈ {0, yi}.\nWe constrain each row i with the constraint Sequence(Mi, 1, 2, 2, {0}), stating that in each sequence of length 2, at least one 0 occurs. On columns 1 (resp. 3 and 5) we put the Gcc constraint stating that each value in W (resp. Z and Y ) occurs at least once, and that at least m− q many 0’s occur. On columns 2 and 4 we put the Gcc constraint stating that at least q many t’s occur, and at least m− q many 0’s.\nWe show that this instance of SequenceGcc has a solution iff there exists a 3D matching.\n(⇒) Take a solution for SequenceGcc. We know column 2 contains exactly m− q many t’s, and q many 0’s. For each occurrence of a t in column 2 at row i, columns 1 and 3 contain a 0 at row i (by the Sequence constraint). Then, by the Gcc constraint, for all rows j where column 2 contains a 0, columns 1 and 3 contain a non-0 at row j, and thus (by Sequence) column 4 contains a 0 at row j. By a similar argument, we know that in the remaining rows column 4 contains t’s. Continuing this argument for column 5, we know that in the solution there are q many rows taking values (wi, 0, zi, 0, yi) and m − q rows taking values (0, t, 0, t, 0). By the Gcc constraints, we know that each value w ∈ W occurs exactly once, as well as each value z ∈ Z and each y ∈ Y . Since the possible values were chosen by taking elements from M , we know that M ′ = {si | Mi 6= (0, t, 0, t, 0)} is a 3D matching.\n(⇐) Let M ′ ⊆ M be a 3D matching. We can fill M as follows. For each (wi, zi, yi) = si ∈ M ′, we let Mi = (wi, 0, zi, 0, yi). For each si ∈ M\\M ′ we let Mi = (0, t, 0, t, 0). Obviously each row satisfies the Sequence constraint. Since |M ′| = q and each value w ∈ W occurs exactly once in the first coordinate of M ′ (and similarly for values z ∈ Z and the second coordinate, and y ∈ Y and the third coordinate), we have that each column satisfies the corresponding Gcc constraint.\nNote that the Sequence constraints on all rows are the same, but the Gcc constraints on the columns differ.\nTheorem 4. Enforcing BC on SequenceGcc is NP-hard, already for just 5 columns.\nProof: The proof is similar to the proof of Theorem 3, and also inspired by [6].\nLet cwi (resp. czi, cyi) be the number of occurrences of the value wi (resp. zi, yi) in M . For each value wi (resp. zi, yi) we create cwi − 1 (resp. czi − 1, cyi − 1) clones of it. We now define the total order on values as U = [−w1q , . . . ,−w cwq−1 q , . . . ,−w11, . . . ,−w cw1−1 1 ,−z 1 q , . . . ,−z czq−1 q , . . . ,−z11, . . . , −zcz1−11 ,−y 1 q , . . . ,−y cyq−1 q , . . . ,−y11, . . . ,−y cy1−1 1 , 0, t, y1, . . . , yq, z1, . . . , zq, w1, . . . , wq].\nWe create the matrix M in a similar fashion as in the proof for Theorem 3, with the difference that for each (wi, zi, yi) = si we let Mi,1 ∈ [−w1i , . . . ,−w cwi−1 i , . . . , wi], Mi,3 ∈ [−z 1 i , . . . ,−z czi−1 i , . . . , zi], Mi,5 ∈ [−y1i , . . . ,−y cyi−1 i , . . . , yi], and Mi,2 ∈ [0, t] and Mi,4 ∈ [0, t].\nWe adapt the constraint on rows to Sequence(Mi, 1, 2, 2, [−w1q , 0]), stating that in each sequence of length 2, at least one value in [−w1q , 0] occurs. On columns 1 (resp. 3 and 5) we replace the Gcc constraint with one stating that each value in {−w1q , . . . ,−w cwq−1 q , . . . ,−w11 , . . . ,−w cw1−1 1 } ∪ W (resp. {−z1q , . . . ,−z czq−1 q , . . . ,−z11 , . . . ,−z cz1−1 1 } ∪ Z and {−y1q , . . . ,−y cyq−1 q , . . . ,−y11, . . . ,−y cy1−1 1 } ∪ Y ) occurs at least once. We do not change the Gcc constraints on columns 2 and 4.\nWe show that this instance of SequenceGcc has a solution iff there exists a 3D matching.\n(⇒) By reasoning similarly to the proof of Theorem 3 (replacing ‘0’ with ‘a value in [−w1q , 0]’ when reasoning about columns 1, 3 and 5), we know that in the solution there are q many rows taking values (wi, 0, zi, 0, yi), possibly containing clones, and m − q rows taking values (n, t, n′, t, n′′) where n, n′, n′′ are either 0 or some clone w′i, z ′ i, or y ′ i (respectively).\nFurthermore, by the Gcc constraint on the odd columns, we know that each value in {−w1q , . . . ,−w cwq−1 q , wq} must occur exactly once. Since these values occur only in the domains of Mi,1 for the cwq many si ∈ M that contain wq, we know that each of these Mi,1 must take a value in {−w1q , . . . ,−w cwq−1 q , wq}.\nThen, by the Gcc constraint on the odd columns, we know that each value in {−w1q−1, . . . ,−w cwq−1−1 q−1 , wq−1} must occur exactly once. These values occur only in the domains of Mi,1 for the si ∈ M that contain wq−1 or wq. However, the Mi,1 for the si ∈ M that contain wq must take values in {−w1q , . . . ,−w cwq−1 q , wq}. Therefore, the Mi,1 for the si ∈ M that contain wq−1 must take a value in {−w1q−1, . . . ,−w cwq−1−1 q−1 , wq−1}.\nRepeating this argument recursively until reaching the value t, we can restrict the effective domain of the odd positions of Mi for si = (wi, zi, yi) ∈ M to Mi,1 ∈ {−w1i , . . . ,−w cwi−1 i , wi}, Mi,3 ∈ {−z 1 i , . . . ,−z czi−1 i , zi}, and Mi,5 ∈ {−y1i , . . . ,−y cyi−1 i , yi}.\nTherefore, we know that each row Mi for si = (wi, zi, yi) ∈ M either has the values (wi, 0, zi, 0, yi) or the values (w ′ i, t, z ′ i, t, y ′ i) for some clones w ′ i, z ′ i, y ′ i of\nwi, zi, yi. Now, by the Gcc constraints, we know that each value w ∈ W occurs exactly once, as well as each value z ∈ Z and each y ∈ Y . Since the possible values were chosen by taking elements from M , we know that M ′ = {si | Mi = (w, 0, z, 0, y), w ∈ W, z ∈ Z, y ∈ Y } is a 3D matching.\n(⇐) Let M ′ ⊆ M be a 3D matching. We can fill M as follows. For each (wi, zi, yi) = si ∈ M ′, we let Mi = (wi, 0, zi, 0, yi). For each (wi, zi, yi) = si ∈ M\\M ′ we let Mi = (w′i, t, z ′ i, t, y ′ i) for some clones w ′ i, z ′ i, y ′ i of wi, zi, yi that have not been used before in the process of filling M. We know there are enough different clones for this procedure. It is easy to verify that this instantiation of M satisfies all the constraints."
    }, {
      "heading" : "3 Fixed parameter tractable cases",
      "text" : "We have seen that propagating the RegularGcc matrix constraint is NP-hard even under the strong restriction that either the number of values or the number of columns is bounded. However, if we consider Regular2 and we bound the number of columns and the number of states in the row and column automata we at last have a case in which propagation is polynomial.\nTheorem 5. Enforcing DC on Regular2 is fixed parameter tractable in k = C · |Q| · (log |Q′|), where C is the number of columns, |Q| is the size of the row automata, and |Q′| is the size of the column automata.\nProof: We assume w.l.o.g. that all row constraints are the same, and all column constraints are the same. We can encode the matrix constraint on a R × C matrix M in a single DFA on the matrix stretched out to a single sequence of variables M1,1, . . . ,M1,C , . . . ,MR,1, . . . ,MR,C . The state set of the automaton is Q×Q′|C|. In each state, the automaton keeps track of the current state q′ ∈ Q′ for each column c, as well as the current state q ∈ Q in the current row. The size of the automaton is O(|Q| · 2C(log |Q|)). Enforcing DC on a Regular constraint takes time polynomial in the size of the automaton, so our algorithm runs in fixed parameter tractable time.\nWe also get tractability if we bound the number of rows and the size of the automata.\nTheorem 6. Enforcing DC on RegularGcc is fixed parameter tractable in k = r(logQ) where r is the number of rows and Q the maximum number of states in any row automaton.\nProof: This follows directly from Observation 2 in [4], and the fact that Gcc over a sequence with fixed size can be encoded in a DFA with polynomially many states.\nOn the other hand, just bounding the number of rows is not enough to give tractability.\nTheorem 7. Enforcing BC on RegularGcc is W[2]-hard in k = R the number of rows, even with just 2 values.\nProof: This proof is similar to the proof of Theorem 3 in [4]. We reduce from p-Hitting-Set. Let H = (V,E) a hypergraph, where V = {v1, . . . , v|V |} and E = {e1, . . . , e|E|}. We ask if there is a hitting set S ⊆ V in H of cardinality k.\nWe construct an instance M of RegularGcc with |V | + |E| columns and k rows on the alphabet {0, 1}. The Regular constraint accepts |V | different words w1, . . . , w|V | of length |V | + |E|. For any word wv, the vth value is 1, and the remainder of the first |V | values is 0. Also, for any word wv and any 1 ≤ j ≤ |E|, the jth value of wv is 1 if v ∈ ej , and is 0 otherwise. The Gcc constraints we put on the columns are as follows. In the first |V | columns we require exactly one 1. In the remaining columns, we require at least one 1.\nIn this reduction, each row corresponds to one vertex that is being chosen for inclusion in the hitting set, and each column after the first |V | to one hyperedge.\nThe Gcc constraints on the first |V | columns ensure that no vertex is chosen in two rows. The constraints on the last |E| columns ensure that each hyperedge contains a vertex chosen for the hitting set. If there is a hyperedge all vertices of which are not included in the hitting set, the column corresponding to this hyperedge will contain 0’s only, violating the Gcc constraint of that column.\nWe show that there exists a hitting set S in H of cardinality k iff the RegularGcc matrix constraint has a solution.\n(⇒) Assume there exists a hitting set S in H of size k. We construct an assignment to RegularGcc by matching one vertex v ∈ S with each row (in any manner). If row i is matched to vertex v, we assign word wv to row i. The fact that S contains k different vertices v ensures that k different words wv are used. Also, since S is a hitting set, we know that for each hyperedge ej there is at least one v ∈ ej ∩S, and so each of the last |E| columns contains at least one 1. Thus the Gcc constraints are satisfied.\n(⇐) Suppose the RegularGcc matrix constraint has a solution. We construct a hitting set S by taking all v such that wv is a row in the solution. By the Gcc constraints we know that the solution contains k different words wv, so S is of size k. Now, to derive the contrary, assume there exists a hyperedge ej ∈ E such that S ∩ ej = ∅. Then the column corresponding to ej (column |V | + j) contains only 0’s. This violates Gcc on this column, which is a contradiction.\nNote that the Gcc constraints in the above proof can be expressed with Regular constraints of bounded size as well, which gives us the following corollary.\nCorollary 2. Enforcing BC on the Regular2 matrix constraint is W[2]-hard in k the number of rows, even with just 2 values.\nAnother special case that is intractable is when we repace the Gcc constraint on the columns with a simpler sum constraint.\nTheorem 8. Enforcing BC on the RegularSum matrix constraint is W[2]hard in k the number of rows, even with just 3 values.\nProof: (Sketch) The proof is similar to the proof of Theorem 7 and the proof of Theorem 3 in [4]. We reduce from p-Hitting-Set and construct a matrix constraint as in the proof of Theorem 7, with the following differences. The\nfirst |V | columns we fill with −1’s instead of 1’s. We can then replace the Gcc constraints on these columns with the Sum constraint requiring a sum of at least −1. The Gcc constraints on the last |E| columns can be replaced with the Sum constraint requiring a sum of at least 1. The arguments in the proof of Theorem 7 now hold for this instance of RegularSum.\nNote that this result is strictly stronger than the W[1]-hardness proof of enforcing BC on RegularSum in [4]."
    }, {
      "heading" : "4 Some necessary conditions",
      "text" : "Motivated by these rather negative complexity results, we investigate how to improve propagation over a simple decomposition into separateRegular andGcc constraints by means of deriving necessary conditions based on string properties. In fact, we will show how to extend the method of [5] to the (decomposed) setting of multicostRegular constraints on the rows andGcc constraints on the columns. This method is based on a double counting argument. Using automata constraints we extract several string properties from the rows. For these string properties, we derive lower and upper bounds based on the Gcc constraints on the columns. This allows us to derive necessary constraints relating the bounds to the corresponding string properties.\nWe start with some preliminary definitions needed for our exposition. The multicostRegular global constraint [7] is defined as follows. Given a sequence X = (x1, x2, . . . , xn) of finite domain decision variables and a deterministic finite automaton A = (Q, V,∆, s, F ), the constraint Regular(X,A) holds iff X is a word of length n over V accepted by DFA A. Given a vector Z = (z0, . . . , zR) of bounded variables and c = (crq,v) r∈[0...R] q∈Q,v∈V a family of assignment cost matrices, multicostRegular(X,Z,A, c) holds iff Regular(X,A) holds and for an accepting run q0q1 . . . qn of A on the instantiation (v0, . . . , vn) of X we have that ∑\n0≤i<n c r qi,vi+1 = zr for all 0 ≤ r ≤ R. For any two DFAs A1 = (Q1, V,∆1, s1, F1) and A2 = (Q2, V,∆2, s2, F2), with corresponding c1 and c2 cost matrices over resources R = {r0, . . . , rR}, we define the product automaton A1 ×A2 = (Q1 ×Q2, V,∆, (s1, s2), F1 × F2) and product cost matrix c = c1 × c2 as follows.\n∆((q1, q2), v) = (∆1(q1, v), ∆2(q2, v))\ncr(q1,q2),v = c 1,r q1,v + c2,rq2,v for 0 ≤ r ≤ R\nIn other words, when taking the product of two weighted automata, we take the usual cross product of the underlying automata, and add the cost matrices.\nWe show how to extract relevant string properties using multicostRegular constraints on the rows. In the following, we let v ∈ V denote a value that the decision variables can take, we let v̂, ŵi ⊆ V (for indices i ∈ N) denote a subset of these values, we let ¬v̂ denote V \\v̂, and we let Z be a set of bounded variables representing the calculated weights. We also define the concatenation ŵ1 · . . . ·ŵm of several ŵi as the set {w1 · · ·wm ∈ V m | wi ∈ ŵi, 1 ≤ i ≤ m}.\nTo extract the number of uninterrupted stretches of elements from v̂ in X using a resource variable zr ∈ Z, we can use the weighted DFA Av̂1 (Figure 2), where transitions are marked with the symbol and the cost cr they consume. For any word X , we have that multicostRegular(X,Z,Av̂1 , c) holds for z r the number of stretches of symbols in v̂ that occur in X .\nTo extract whether a word w ∈ ŵ occurs in X starting at position k using a resource variable zrk, we can use the weighted DFA A k,ŵ 2 (Figure 3) with parameter k ∈ N, where transitions are marked with the symbol and the cost cr they consume. For any wordX , we have that multicostRegular(X,Z,Ak,ŵ2 , c) sets zrk to true if and only if some word w ∈ ŵ occurs in X starting at position k. To extract the total number of occurrences of words w ∈ ŵ (starting any position) in X , we take the sum of the values of the variables zrk (for 1 ≤ k ≤ n) that represent whether a suitable word w occurs in X starting at position k.\nTo extract the minimum and maximum length of stretches, we can simulate counters using weights. Let A be a DFA annotated with counters d = (d1, . . . , dm), taking their values from {0, . . . , n − 1}. We can construct a DFA A′ of size less than or equal to nm · |A|, together with a cost matrix c for resources r1, . . . , rm such that for any word w there exists an accepting run for w on A where the counters have final values (v1, . . . , vm) if and only if there exists an accepting run for w on A′ for (z1, . . . , zm) = (v1, . . . , vm). This can be done straightforwardly by choosing Q×{0, . . . , n−1}m as state set for A′, and choosing transitions ∆ corresponding to the update formulae for the counters. Now c can be chosen to mimic the changes in counter values over transitions. The automaton A′ can possibly be reduced in size by removing unreachable states or minimizing it using other methods.\nWe can transform any given automaton A to extract the minimum and maximum length of a stretch of symbols from v̂ occurring in A on X as follows.\nWe annotate A with counters that represent stretchminlen(v̂, n) and stretchmaxlen(v̂, n), as described in [5]. Then we transform this annotated automaton, as described above, into an automaton A′ with resource variables zv̂min and zv̂max whose values (respectively) represent the minimum and maximum length of stretches of symbols in v̂ occurring in X .\nThe above automata, extracting the different string properties from rows, can be combined with each other and with other automata by using the product operation. By defining zero cost matrices for all resources not used explicitly in a given automaton, we can extract several different string properties simultaneously with one weighted product automaton.\nIn this more general decomposed setting with multicostRegular constraints on the rows, a tractable option for propagation is the algorithm based on a Lagrangian relaxation of the Resource Constrained Shortest Path Problem (RCSPP) from [7]. Using weighted automata to extract string properties has several advantages. The size of the automata is relatively low. The automata used to extract the number of stretch occurrences are even of constant size. A weighted automaton used to extract a string property is never larger than the unfolding of an (unweighted) automaton annotated with counters used to extract the same string property. Also, the use of weighted automata allows us to express several other constraints with small automata. For instance, Gcc constraints on the rows can be expressed by a weighted automaton with a single state. In fact, Gcc constraints can be expressed using additional weights on other automaton constraints already posed on the rows.\nUsing the above string properties, we can derive necessary conditions that exploit the matrix structure. Consider the following CSP, similar to the one sketched in [5]. Given three positive integers R, K, and V , we have an R ×K matrix M of decision variables with domain {0, 1, . . . , V − 1}, and a V × K matrix M# of cardinality variables with domain {0, 1, . . . , R}. Each row r, for 0 ≤ r < R, of M is subject to a multicostRegular constraint. For simplicity, we assume that each row is subject to the same constraint. Each column k, for 0 ≤ k < K, of M is subject to a Gcc constraint that restricts the number of occurrences of the values according to column k of M#. Let #vk denote the number of occurrences of value v, for 0 ≤ v < V , in column k of M, that is, the cardinality variable in row v and column k of M#. For any v̂ ⊆ V , we let #v̂k denote ∑\nv∈v̂(# v k).\nIn order to constrain the number of occurrences of words, we define the bounds lwk(ŵ) and uwk(ŵ) on the number of occurrences of words in ŵ starting at column k, based on the Gcc constraints on the columns, as follows:\nlwk(ŵ) = max\n\n\n\n\n|ŵ|−1 ∑\nj=0\n# ŵj k+j\n\n− (|ŵ| − 1) · R, 0\n\n (1)\nuwk(ŵ) = |ŵ|−1\nmin j=0\n(\n# ŵj k+j\n)\n(2)\nNote that definitions (1) and (2) are exactly the same as in [5]. The lower bound (1) is the worst-case intersection of all column value occurrences. The upper bound (2) is justified by the fact that a word cannot occur more often than its minimally occurring letter. We now get the following necessary conditions for each 0 ≤ k < K:\nlwk(ŵ) ≤ R−1 ∑\nr=0\nzŵr,k (3) uwk(ŵ) ≥ R−1 ∑\nr=0\nzŵr,k (4)\nwhere zŵr,k denotes the resource variable representing whether a word in ŵ occurs in row r starting at column k. Since we extracted the number of word occurrences for each starting position k, we can directly relate the bounds derived from the column constraints with the number of word occurrences per starting position. This results in constraints (3) and (4) potentially leading to more propagation than their counterparts in [5]. This is illustrated in Example 1. Note that the constraints from [5] on words occurring as a prefix or as a suffix correspond to particular cases of constraints (3) and (4).\nExample 1. Consider the scenario concerning a partially instantiated 5 × 5 matrix in Figure 4, which could occur as a node in the search tree. Let ŵ = {2}{2}. In this scenario lwk(ŵ) are variables. Also, zŵr is a variable such that zŵr = ∑K−1 k=0 z ŵ r,k. In this scenario, the bounds of the variables z ŵ r,k can be automatically derived by the row automata. By using equation (3), we can directly detect unsatisfiability in this case, since lw1(ŵ) ∈ [3, 5] and thus lw1(ŵ) 6≤ ( ∑R−1 r=0 z ŵ r,1) ∈ [0, 2]. Consider the counterpart of equation (3) from [5]: ∑K−|ŵ|\nk=0 lwk(ŵ) ≤ ∑R−1 r=0 z ŵ r . Using this constraint, unsatisfiability cannot\ndirectly be detected in this particular case.\nTake note of the following case, where ŵ = v̂ for some v̂ ⊆ V . In this case, for each 0 ≤ k < K the constraints (1) and (2) and the constraints (3) and (4) simplify to, respectively:\nlwk(v̂) = uwk(v̂) = # v̂ k (5) # v̂ k =\nR−1 ∑\nr=0\nzv̂r,k (6)\nIn order to constrain the number of occurrences of stretches, we define the bounds ls+k and us + k (referring to the number of uninterrupted stretches of variables from v̂ that start in column k) and the bounds ls−k and us − k (referring to the number of uninterrupted stretches of variables from v̂ that end in column k),\nbased on the Gcc constrains as follows:\nls+k = max(0,# v̂ k −# v̂ k−1) (7)\nus+k = # v̂ k −max(0,# v̂ k−1 +# v̂ k −R) (8)\nls−k = max(0,# v̂ k −# v̂ k+1) (9)\nus−k = # v̂ k −max(0,# v̂ k+1 +# v̂ k −R) (10)\nDefinitions (7) through (10) are exactly the same as in [5]. The lower bound (7) is the difference between the number of occurrences of values v̂ in column k minus the number of occurrences of v̂ in column k − 1, if positive. If the total number of occurrences of values v̂ on column k and on column k− 1 are strictly greater than the number of rows R, then there must be at least #v̂k−1 +# v̂ k −R stretches of values v̂ that cover both columns. This minimum intersection gives us the upper bound (8). Bounds (9) and (10) are derived similarly. We now get the following necessary conditions:\nK−1 ∑\nk=0\nls+k (v̂) ≤ R−1 ∑\nr=0\nzv̂r (11)\nK−1 ∑\nk=0\nus+k (v̂) ≥ R−1 ∑\nr=0\nzv̂r (12)\nK−1 ∑\nk=0\nls−k (v̂) ≤ R−1 ∑\nr=0\nzv̂r (13)\nK−1 ∑\nk=0\nus−k (v̂) ≥ R−1 ∑\nr=0\nzv̂r (14)\nwhere zv̂r denotes the variable corresponding to the resource that represents the number of uninterrupted sequences of symbols in v̂ occurring in row r.\nIn order to constrain the minimum and maximum length of a stretch, using the minimum and maximum length (zv̂min and z v̂ max, respectively) of uninterrupted sequences of symbols in v̂ occurring in any row, we get the following necessary conditions for each 0 ≤ k < K:\n#v̂k ≥ k ∑\nj=max(0,k−zv̂min+1)\nls+j (v̂) (15) #v̂k ≥\nmin(K−1,k+zv̂min−1) ∑\nj=k\nls−j (v̂) (16)\nConstraints (15) and (16) are justified by the fact that stretches starting resp. ending at the considered columns j must overlap column k. Also, for each 0 ≤ k < K − zv̂max we get the necessary condition:\nls+k (v̂) +\nzv̂max ∑\nj=zv̂ min\n#v̂k+j − (z v̂ max − z v̂ min + 1) ·R ≤ 0 (17)\nand for each zv̂max ≤ k < K the necessary condition:\nls−k (v̂) +\nzv̂max ∑\nj=zv̂ min\n#v̂k−j − (z v̂ max − z v̂ min + 1) ·R ≤ 0 (18)\nThe justification behind constraint (17) is that for a stretch of values v̂ beginning at column k, there must be a value not in v̂ in some column j, for k + zv̂min ≤ j ≤ k + zv̂max. Constraint (18) is justified similarly."
    }, {
      "heading" : "5 Evaluation",
      "text" : "To evaluate our method, we used NSPLib [8], a library of benchmark instances of the nurse scheduling problem (NSP). This is a particular rostering problem. For N the number of nurses, D the number of days in the scheduling horizon, and S the number of shifts, the objective is to construct a N × D matrix of values in the integer interval [1, S], where value S represents the off-duty shift.\nIn instance files, there are hard coverage constraints and soft preference constraints. We only consider the hard coverage constraints. These give for each day d and shift s the lower bound on the number of nurses that must be assigned to shift s on day d. These constraints can be modelled by Gcc constraints on the columns. We considered instance files forN×7 rosters withN ∈ {25, 50, 75, 100}.\nCase files provide hard constraints on the rows. For each shift s, there are lower and upper bounds on the number of occurrences of s in any row. There are also lower and upper bounds on the cumulative number of occurrences of the working shifts 1, . . . , S − 1 in any row. These two types of constraints can be modelled by Gcc constraints on the rows. For each shift s, there are also lower and upper bounds on the length of any stretch of value s in any row. Finally, there are lower and upper bounds on the length of any stretch of working shifts 1, . . . , S − 1 in any row. These two types of constraints can be modelled by stretch path and stretch path partition constraints on the rows, respectively. By translating these row constraints to automata, we get that the NSP benchmark problems as described above correspond to the RegularGcc pattern studied in this paper.\nIn order to compare the effect of the necessary conditions in the settings of both weighted and unweighted automata, we implemented the row constraints (both for the constraints from the case files and for extracting string properties) using weighted finite automata as well as regular (unweighted) finite automata. For the setting of unweighted automata, we translated the case constraints specified for each shift and for the total set of working shifts as a single Regular constraint on each row (by taking the corresponding minimised product DFA). For each string property that we extract from the rows, we used automata annotated with counters (as described in [5]), unfolded into a DFA, expressed as a decomposition into ternary constraints [9] allowing us to extract the counter values. The methods used in [5] for automata annotated with counters are not implemented in the free major constraint programming libraries and solvers.\nFor the setting of weighted automata. We translated the case constraints for each shift and for the total set of working shifts as a single multicostRegular constraint on each row (by taking the corresponding product automaton). For each string property that we extract from the rows, we posed a single multi-\ncostRegular constraint defined by the corresponding weighted automaton as described in Section 4.\nIn order to compare the two settings fairly, we posed the constraints defined by automata in a similar pattern, i.e., we take the products of corresponding automata in the two settings. One advantage that the setting of weighted automata possesses, is that taking the product of particular automata results in a relatively small increase in the automaton size, not nearly as explosive as the size increase in the corresponding unweighted product automaton. In order to improve propagation, we were able to pose the weighted automata extracting the number of stretches of different shifts from the rows as the product of the corresponding automaton with (a copy of) the automata specifying the constraints on the number of shift occurrences from the case file. In the unweighted setting this is completely intractable, since the size of the product DFA corresponding to the automata annotated with counters gets too large.\nIn both settings, we implemented necessary constraints based on the following string properties:\n– for each shift, lower and upper bounds on the number of its occurrences, – for each shift, lower and upper bounds on the number and length of its\nstretches, – each word of length at most 2 that consists of one single shift.\nIn the setting of weighted automata, the necessary constraints are derived as described in Section 4. In the setting of unweighted automata, the necessary constraints are derived as in [5].\nThe objective of our experiments is to measure the impact in runtime and backtracks for the different settings. The experiments were run under Choco 2.1.1 on a 2.27 GHz Intel Xeon with a 4GB RAM. All runs were allocated 3 CPU minutes. For each case and nurse count N , we used instances 1-270.\nIn the experiments we used a labelling procedure that selects variables with the smallest domain, with a row-wise order as tie-breaker, and selects the smallest value. We used a LexChain constraint for symmetry breaking. We used the implementation of the multicostRegular constraint available in Choco.\nTable 1 summarises the running of the instances for the different settings (the setting of weighted automata with cross products (CWA) and without extra cross products (WA), and the setting of unweighted automata (UA)), for Cases 7 and 8. Each row first indicates the number of known instances of some satisfiability status for a given case and nurse count N , and then the performance of each setting to the first solution, namely the number of instances decided to be of that status without timing out, as well as the average runtime (in seconds) and the average number of backtracks for all instances on which none of the settings timed out. Numbers in boldface indicate best performance in a row.\nThe benchmark results in Table 1 show that WA and CWA were able to solve significantly more instances compared to the method using unweighted automata, both for satisfiable and unsatisfiable instances. Further, CWA improved the performance for most of the benchmarks in terms of number of backtracks and runtime, compared to WA. Notably, the UA method solved only 4 out of 156\nknown unsatisfiable instances while CWA and UA solved all of these benchmarks. This shows that using weighted automata together with necessary constraints leads to significantly more pruning than using unweighted automata with similar necessary constraints. For the majority of solved unsatisfiable instances, WA and CWA detected unsatisfiability at the root of the search tree. This is not visible in the table, because the shown runtimes and number of backtracks are based on instances solved by all methods. Note that these benchmarking results are not directly comparable to the results in [5], since these results were obtained under a different experimental set-up (e.g. a different search strategy was used).\nOverall, the results indicate that the use of weighted automata to solve rostering problems shows potential. A combination of weighted automata and necessary constraints dramatically increase propagation compared to using unweighted automata. Our results on unsatisfiable instances suggest that such a combination can be very useful in finding optimum solutions for rostering problems. Another advantage of our approach is that it can be easily implemented in open-source constraint solvers."
    }, {
      "heading" : "6 Conclusions",
      "text" : "We studied the propagation of the RegularGcc matrix constraint. We showed that propagation is NP-hard, even under some strong restrictions, and also showed two cases in which propagation is fixed parameter tractable. Additionally, we showed how to improve propagation over a decomposition into separate Regular constraints on the rows and Gcc constraints on the columns by identifying some necessary but insufficient conditions. We showed how the use of weighted automata for the row constraints can be beneficial. Experimental results on nurse scheduling problems demonstrate the potential for this method."
    } ],
    "references" : [ {
      "title" : "Matrix modelling",
      "author" : [ "P. Flener", "A.M. Frisch", "B.H.Z. Kzlltan", "I. Miguel", "T. Walsh" ],
      "venue" : "Proceedings of the International Workshop on Modelling and Problem Formulation.",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Matrix modelling: Exploiting common patterns in constraint programming",
      "author" : [ "P. Flener", "A.M. Frisch", "B.H.Z. Kzlltan", "I. Miguel", "T. Walsh" ],
      "venue" : "Proceedings of the International Workshop on Reformulating Constraint Satisfaction Problems.",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "The Cardinality Matrix Constraint",
      "author" : [ "J.C. Régin", "C.P. Gomes" ],
      "venue" : "In Wallace, M., ed.: Proceedings of the 10th International Conference on Principles and Practice of Constraint Programming (CP’04). Volume 3258 of Lecture Notes in Computer Science., Springer",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Global matrix constraints",
      "author" : [ "George Katsirelos", "C.G.Q. Nina Narodytska", "T. Walsh" ],
      "venue" : "Proceedings of the International Workshop on Constraint Modelling and Reformulation.",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "On matrices, automata, and double counting",
      "author" : [ "N. Beldiceanu", "M. Carlsson", "P. Flener", "J. Pearson" ],
      "venue" : "In Lodi, A., Milano, M., Toth, P., eds.: Proceedings of the 7th International Conference on Integration of AI and OR Techniques in Constaint Programming for Combinatorial Optimization Problems (CPAIOR’10). Volume 6140 of Lecture Notes in Computer Science., Springer",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Sequencing and Counting with the multicost-regular Constraint",
      "author" : [ "J. Menana", "S. Demassey" ],
      "venue" : "In van Hoeve, W.J., Hooker, J.N., eds.: Proceedings of the 6th International Conference on Integration of AI and OR Techniques in Constaint Programming for Combinatorial Optimization Problems (CPAIOR’09). Volume 5547 of Lecture Notes in Computer Science., Springer",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "On the characterization and generation of nurse scheduling problem instances",
      "author" : [ "M. Vanhoucke", "B. Maenhout" ],
      "venue" : "European Journal of Operational Research 196(2)",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Global grammar constraints",
      "author" : [ "C.G. Quimper", "T. Walsh" ],
      "venue" : "In Benhamou, F., ed.: Proceedings of the 12th International Conference on Principles and Practice of Constraint Programming (CP’06). Volume 4204., Springer",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2006
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Many such models contain matrices of decision variables [1–3].",
      "startOffset" : 56,
      "endOffset" : 61
    }, {
      "referenceID" : 1,
      "context" : "Many such models contain matrices of decision variables [1–3].",
      "startOffset" : 56,
      "endOffset" : 61
    }, {
      "referenceID" : 2,
      "context" : "Many such models contain matrices of decision variables [1–3].",
      "startOffset" : 56,
      "endOffset" : 61
    }, {
      "referenceID" : 3,
      "context" : "Matrix constraints are global constraints that apply to such matrices [4].",
      "startOffset" : 70,
      "endOffset" : 73
    }, {
      "referenceID" : 4,
      "context" : "Therefore, as in [5], we look for partial methods that only enforce a limited level of consistency.",
      "startOffset" : 17,
      "endOffset" : 20
    }, {
      "referenceID" : 3,
      "context" : "Proof: This follows directly from Observation 2 in [4], and the fact that Gcc over a sequence with fixed size can be encoded in a DFA with polynomially many states.",
      "startOffset" : 51,
      "endOffset" : 54
    }, {
      "referenceID" : 1,
      "context" : "Enforcing BC on RegularGcc is W[2]-hard in k = R the number of rows, even with just 2 values.",
      "startOffset" : 31,
      "endOffset" : 34
    }, {
      "referenceID" : 3,
      "context" : "Proof: This proof is similar to the proof of Theorem 3 in [4].",
      "startOffset" : 58,
      "endOffset" : 61
    }, {
      "referenceID" : 1,
      "context" : "Enforcing BC on the Regular matrix constraint is W[2]-hard in k the number of rows, even with just 2 values.",
      "startOffset" : 50,
      "endOffset" : 53
    }, {
      "referenceID" : 1,
      "context" : "Enforcing BC on the RegularSum matrix constraint is W[2]hard in k the number of rows, even with just 3 values.",
      "startOffset" : 53,
      "endOffset" : 56
    }, {
      "referenceID" : 3,
      "context" : "Proof: (Sketch) The proof is similar to the proof of Theorem 7 and the proof of Theorem 3 in [4].",
      "startOffset" : 93,
      "endOffset" : 96
    }, {
      "referenceID" : 0,
      "context" : "Note that this result is strictly stronger than the W[1]-hardness proof of enforcing BC on RegularSum in [4].",
      "startOffset" : 53,
      "endOffset" : 56
    }, {
      "referenceID" : 3,
      "context" : "Note that this result is strictly stronger than the W[1]-hardness proof of enforcing BC on RegularSum in [4].",
      "startOffset" : 105,
      "endOffset" : 108
    }, {
      "referenceID" : 4,
      "context" : "In fact, we will show how to extend the method of [5] to the (decomposed) setting of multicostRegular constraints on the rows andGcc constraints on the columns.",
      "startOffset" : 50,
      "endOffset" : 53
    }, {
      "referenceID" : 5,
      "context" : "The multicostRegular global constraint [7] is defined as follows.",
      "startOffset" : 39,
      "endOffset" : 42
    }, {
      "referenceID" : 4,
      "context" : "We annotate A with counters that represent stretchminlen(v̂, n) and stretchmaxlen(v̂, n), as described in [5].",
      "startOffset" : 106,
      "endOffset" : 109
    }, {
      "referenceID" : 5,
      "context" : "In this more general decomposed setting with multicostRegular constraints on the rows, a tractable option for propagation is the algorithm based on a Lagrangian relaxation of the Resource Constrained Shortest Path Problem (RCSPP) from [7].",
      "startOffset" : 235,
      "endOffset" : 238
    }, {
      "referenceID" : 4,
      "context" : "Consider the following CSP, similar to the one sketched in [5].",
      "startOffset" : 59,
      "endOffset" : 62
    }, {
      "referenceID" : 4,
      "context" : "Note that definitions (1) and (2) are exactly the same as in [5].",
      "startOffset" : 61,
      "endOffset" : 64
    }, {
      "referenceID" : 4,
      "context" : "This results in constraints (3) and (4) potentially leading to more propagation than their counterparts in [5].",
      "startOffset" : 107,
      "endOffset" : 110
    }, {
      "referenceID" : 4,
      "context" : "Note that the constraints from [5] on words occurring as a prefix or as a suffix correspond to particular cases of constraints (3) and (4).",
      "startOffset" : 31,
      "endOffset" : 34
    }, {
      "referenceID" : 2,
      "context" : "By using equation (3), we can directly detect unsatisfiability in this case, since lw1(ŵ) ∈ [3, 5] and thus lw1(ŵ) 6≤ ( ∑R−1 r=0 z ŵ r,1) ∈ [0, 2].",
      "startOffset" : 92,
      "endOffset" : 98
    }, {
      "referenceID" : 4,
      "context" : "By using equation (3), we can directly detect unsatisfiability in this case, since lw1(ŵ) ∈ [3, 5] and thus lw1(ŵ) 6≤ ( ∑R−1 r=0 z ŵ r,1) ∈ [0, 2].",
      "startOffset" : 92,
      "endOffset" : 98
    }, {
      "referenceID" : 1,
      "context" : "By using equation (3), we can directly detect unsatisfiability in this case, since lw1(ŵ) ∈ [3, 5] and thus lw1(ŵ) 6≤ ( ∑R−1 r=0 z ŵ r,1) ∈ [0, 2].",
      "startOffset" : 140,
      "endOffset" : 146
    }, {
      "referenceID" : 4,
      "context" : "[5]: K−|ŵ| k=0 lwk(ŵ) ≤ ∑R−1 r=0 z ŵ r .",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 1,
      "context" : "1 1 lw0(ŵ) ∈ [0, 2] z ŵ 0,1 ∈ [0, 1] z ŵ 0 ∈ [0, 1] lw1(ŵ) ∈ [3, 5] z ŵ 1,1 ∈ [0, 1] z ŵ 1 ∈ [0, 1] lw2(ŵ) ∈ [0, 2] z ŵ 2,1 = 0 z ŵ 2 ∈ [0, 1] lw3(ŵ) ∈ [0, 5] z ŵ 3,1 = 0 z ŵ 3 ∈ [0, 1] lw4(ŵ) = 0 z ŵ 4,1 = 0 z ŵ 4 ∈ [0, 1]",
      "startOffset" : 13,
      "endOffset" : 19
    }, {
      "referenceID" : 0,
      "context" : "1 1 lw0(ŵ) ∈ [0, 2] z ŵ 0,1 ∈ [0, 1] z ŵ 0 ∈ [0, 1] lw1(ŵ) ∈ [3, 5] z ŵ 1,1 ∈ [0, 1] z ŵ 1 ∈ [0, 1] lw2(ŵ) ∈ [0, 2] z ŵ 2,1 = 0 z ŵ 2 ∈ [0, 1] lw3(ŵ) ∈ [0, 5] z ŵ 3,1 = 0 z ŵ 3 ∈ [0, 1] lw4(ŵ) = 0 z ŵ 4,1 = 0 z ŵ 4 ∈ [0, 1]",
      "startOffset" : 30,
      "endOffset" : 36
    }, {
      "referenceID" : 0,
      "context" : "1 1 lw0(ŵ) ∈ [0, 2] z ŵ 0,1 ∈ [0, 1] z ŵ 0 ∈ [0, 1] lw1(ŵ) ∈ [3, 5] z ŵ 1,1 ∈ [0, 1] z ŵ 1 ∈ [0, 1] lw2(ŵ) ∈ [0, 2] z ŵ 2,1 = 0 z ŵ 2 ∈ [0, 1] lw3(ŵ) ∈ [0, 5] z ŵ 3,1 = 0 z ŵ 3 ∈ [0, 1] lw4(ŵ) = 0 z ŵ 4,1 = 0 z ŵ 4 ∈ [0, 1]",
      "startOffset" : 45,
      "endOffset" : 51
    }, {
      "referenceID" : 2,
      "context" : "1 1 lw0(ŵ) ∈ [0, 2] z ŵ 0,1 ∈ [0, 1] z ŵ 0 ∈ [0, 1] lw1(ŵ) ∈ [3, 5] z ŵ 1,1 ∈ [0, 1] z ŵ 1 ∈ [0, 1] lw2(ŵ) ∈ [0, 2] z ŵ 2,1 = 0 z ŵ 2 ∈ [0, 1] lw3(ŵ) ∈ [0, 5] z ŵ 3,1 = 0 z ŵ 3 ∈ [0, 1] lw4(ŵ) = 0 z ŵ 4,1 = 0 z ŵ 4 ∈ [0, 1]",
      "startOffset" : 61,
      "endOffset" : 67
    }, {
      "referenceID" : 4,
      "context" : "1 1 lw0(ŵ) ∈ [0, 2] z ŵ 0,1 ∈ [0, 1] z ŵ 0 ∈ [0, 1] lw1(ŵ) ∈ [3, 5] z ŵ 1,1 ∈ [0, 1] z ŵ 1 ∈ [0, 1] lw2(ŵ) ∈ [0, 2] z ŵ 2,1 = 0 z ŵ 2 ∈ [0, 1] lw3(ŵ) ∈ [0, 5] z ŵ 3,1 = 0 z ŵ 3 ∈ [0, 1] lw4(ŵ) = 0 z ŵ 4,1 = 0 z ŵ 4 ∈ [0, 1]",
      "startOffset" : 61,
      "endOffset" : 67
    }, {
      "referenceID" : 0,
      "context" : "1 1 lw0(ŵ) ∈ [0, 2] z ŵ 0,1 ∈ [0, 1] z ŵ 0 ∈ [0, 1] lw1(ŵ) ∈ [3, 5] z ŵ 1,1 ∈ [0, 1] z ŵ 1 ∈ [0, 1] lw2(ŵ) ∈ [0, 2] z ŵ 2,1 = 0 z ŵ 2 ∈ [0, 1] lw3(ŵ) ∈ [0, 5] z ŵ 3,1 = 0 z ŵ 3 ∈ [0, 1] lw4(ŵ) = 0 z ŵ 4,1 = 0 z ŵ 4 ∈ [0, 1]",
      "startOffset" : 78,
      "endOffset" : 84
    }, {
      "referenceID" : 0,
      "context" : "1 1 lw0(ŵ) ∈ [0, 2] z ŵ 0,1 ∈ [0, 1] z ŵ 0 ∈ [0, 1] lw1(ŵ) ∈ [3, 5] z ŵ 1,1 ∈ [0, 1] z ŵ 1 ∈ [0, 1] lw2(ŵ) ∈ [0, 2] z ŵ 2,1 = 0 z ŵ 2 ∈ [0, 1] lw3(ŵ) ∈ [0, 5] z ŵ 3,1 = 0 z ŵ 3 ∈ [0, 1] lw4(ŵ) = 0 z ŵ 4,1 = 0 z ŵ 4 ∈ [0, 1]",
      "startOffset" : 93,
      "endOffset" : 99
    }, {
      "referenceID" : 1,
      "context" : "1 1 lw0(ŵ) ∈ [0, 2] z ŵ 0,1 ∈ [0, 1] z ŵ 0 ∈ [0, 1] lw1(ŵ) ∈ [3, 5] z ŵ 1,1 ∈ [0, 1] z ŵ 1 ∈ [0, 1] lw2(ŵ) ∈ [0, 2] z ŵ 2,1 = 0 z ŵ 2 ∈ [0, 1] lw3(ŵ) ∈ [0, 5] z ŵ 3,1 = 0 z ŵ 3 ∈ [0, 1] lw4(ŵ) = 0 z ŵ 4,1 = 0 z ŵ 4 ∈ [0, 1]",
      "startOffset" : 109,
      "endOffset" : 115
    }, {
      "referenceID" : 0,
      "context" : "1 1 lw0(ŵ) ∈ [0, 2] z ŵ 0,1 ∈ [0, 1] z ŵ 0 ∈ [0, 1] lw1(ŵ) ∈ [3, 5] z ŵ 1,1 ∈ [0, 1] z ŵ 1 ∈ [0, 1] lw2(ŵ) ∈ [0, 2] z ŵ 2,1 = 0 z ŵ 2 ∈ [0, 1] lw3(ŵ) ∈ [0, 5] z ŵ 3,1 = 0 z ŵ 3 ∈ [0, 1] lw4(ŵ) = 0 z ŵ 4,1 = 0 z ŵ 4 ∈ [0, 1]",
      "startOffset" : 136,
      "endOffset" : 142
    }, {
      "referenceID" : 4,
      "context" : "1 1 lw0(ŵ) ∈ [0, 2] z ŵ 0,1 ∈ [0, 1] z ŵ 0 ∈ [0, 1] lw1(ŵ) ∈ [3, 5] z ŵ 1,1 ∈ [0, 1] z ŵ 1 ∈ [0, 1] lw2(ŵ) ∈ [0, 2] z ŵ 2,1 = 0 z ŵ 2 ∈ [0, 1] lw3(ŵ) ∈ [0, 5] z ŵ 3,1 = 0 z ŵ 3 ∈ [0, 1] lw4(ŵ) = 0 z ŵ 4,1 = 0 z ŵ 4 ∈ [0, 1]",
      "startOffset" : 152,
      "endOffset" : 158
    }, {
      "referenceID" : 0,
      "context" : "1 1 lw0(ŵ) ∈ [0, 2] z ŵ 0,1 ∈ [0, 1] z ŵ 0 ∈ [0, 1] lw1(ŵ) ∈ [3, 5] z ŵ 1,1 ∈ [0, 1] z ŵ 1 ∈ [0, 1] lw2(ŵ) ∈ [0, 2] z ŵ 2,1 = 0 z ŵ 2 ∈ [0, 1] lw3(ŵ) ∈ [0, 5] z ŵ 3,1 = 0 z ŵ 3 ∈ [0, 1] lw4(ŵ) = 0 z ŵ 4,1 = 0 z ŵ 4 ∈ [0, 1]",
      "startOffset" : 179,
      "endOffset" : 185
    }, {
      "referenceID" : 0,
      "context" : "1 1 lw0(ŵ) ∈ [0, 2] z ŵ 0,1 ∈ [0, 1] z ŵ 0 ∈ [0, 1] lw1(ŵ) ∈ [3, 5] z ŵ 1,1 ∈ [0, 1] z ŵ 1 ∈ [0, 1] lw2(ŵ) ∈ [0, 2] z ŵ 2,1 = 0 z ŵ 2 ∈ [0, 1] lw3(ŵ) ∈ [0, 5] z ŵ 3,1 = 0 z ŵ 3 ∈ [0, 1] lw4(ŵ) = 0 z ŵ 4,1 = 0 z ŵ 4 ∈ [0, 1]",
      "startOffset" : 217,
      "endOffset" : 223
    }, {
      "referenceID" : 4,
      "context" : "Definitions (7) through (10) are exactly the same as in [5].",
      "startOffset" : 56,
      "endOffset" : 59
    }, {
      "referenceID" : 6,
      "context" : "To evaluate our method, we used NSPLib [8], a library of benchmark instances of the nurse scheduling problem (NSP).",
      "startOffset" : 39,
      "endOffset" : 42
    }, {
      "referenceID" : 4,
      "context" : "For each string property that we extract from the rows, we used automata annotated with counters (as described in [5]), unfolded into a DFA, expressed as a decomposition into ternary constraints [9] allowing us to extract the counter values.",
      "startOffset" : 114,
      "endOffset" : 117
    }, {
      "referenceID" : 7,
      "context" : "For each string property that we extract from the rows, we used automata annotated with counters (as described in [5]), unfolded into a DFA, expressed as a decomposition into ternary constraints [9] allowing us to extract the counter values.",
      "startOffset" : 195,
      "endOffset" : 198
    }, {
      "referenceID" : 4,
      "context" : "The methods used in [5] for automata annotated with counters are not implemented in the free major constraint programming libraries and solvers.",
      "startOffset" : 20,
      "endOffset" : 23
    }, {
      "referenceID" : 4,
      "context" : "In the setting of unweighted automata, the necessary constraints are derived as in [5].",
      "startOffset" : 83,
      "endOffset" : 86
    }, {
      "referenceID" : 4,
      "context" : "Note that these benchmarking results are not directly comparable to the results in [5], since these results were obtained under a different experimental set-up (e.",
      "startOffset" : 83,
      "endOffset" : 86
    } ],
    "year" : 2016,
    "abstractText" : "We study propagation of the RegularGcc global constraint. This ensures that each row of a matrix of decision variables satisfies a Regular constraint, and each column satisfies a Gcc constraint. On the negative side, we prove that propagation is NP-hard even under some strong restrictions (e.g. just 3 values, just 4 states in the automaton, or just 5 columns to the matrix). On the positive side, we identify two cases where propagation is fixed parameter tractable. In addition, we show how to improve propagation over a simple decomposition into separate Regular and Gcc constraints by identifying some necessary but insufficient conditions for a solution. We enforce these conditions with some additional weighted row automata. Experimental results demonstrate the potential of these methods on some standard benchmark problems.",
    "creator" : "dvips(k) 5.991 Copyright 2011 Radical Eye Software"
  }
}