{
  "name" : "1006.1407.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Begin, After, and Later: a Maximal Decidable Interval Temporal Logic",
    "authors" : [ "Angelo Montanari", "Margherita Napoli", "Mimmo Parente", "Davide Bresolin", "Pietro Sala", "Guido Sciavicco" ],
    "emails" : [ "davide.bresolin@univr.it", "pietro.sala@univr.it", "guido@um.es" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Angelo Montanari, Margherita Napoli, Mimmo Parente (Eds.) Proceedings of GandALF 2010 EPTCS 25, 2010, pp. 72–88, doi:10.4204/EPTCS.25.10\nBegin, After, and Later: a Maximal Decidable Interval Temporal Logic∗\nDavide Bresolin University of Verona\nVerona, Italy davide.bresolin@univr.it\nPietro Sala University of Verona\nVerona, Italy pietro.sala@univr.it\nGuido Sciavicco University of Murcia\nMurcia, Spain guido@um.es\nInterval temporal logics (ITLs) are logics for reasoning about temporal statements expressed over intervals, i.e., periods of time. The most famous ITL studied so far is Halpern and Shoham’s HS, which is the logic of the thirteen Allen’s interval relations. Unfortunately, HS and most of its fragments have an undecidable satisfiability problem. This discouraged the research in this area until recently, when a number non-trivial decidable ITLs have been discovered. This paper is a contribution towards the complete classification of all different fragments of HS. We consider different combinations of the interval relations begins (B), after (A), later (L) and their inverses A, B and L. We know from previous works that the combinationABBA is decidable only when finite domains are considered (and undecidable elsewhere), and thatABB is decidable over the natural numbers. We extend these results by showing that decidability of ABB can be further extended to capture the language ABBL, which lies in between ABB and ABBA, and that turns out to be maximal w.r.t decidability over strongly discrete linear orders (e.g. finite orders, the naturals, the integers). We also prove that the proposed decision procedure is optimal with respect to the EXPSPACE complexity class."
    }, {
      "heading" : "1 Introduction",
      "text" : "Interval temporal logics (ITLs) are logics for reasoning about temporal statements expressed over intervals instead of points. The most famous ITL studied so far is probably Halpern and Shoham’s HS [6], which is the logic of (the thirteen) Allen’s interval relations between intervals [1]. It features a modal operator for each relation, that is after (〈A〉) (also called meets), begins (〈B〉), ends (〈E〉), overlaps (〈O〉), during (〈D〉), later (〈L〉), and their inverses (denoted by 〈X〉, where 〈X〉 is a modal operator), although some of them are definable in terms of others. Since HS is undecidable when interpreted over almost all interesting classes of linearly ordered sets, it is natural to ask whether there exist decidable fragments of it, and how the properties of the underlying linearly ordered domain can influence its decidable/undecidable status. In the literature, the classes of linear orderings that have received more attention are i) the class of all linearly ordered sets, ii) the set of all discrete linearly ordered sets, iii) the class of all dense linearly ordered sets. In the second case one can also distinguish among strong discreteness (i.e., N,Z-like), and weak discreteness (which allows non-standard models such as N+Z). In recent years, a number of papers have been published in which new, sometimes unexpected, decidable and undecidable fragments are presented. Among them, we mention the fragment AA, also known as PNL, presented in [4], and studied also in [3], which is decidable over all interesting classes of models; and the fragment ABB (and, by symmetry, AEE) which is decidable when interpreted over natural numbers [9]. Interestingly enough, the extension ABBA (and AEEA) turns out to be decidable only when finite models are considered, and undecidable as soon as an infinite ascending (resp., descending) chain is admitted\n∗This research was partly supported by the EU project FP7-ICT-223844 CON4COORD, by the Spanish-South African project HS2008-0006, by the Spanish MEC project TIN2009-14372-C03-01, and by the Italian GNCS project ”Logics, Automata, and Games for the formal verification of complex systems”.\nin the model [7]. Other interesting fragments are BB and EE, that are decidable in most cases [5], while any other combination of the four operators B, B, E, and E immediately leads to undecidability [2]. Other combinations such as ABB, and the simpler AB, though, remain still uncovered.\nIn this paper, we present another piece of this complicated puzzle by considering also the Allen’s relation later, that captures any interval starting at some point after the ending point of the current interval, and it can be defined as 〈A〉〈A〉, and the inverse relation before. We will show that the logic ABBL (and the symmetric logic AEEL) is decidable and EXPSPACE-complete when interpreted over strongly discrete linear orders. It is worth emphasizing that adding any other non-definable Allen’s relation to ABBL and to AEEL leads to undecidability over all considered structures, with the exception of A and A, respectively, which keep decidability only when finite models are considered (and cause undecidability over infinite models). Hence, our results shows also that ABBL and AEEL are maximal fragments of HS with respect to decidability in the class of all strongly discrete linear orders.\nThe structure of this paper is as follows. In Section 2 we introduce syntax and semantics of our logic. In Section 3, we deal with the decidability of the satisfiability problem over finite and infinite structures, while in Section 4 we discuss its complexity. Finally, in Section 5 we draw some conclusions and outline future research directions.\n2 The interval temporal logic ABBL\nIn this section, we briefly introduce syntax and semantics of the logicABBL, along with the basic notions of atom, type, and dependency. We conclude the section by providing an alternative interpretation of ABBL over labeled grid-like structures."
    }, {
      "heading" : "2.1 Syntax and semantics",
      "text" : "The logic ABBL features four modal operators 〈A〉, 〈B〉, 〈B〉 and 〈L〉, and it is interpreted in interval temporal structures over a strongly discrete linear order endowed with the four Allen’s relations A (“meets”), B (“begins”), B (“begun by”) and L (“before”). We recall that a linear order O = 〈O,<〉 is strongly discrete if and only if there are only finitely many points between any pair of points x < y ∈O. Example of strongly discrete linear orders are all finite linear orders, and the sets N and Z.\nGiven a set Prop of propositional variables, formulas of ABBL are built up from Prop using the boolean connectives ¬ and ∨ and the unary modal operators 〈A〉, 〈B〉, 〈B〉, 〈L〉. As usual, we shall take advantage of shorthands like ϕ1 ∧ ϕ2 = ¬(¬ϕ1 ∨ ¬ϕ2), [A]ϕ = ¬〈A〉¬ϕ, [B]ϕ = ¬〈B〉¬ϕ, etc. Hereafter, we denote by |ϕ| the size of ϕ. Given any strongly discrete linear order O = 〈O,<〉 we define IO as the set of all closed intervals [x,y], with x,y ∈ O and x < y. For any pair of intervals [x,y], [x ′,y ′]∈ IO, the Allen’s relations “meets”A, “begins” B, “begun by” B, and “before” L are defined as follows:\n• “meets” relation: [x,y]A [x ′,y ′] iff y= x ′;\n• “begins” relation: [x,y] B [x ′,y ′] iff x= x ′ and y ′ < y;\n• “begun by” relation: [x,y] B [x ′,y ′] iff x= x ′ and y < y ′;\n• “before” relation: [x,y] L [x ′,y ′] iff y ′ < x.\nGiven an interval structure S = (IO,A,B,B,L,σ), where σ : IO → P(Prop) is a labeling function that maps intervals in IO to sets of propositional variables, and an initial interval I = [x,y], we define the semantics of an ABBL formula as follows:\n• S,I a iff a ∈ σ(I), for any a ∈ Prop;\n• S,I ¬ϕ iff S,I 6 ϕ;\n• S,I ϕ1 ∨ ϕ2 iff S,I ϕ1 or S,I ϕ2;\n• for every relation R ∈ {A,B,B,L}, S,I 〈R〉ϕ iff there is an interval J ∈ IO such that I R J and S,J ϕ.\nGiven an interval structure S and a formula ϕ, we say that S satisfies ϕ (and hence ϕ is satisfiable) if there is an interval I in S such that S,I ϕ. Accordingly, we define the satisfiability problem for ABBL as the problem of establishing whether a given ABBL-formula ϕ is satisfiable.\nAs we have recalled in the Introduction, we have that S,I 〈L〉ϕ iff S,I 〈A〉〈A〉ϕ, and thus that 〈L〉 is definable in the language of ABBA. As a direct consequence of the decidability and complexity results proved in this paper, we have that the converse it is not true. Moreover, it is easy to see that the operator 〈L〉 cannot be defined in the language of ABB: the modal operators 〈A〉, 〈B〉 and 〈B〉 allow the language to see only intervals whose endpoints are greater or equals to the endpoints of the interval were a formula is interpreted. Hence, the logic ABBL is strictly more expressive than ABB and strictly less expressive than ABBA."
    }, {
      "heading" : "2.2 Atoms, types, and dependencies",
      "text" : "Let S = (IO,A,B,B,L,σ) be an interval structure that satisfies the ABBL-formula ϕ. In the sequel, we relate intervals in S with respect to the set of sub-formulas ofϕ they satisfy. To do that, we introduce the key notions of ϕ-atom and ϕ-type.\nFirst of all, we define the closure Cl(ϕ) of ϕ as the set of all sub-formulas of ϕ and of their negations (we identify ¬¬α with α, ¬〈A〉α with [A]¬α, etc.). For technical reasons, we also introduce the extended closure Cl+(ϕ), which is defined as the set of all formulas in Cl(ϕ) plus all formulas of the forms 〈R〉α and ¬〈R〉α, with R∈ {A,B,B,L} and α∈ Cl(ϕ). Aϕ-atom is any non-empty set F⊆ Cl+(ϕ) such that (i) for every α ∈ Cl+(ϕ), we have α ∈ F iff ¬α 6∈ F and (ii) for every γ = α ∨ β ∈ Cl+(ϕ), we have γ ∈ F iff α ∈ F or β ∈ F (intuitively, a ϕ-atom is a maximal locally consistent set of formulas chosen from Cl+(ϕ)). Note that the cardinalities of both sets Cl(ϕ) and Cl+(ϕ) are linear in the number |ϕ| of sub-formulas of ϕ, while the number of ϕ-atoms is at most exponential in |ϕ| (precisely, we have |Cl(ϕ)| = 2|ϕ|, |Cl+(ϕ)| = 18|ϕ|, and there are at most 28|ϕ| distinct atoms). We define Aϕ as the set of all possible atoms that can be built over Cl+(ϕ).\nWe associate with each interval I ∈ S the set of all formulas α ∈ Cl+(ϕ) such that S,I α. Such a set is called ϕ-type of I and it is denoted by TypeS(I). We have that every ϕ-type is a ϕ-atom, but not vice versa. Hereafter, we shall omit the argument ϕ, thus calling a ϕ-atom (resp., a ϕ-type) simply an atom (resp., a type). Given an atom F, we denote by Obs(F) the set of all observable of F, namely, the formulas α ∈ Cl(ϕ) such that α ∈ F. Similarly, given an atom F and a relation R ∈ {A,B,B,L}, we denote by ReqR(F) the set of all R-requests of F, namely, the formulas α ∈ Cl(ϕ) such that 〈R〉α ∈ F. Taking advantage of the above sets, we can define the following three relations between two atoms F and G:\nF A−→G iff ReqA(F) = Obs(G) ∪ ReqB(G) ∪ ReqB(G)\nF B−→G iff\n \n\nObs(F) ∪ ReqB(F) ⊆ ReqB(G) ⊆ Obs(F) ∪ ReqB(F) ∪ ReqB(F)\nObs(G) ∪ ReqB(G) ⊆ ReqB(F) ⊆ Obs(G) ∪ ReqB(G) ∪ ReqB(G)\nReqL(F) = ReqL(G).\nF L−→G iff Obs(G)∪ReqL(G) ⊆ ReqL(F)\nNote that the relations B−→ and L−→ are transitive, while A−→ is not. Moreover, all A−→ , B−→ and L−→ satisfy a view-to-type dependency, namely, for every pair of intervals I,J in S, we have that\nI A J implies TypeS(I) A−→ TypeS(J) I B J implies TypeS(I) B−→ TypeS(J)\nI L J implies TypeS(I) L−→ TypeS(J)."
    }, {
      "heading" : "2.3 Compass structures",
      "text" : "The logicABBL can be equivalently interpreted over grid-like structures (hereafter called compass structures) by exploiting the existence of a natural bijection between the intervals I = [x,y] and the points p = (x,y) of an O×O grid such that x < y. As an example, in Fig. 1 are shown five intervals I0, ...,I4, such that I0 B I1, I0 B I2, I0 A I3, and I0 L I4, together with the corresponding points p0, ...,p4 of a grid (note that the four Allen’s relations A,B,B,L between intervals are mapped to the corresponding spatial relations between points; for the sake of readability, we name the latter ones as the former ones).\nDEFINITION 1. Given anABBL formula ϕ, a (consistent and fulfilling) compass (ϕ-)structure is a pair G = (PO,L), where PO is the set of points of the form p = (x,y), with x,y ∈ O and x < y, and L is function that maps any point p ∈ PO to a (ϕ-)atom L(p) in such a way that:\n• for every pair of points p,q∈PO and every relation R∈ {A,B,L}, if pRq holds, then L(p) R−→L(q) follows (consistency);\n• for every point p ∈ PO, every relation R ∈ {A,B,B,L}, and every formula α ∈ ReqR ( L(p) )\n, there is a point q ∈ PO such that p R q and α ∈ Obs ( L(q) ) (fulfillment).\nWe say that a compass (ϕ-)structure G= (PO,L) features a formula α if there is a point p∈ PO such that α ∈L(p). The following proposition implies that the satisfiability problem for ABBL is reducible to the problem of deciding, for any given formula ϕ, whether there exists a ϕ-compass structure featuring ϕ.\nPROPOSITION 2. AnABBL-formula ϕ is satisfied by some interval structure if and only if it is featured by some (ϕ-)compass structure.\n3 Deciding the satisfiability problem for ABBL\nIn this section, we prove that the satisfiability problem for ABBL is decidable by providing a “smallmodel theorem” for the satisfiable formulas of the logic. For the sake of simplicity, we first show that the satisfiability problem for ABBL interpreted over finite interval structures is decidable and then we generalize such a result to all (finite or infinite) interval structures based on strong discrete linear orders.\nAs a preliminary step, we introduce the key notions of shading, of witness set, and of compatibility between rows of a compass structure. Let G= (PO,L) be a compass structure and let y∈O. The shading of the row y of G is the set ShadingG(y) = { L(x,y) : x< y } , namely, the set of the atoms of all points in PO whose vertical coordinate has value y (basically, we interpret different atoms as different colors). A witness set for y is any minimal set Wit(y)⊆ {(xψ,yψ) : xψ<yψ∧yψ>y} that respects the following property:\n(WIT) for every ψ ∈ Cl(ϕ) that appears in the labeling of some point (x ′,y ′) with y ′ > y, there exists a witness (xψ,yψ) ∈Wit(y) such that\n1. ψ ∈ L(xψ,yψ) , and 2. yψ is minimal, that is, for all (x ′,y ′) with y < y ′ < yψ, ¬ψ ∈L(x ′,y ′).\nSince Wit(y) is minimal we have that there is at most one distinct point for every ψ ∈ Cl(ϕ) and thus |Wit(y)| < |Cl(ϕ)| = 2 · |ϕ|. Intuitively, a witness set for a row y is a set that contains, for every formula ψ that occurs in some point above the row y, a witness (xψ,y) for it, that is, a point that satisfies ψ at the minimum possible distance from the row y. The notion of shading and of witness set allow us to determine whether two rows are compatible or not.\nLet P ⊆ PO a set of points and y be a coordinate we define πy(P) = {x : (x,y) ∈ P∧x < y)}, the set of all x-coordinate belonging to points in P which are smaller than y.\nDEFINITION 3. Given a compass structure G and two rows y0 < y1, we say that y0 and y1 are compatible if and only if the following properties holds:\n1. ShadingG(y0) = ShadingG(y1); 2. L(y0 −1,y0) = L(y1 −1,y1);\n3. there exists a witness set Wit(y1) for y1 and an injective mapping function w : πy1(Wit(y1)) 7→ {x : x < y0} s.t. L(x,y1) = L(w(x),y0) for every x ∈ πy1(Wit(y1)), that assigns a distinct xcoordinate on the row y0 for every witness (xψ,yψ) in Wit(y1) with xψ6 y1.\nIn the following, we will show how the properties of compatible rows can be used to contract compass structures to smaller ones, first for finite models and then for infinite ones."
    }, {
      "heading" : "3.1 A small-model theorem for finite structures",
      "text" : "Let ϕ be an ABBL formula. It is easy to see that ϕ is satisfiable over a finite model if and only if the formula ϕ∨ 〈B〉ϕ∨ 〈A〉ϕ∨ 〈A〉〈A〉ϕ is featured by the initial point (0,1) a finite compass structure G= (PO,L). We prove that we can restrict our attention to compass structures G= (PO,L) with a number of points in O bounded by a double exponential in |ϕ|. We start with the following lemma that proves two simple, but crucial, properties of the relations A−→ , B−→ , and L−→ .\nLEMMA 4. Let F,G,H be some atoms:\n1. if F A−→H and G B−→H hold, then F A−→G holds as well;\n2. if F B−→G and G L−→H hold, then F L−→H holds as well.\nProof. The proof for property 1 can be found in [8]. As for property 2, we have that, by the definition of B−→ , if F B−→G then ReqL(F) =ReqL(G). This implies that Obs(H)∪ReqL(H)⊆ReqL(F) and thus F L−→H holds as well. ✷\nThe next lemma shows that, under suitable conditions, a given compass structure G may be reduced in length, preserving the existence of atoms featuring ϕ.\nLEMMA 5. Let G be a finite compass structure of size N featuring ϕ on the initial point (0,1). If there exist two compatible rows 0 < y0 < y1 < N in G, then there exists a compass structure G ′ of size N ′ =N−y1 +y0 that features ϕ.\nProof. Suppose that 0 < y0 < y1 < N are two compatible rows of G. By definition, we have that ShadingG(y0) = ShadingG(y1), L(y0 − 1,y0) = L(y1 − 1,y1), and there exists a witness set Wit(y1) for y1 and an injective mapping function w : πy1(Wit(y1)) 7→ {x : x < y0} that assigns a distinct xcoordinate on the row y0 for every witness (xψ,yψ) in Wit(y1) with xψ 6 y1. Then, we can define a function f : {0, ...,y0 −1} 7→ {0, ...,y1−1} such that, for every 0 6 x < y0, L(x,y0) =L(f(x),y1) and for every (xψ,yψ) ∈Wit(y1) if xψ< y1 then f(w(xψ)) = xψ.\nLet k= y1 −y0,N ′ =N−k (<N), O ′ = 〈{0, . . . ,N ′−1},<〉, and PO ′ be the correspondent portion of the grid. We extend f to a function that maps points in PO ′ to points in PO as follows:\n• if p= (x,y), with 0 6 x < y < y0, then we simply let f(p) = p;\n• if p= (x,y), with 0 6 x < y0 6 y, then we let f(p) = (f(x),y+k);\n• if p= (x,y), with y0 6 x < y, then we let f(p) = (x+k,y+k).\nWe denote by L ′ the labeling of PO ′ such that, for every point p ∈ PO ′ , L ′(p) =L(f(p)) and we denote by G ′ the resulting structure (PO ′ ,L ′) (see Figure 2). We have to prove that G ′ is a consistent and fulfilling compass structure that features ϕ. First, we show that G ′ satisfies the consistency conditions for the relations B, A, and L; then we show that G ′ satisfies the fulfillment conditions for the B-, B-, A, and L-requests; finally, we show that G ′ features ϕ.\nCONSISTENCY WITH RELATION B. Consider two points p = (x,y) and p ′ = (x ′,y ′) in G ′ such that p B p ′, i.e., 0 6 x = x ′ < y ′ < y < N ′. We prove that L ′(p) B−→L ′(p ′) by distinguishing among the following three cases (note that exactly one of such cases holds):\n1. y < y0 and y ′ < y0, 2. y> y0 and y ′ > y0, 3. y> y0 and y ′ < y0.\nIf y < y0 and y ′ < y0, then, by construction, we have f(p) = p and f(p ′) = p ′. Since G is a (consistent) compass structure, we immediately obtain L ′(p) = L(p) B−→L(p ′) = L ′(p ′).\nIf y > y0 and y > y0, then, by construction, we have either f(p) = (f(x),y+ k) or f(p) = (x+ k,y+k), depending on whether x < y0 or x > y0. Similarly, we have either f(p ′) = (f(x ′),y ′+k) = (f(x),y ′+k) or f(p ′) = (x ′+k,y ′+k) = (x+k,y ′+k). This implies f(p) B f(p ′) and thus, since G is a (consistent) compass structure, we have L ′(p) = L(f(p)) B−→ L(f(p ′)) = L ′(p ′).\nIf y > y0 and y ′ < y0, then, since x < y ′ < y0, we have by construction f(p) = (f(x),y+ k) and f(p ′) = p ′. Moreover, if we consider the point p ′′ = (x,y0) in G ′, we easily see that (i) f(p ′′) = (f(x),y1), (ii) f(p) B f(p ′′) (whence L(f(p)) B−→L(f(p ′′))), (iii) L(f(p ′′)) = L(p ′′), and (iv) p ′′ B p ′ (whence L(p ′′) B−→L(p ′)). It thus follows that L ′(p) = L(f(p)) B−→L(f(p ′′)) = L(p ′′) B−→ L(p ′) = L(f(p ′))=L ′(p ′). Finally, by exploiting the transitivity of the relation B−→ , we obtain L ′(p) B−→L ′(p ′).\nG\nCONSISTENCY WITH RELATION A. Consider two points p= (x,y) and p ′ = (x ′,y ′) such that pA p ′, i.e., 0 6 x < y = x ′ < y ′ <N ′. We define p ′′ = (y,y+1) in such a way that p A p ′′ and p ′ B p ′′ and we distinguish between the following two cases:\n1. y> y0,\n2. y < y0.\nIf y> y0, then, by construction, we have f(p)A f(p ′′). Since G is a (consistent) compass structure, it follows that L ′(p) = L(f(p)) A−→ L(f(p ′′)) = L ′(p ′′).\nIf y < y0, then, by construction, we have L(p ′′) = L(f(p ′′)). Again, since G is a (consistent) compass structure, it follows that L ′(p) = L(f(p)) = L(p) A−→ L(p ′′) = L(f(p ′′)) = L ′(p ′′).\nIn both cases we have L ′(p) A−→L ′(p ′′). Now, we recall that p ′ B p ′′ and that, by previous arguments, G ′ is consistent with the relation B. We thus have L ′(p ′) B−→L ′(p ′′). Finally, by applying Lemma 4, we obtain L ′(p) A−→L ′(p ′).\nCONSISTENCY WITH RELATION L. Consider two points p = (x,y) and p ′ = (x ′,y ′) in G ′ such that p L p ′, i.e., 0 6 x ′ < y ′ < x < y < N ′. We prove that L ′(p) L−→L ′(p ′) by distinguishing among the following three cases (note that exactly one of such cases holds):\n1. y < y0 and y ′ < y0, 2. y> y0 and y ′ > y0, 3. y> y0 and y ′ < y0.\nIf y < y0 and y ′ < y0, then, by construction, we have f(p) = p and f(p ′) = p ′. Since G is a (consistent) compass structure, we immediately obtain L ′(p) = L(p) L−→L(p ′) = L ′(p ′).\nIf y> y0 and y ′ > y0, then, by construction, we have either f(p ′) = (f(x ′),y ′+k) or f(p ′) = (x ′+ k,y ′+k), depending on whether x ′ < y0 or x ′ > y0. Since y0 6 y ′ < x, we have f(p) = (x+k,y+k). This implies f(p) L f(p ′) and thus, since G is a (consistent) compass structure, we have L ′(p) =L(f(p)) L−→ L(f(p ′)) = L ′(p ′).\nIf y> y0 and y ′ <y0, then, we have by construction that f(p ′) = p ′ and either f(p) = (x+k,y+k) or f(p) = (f(x),y+ k). In the former case we have that f(p) L f(p ′) and thus, since G is a consistent\ncompass structure, L ′(p) = L(f(p)) L−→L(f(p ′)) = L ′(p ′). In the latter case it is not necessarily true that y ′ < f(x). Consider the points p ′′ = (f(x),y1) and p ′′′ = (x,y0): by the definition of f, L(p ′′) = L(p ′′′). Moreover, we have that f(p)Bp ′′ and p ′′′Lf(p ′) = p ′. Since G is a consistent compass structure, this implies that L ′(p) = L(f(p)) B−→L(p ′′) = L(p ′′′) L−→L(f(p ′)) = L ′(p ′). Finally, by applying Lemma 4, we obtain L ′(p) L−→L ′(p ′).\nFULFILLMENT OF B-REQUESTS. Consider a point p=(x,y) in G ′ and someB-request α∈ReqB ( L ′(p) ) associated with it. Since, by construction, α ∈ ReqB ( L(f(p)) )\nand G is a (fulfilling) compass structure, we know that G contains a point q ′ = (x ′,y ′) such that f(p)B q ′ and α ∈Obs ( L(q ′) ) . We prove that G ′ contains a point p ′ such that p B p ′ and α ∈ Obs ( L ′(p ′) )\nby distinguishing among the following three cases (note that exactly one of such cases holds):\n1. y < y0 2. y ′ > y1, 3. y> y0 and y ′ < y1.\nIf y < y0, then, by construction, we have p = f(p) and q ′ = f(q ′). Therefore, we simply define p ′ = q ′ in such a way that p= f(p) B q ′ = p ′ and α ∈Obs ( L ′(p ′) ) (=Obs ( L(f(p ′)) ) =Obs ( L(q ′) )\n). If y ′ > y1, then, by construction, we have either f(p) = (f(x),y+k) or f(p) = (x+k,y+k), depending on whether x<y0 or x> y0. We define p ′ = (x,y ′−k) in such a way that pBp ′. Moreover, we observe that either f(p ′) = (f(x),y ′) or f(p ′) = (x+k,y ′), depending on whether x < y0 or x> y0, and in both cases f(p ′) = q ′ follows. This shows that α ∈ Obs ( L ′(p ′) ) (= Obs ( L(f(p ′) ) = Obs ( L(q ′) )\n). If y > y0 and y ′ < y1, then we define p = (x,y0) and q = (x ′,y1) and we observe that f(p) B q,\nq B q ′, and f(p) = q. From f(p) B q and q B q ′, it follows that α ∈ ReqB ( L(q) )\nand hence α ∈ ReqB ( L(p) )\n. Since G is a (fulfilling) compass structure, we know that there is a point p ′ such that p B p ′ and α ∈ Obs ( L(p ′) ) . Moreover, since p B p ′, we have f(p ′) = p ′, from which we obtain p B p ′ and α ∈ Obs ( L(p ′) ) .\nFULFILLMENT OF B-REQUESTS. The proof that G ′ fulfills all B-requests of its atoms is symmetric with respect to the previous one.\nFULFILLMENT OFA-REQUESTS. Consider a point p=(x,y) in G ′ and someA-requestα∈ReqA ( L ′(p) ) associated with p in G ′. Since, by previous arguments, G ′ fulfills all B-requests of its atoms, it is sufficient to prove that either α ∈ Obs ( L ′(p ′) )\nor α ∈ ReqB ( L ′(p ′) ) , where p ′ = (y,y+ 1). This can be easily proved by distinguishing among the three cases y < y0 −1, y= y0 −1, and y> y0.\nFULFILLMENT OF L-REQUESTS. Consider a point p= (x,y) in G ′ and some L-request α∈ReqL ( L ′(p) ) associated with it. Since, by construction, α ∈ ReqL ( L(f(p)) )\nand G is a (fulfilling) compass structure, we know that G contains a point q ′ = (x ′,y ′) such that f(p) L q ′ and α ∈ Obs ( L(q ′) )\n. To simplify the proofs, we assume that q ′ is minimal with respect to the vertical coordinate, that is, for every other point q ′′ = (x ′′,y ′′) with y ′′ < y ′, α 6∈ Obs ( L(q ′′) ) . We prove that G ′ contains a point p ′ such that p L p ′ and α ∈ Obs ( L ′(p ′) )\nby distinguishing among the following five cases (note that exactly one of such cases holds):\n1. y6 y0,\n2. x < y0 and y> y0, 3. x> y0 and y ′ < y1, 4. x> y0 and y ′ = y1, 5. x> y0 and y ′ > y1.\nIf y < y0, then, by construction, we have p = f(p) and q ′ = f(q ′). Therefore, we simply define p ′ = q ′ in such a way that p= f(p) L q ′ = p ′ and α ∈Obs ( L ′(p ′) ) (=Obs ( L(f(p ′)) ) =Obs ( L(q ′) )\n). If x < y0 and y > y0 then f(p) = (f(x),y+ k). Now, consider the point p ′′ = (f(x),y1): since f(p)Bp ′′ and G is a consistent compass structure, we have that ReqL(p ′′) = ReqL(f(p)). By definition of f, we have that L(f(x),y1) =L(x,y0) and thus, since G is fulfilling, there exists a point p ′ = (x ′′,y ′′) such that y ′′ < x and α ∈ Obs ( L(p ′) ) . Since f(p ′) = p ′, this shows that α ∈ Obs ( L ′(p ′) )\nas well. If x > y0 and y ′ < y1 then f(p) = (x+ k,y+ k). Since G is a consistent compass structure, we have that α ∈ ReqL(L(y1 −1,y1)). By the definition of compatible rows, we have that L(y1 −1,y1) = L(y0 − 1,y0) and thus (by the minimality assumption) y ′ < y0 and q ′ = f(q ′). Therefore, we simply define p ′ = q ′ in such a way that p L q ′ = p ′ and α ∈ Obs ( L ′(p ′) ) (= Obs ( L(f(p ′)) ) =Obs ( L(q ′) )\n). If x> y0 and y ′ = y1 then L(q ′)∈ ShadingG(y1). By the definition of compatible rows, we have that ShadingG(y1) = ShadingG(y0) and thus there must exists a point q ′′=(x ′′,y0) such that L(q ′) =L(q ′′) and y0 < y ′, against the hypothesis that q ′ is a minimal point satisfying α. Hence, this case cannot happen.\nIf x > y0 and y ′ > y1 then, by the minimality assumption on q ′ we have that for every y ′′ < y ′, α 6∈Obs ( L(x ′′,y ′′) )\nfor any x ′′ <y ′′. Hence, by the definition of witness set, we have that there exists a witness (xα,yα)∈Wit(y1) such that α∈Obs ( L(xα,yα) )\nand yα = y ′ (by the minimality assumption). If xα>y1 then we define p ′=(xα−k,yα−k). Otherwise, xα<y1 and by the definition of the mapping function w and of the function f, we have that f(w(xα)) = xα: we define p ′ = (w(xα),y ′−k). In both cases we have that f(p ′) = (xα,yα), pLp ′ and α ∈ Obs ( L ′(p ′) ) .\nFEATURED FORMULAS. Recall that, by previous assumptions, ϕ ∈ L(0,1). Since our contraction procedure never changes the labelling of the initial point, ϕ ∈ L ′(0,1) as well. ✷\nOn the grounds of the above result, we can provide a suitable upper bound for the length of a minimal finite interval structure that satisfies ϕ, if there exists any. This yields a straightforward, but inefficient, 2NEXPTIME algorithm that decides whether a given ABBL-formula ϕ is satisfiable over finite interval structures.\nTHEOREM 6. AnABBL-formula ϕ is satisfied by some finite interval structure iff it is featured by some compass structure of length N6 (8|ϕ|+15)2 32|ϕ|+56 ·232|ϕ|+56 (i.e., double exponential in |ϕ|).\nProof. Suppose that ϕ is satisfied by a finite interval structure S, and let ξ = ϕ∨ 〈B〉ϕ∨ 〈A〉ϕ∨ 〈A〉〈A〉ϕ. By Proposition 2, there is a compass structure G that features ξ on the initial point and has finite length N. By Lemma 5, we can assume without loss of generality that all rows of G are pairwise incompatible. We recall from Section 2.2 that G contains at most 28|ξ| distinct atoms. For every row y of the compass structure and every atom F ∈Aξ, let #(F,y) be the cardinality of the set {(x,y) : x < y and L(x,y) = F}. We associate to every row y of the structure a characteristic function cy :Aξ 7→ N defined as follows:\ncy(F) =\n{ #(F,y) #(F,y) 6 2|ξ|\n2|ξ| otherwise (1)\nSince any witness set Wit(y) contains at most 2|ξ| witnesses, it is easy to see that two rows y0 and y1 with the same characteristic function and such that L(y0 − 1,y0) = L(y1 − 1,y1) are compatible. The number of possible characteristic functions is bounded by (2|ξ|+1)2 8|ξ| , and thus G cannot have more than (2|ξ|+ 1)2 8|ξ| · 28|ξ| rows. Since |ξ| = 4|ϕ|+ 7 we can conclude that N 6 (8|ϕ|+ 15)2 32|ϕ|+56\n· 232|ϕ|+56, and thus double exponential in |ϕ|. ✷"
    }, {
      "heading" : "3.2 A small-model theorem for infinite structures",
      "text" : "In general, compass structures that feature ϕ may be infinite. Here, we prove that, without loss of generality, we can restrict our attention to sufficiently “regular” infinite compass structures, which can be represented in double exponential space with respect to |ϕ|. To do that, we introduce the notion of compass structure generator, that is, of a finite compass structure featuring ϕ that can be extended to an infinite fulfilling one.\nDEFINITION 7. We say that a finite compass structure G= (PO,L) of size N is partially fulfilling if for every point (x,y) ∈ PO such that y < N− 1, for every relation R ∈ {A,B,B,L}, and for every formula ψ ∈ ReqR(L(p)), one of the following conditions hold:\n1. there exists a point p ′ ∈ PO such that p R p ′ and ψ ∈ Obs(L(p ′)) (ψ is fulfilled in p ′),\n2. R= B and ψ ∈ ReqB(L(x,N−1)), 3. R=A and ψ ∈ReqB(L(y,N−1)), 4. R= L and ψ ∈ ReqL(L(0,1)).\nNotice that all B-requests are fulfilled in a partially fulfilling compass structure and that B, A, and L requests are either fulfilled or “transferred to the border” of the compass structure. Moreover, any substructure G ′ of a fulfilling compass structure G is partially fulfilling.\nDEFINITION 8. Given a finite compass structure G = (PO,L) and a row y, a future witness set for y is any minimal set FutWit(y) ⊆ {x : x < y} such that for every F ∈ ShadingG(y) there exists a witness xF ∈ FutWit(y) that respects the following properties:\n1. L(xF,y) = F, 2. for every ψ ∈ ReqB(F) there exists a point (xF,y ′) ∈ G with y ′ > y and ψ ∈ Obs(L(xF,y)).\nSince FutWit(y) is minimal, we have that for every F ∈ Shading(y) there is exactly one witness xF in FutWit(y). Hence, |FutWit(y))|6 28|ϕ|.\nDEFINITION 9. Given a finite compass structure G = (PO,L) and a row y, a past witness set for y is any minimal set PastWit(y) ⊆ PO such that for every request ψ ∈ ReqL(Obs(L(y− 1,y)) there exists a witness (xψ,yψ) such that ψ ∈ Obs(L(xψ,yψ)) and yψ< y−1.\nAgain, by the minimality of PastWit(y) we have that there is at most one distinct point for every Lformula in L(y−1,y) and thus |PastWit(y)| 6 |ReqL(y−1,y)|6 |Cl(ϕ)| 6 2 · |ϕ|.\nWe concentrate our attention on infinite structures that are unbounded both on the future and on the past (i.e., based on the set of integers Z). The case when the structure is unbounded only in one direction (e.g., the naturals N or the set of negative integers Z−) can be tackled in a similar way by appropriately adapting the following notions and theorems.\nDEFINITION 10. Given an ABBL formula ϕ and a finite, partially fulfilling compass structure G = (PO,L) of size N, we say that G is a compass generator for ϕ if there exists four rows yϕ, y0, y1, and y2 which satisfy the following properties:\nG1 y0 < y1 < y2 and y0 6 yϕ,\nG2 ϕ ∈ L(yϕ−1,yϕ) or 〈B〉ϕ ∈ L(yϕ−1,yϕ),\nG3 Shading(y1)⊆ Shading(y0) and L(y0 −1,y0) = L(y1 −1,y1),\nG4 there exists a past witness set PastWit(y1) such that y0 6 min(πy1(PastWit(y1))),\nG5 Shading(N−1)⊆ Shading(y2) and L(y2 −1,y2) = L(N−2,N−1),\nG6 there exists a future witness set FutWit(y2) for y2.\nThe next theorem shows that the information contained in a compass generator for ϕ is sufficient to build an infinite fulfilling compass structure featuring ϕ.\nTHEOREM 11. An ABBL formula ϕ is satisfiable over the integers Z if and only if there exists a compass generator G= (PO,L) for ϕ.\nProof. (⇒) Let ϕ an ABBL formula that is satisfiable over an infinite fulfilling compass structure G = (PZ,L). Since G features ϕ we have that there exists a point (x,y) with ϕ ∈ L(x,y) and thus the row yϕ = x+1 respects condition G2.\nNow, let Inf (G) be the set of shadings that occurs infinitely often in G. We define y1 as the greatest row such that for every y ′ 6 y1, Shading(y ′) ∈ Inf (G), and y2 as the smallest row such that for every y ′ > y2, Shading(y ′) ∈ Inf (G). Clearly, since G is unbounded in the past, we can find two rows ymin and y0 such that ymin < y0, and a corresponding portion of the grid Pymin = {(x,y) : x> ymin} such that (i) y0 6 yϕ, (ii) y0 < y1, (iii) Shading(y1) ⊆ Shading(y0) in Pymin , (iv) L(y0 − 1,y0) = L(y1 − 1,y1), and (v) there exists a past witness set PastWit(y1) for y1 such that y0 6 min(πy1(PastWit(y1))) in Pymin . Hence, conditions G3 and G4 are respected.\nSymmetrically, since G is unbounded in the future, we can find a row ymax>y2 and a corresponding portion of the grid Pymaxymin = {(x,y) : x> ymin∧y6 ymax} such that\n1. Shading(ymax)⊆ Shading(y2), 2. L(y2 −1,y2) = L(ymax−1,ymax), and 3. there exists a future witness set FutWit(y2) for y2 in P ymax ymin .\nThis shows that conditions G5 and G6 are respected as well. Since y0 6 yϕ and y0 <y1 < y2 condition G1 is also respected. Since the restriction of G to the finite grid Pymaxymin is a partially fulfilling compass structure, we have found the required compass generator for ϕ.\n(⇐) Let G = (PO,L) be a compass generator of size N for ϕ and let y0 < y1 < y2 and yϕ be the four rows that satisfy properties G1–G6 of Definition 10. We will define an infinite sequence of partially fulfilling compass structures G0 ⊂ G1 ⊂ G2 ⊂ . . . such that the infinite union Gω = ⋃+∞ i=0 Gi is an infinite fulfilling compass structure that features ϕ. We start from the initial compass structure G0 = (P0,L0) where P0 = {(x,y)∈ PO : x> y0−1∧y0 6 y <N} and L0(x,y) =L(x,y) for every point (x,y) ∈ P0O, and we will show how to iteratively build the infinite sequence of compass structures. For every step i of the procedure, let Gi = (Pi,Li) be the current structure, and let yimin and y i max be the minimum and maximum vertical coordinate in Pi, respectively. We guarantee that the following invariant is respected:\n(INV) ShadingGi(y i max)⊆ ShadingG(y2),\nShadingGi(y i min+y1 −y0)⊆ ShadingG(y0), Li(yimax−1,y i max) = L(y2 −1,y2), and L i(yimin−1,y i min) = L(y0 −1,y0).\nThe invariant trivially holds for G0. Now, suppose that Gi respects (INV) and let kpast = y1 −y0 and kfuture = N− y2. Figure 3 depicts how Gi+1 = (Pi+1,Li+1) can be built from Gi. Formally, the procedure is defined as follows.\na) yi+1min = y i min−kpast, y i+1 max = y i max+kfuture, and P i+1 = {(x,y) ∈ PZ : x > y i+1 min− 1∧\nyi+1min 6 y < y i+1 max}.\nb) for every point p ∈ Pi+1 ∩Pi, let Li+1(p) =Li(p).\ny0\ny1\nN−1\ny2\nthat ShadingGi(y i max) ⊆ ShadingG (y2). Then there exists a point x ∈ FutWit(y2) such that Li+1(x,yimax) =L(x,y2). We define L i+1(x,yimax+j)=L(x,y2+j) for every 16 j6 kfuture.\nIt is easy to see that Gi is a partially fulfilling compass structure that respects the invariant. Moreover, suppose that for some point p= (x,y) ∈ Pi and relation R ∈ {A,B,B,L} there exists α ∈ReqR(p) that is not fulfilled in Gi. We show that Gi+1 fulfills the R-request α for p.\n• If R =A, since Gi is partial fulfilling and it is finite we have that the point p ′ = (y,yimax) is such that α ∈ ReqB(L(p\n′)). By step h) of the procedure, and by the definition of future witness set, Gi+1 contains a point p ′′ = (y,yimax+ j) such that α ∈ L i+1(p ′′).\n• If R = B, by Definition 7 we have all the B-requests in a partial fulfilling compass structure are fulfilled and thus this case connot be given.\n• If R= B the case is analogous to the case of R =A.\n• If R = L, since Gi is partial fulfilling and it is finite we have that α ∈ ReqL(L(y i min−1,y i min)).\nBy point c) of the construction we have that Li(yimin−1,y i min) =L(y0−1,y0) =L(y1−1,y1). Hence, by condition G4 of Definition 10 and by the definition of past witness set, there exists a point (x,y) with y0 6 x < y6 y1 such that α ∈ L(x,y). By construction we have that L(x,y) = Li+1(x−(i+ 1) ·kpast,y−(i+ 1) ·kpast) and thus and thus the L-request α for the point p is fulfilled at step i+1 by the point (x−(i+1) ·kpast,y−(i+1) ·kpast).\nHence, we can conclude that the infinite compass structure Gω is fulfilling. By condition G2 of Definition 10 we have that Gω features ϕ and thus that ϕ is satisfiable over the integers. ✷\nTheorem 11 shows that satisfiability of a formula over infinite models can be reduced to the existence of a finite compass generator for it. However, it does not give any bound on the size of it. In the following we will show how the techniques exploited in Section 3.1 for finite models can be adapted to obtain a doubly exponential bound on the size of compass generators.\nDEFINITION 12. Given a compass generator G = (PO,L), we say that two rows y < y ′ are globally compatible if and only if the following properties holds:\n1. L(y−1,y) = L(y ′−1,y ′) and ShadingG(y) = ShadingG(y ′), 2. for every y ∈ {yϕ,y0,y1,y2} it is not the case that y6 y6 y ′,\n3. there exists a past witness set PastWit(y1) such that for every point (x,y) ∈ PastWit(y1) it is not the case that y6 y6 y ′;\n4. there exists a future witness set FutWit(y2) such that for every point x ∈ FutWit(y2) and every B-request α ∈ ReqB(L(x,y2) there is a point (x,y) such that y2 < y, α ∈ Obs(L(x,y2)) and it is not the case that y6 y6 y ′;\n5. there exists a witness set Wit(y ′) for y ′ and an injective mapping function w : πy ′(Wit(y ′)∪ PastWit(y1) ∪ FutWit(y2)) 7→ {x : x < y}, such that L(x,y ′) = L(w(x),y), for every x ∈ πy ′(Wit(y ′)∪PastWit(y1)∪FutWit(y2)), and w(x) = x, for every x ∈ πy ′(PastWit(y1).\nClearly, two globally compatible rows are compatible. The additional conditions of the definition guarantees that the contraction procedure do not remove “meaningful” parts of the compass generator, like the rows yϕ, y0, y1, and y2 (condition 2) or future and past witnesses (conditions 3 and 4).\nLEMMA 13. Let G be a compass generator for ϕ of size N. If there exist two global-compatible rows 0< y < y ′ <N in G, then there exists a compass generator G ′ of size N ′ =N−y+y ′ that features ϕ.\nProof. We can define a function f : {0, ...,y} → {0, ...,y ′} and contract G to a smaller compass structure G ′ in the very same way of Lemma 5. It can be easily proved that the obtained G ′ is a partial fulfilling compass structure. Let k = y ′−y and let y ′ϕ = yϕ if yϕ < y, y ′ ϕ = yϕ−k otherwise. To prove that G ′ is a compass generator, let us consider the following four cases.\n- If y ′ < y0, then we have that y ′i = yi−k for i ∈ {0,1,2,ϕ} satisfy conditions G1-G6 in G ′. - If y0 <y< y ′ < y1, then for every point (x,y) ∈ PastWit(y1) we have that either f(x,y) = (x,y) (when y < y) or f(x,y− k) = (w(x),y− k) = (x,y) (when y > y ′), and thus PastWit(y1) is a past witness set for G ′ as well. From this we can conclude that y ′ϕ,y0,y1 −k, and y2 −k satisfy conditions G1-G6 in G ′.\n- If y0 < y1 < y < y ′ < y2, then it is easy to prove that y ′ϕ,y0,y1 and y2 −k satisfy G1-G6 in G ′. - If y0 < y1 < y2 < y < y ′, then it is easy to observe that y ′ϕ,y0,y1 and y2 satisfy G1-G6 in G ′.\nHence, in all possible cases G ′ is a compass generator for ϕ. ✷\nTHEOREM 14. An ABBL-formula ϕ is satisfied by some infinite interval structure iff it is featured by some compass generator of length N6 (2|ϕ|+1)2 8|ϕ| ·216|ϕ| 2+8|ϕ| (i.e., double exponential in |ϕ|).\nProof. Suppose that ϕ is satisfied by a infinite interval structure S. By Theorem 11, there is a compass generator G that features ϕ. By Lemma 13, we can assume without loss of generality that all rows of G are pairwise global-incompatible. Let cy the characteristic function defined in the proof of Theorem 6. Now, let x1 < . . .< xk be the ordered sequence of the points in PastWit(y1). We associate to every row y a finite word Wy of length |Wy| 6 k 6 2 · |ϕ| on the alphabet Aϕ (|Aϕ| = 28|ϕ|) such that for every xi ∈ PastWit(y1), W(i) = L(xi,y). It is easy to prove that two rows y < y ′ in O with cy(F) = cy ′ , Wy =Wy ′ and such that L(y ′−1,y ′) = L(y−1,y) are global-compatible.\nSince the number of possible characteristic functions is bounded by (2|ϕ|+1)2 8|ϕ| , and the number of\npossible words is bounded by (28|ϕ|)2·|ϕ| = 216|ϕ| 2 , G cannot have more than (2|ϕ|+1)2 8|ϕ| ·216|ϕ| 2+8|ϕ| rows, and thus N is at most doubly exponential in |ϕ|. ✷\n4 Complexity bounds to the satisfiability problem for ABBL\nIn this section, we discuss the complexity of the satisfiability problem forABBL interpreted over strongly discrete interval temporal structures. An EXPSPACE lower bound on the complexity follows from the reduction of the exponential-corridor tiling problem (which is known to be EXPSPACE-complete [10]) to the satisfiability problem for the fragment ABB given in [8].\nTo give an upper bound to the complexity we claim that the existence of a compass structure (or compass generator) G that features a given formula ϕ can be decided by verifying suitable local (and stronger) consistency conditions over all pairs of contiguous rows, in a way similar to the EXPSPACE algorithm given in [8] for ABB. In this way, to check those local conditions it is sufficient to store only (i) a counter y with the number of the current row, (ii) two guessed shadings S and S ′ associated with the rows y and y+1, and (iii) the characteristic functions of the shadings of y and y+1. Since all this information needs only an exponential amount of space, the complexity of the satisfiability problem for ABBL is in EXPSPACE. The procedure for the infinite case is depicted in Figure 4. For the sake of\nbrevity, given a shading S we denote with FπS the unique element of S such that ReqB(F π S) = ∅. Note that for every row y with shading S, the type of the unit interval [y−1,y] is exactly FπS , while the type F of all other intervals in the row must contain the formula 〈B〉⊤, and thus it cannot be the case that ReqB(F) = ∅. Given a function cS : S→ {0, ...,8|ϕ|+ 14} such that cS(FπS) 6 1, we denote with S (extended shading) the pair 〈S,cS〉; thus, in the code we use S to denote a shading, and S to denote an extended-shading. Moreover we have to introduce the following stronger version of the relation B−→ :\nF B7−→G iff\n \n\nReqB(F) = Obs(G) ∪ ReqB(G)\nReqB(G) = Obs(F) ∪ ReqB(F)\nReqL(F) = ReqL(G).\nFinally, given two extended shadings S= 〈S,cS〉 and S ′ = 〈S ′,cS ′〉, we say that S ′ is a successor of S, and we write S 7−→S ′, if the following conditions hold:\n• for every F ∈ S ′ with ReqB(F) 6= ∅ there exists G ∈ S with F B7−→G; • there exists a set R⊆ S ′×S× {1, ...,8|ϕ|+14} such that for every (F,G,n) ∈ R, F B7−→G, for every F ∈ S ′ we have ∑\n(F,G,n)∈R n = cS ′(F), and for every G ∈ S we have\n∑\n(F,G,n)∈R n = cS(G).\nThe second condition ensures that all the witnesses of the lower shading S are correctly transferred in the upper shading S ′ according to the functions cS and cS ′ . It is easy to see that, given two rows y and y+1 with shadings S and S ′, the two extended shadings S= 〈S,cy〉 and S ′ = 〈S ′,cy+1〉, (where cy and cy+1 are the characteristic functions of y and y+1, respectively) are such that S 7−→S ′.\nThe main procedure basically guesses two extended shadings Spast and Sfuture which represent the rows y0 and y2 of a compass generator, and then it checks whether a compass generator featuring them exists. The procedure checkPast ensures that we can construct the portion of the compass structure between y0 and y1 (see Figure 3). The procedure starts from y0 and construct this portion incrementally row by row until it reaches row y1. The procedure exits successfully when it reaches, without exceeding the given number of steps, a row labelled with the extended shading Spast and such that all formulas ψ ∈ ReqL(F π Spast\n) are ”witnessed” by points with the first coordinate greater than the starting row (i.e., points belonging to the red triangle in Figure 3) to guarantee that there exists a past witness set for y1 that respects condition G3 of Definition 10. This condition is verified by means of the set Slower which keeps track of such points. The procedure checkFinite simply checks if the extended shading Sfuture is ”reachable” from the extended shading Spast, and thus it represents the construction of the finite part of a compass generator (the portion between y1 and y2 in Figure 3). Finally the the procedure checkFuture ensures that we can construct the portion between y2 and N−1 of a compass generator. This last procedure is similar to the procedure checkPast, and it checks whether there exists a portion of a compass structure where both the lowest and the biggest rows are labelled with Sfuture. To guarantee that a future witness set for y2 exists (condition G6 of Definition 10), we require that for every F ∈ Sfuture and for every ψ ∈ ReqB(F), it is the case that ψ is fulfilled by some successor of Sfuture. This condition is ensured by means of the set REQF, which keeps track of the formulas in ReqB(F) that still need to be satisfied. It is worth to notice that all the counters, the extended shadings, and the shadings using in these procedures can be represented using exponential space with respect to the length of the input formula. Summing up, we obtain the following tight complexity result.\nTHEOREM 15. The satisfiability problem for ABBL interpreted over strongly complete linear orders is EXPSPACE-complete."
    }, {
      "heading" : "5 Conclusions",
      "text" : "We considered an interval temporal logic (ABBL) with four modalities, corresponding, respectively, to Allen’s interval relations after, begins, begun-by, and before, and interpreted in the class of all strongly discrete linearly ordered sets, which includes, among others, all frames built over N, Z, and finite orders. We showed that this logic is decidable in EXPSPACE, and complete for this class. The importance of this result relies on the fact that, for the considered interpretations, this logic is maximal with respect to decidability. Moreover, these results represent a non-trivial contribution towards the complete classification of all fragments of Halpern and Shoham’s modal logic of intervals. We plan to complete the study of this particular language when it is interpreted over other classes of orders, such as the class of all dense linearly ordered sets, or the class of all linear orders, and to refine these results to include point-intervals, too."
    } ],
    "references" : [ {
      "title" : "Maintaining Knowledge About Temporal Intervals",
      "author" : [ "J.F. Allen" ],
      "venue" : "Communications of the Association for Computing Machinery",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1983
    }, {
      "title" : "Decidable and Undecidable Fragments of Halpern and Shoham’s Interval Temporal Logic: towards a complete classification.  88  Begin, After, and Later: a Maximal Decidable Interval Temporal Logic In: Proceedings of the 15th International Conference on Logic for Programming, Artificial Intelligence, and Reasoning (LPAR), Lecture Notes in Computer Science 5330",
      "author" : [ "D. Bresolin", "D. Della Monica", "V. Goranko", "A. Montanari", "G. Sciavicco" ],
      "venue" : null,
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2008
    }, {
      "title" : "Propositional Interval Neighborhood Logics: expressiveness, decidability, and undecidable extensions",
      "author" : [ "D. Bresolin", "V. Goranko", "A. Montanari", "G. Sciavicco" ],
      "venue" : "Annals of Pure and Applied Logic",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2009
    }, {
      "title" : "Propositional Interval Neighborhood Temporal Logics",
      "author" : [ "V. Goranko", "A. Montanari", "G. Sciavicco" ],
      "venue" : "Journal of Universal Computer Science",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2003
    }, {
      "title" : "A Road Map of Interval Temporal Logics and Duration Calculi",
      "author" : [ "V. Goranko", "A. Montanari", "G. Sciavicco" ],
      "venue" : "Applied Non-classical Logics",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2004
    }, {
      "title" : "A Propositional Modal Logic of Time Intervals",
      "author" : [ "J.Y. Halpern", "Y. Shoham" ],
      "venue" : "Journal of the ACM",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1991
    }, {
      "title" : "Maximal decidable fragments of Halpern and Shoham’s modal logic of intervals",
      "author" : [ "A. Montanari", "G. Puppis", "P. Sala" ],
      "venue" : "Proceedings of the 37th International Colloquium on Automata, Languages and Programming (ICALP",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2010
    }, {
      "title" : "Decidability of the Interval Temporal Logic ABB Over the Natural Numbers",
      "author" : [ "A. Montanari", "G. Puppis", "P. Sala", "G. Sciavicco" ],
      "venue" : "Research Report UDMI/2009/07, Department of Mathematics and Computer Science,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2009
    }, {
      "title" : "Decidability of the Interval Temporal Logic ABB on Natural Numbers",
      "author" : [ "A. Montanari", "G. Puppis", "P. Sala", "G. Sciavicco" ],
      "venue" : "Proceedings of the 27th Symposium on Theoretical Aspects of Computer Science (STACS",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2010
    }, {
      "title" : "The Convenience of Tilings",
      "author" : [ "P. Van Emde Boas" ],
      "venue" : null,
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1997
    } ],
    "referenceMentions" : [ {
      "referenceID" : 5,
      "context" : "The most famous ITL studied so far is probably Halpern and Shoham’s HS [6], which is the logic of (the thirteen) Allen’s interval relations between intervals [1].",
      "startOffset" : 71,
      "endOffset" : 74
    }, {
      "referenceID" : 0,
      "context" : "The most famous ITL studied so far is probably Halpern and Shoham’s HS [6], which is the logic of (the thirteen) Allen’s interval relations between intervals [1].",
      "startOffset" : 158,
      "endOffset" : 161
    }, {
      "referenceID" : 3,
      "context" : "Among them, we mention the fragment AA, also known as PNL, presented in [4], and studied also in [3], which is decidable over all interesting classes of models; and the fragment ABB (and, by symmetry, AEE) which is decidable when interpreted over natural numbers [9].",
      "startOffset" : 72,
      "endOffset" : 75
    }, {
      "referenceID" : 2,
      "context" : "Among them, we mention the fragment AA, also known as PNL, presented in [4], and studied also in [3], which is decidable over all interesting classes of models; and the fragment ABB (and, by symmetry, AEE) which is decidable when interpreted over natural numbers [9].",
      "startOffset" : 97,
      "endOffset" : 100
    }, {
      "referenceID" : 8,
      "context" : "Among them, we mention the fragment AA, also known as PNL, presented in [4], and studied also in [3], which is decidable over all interesting classes of models; and the fragment ABB (and, by symmetry, AEE) which is decidable when interpreted over natural numbers [9].",
      "startOffset" : 263,
      "endOffset" : 266
    }, {
      "referenceID" : 6,
      "context" : "in the model [7].",
      "startOffset" : 13,
      "endOffset" : 16
    }, {
      "referenceID" : 4,
      "context" : "Other interesting fragments are BB and EE, that are decidable in most cases [5], while any other combination of the four operators B, B, E, and E immediately leads to undecidability [2].",
      "startOffset" : 76,
      "endOffset" : 79
    }, {
      "referenceID" : 1,
      "context" : "Other interesting fragments are BB and EE, that are decidable in most cases [5], while any other combination of the four operators B, B, E, and E immediately leads to undecidability [2].",
      "startOffset" : 182,
      "endOffset" : 185
    }, {
      "referenceID" : 7,
      "context" : "The proof for property 1 can be found in [8].",
      "startOffset" : 41,
      "endOffset" : 44
    }, {
      "referenceID" : 9,
      "context" : "An EXPSPACE lower bound on the complexity follows from the reduction of the exponential-corridor tiling problem (which is known to be EXPSPACE-complete [10]) to the satisfiability problem for the fragment ABB given in [8].",
      "startOffset" : 152,
      "endOffset" : 156
    }, {
      "referenceID" : 7,
      "context" : "An EXPSPACE lower bound on the complexity follows from the reduction of the exponential-corridor tiling problem (which is known to be EXPSPACE-complete [10]) to the satisfiability problem for the fragment ABB given in [8].",
      "startOffset" : 218,
      "endOffset" : 221
    }, {
      "referenceID" : 7,
      "context" : "To give an upper bound to the complexity we claim that the existence of a compass structure (or compass generator) G that features a given formula φ can be decided by verifying suitable local (and stronger) consistency conditions over all pairs of contiguous rows, in a way similar to the EXPSPACE algorithm given in [8] for ABB.",
      "startOffset" : 317,
      "endOffset" : 320
    } ],
    "year" : 2013,
    "abstractText" : "Interval temporal logics (ITLs) are logics for reasoning about temporal statements expressed over intervals, i.e., periods of time. The most famous ITL studied so far is Halpern and Shoham’s HS, which is the logic of the thirteen Allen’s interval relations. Unfortunately, HS and most of its fragments have an undecidable satisfiability problem. This discouraged the research in this area until recently, when a number non-trivial decidable ITLs have been discovered. This paper is a contribution towards the complete classification of all different fragments of HS. We consider different combinations of the interval relations begins (B), after (A), later (L) and their inverses A, B and L. We know from previous works that the combinationABBA is decidable only when finite domains are considered (and undecidable elsewhere), and thatABB is decidable over the natural numbers. We extend these results by showing that decidability of ABB can be further extended to capture the language ABBL, which lies in between ABB and ABBA, and that turns out to be maximal w.r.t decidability over strongly discrete linear orders (e.g. finite orders, the naturals, the integers). We also prove that the proposed decision procedure is optimal with respect to the EXPSPACE complexity class.",
    "creator" : "LaTeX with hyperref package"
  }
}