{
  "name" : "1007.4040.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Loop Formulas for Description Logic Programs∗",
    "authors" : [ "YISONG WANG", "JIA-HUAI YOU", "LI YAN YUAN" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "KEYWORDS: Semantic web, description logic programs, answer sets, loop formulas"
    }, {
      "heading" : "1 Introduction",
      "text" : "Logic programming under the answer set semantics (ASP) is a nonmonotonic reasoning paradigm for declarative problem solving (Marek and Truszczynski 1999; Niemelä 1999). Recently, there have been extensive interests in combining ASP with other computational and reasoning paradigms. One of the main interests in this direction is the integration of ASP with ontology reasoning, for the Semantic Web.\nThe Semantic Web is an evolving development of the World Wide Web in which the meaning of information and services on the web are defined, so that the web content can be precisely understood and used by agents (Berners-Lee et al. 2001). For this purpose, a layered structure including the Rules Layer built on top of the Ontology Layer has been recognized as a fundamental framework. Description Logics (DLs) (Baader et al. 2007) provide a formal basis for the Web Ontology Language which is the standard of the Ontology Layer (W3C OWL Working Group 2009).\n∗ This is the full version of (Wang et al. 2010).\nar X\niv :1\n00 7.\n40 40\nv1 [\ncs .A\nI] 2"
    }, {
      "heading" : "2 Y. Wang et al.",
      "text" : "Adding nonmonotonic rules to the Rules Layer would allow default reasoning with ontologies. For example, we know that most natural kinds do not have a clear cut definition. For instance, a precise definition of scientist seems to be difficult by enumerating what a scientist is, and does. Though we can say that a scientist possesses expert knowledge on the subject of his or her investigation, we still need a definition of expert knowledge, which cannot be defined quantitatively. Using nonmonotonic rules, we can perform default, typicality reasoning over categories, concepts, and roles. The integration of DLs and (nonmonotonic) rules has been extensively investigated as a crucial problem in the study of the Semantic Web, such as Semantic Web Rule Language (SWRL) (Horrocks and PatelSchneider 2004), MKNF knowledge base (Motik and Rosati 2010), and Description Logic Programs (dl-programs) (Eiter et al. 2008).\nThere are different approaches to the integration of ASP with description logics. The focus of this paper is on the approach based on dl-programs. Informally, a dl-program is a pair (O ,P), where O is a DL knowledge base and P is a logic program whose rule bodies may contain queries, embedded in dl-atoms, to the knowledge base O . The answer to such a query depends on inferences by rules over the DL knowledge base O . In this way, rules are built on top of ontologies. On the other hand, ontology reasoning is also enhanced, since it depends not only on O but also on inferences using (nonmonotonic) rules. Two semantics for dl-programs have been proposed, one of which is based on strong answer sets and the other based on weak answer sets.\nIn this paper, we generalize the notions of completion and loop formulas of logic programs (Lin and Zhao 2004) to dl-programs and show that weak and strong answer sets of a dl-program can be captured precisely by the models of its completion and the corresponding loop formulas. This provides not only a semantic characterization of answer sets for dl-programs but also an alternative mechanism for answer set computation, using a dl-reasoner and a SAT solver.\nAs commented by (Eiter et al. 2008), the reason to introduce strong answer sets is because some weak answer sets seem counterintuitive due to “self-supporting” loops. Recently however, one of the co-authors of this paper, Yi-Dong Shen, discovered that strong answer sets may also possess self-supporting loops, and a detailed analysis leads to the conclusion that the problem cannot be easily fixed by an alternative definition of reduct, since the reduct of dl-atoms may not be able to capture dynamically generated self-supports arising from the integrated context.\nThe solution proposed in this paper is to use loop formulas as a way to define answer sets for dl-programs that are free of self-supports. Thus, we define what are called canonical loops and canonical loop formulas. Given a dl-program, the models of its completion satisfying the canonical loop formulas constitute a new class of answer sets, called canonical answer sets, that are minimal and noncircular.\nThe paper is organized as follows. In the next section, we recall the basic definitions of description logics and dl-programs. In Section 3, we define completion, weak and strong loop formulas for dl-programs. The new semantics of dl-programs based on canonical loop formulas is given in Section 4. Section 5 discusses related work, and finally Section 6 gives concluding remarks.\nLoop Formulas for Description Logic Programs1 3"
    }, {
      "heading" : "2 Preliminaries",
      "text" : "In this section, we briefly review the basic notations for description logics and description logic programs (Eiter et al. 2008)."
    }, {
      "heading" : "2.1 Description logics",
      "text" : "In principle, the description logics employed in description logic programs can be arbitrary, with the restriction that the underlying entailment relation is decidable. Due to space limitation, we introduce the basic description logic ALC (Baader et al. 2007), instead of the description logics SHIF and SHOIN described in (Eiter et al. 2008). The notations introduced here will be used throughout the paper, particularly the entailment relation O |= F , given at the end of this subsection.\nFor the languageALC, we assume a vocabulary Ψ = (A ∪R, I), where A,R and I are pairwise disjoint (denumerable) sets of atomic concepts, roles (including equality ≈ and inequality 6≈), and individuals respectively. The concepts of ALC are defined as follows:\nC ,D −→ A|>|⊥|¬C |C uD |C tD |∀R · C |∃R · C\nwhere A is an atomic concept and R is a role. The assertions of ALC are of the forms C (a) or R(b, c), where C is a concept, R is a role, and a, b, c are individuals. An inclusion axiom ofALC has the form C v D where C and D are concepts. A description knowledge base (or ontology) of ALC is a set of inclusion axioms and assertions of ALC.\nThe semantics of ALC is defined by translating to first-order logic and then using classical first-order interpretations as its semantics. Informally, let the transformation be τ : (1) τ(A) = A(x ), τ(R) = R(x , y) where A is an atomic concept and R a role; (2) τ(∀R·C ) = ∀x ·R(y , x ) ⊃ τ(C )(x ), and τ(∃R·C ) = ∃x ·R(y , x )∧τ(C )(x ); (3) τ(¬C ) = ¬τ(C )(x ), τ(C uD) = τ(C )(x ) ∧ τ(D)(x ), and τ(C tD) = τ(C )(x ) ∨ τ(D)(x ); (4) τ(A(a)) = A(a), τ(R(b, c)) = R(b, c); (5) τ(C v D) = ∀x · τ(C )(x ) ⊃ τ(D)(x ). Then, the semantics ofALC follows from that of first-order logic, so is the entailment relation O |= F , for a description knowledge base O and an assertion or inclusive axiom F ."
    }, {
      "heading" : "2.2 Description logic programs",
      "text" : "Let Φ = (P, C) be a first-order vocabulary with nonempty finite sets C and P of constant symbols and predicate symbols respectively such that P is disjoint from A ∪R and C ⊆ I. Atoms are formed from the symbols in P and C as usual.\nA dl-atom is an expression of the form\nDL[S1 op1 p1, . . . ,Sm opm pm ;Q ](~t), (m ≥ 0) (1)\nwhere\n• each Si is either a concept, a role or a special symbol in {≈, 6≈}; • opi ∈ {⊕, , }; • pi is a unary predicate symbol in P if Si is a concept, and a binary predicate symbol\nin P otherwise. The pis are called input predicate symbols; • Q(~t) is a dl-query, i.e., either (1) C (t) where~t = t ; (2) C v D where~t is an empty\nargument list; (3) R(t1, t2) where~t = (t1, t2); (4) t1 ≈ t2 where~t = (t1, t2); or their negations, where C and D are concepts, R is a role, and~t is a tuple of constants."
    }, {
      "heading" : "4 Y. Wang et al.",
      "text" : "The precise meanings of {⊕, , } will be defined shortly. Intuitively, S ⊕ p (resp. S p) extends S (resp. ¬S ) by the extension of p, and S p constrains S to p.\nFor example, suppose the interface is such that if any individual x is registered for a course (the information from outside an ontology) then x is a student (x may not be a student by the ontology before this communication), and we query if a is a student. We can then write the dl-atom DL[Student ⊕ registered ;Student ](a). Similarly, DL[Student registered ;¬Student u ¬Employed ](a) queries if a is not a student nor employed, with the ontology enhancement that if we cannot show x is registered, then x is not a student.\nA dl-rule (or simply a rule) is an expression of the form\nA← B1, . . . ,Bm ,not Bm+1, . . . ,not Bn , (n ≥ m ≥ 0) (2)\nwhere A is an atom, each Bi (1 ≤ i ≤ n) is an atom2 or a dl-atom. We refer to A as its head, while the conjunction of Bi(1 ≤ i ≤ m) and not Bj (m + 1 ≤ j ≤ n) is its body. For convenience, we may abbreviate a rule in the form (2) as\nA← Pos,not Neg (3)\nwhere Pos = {B1, . . . ,Bm} and Neg = {Bm+1, . . . ,Bn}. Let r be a rule of the form (3). If Neg = ∅ and Pos = ∅, r is a fact and we may write it as “A” instead of “A ←”. A description logic program (dl-program) K = (O ,P) consists of a DL knowledge base O and a finite set P of dl-rules. In what follows we assume the vocabulary of P is implicitly given by the constant symbols and predicates symbols occurring in P , unless stated otherwise.\nGiven a dl-program K = (O ,P), the Herbrand base of P , denoted by HBP , is the set of atoms formed from the predicate symbols in P occurring in P and the constant symbols in C occurring in P . An interpretation I (relative to P ) is a subset of HBP . Such an I is a model of an atom or dl-atom A under O , written I |=O A, if the following holds:\n• if A ∈ HBP , then I |=O A iff A ∈ I ; • if A is a dl-atom DL(λ;Q)(~t) of the form (1), then I |=O A iff O(I ;λ) |= Q(~t)\nwhere O(I ;λ) = O ∪ ⋃m\ni=1 Ai(I ) and, for 1 ≤ i ≤ m ,\nAi(I ) =  {Si(~e)|pi(~e) ∈ I }, if opi = ⊕; {¬Si(~e)|pi(~e) ∈ I }, if opi = ; {¬Si(~e)|pi(~e) /∈ I }, if opi = ;\nwhere ~e is a tuple of constants over C. The interpretation I is a model of a dl-rule of the form (3) iff I |=O B for any B ∈ Pos and I 6|=O B ′ for any B ′ ∈ Neg implies I |=O A. I is a model of a dl-programK = (O ,P), written I |=O K, iff I is a model of each rule of P . I is a supported model ofK = (O ,P) iff, for any h ∈ I , there is a rule (h ← Pos,not Neg) in P such that I |=O A for any A ∈ Pos and I 6|=O B for any B ∈ Neg.\nA dl-atom A is monotonic relative to a dl-program K = (O ,P) if I |=O A implies I ′ |=O A, for all I ⊆ I ′ ⊆ HBP , otherwise A is nonmonotonic. It is clear that if a dl-atom does not mention then it is monotonic. However, a dl-atom may be monotonic even if it mentions . E.g., the dl-atom DL[S p,S p;¬S ](a) is monotonic (which is a tautology). Clearly, the operator is the only one that may cause a dl-atom to be nonmonotonic. Thus\n2 Different from that of (Eiter et al. 2008), we consider ground atoms instead of literals for convenience.\nLoop Formulas for Description Logic Programs3 5\none has no reason to use in monotonic dl-atoms. It is a reasonable assumption that we can rewrite a monotonic dl-atom into an equivalent one without using at all.\nWe use DLP to denote the set of all dl-atoms that occur in P , DL+P ⊆ DLP to denote the set of monotonic dl-atoms, and DL?P = DLP \\ DL + P . A dl-program K = (O ,P) is positive if (i) P is “not”-free, and (ii) every dl-atom is monotonic relative toK. It is evident that if a dl-program K is positive, then K has a (set inclusion) least model."
    }, {
      "heading" : "2.3 Strong and weak answer sets",
      "text" : "Let K = (O ,P) be a dl-program. The strong dl-transform of K relative to O and an interpretation I ⊆ HBP , denoted by Ks,I , is the positive dl-program (O , sP IO ), where sP IO is obtained from P by deleting:\n• the dl-rule r of the form (2) such that either I 6|=O Bi for some 1 ≤ i ≤ m and Bi ∈ DL?P , or I |=O Bj for some m + 1 ≤ j ≤ n; and • the nonmonotonic dl-atoms and not A from the remaining dl-rules where A is an atom or dl-atom.\nThe interpretation I is a strong answer set of K if it is the least model of Ks,I . The weak dl-transform of K relative to O and an interpretation I ⊆ HBP , denoted by Kw ,I , is the positive dl-program (O ,wP IO), where wP IO is obtained from P by deleting:\n• the dl-rules of the form (2) such that either I 6|=O Bi for some 1 ≤ i ≤ m and Bi ∈ DLP , or I |=O Bj for some m + 1 ≤ j ≤ n; and • the dl-atoms and not A from the remaining dl-rules where A is an atom or dl-atom.\nThe interpretation I is a weak answer set of K if I is the least model of Kw ,I .\nExample 1 Consider the following dl-programs:\n• K0 = (O ,P0) where O = {c v c′} and P0 = {w(a)←DL[c⊕p; c′](a); p(a)←}. For this dl-program to make some sense, let’s image this situation: c′ and c are classes of good conference papers and ICLP papers respectively, p(x ) means that x is a paper in the TPLP special issue of ICLP 2010, w(x ) means that x is worth reading, and a stands for “this paper”. Note that c and c′ are concepts in O , and p and w are predicates outside of O . The communication is through the dl-rule, w(a) ← DL[c ⊕ p; c′](a), which says that if “this paper” is a good conference paper, given that any paper in the TPLP special issue of ICLP 2010 is an ICLP paper and ICLP papers are good conference papers (by the knowledge in O), then it is worth reading. K0 has exactly one strong answer set {p(a),w(a)}, which is also its unique weak answer set. • Now, suppose someone writes K1 = (O ,P1) where O = {c v c′} and P1 = {p(a) ← DL[c ⊕ p; c′](a)}. This program has a unique strong answer set I1 = ∅ and two weak answer sets I1 and I2 = {p(a)}. It can be seen that there is a circular justification in the weak answer set I2: that “this paper” is in the TPLP special issue of ICLP 2010 is justified by its being in it. The interested reader may verify the following. By the definition of ⊕, O(I2; c ⊕"
    }, {
      "heading" : "6 Y. Wang et al.",
      "text" : "p) = O ∪{c(a)}, and clearly O 6|= c′(a) and {c(a), c v c′} |= c′(a). So the weak dl-transform relative to O and I2 is Kw ,I21 = (O , {p(a) ←}). Since I2 coincides with the least model of {p(a)←}, it is a weak answer set of K1. Similarly, one can verify that the strong dl-transform relative to O and I2 is Ks,I21 = (O ,P1). Its least model is the empty set, so I2 is not a strong answer set of K1. • K2 = (O ,P2) where O = ∅ and P2 = {p(a) ← DL[c ⊕ p, b q ; c u ¬b](a)}. Both ∅ and {p(a)} are strong and weak answer sets of the dl-program. • K3 = (∅,P3) where P3 = {p(a)← DL[c p, b q ;¬c u ¬b](a)}. ∅ and {p(a)} are both strong and weak answer sets of the dl-program. • K4 = (∅,P4) where P4 = {p(a) ← DL[c p;¬c](a)}. K4 has no weak answer set, and thus it has no strong answer set either.\nThese dl-programs show that strong (and weak) answer sets may not be (set inclusion) minimal. It has been shown that if a dl-program contains no nonmonotonic dl-atoms then its strong answer sets are minimal (Eiter et al. 2008). However, this does not hold for weak answer sets as shown by the dl-program K1 above, even if it is positive. It is known that strong answer sets are always weak answer sets, but not vice versa (Eiter et al. 2008)."
    }, {
      "heading" : "3 Completion and Loop Formulas",
      "text" : "In this section, we define completion, characterize weak and strong answer sets by loop formulas, and outline an alternative method of computing weak and strong answer sets."
    }, {
      "heading" : "3.1 Completion",
      "text" : "Given a dl-program K = (O ,P), we assume an underlying propositional language LK, such that the propositional atoms of LK include the atoms and dl-atoms occurring in P . The formulas of LK are defined as usual using the connectives ¬,∧,∨,⊃ and↔. The dlinterpretations (or simply interpretations if it is clear from context) of the language LK are the interpretations relative to P , i.e., the subsets of HBP . For a formula ψ of LK and an interpretation I of LK, we say I is a model of ψ relative to O , denoted I |=O ψ, whenever (i) if ψ is an atom, then ψ ∈ I ; (ii) if ψ is a dl-atom, then I |=O ψ; and (iii) the above is extended in the usual way to arbitrary formulas of LK.\nLet K = (O ,P) be a dl-program and h an atom in HBP . The completion of h (relative to K), written COMP(h,K), is the following formula of LK:\nh ↔ ∨\n1≤i≤n  ∧ A∈Posi A ∧ ∧ B∈Neg i ¬B  , where (h ← Pos1,not Neg1), . . . , (h ← Posn ,not Negn) are all the rules in P whose heads are the atom h . The completion of K, written COMP(K), is the collection of completions of all atoms in HBP .\nRecall that a model M ⊆ HBP of a dl-program K = (O ,P) is a supported model if for any atom a ∈ M , there is a rule in P whose head is a and whose body is satisfied by M . Proposition 1 LetK = (O ,P) be a dl-program and I an interpretation of P . Then I is a supported model of K if and only if I |=O COMP(K).\nLoop Formulas for Description Logic Programs4 7\nProposition 2 Every weak (resp. strong) answer set of a dl-program K is a supported model of K."
    }, {
      "heading" : "3.2 Weak loop formulas",
      "text" : "In order to capture weak answer sets of dl-programs using completion and loop formulas, we define weak loops. Formally, let K = (O ,P) be a dl-program. The weak positive dependency graph of K, written GwK , is the directed graph (V ,E ), where V = HBP (note that a dl-atom is not in V ), and (u, v) ∈ E if there is a dl-rule of the form (2) in P such that A = u and Bi = v for some i (1 ≤ i ≤ m). A nonempty subset L of HBP is a weak loop of K if there is a cycle in GwK which goes through only and all the nodes in L.\nGiven a weak loop L of a dl-program K = (O ,P), the weak loop formula of L (relative to K), written wLF(L,K), is the following formula of LK:\n∨ L ⊃ ∨ 1≤i≤n  ∧ A∈Posi A ∧ ∧ B∈Neg i ¬B  where (h1 ← Pos1,not Neg1), . . . , (hn ← Posn ,not Negn) are all the rules in P such that hi ∈ L and Posi ∩ L = ∅ for any i (1 ≤ i ≤ n).\nTheorem 1 LetK = (O ,P) be a dl-program and I an interpretation of P . Then I is a weak answer set of K if and only if I |=O COMP(K) ∪ wLF(K), where wLF(K) is the set of weak loop formulas of all weak loops of K."
    }, {
      "heading" : "3.3 Strong loop formulas",
      "text" : "Let K = (O ,P) be a dl-program. The strong positive dependency graph of K, denoted by GsK, is the directed graph (V ,E ), where V = HBP and (p(~c), q(~c\n′)) ∈ E if there is a rule of the form (2) in P such that, (1) A = p(~c) and, (2) for some i (1 ≤ i ≤ m), either\n• Bi = q(~c′), or • Bi is a monotonic dl-atom mentioning the predicate q and ~c′ is a tuple of constants\nmatching the arity of q . (If this condition is ignored then it becomes the definition of weak positive dependency graph.)\nA nonempty subset L of HBP is a strong loop of K if there is a cycle in GsK which passes only and all the nodes in L.\nTo define strong loop formulas of a dl-program K = (O ,P), we need to extend the vocabulary Φ, such that, for any predicate symbol p and a nonempty set of atoms L, Φ contains the predicate symbol pL that has the same arity as that of p.\nLet L be a nonempty set of atoms, A = DL[λ;Q ](~t) be a dl-atom. The irrelevant formula of A relative to L, written by IF(A,L), is the conjunction of (1) DL[λL;Q ](~t), where λL is obtained from λ by replacing each predicate symbol p with pL whenever p appears in both λ and L and, (2) for each predicate symbol p mentioned in both λ and L, the instantiation"
    }, {
      "heading" : "8 Y. Wang et al.",
      "text" : "on C (Chen et al. 2006) of the formula:\n∀~X · pL(~X )↔ p(~X ) ∧ ∧\np(~c)∈L\n~X 6= ~c  (4) where ~X is a tuple of distinct variables matching the arity of p, and ~X 6= ~c stands for ¬(~X = ~c), i.e., ¬(x1 = c1 ∧ . . . ∧ xk = ck ) if ~X = (X1, . . . ,Xk ) and ~c = (c1, . . . , ck ). Please note that, the instantiation of a formula ∀x · ψ on a finite set D of constants is the formula ∧ d∈D ψ[x/d ], in which c = c (resp., c = c\n′) is replaced with > (true) (resp., ⊥ (false)), where c and c′ are two distinct constants. In what follows, we identify the formula (4) with its instantiation whenever it is clear from its context, unless otherwise stated.\nFor instance, let A = DL[c ⊕ p; c](a) and L = {p(a), p(b)}. Then IF (A,L) is the formula:\nDL[c ⊕ pL; c](a) ∧ (pL(a)↔ p(a) ∧ a 6= a) ∧ (pL(b)↔ p(b) ∧ a 6= b)\nwhich is equivalent to\nDL[c ⊕ pL; c](a) ∧ ¬pL(a) ∧ (pL(b)↔ p(b))·\nIntuitively, the irrelevant formula of A relative to L says that the truth of A only depends on the truth of the atoms not in L.\nWe are now in a position to define strong loop formulas. Let L be a strong loop of K = (O ,P). The strong loop formula of L (relative to K), written sLF(L,K), is the following formula of LK:∨\nL ⊃ ∨\n1≤i≤n  ∧ A∈Posi γ(A,L) ∧ ∧ B∈Neg i ¬B  where\n• (h1 ← Pos1,not Neg1), . . . , (hn ← Posn ,not Negn) are all the rules in P such that hi ∈ L and Posi ∩ L = ∅ for all i (1 ≤ i ≤ n), • γ(A,L) = IF(A,L) if A is a monotonic dl-atom, and A otherwise.\nIn general, we have to recognize the monotonicity of dl-atoms in order to construct strong loops of dl-programs. In this sense, the strong loops and strong loop formulas are defined semantically. If a dl-atom does not mention the operator then it is obviously monotonic. Thus for the class of dl-programs in which no monotonic dl-atoms mention , the strong loops and strong loop formulas are given syntactically, since it is sufficient to determine the monotonicity of a dl-atom by checking whether it contains the operator .\nExample 2 Let K = (∅,P) be a dl-program where P consists of\np(a)← DL[c ⊕ p; c](a); p(a)← not DL[c ⊕ p; c](a)·\nThe dl-program K has a unique strong loop L = {p(a)}, but doesn’t have any weak loops. Its completion is the formula:\np(a)↔ DL[c ⊕ p; c](a) ∨ ¬DL[c ⊕ p; c](a)\nLoop Formulas for Description Logic Programs6 9\nwhich equals to the formula p(a) ↔ >, i.e., p(a). Note that, the strong loop formula sLF(L,K) is the formula:\np(a) ⊃ [\nDL[c ⊕ pL; c](a) ∧ (pL(a)↔ p(a) ∧ a 6= a) ∨¬DL[c ⊕ p; c](a)\n] ·\nIt is clear that the interpretation I = {p(a)} is a model of COMP(K) relative to the DL knowledge base O = ∅. However, I 6|=O sLF(L,K).\nTheorem 2 Let K = (O ,P) be a dl-program and I an interpretation of P . Then I is a strong answer set of K if and only if I ′ |=O COMP(K) ∪ sLF(K), where sLF(K) is the set of strong loop formulas of all strong loops of K and I ′ is the extension of I satisfying (4).\nSince a weak loop of a dl-program K is also a strong loop of K, as a by-product, our loop formula characterizations yield an alternative proof that strong answer sets are also weak answer sets.\nProposition 3 Let K = (O ,P) be a dl-program, I an interpretation of P and L a weak loop of K. Then we have I ′ |=O sLF(L,K) ⊃ wLF(L,K), where I ′ is the extension of I satisfying (4)."
    }, {
      "heading" : "3.4 An alternative method of computing weak and strong answer sets",
      "text" : "Theorems 1 and 2 serve as the basis for an alternative method of computing weak and strong answer sets using a SAT solver, along with a dl-reasoner R with the following property:R is sound, complete, and terminating for entailment checking. Let K = (O ,P) be a dl-program and T = COMP(K). We replace all dl-atoms in T with new propositional atoms to produce T ′. Let ξA be the new atom in T ′, for the dl-atom A in T , and X be the set of all such new atoms in T ′. Below, we outline an algorithm to compute the weak answer sets of K (here we only describe how to compute the first such an answer set). To compute a strong answer set, replace the word weak with strong.\n(i) Generate a model I of T ; if there is none, then there is no weak answer set. (ii) Check if I is a weak answer set of K,\n(a) if yes, return I as a weak answer set of K. (b) if no, add a weak loop formula into T that is not satisfied by I relative to O ,\nand goto (i).\nTo generate a model of T , we compute a model M of T ′ using a SAT solver, and then use R to check the entailment: For any dl-atom A in T , if M |= ξA then M |=O A otherwise M 6|=O A. Let M ′ = M /X . It is not difficult to verify that M ′ is a model of K.\nThe strong and weak answer set semantics of dl-programs have been implemented in a prototype system called SWLP5, using the ASP solver DLV and a dl-reasoner. The main\n5 https://www.mat.unical.it/ianni/swlp/; also see (Eiter et al. 2008) for the details of the implementation and interesting dl-programs"
    }, {
      "heading" : "10 Y. Wang et al.",
      "text" : "difference in the method outlined here is that we use a SAT solver to generate candidate models, which allows to take the advantages of the state-of-the-art SAT technology.\nFor strong answer sets, the construction of a strong loop formula requires checking monotonicity of dl-atoms. However, for the class of dl-programs mentioning no , this checking is not needed and the construction of a strong loop formula is hence tractable."
    }, {
      "heading" : "4 Canonical Answer Sets",
      "text" : ""
    }, {
      "heading" : "4.1 Motivation: the problem of self-support",
      "text" : "As commented by Eiter et al. (Eiter et al. 2008), some weak answer sets may be considered counterintuitive because of “self-supporting” loops. For instance, consider the weak answer set {p(a)} of the dl-programK1 in Example 1. The evidence of the truth of p(a) is inferred by means of a self-supporting loop: “p(a) ⇐ DL[c ⊕ p; c′](a) ⇐ p(a)”, which involves not only the dl-atom DL[c ⊕ p; c′](a) but the DL knowledge base O . Thus the truth of p(a) depends on the truth of itself. This self-support is excluded by the strong loop formula of the loop L = {p(a)}.\nLet’s consider the dl-program K2 in Example 1 again. Note that {p(a)} is a strong answer set of K2. The truth of the atom p(a) depends on the truth of [c u ¬b](a) which depends on the truth of p(a) and ¬q(a). Thus the truth of p(a) depends on the truth of itself. The self-supporting loop is: “p(a)⇐ DL[c⊕p, b q ; cu¬b](a)⇐ (p(a)∧¬q(a))”. In this sense, some strong answer sets may be considered counterintuitive as well.\nThe notion of “circular justification” was formally defined by (Liu and You 2008) to characterize self-supports for lparse programs, which was motivated by the notion of unfoundedness for logic programs (Van Gelder et al. 1991) and logic programs with aggregates (Calimeri et al. 2005). With slight modifications, we extend the concept of circular justification to dl-programs. Formally, let K = (O ,P) be a dl-program and I ⊆ HBP be a supported model of K. I is said to be circularly justified (or simply circular) if there is a nonempty subset M of I such that\nI \\M 6|=O ∧\nA∈Pos A ∧ ∧ B∈Neg ¬B (5)\nfor any dl-rule (h ← Pos,not Neg) in P with h ∈ M and I |=O ∧ A∈Pos A∧ ∧\nB∈Neg ¬B . Otherwise, we say that I is noncircular. Intuitively speaking, Condition (5) means that the atoms in M have no support from outside of M , i.e., they have to depend on themselves.\nExample 3 Let K = (∅,P) where P consists of\np(a)← not DL[b p;¬b](a)·\nIt is not difficult to verify that K has two weak answer sets ∅ and {p(a)}. They are strong answer sets of K as well. In terms of the above definition, {p(a)} is circular.\nIt is interesting to note that weak answer sets allow self-supporting loops involving any dl-atoms (either monotonic or nonmonotonic), while strong answer sets allow selfsupporting loops only involving nonmonotonic dl-atoms and their default negations. These considerations motivate us to define a new semantics which is free of circular justifications.\nLoop Formulas for Description Logic Programs7 11"
    }, {
      "heading" : "4.2 Canonical answer sets by loop formulas",
      "text" : "Let K = (O ,P) be a dl-program. The canonical dependency graph of K, written GcK, is the directed graph (V ,E ), where V = HBP and (u, v) ∈ E if there is a rule of the form (2) in P such that A = u and there exists an interpretation I ⊆ HBP such that either of the following two conditions holds:\n(1) I 6|=O Bi and I ∪{v} |=O Bi , for some i (1 ≤ i ≤ m). In this case, we say that v is a positive monotonic (resp., nonmonotonic) dependency of Bi if Bi is a monotonic (resp., nonmonotonic) dl-atom. Intuitively, the truth of Bi may depend on that of v while the truth of u may depend on that of Bi . Thus the truth of u may depend on that of v . (2) I |=O Bj and I ∪ {v} 6|=O Bj , for some j (1 + m ≤ j ≤ n). Clearly, Bj must be nonmonotonic. In this case, we say that v is a negative nonmonotonic dependency of Bj . Intuitively, the truth of u may depend on that of “not Bj ”, while its truth may depend on that of v . Thus the truth of u may depend on that of v .\nA nonempty subset L of HBP is a canonical loop of K if there is a cycle in GcK that goes through only and all the nodes in L. It is clear that if Bi = v then the interpretation I = {v} satisfies v while I \\ {v} does not. Thus the notion of canonical loops is a generalization of that of weak loops given in Subsection 3.2, and a generalization of the notion of loops for normal logic programs (Lin and Zhao 2004).\nNote further that the canonical dependency graph is not a generalization of the strong positive dependency graph, since some strong loops are not canonical loops. E.g., with the dl-program K = (∅,P), where P = {p(a) ← DL[c p, c p,¬c](a)}, the dlatom A = DL[c p, c p,¬c](a) is equivalent to >. So it is monotonic. It follows that L = {p(a)} is a strong loop of K. However L is not a canonical loop of K because there is no interpretation I such that I 6|=O A and I ∪ {p(a)} |=O A.\nDue to the two kinds of dependencies in a canonical dependency graph defined above, to define canonical loop formulas, we need two kinds of irrelevant formulas: Let L be a set of atoms and A = DL[λ;Q ](~t) a nonmonotonic dl-atom. The positive canonical irrelevant formula of A with respect to L, written pCF(A,L), is the conjunction of (1) DL[λL;Q ](~t), where λL is obtained from λ by replacing each predicate p with pL if L contains an atom p(~c) which is a positive nonmonotonic dependency of A and, (2) for each predicate p occurring in λ, the instantiation on C of the formula (4) if L contains an atom p(~c) which is a positive nonmonotonic dependency of A. The negative canonical irrelevant formula of A with respect to L, written nCF(A,L), is the conjunction of (1) DL[λL;Q ](~t), where λL is obtained from λ by replacing each predicate p with pL if L contains an atom p(~c) which is a negative nonmonotonic dependency of A and, (2) for each predicate p occurring in λ, the instantiation on C of the formula (4) if L contains an atom p(~c) which is a negative nonmonotonic dependency of A.\nLet K = (O ,P) be a dl-program, M ⊆ HBP and L a loop of K. The canonical loop formula of L relative to K under M , written cLF(L,M ,K), is the following formula:\n∨ L ⊃ ∨ 1≤i≤n  ∧ A∈Posi δ1(A,L) ∧ ∧ B∈Neg i ¬δ2(B ,L) \nwhere\n• (h1 ← Pos1,not Neg1), . . . , (hn ← Posn ,not Negn) are all the rules in P such that hi ∈ L, Posi∩L = ∅ and M |=O ∧ A∈Posi A∧ ∧ B∈Neg i ¬B for each i (1 ≤ i ≤ n), • δ1(A,L) = pCF(A,L) if A is a nonmonotonic dl-atom, γ(A,L) otherwise, • δ2(B ,L) = nCF(B ,L) if B is a nonmonotonic dl-atom, and B otherwise.\nGiven a dl-program K = (O ,P) and an interpretation I ⊆ HBP . We call I a canonical answer set of K if I ′ is a model of COMP(K) ∪ cLF(I ,K) relative to O , where I ′ is the extension of I satisfying (4) and cLF(I ,K) = {cLF(L, I ,K)|L is a canonical loop of K}. It is not difficult to prove that every canonical answer set of a dl-program K is a supported model of K.\nExample 4 Consider the dl-program K2 in Example 1, i.e., K2 = (∅,P2) where P2 = {p(a) ← DL[c⊕p, b q ; cu¬b](a)}. It is easy to see that the dl-atom DL[c⊕p, b q ; cu¬b](a) is nonmonotonic, ∅ 6|=O DL[c ⊕ p, b q ; c u ¬b](a), and {p(a)} |=O DL[c ⊕ p, b q ; c u¬b](a). Thus L = {p(a)} is a canonical loop of K2. Let I = {p(a)}. The canonical loop formula cLF(L, I ,K) is equivalent to\np(a) ⊃ DL[c ⊕ pL, b q ; c u ¬b](a) ∧ (pL(a)↔ p(a) ∧ (a 6= a))\nwhere the last conjunct is equivalent to ¬pL(a). Thus, the loop formula is not satisfied by the extension of I satisfying (4) relative to the knowledge base ∅. So I is not a canonical answer set of K2, even if I is a model of COMP(K2) relative to the knowledge base ∅.\nThe next example demonstrates the difference among the positive dependency graphs of dl-programs.\nExample 5 Let K = (O ,P) be a dl-program where O = ∅ and P consists of the following rules:\np(a1)← DL[c ⊕ p, c](a1), p(a3)← not DL[c p,¬c](a3), p(a2)← DL[c ⊕ p, b q ; c u ¬b](a2), p(a4)← p(a4).\nThe only weak positive dependency on HBP is (p(a4), p(a4)), the strong positive dependency includes (p(a1), p(a1)) besides the weak one, while the canonical positive dependency contains (p(a2), p(a2)) and (p(a3), p(a3)) in addition to the strong ones. Figure 1 depicts the various dependency relations on HBP . The weak positive dependency graph is GwK = (V ,E ) where V = {p(ai), q(ai)|1 ≤ i ≤ 4} and E = {(p(a4), p(a4))}, while the strong one is GsK = (V ,E\n′) where E ′ = E ∪ {(p(a1), p(a1))}. The canonical dependency graph is GcK = (V ,E ′′) where E ′′ = E ′ ∪ {(p(a2), p(a2)), (p(a3), p(a3))}.\nLoop Formulas for Description Logic Programs8 13\nComparing with the previous definitions of loop formulas, in addition to the irrelevant formulas of nonmonotonic dl-atoms, the definition of canonical loop formulas has a notable distinction: it is given under a set M of atoms whose purpose is to restrict that the support of any atom in L come from the rules whose bodies are satisfied by M (relative to a knowledge base). The next proposition shows that the canonical loops and canonical loop formulas for dl-programs are indeed a generalization of loops and loop formulas for normal logic programs (Lin and Zhao 2004) respectively.\nProposition 4 Let P be a normal logic program, L ⊆ HBP and M a model of the completion of P .\n(1) L is a loop of P if and only if L is a canonical loop of K = (∅,P). (2) M |= LF (L,P) if and only if M |=O cLF(L,M ,P), where LF (L,P) is the loop\nformula associated with L under P (Lin and Zhao 2004) and O = ∅.\nProposition 5 Let K = (O ,P) be a dl-program and I a canonical answer set of K. Then I is minimal in the sense that K has no canonical answer set I ′ such that I ′ ⊂ I .\nThe following two propositions show that the canonical answer sets of dl-programs are noncircular strong answer sets. Thus canonical answer sets are weak answer sets as well.\nProposition 6 Let K = (O ,P) be a dl-program and I ⊆ HBP a canonical answer set of K. Then I is noncircular.\nProposition 7 Let K = (O ,P) be a dl-program and I ⊆ HBP a canonical answer set of K. Then I is a strong answer set of K.\nThe following proposition, together with Proposition 6, implies that the operator is the only cause that a strong answer set of a dl-program is circular.\nProposition 8 Let K = (O ,P) be a dl-program in which P does not mention the operator . Then I ⊆ HBP is a canonical answer set of K if and only if I is a strong answer set of K."
    }, {
      "heading" : "5 Related Work",
      "text" : "Integrating ASP with description logics has attracted a great deal of attention recently. The existing approaches can be roughly classified into three categories. The first is to adopt a nonmonotonic formalism that covers both ASP and first-order logic (if not for the latter, then extend it to the first-order case) (Motik and Rosati 2010; Bruijn et al. 2007), where ontologies and rules are written in the same language, resulting in a tight coupling. The second is a loose approach: An ontology knowledge base and the rules share the same constants but not the same predicates, and the communication is via a well-defined interface, such as dl-atoms (Eiter et al. 2008). The third is to combine ontologies with hybrid rules (Rosati 2005; Rosati 2006; de Bruijn et al. 2007), where predicates in the language of ontologies are interpreted classically, whereas those in the language of rules are interpreted nonmonotonically."
    }, {
      "heading" : "14 Y. Wang et al.",
      "text" : "Although each approach above has its own merits, the loose approach possesses some unique advantages. In many situations, we would like to combine existing knowledge bases, possibly under different logics. In this case, a notion of interface is natural and necessary. The loose approach seems particularly intuitive, as it does not rely on the use of modal operators nor on a multi-valued logic. One notices that dl-programs share similar characteristics with another recent interest, multi-context systems, in which knowledge bases of arbitrary logics communicate through bridge rules (Brewka and Eiter 2007).\nHowever, the relationships among these different approaches are currently not well understood. For example, although we know how to translate a dl-program without the nonmonotonic operator to an MKNF theory while preserving the strong answer set semantics (Motik and Rosati 2010), when is involved, no such a translation is known. Similarly, although a variant of Quantified Equilibrium Logic (QEL) captures the existing hybrid approaches, as shown by (de Bruijn et al. 2007), it is not clear how one would apply the loop formulas for logic programs with arbitrary sentences (Lee and Meng 2008) to dl-programs, since, to the best of our knowledge, there is no syntactic, semantics-preserving translation from dl-programs to logic programs with arbitrary sentences or to QEL.\nIn fact, the loop formulas for dl-programs are more involved than any previously known loop formulas, due to mixing ASP with classical first-order logic. This is evidenced by the fact that weak loop formulas permit self-supports, strong loop formulas eliminate certain kind of self-supports, and finally canonical loop formulas remove all self-supports. This seems to be a unique phenomenon that arises to dl-programs, not to any other known extensions of ASP, including logic programs with arbitrary sentences."
    }, {
      "heading" : "6 Concluding Remarks",
      "text" : "In this paper, we characterized the weak and strong answer sets of dl-programs by program completion and loop formulas. Although these loop formulas also provide an alternative mechanism for computing answer sets, building such a system presents itself as an interesting future work. We also proposed the canonical answer sets for dl-programs, which are minimal and noncircular in a formal sense. From the perspective of loop formulas, we see a notable distinction among the weak, strong and canonical answer sets: the canonical answer sets permit no circular justifications, the strong answer sets permit circular justifications involving nonmonotonic dl-atoms but not monotonic ones, whereas the weak answer sets permit circular justifications that involve any dl-atoms but not atoms.\nWe remark that, for a given dl-program K = (O ,P), to decide if a set M ⊆ HBP is a strong or canonical loop and to construct the strong or canonical loop formula of M are generally quite difficult, since we have to decide the monotonicity of the dl-atoms occurring in P . The exact complexity of deciding if a set of atoms is a strong or canonical loop is one of our ongoing studies, in addition to the complexity of deciding if a given dl-program has a canonical answer set.\nAcknowledgment: We thank the anonymous reviewers for their detailed comments, which helped improve the presentation of the paper. Yisong Wang was supported in part by NSFC grants 90718009 and 60703095, the Fund of Guizhou Science and Technology 2008[2119], the Fund of Education Department of Guizhou Province 2008[011], Scientific Research Fund for talents recruiting of Guizhou University 2007[042]. Jia-Huai You and Li Yan\nLoop Formulas for Description Logic Programs9 15\nYuan are partially supported by NSERC and by the Ministry of Science and Technology of China under 863 plan. Yi-Dong Shen is supported in part by NSFC grants 60970045 and 60721061."
    }, {
      "heading" : "BAADER, F., CALVANESE, D., MCGUINNESS, D. L., NARDI, D., AND PATEL-SCHNEIDER, P. F.",
      "text" : "2007. The Description Logic Handbook: Theory, Implementation, and Applications , 2nd ed. Cambridge University Press, New York, NY.\nBERNERS-LEE, T., HENDLER, J., AND LASSILA, O. 2001. The semantic web. Scientific American Magazine 284, 5, 34–43.\nBREWKA, G. AND EITER, T. 2007. Equilibria in heterogeneous nonmonotonic multi-context systems. In Proceedings of the Twenty-second AAAI Conference on Artificial Intelligence (AAAI 2007). AAAI Press, Vancouver, British Columbia, Canada, 385–390.\nBRUIJN, J., EITER, T., POLLERES, A., AND TOMPITS, H. 2007. Embedding non-ground logic programs into autoepistemic logic for knowledge-base combination. In Proceedings of the 20th International Joint Conference On Artificial Intelligence (IJCAI-07). Hyderabad, India, 304–309.\nCALIMERI, F., FABER, W., LEONE, N., AND PERRI, S. 2005. Declarative and computational properties of logic programs with aggregates. In Proceedings of the Nineteenth International Joint Conference on Artificial Intelligence (IJCAI 2005). Professional Book Center, Edinburgh, Scotland, UK, 406–411.\nCHEN, Y., LIN, F., WANG, Y., AND ZHANG, M. 2006. First-order loop formulas for normal logic programs. In Proceedings of the 10th International Conference on Principles of Knowledge Representation and Reasoning (KR 2006). AAAI Press, Lake District of the United Kingdom, 298–307.\nDE BRUIJN, J., PEARCE, D., POLLERES, A., AND VALVERDE, A. 2007. Quantified equilibrium logic and hybrid rules. In Web Reasoning and Rule Systems, First International Conference, RR 2007. Lecture Notes in Computer Science, vol. 4524. Springer, Innsbruck , Austria.\nEITER, T., IANNI, G., LUKASIEWICZ, T., SCHINDLAUER, R., AND TOMPITS, H. 2008. Combining answer set programming with description logics for the semantic web. Artifical Intelligence 172, 12-13, 1495–1539.\nHORROCKS, I. AND PATEL-SCHNEIDER, P. F. 2004. A proposal for an OWL rules language. In Proceedings of the 13th international conference on World Wide Web (WWW 2004). ACM, New York, NY, USA, 723–731.\nLEE, J. AND MENG, Y. 2008. On loop formulas with variables. In Proceedings of the 11th International Conference on Principles of Knowledge Representation and Reasoning (KR 2008). AAAI Press, Sydney, Australia, 444–453.\nLIN, F. AND ZHAO, Y. 2004. ASSAT: computing answer sets of a logic program by SAT solvers. Artificial Intelligence 157, 1-2, 115–137.\nLIU, G. AND YOU, J.-H. 2008. Lparse programs revisited: Semantics and representation of aggregates. In Logic Programming, 24th International Conference (ICLP 2008). Lecture Notes in Computer Science, vol. 5366. Springer, Udine, Italy, 347–361.\nMAREK, V. W. AND TRUSZCZYNSKI, M. 1999. Stable models and an alternative logic programming paradigm. In The Logic Programming Paradigm: A 25-Year Perspective, K. Apt, V. Marek, M. Truszczynski, and D. Warren, Eds. Springer-Verlag, Berlin, 375–398.\nMOTIK, B. AND ROSATI, R. 2010. Reconciling description logics and rules. Journal of the ACM 36, 165–228.\nNIEMELÄ, I. 1999. Logic programs with stable model semantics as a constraint programming paradigm. Annals of Mathematics and Artificial Intelligence 25, 3-4, 241–273.\nROSATI, R. 2005. On the decidability and complexity of integrating ontologies and rules. Journal of Web Semantics 3, 1, 61–73."
    }, {
      "heading" : "16 Y. Wang et al.",
      "text" : "ROSATI, R. 2006. DL+log: Tight integration of description logics and disjunctive datalog. In Proceedings, Tenth International Conference on Principles of Knowledge Representation and Reasoning (KR2006). AAAI Press, Lake District of the United Kingdom, 68–78.\nVAN GELDER, A., ROSS, K. A., AND SCHLIPF, J. S. 1991. The well-founded semantics for general logic programs. J. ACM 38, 3, 620–650.\nW3C OWL WORKING GROUP. 2009. OWL 2 Web Ontology Language: Document Overview. W3C Recommendation, aa. Available at http://www.w3.org/TR/owl2-overview/.\nWANG, Y., YOU, J.-H., YUAN, L.-Y., AND SHEN, Y.-D. 2010. Loop formulas for description logic programs. Theory and Practice of Logic Programming, 26th Int’l. Conference on Logic Programming (ICLP’10) Special Issue 10, 4-6, 531–545."
    }, {
      "heading" : "Appendix: Proofs",
      "text" : "We first recall the operator γK : HBP → HBP for a positive dl-program K = (O ,P) (Eiter et al. 2008): let I ⊆ HBP ,\nγK(I ) = {h|(h ← Pos) ∈ P and I |=O A for any A ∈ Pos} (6)\nSince γK is monotonic, so it has the least fix-point which is the unique least model of K. Such least fix-point can be iteratively constructed as:\n• γ0K = ∅; • γn+1K = γK(γnK).\nIt is clear that the least fix-point lfp(γK) = γ∞K . So I ⊆ HBP is a strong (resp., weak) answer set of a dl-program K = (O ,P) if and only if I = lfp(γKs,I ) (resp., I = lfp(γKw,I )).\nProposition 1 Let K = (O ,P) be a dl-program and I ⊆ HBP . Then I is a supported model of K if and only if I |=O COMP(K)."
    }, {
      "heading" : "Proof",
      "text" : "The interpretation I is a supported model of K iff, for any h ∈ I , there exists a rule (h ← Pos,not Neg) in P such that\nI |=O  ∧ A∈Pos A ∧ ∧ B∈Neg ¬B  iff I |=O COMP(h,K) for any h ∈ I iff I |=O COMP(K).\nProposition 2 Let K = (O ,P) be a dl-program and I ⊆ HBP a strong (or weak) answer set of K. Then I is a supported model of K.\nLoop Formulas for Description Logic Programs10 17"
    }, {
      "heading" : "Proof",
      "text" : "(1) Let I be a strong answer set of K. It is sufficient to show that, for any h ∈ I , I |=O COMP(h,K) by Proposition 1. Note that h ∈ I ⇒ there is a dl-rule (r ′ : h ← Pos1) in sP IO such that I |=O A for any A ∈ Pos1 ⇒ there is a dl-rule (r : h ← Pos1,Pos2,not Neg) in P such that r ′ is obtained from r by the strong dl-transformation, where Pos2 is a set of nonmonotonic dl-atoms, i.e., (i) I |=O B for any B ∈ Pos2, and (ii) I 6|=O B ′ for any B ′ ∈ Neg ⇒ I |=O ∧ A∈Pos1∪Pos2 A ∧ ∧ B∈Neg ¬B .\nConsequently, I is a supported model of K. (2) The proof is similar when I is a weak answer set of K.\nTheorem 1 Let K = (O ,P) be a dl-program and I ⊆ HBP . I is a weak answer set of K if and only if I |=O COMP(K) ∪ wLF(K), where wLF(K) is the set of weak loop formulas relative to K."
    }, {
      "heading" : "Proof",
      "text" : "(⇒) By Proposition 2, we only need to show that, I |=O wLF(L,K) for any weak loop L of K. Suppose I 6|=O wLF(L,K), i.e.,\nI |=O ∨ L and I 6|=O  ∧ A∈Pos A ∧ ∧ B∈Neg ¬B  (7) for any rule (h ← Pos,not Neg) in P such that h ∈ L and Pos ∩ L = ∅. It implies that I ∩L 6= ∅. Without loss of generality, suppose L = {h1, . . . , hk} and h1 ∈ I ∩L. Because I is a weak answer set of K, I = lfp(γKw,I ). It follows that h1 ∈ lfp(γKw,I ). Let k1 be the least number such that h1 ∈ γk1+1Kw,I . Thus wP I O must have a rule\nr1 : h1 ← Pos1\nsuch that γk1Kw,I |=O A for any A ∈ Pos1. Suppose r1 is obtained from the following rule\nh1 ← Pos1,Adl1,not Neg1\nin P by the weak dl-transformation, where Adl1 is a set of dl-atoms. Thus I |=O A for any A ∈ Adl1 and I 6|=O B for any B ∈ Neg1. By (7), Pos1 ∩ L 6= ∅. Note that h1 /∈ Pos1. Thus (L\\{h1})∩Pos1 6= ∅. Without loss of generality, suppose h2 ∈ Pos1. Similarly, there exists the least number k2 such that h2 ∈ γk2+1Kw,I . Using the construction, we may have a sequence (k1, k2, . . . , ) of natural numbers and a sequence (h1, h2 . . . , ) of atoms in L ∩ I such that\n• ki is the smallest number such that hi ∈ γki+1Kw,I , • (hi ← Posi) is the rule in wP IO such that Posi ⊆ γ ki Kw,I , and • ki < kj for any 0 ≤ i < j ."
    }, {
      "heading" : "18 Y. Wang et al.",
      "text" : "Since I ∩ L is finite, there must be some i , j (0 ≤ i < j ) such that hi = hj . This implies that ki = kj . This is a paradox. Thus I |=O wLF(L,K).\n(⇐) Firstly, we show I ⊆ lfp(γKw,I ). Let Γ be the set of rules in wP IO whose bodies are satisfied by I . Since I is a supported model of K, the heads of rules in Γ are also satisfied by I . Moreover, I is the set of atoms occurring in Γ. Let I ∗ = lfp(γKw,IΓ ), where KΓ = (O ,Γ). Let I− = I \\ I ∗ and ΓI− be the set of rules in Γ whose heads are in I−. We show that (O ,ΓI−) has at least one terminating loop.\nFor any rule (r : h ← Pos) in ΓI− , Pos ⊆ I since I |= A for any A ∈ Pos and wP IO mentions only atoms. However Pos \\ I ∗ 6= ∅ otherwise I ∗ |= A for any A ∈ Pos and then r /∈ ΓI− . It implies that\nPos ∩ (I \\ I ∗) 6= ∅·\nSuppose h ′ ∈ Pos ∩ I−. Then there is an edge (h, h ′) in the weak positive dependency graph of (O ,ΓI−). So we can construct a sequence of atoms\n(h1, h2, . . . , hi , . . .)\nsuch that hi ∈ I− for any i ≥ 1 and (hi , hi+1) is an edge of the weak positive dependency graph of (O ,ΓI−). Since I− is finite, the above sequence must contain a loop. It is clear that if a graph has a loop then it has at least one terminating loop. Now suppose L = {h1, . . . , hk} is a terminating loop of ΓI− . We further claim that, for any rule (h ← Pos) in ΓI− such that h ∈ L:\nI− ∩ Pos ⊆ L·\nOtherwise, we can construct another path (h, h ′, . . .) in the positive weak dependency graph of (O ,ΓI−) such that h ′ ∈ I ∩ Pos and h ′ /∈ L. Thus we have a path from L to another maximal loop of the weak dependency graph of (O ,ΓI−), which contradicts the fact that L is a terminating loop.\nNote that L is also a weak loop of K, I |=O wLF(L,K) and L ⊆ I−. It follows that P should have at least one rule\nr ′ : h ′ ← Pos′,not Neg′\nsuch that Pos′ ∩ L = ∅, I |=O A for any A ∈ Pos′ and I 6|=O B for any B ∈ Neg′, where h ′ ∈ L. Suppose (r∗ : h ′ ← Pos∗) is the rule obtained from r ′ by the weak dltransformation. Evidently, r∗ ∈ Γ. Furthermore r∗ ∈ ΓI− since h ′ ∈ L ⊆ I−. This implies that I− ∩ Pos∗ ⊆ L which contradicts with Pos∗ ∩ L = ∅ since I− ∩ Pos∗ 6= ∅. Consequently, I− = ∅ and then I ⊆ I ∗ = lfp(γKw,IΓ ) ⊆ I . It implies that I = I\n∗ and I ⊆ lfp(γKw,I ) by Γ ⊆ wP IO .\nSecondly, we prove lfp(γKw,I ) ⊆ I . Let I ′ = lfp(γKw,I ) \\ I . Suppose I ′ 6= ∅. Let h be an arbitrary atom in I ′. There is the least number k such that h ∈ γk+1Kw,I . So that there exists a rule (r ′ : h ← Pos) in wP IO such that Pos ⊆ γkKw,I . Note that h /∈ I and I |=O COMP(h,K). It follows that, for any rule (h ← Pos,not Neg) in P ,\nI 6|=O ∧\nA∈Pos A ∧ ∧ B∈Neg ¬B ·\nIt implies that Pos 6⊆ I . Thus there exists an atom h ′ ∈ Pos such that h ∈ γkKw,I \\ I . So we\nLoop Formulas for Description Logic Programs11 19\ncan construct a sequence of numbers (k0, k1, . . .) and a sequence (h1, h2, . . .) of atoms in I ′ such that, for any i ≥ 0,\n• ki is the least number such that hi ∈ γki+1Kw,I , • hi ← Posi is the rule in wP IO such that Posi ⊆ γ ki Kw,I , and • ki > kj for any 0 ≤ i < j .\nSince I ′ is finite, there exists 0 ≤ i < j such that hi = hj which implies that ki = kj . It contradicts with kk > kj . Thus I ′ = ∅, i.e., lfp(γKw,I ) ⊆ I .\nConsequently I is a weak answer set of K.\nLemma 1 Let K = (O ,P) be a dl-program, I ⊆ HBP , I ′ is the extension of I satisfying (4) and L be an arbitrary nonempty set of atoms. Then we have, for any dl-atom A, I ′ |=O IF(A,L) iff I \\ L |=O A."
    }, {
      "heading" : "Proof",
      "text" : "Since I ′ is the extension of I satisfying (4), we have that p(~c) ∈ I iff p(~c) ∈ I ′ for any p(~c) ∈ HBP . Furthermore, for any atom pL(~c), pL(~c) ∈ I ′ iff p(~c) ∈ I \\ L. Without loss of generality, let A = DL[S ⊕ p,S ′ q ;Q ](~t). It obviously holds that if the predicates p and q do not occur in L since IF(A,L) = A. Let’s assume that the predicates p and q appear in L. I ′ |=O IF(A,L) ⇔ I ′ |=O DL[S ⊕ pL,S ′ qL;Q ](~t) ⇔ O ∪ {S (~e)|pL(~e) ∈ I ′} ∪ {¬S ′(~e)|qL(~e) /∈ I ′} |= Q(~t) ⇔ O ∪ {S (~e)|p(~e) ∈ I \\ L} ∪ {¬S ′(~e)|q(~e) /∈ I \\ L} |= Q(~t) ⇔ I \\ L |=O DL[S ⊕ p,S ′ q ;Q ](~t) ⇔ I \\ L |=O A.\nThe other two cases, namely (i) p appears in L but not q , and (ii) q appears in L but not p, can be similarly proved.\nLemma 2 Let K = (O ,P) be a dl-program and I ⊆ HBP such that I |=O COMP(K). Then we have that lfp(γKs,I ) ⊆ I ."
    }, {
      "heading" : "Proof",
      "text" : "Let I ′ = lfp(γKs,I ) and I− = I ′ \\ I . If I ′ 6⊆ I then I− 6= ∅. Suppose I ′ 6⊆ I . For any h ∈ I−, there exists the least natural number k and a rule (r : h ← Pos) in sP IO such that γkKs,I |=O A for any A ∈ Pos. But we know that h /∈ I and I |=O COMP(h,K) which implies that, for any rule (r ′ : h ← Pos′,not Neg′) in P :\nI 6|=O ∧\nA∈Pos′ A ∧ ∧ B∈Neg′ ¬B ·\nIt follows that I 6|=O A for some A ∈ Pos. It implies that either\n(i) there is some atom h ′ ∈ Pos ∩ γkKs,I such that h ′ /∈ I , or"
    }, {
      "heading" : "20 Y. Wang et al.",
      "text" : "(ii) there is a monotonic dl-atom A = DL[λ;Q ](~t) in Pos such that, for some S ⊕p (or S p) occurring in λ, there is an atom h ′ = p(~c) such that h ′ ∈ γkKs,I and p(~c) /∈ I .\nIt is evident that h ′ 6= h and h ′ ∈ I−. Thus we have a sequence (k0, k1, . . .) of natural numbers and a sequence (h1, h2, . . .) of atoms in I− such that: for any i ≥ 0,\n• ki is the least number such that hi ∈ γki+1Ks,I , • (hi ← Posi) is in sP IO such that γ ki Ks,I |=O A for any A ∈ Posi , and • ki > kj for any 0 ≤ i < j .\nSince I− is finite, in the above sequence of atoms there must be i , j (0 ≤ i < j ) such that hi = hj . It implies that ki = kj which contradicts with ki > kj . Consequently, I− = ∅, i.e., I ′ ⊆ I .\nTheorem 2 Let K = (O ,P) be a dl-program and I ⊆ HBP . I is a strong answer set of K if and only if I ′ |=O COMP(K) ∪ sLF(K), where sLF(K) is the set of strong loop formulas of all strong loops of K and I ′ is the extension of I satisfying (4)."
    }, {
      "heading" : "Proof",
      "text" : "It is clear that I ′ ∩ HBP = I since I ′ is the extension of I satisfying (4).\n(⇒) Evidently, I ′ |=O COMP(K). By Proposition 2, it is sufficient to prove that, for any strong loop L of K, I ′ |=O sLF(L,K). Suppose L = {h1, . . . , hk} is a strong loop of K and I ′ 6|=O sLF(L,K), i.e.,\nI ′ |=O ∨ L and I ′ 6|=O ∨\n1≤i≤n  ∧ A∈Posi γ(A,L) ∧ ∧ B∈Neg i ¬B  where (h1 ← Pos1,not Neg1), . . . , (hn ← Posn ,not Negn) are all the rules in P such that hi ∈ L and Posi ∩ L = ∅ for any i (1 ≤ i ≤ n). It follows that, for any i (1 ≤ i ≤ n),\nI ′ 6|=O ∧\nA∈Posi γ(A,L) ∧ ∧ B∈Neg\ni\n¬B · (8)\nSince I ′ |=O ∨ L, we have that I ′ ∩L 6= ∅ and then I ∩L 6= ∅. Without loss of generality, let’s assume h1 ∈ I ∩ L. Note that I is a strong answer set of K, i.e., I = lfp(γKs,I ). Thus there is the least number k1 such that h1 ∈ γk1+1Ks,I . So there is a rule (r1 : h1 ← Pos1) in sP IO such that γ k1 Ks,I |=O A for any A ∈ Pos1. It is evident that h1 /∈ Pos1. It implies that P has a rule\nr ′1 : h1 ← Pos1,Ndl1,not Neg1, where Ndl is a set of nonmonotonic dl-atoms, such that r1 is obtained from r ′1 by the strong dl-transformation, i.e., I |=O A for any A ∈ Ndl1 and I 6|=O B for any B ∈ Neg1. Note that I ′ ∩ HBP = I . It is clear that, I ′ |=O A for each A ∈ Ndl1 and I ′ 6|=O B for any B ∈ Neg1. By (8), at least one of the following two cases holds:\n• Pos1 ∩ L 6= ∅. In this case, there is some atom h ∈ Pos1 ∩ L and h 6= h1.\nLoop Formulas for Description Logic Programs12 21\n• I ′ 6|=O IF(A,L) for some monotonic dl-atom A = DL[λ;Q ](~t) in Pos1. By Lemma 1, we have I \\ L 6|=O A. Since A is monotonic, then we further have γk1Ks,I \\ L 6|=O A. But we know that γk1Ks,I |=O A. It follows that, there exists some atom p(~c) ∈ L∩γ k1 Ks,I , p(~c) 6= h1\nand S ⊕ p (or S p) appears in L for some S .\nBy the above analysis, we can have a sequence of natural numbers (k1, k2, . . . , ) and a sequence (h1, h2, . . .) of atoms in L such that, for any i ≥ 1,\n• ki is the least natural number such that hi ∈ γki+1Ks,I , • (hi ← Posi) is the rule in sP IO such that γ ki+1 Ks,I |=O A for any A ∈ Posi , and • ki > kj for any 1 ≤ i < j .\nSince L is finite, there must be some i , j (1 ≤ i < j ) such that hi = hj , which implies that ki = kj . This is a paradox. Consequently, I ′ |=O sLF(L,K).\n(⇐) Let I = I ′∩HBP . By Proposition 1, I is a supported model ofK. Let Γ be the set of rules in sP IO whose bodies are satisfied by I relative to O . Clearly, for any rule (h ← Pos) in Γ, h ∈ I . And inversely, for any h ∈ I , there exists at least one rule (h ← Pos) in Γ. Let I ∗ = lfp(γKs,IΓ ) where KΓ = (O ,Γ). Evidently, I\n∗ ⊆ I . Let I− = I \\ I ∗. Suppose I− 6= ∅. Let ΓI− be the set of rules in Γ whose heads belong to I−. We claim that the dl-program (O ,ΓI−) must have one terminating loop.\nFirstly, let h ∈ I− and suppose (h ← Pos) be a rule in ΓI− . We have that I ∗ 6|=O ∧\nA∈Pos A and I ∗ ∪ I− |=O ∧ A∈Pos A·\nIt follows that there is an atom or dl-atom A in Pos such that I ∗ 6|=O A. That implies that at least one of the following cases hold:\n• there is some atom h ′ ∈ Pos, h ′ ∈ I−; • there exists a monotonic dl-atom A = DL[λ;Q ](~t) in Pos such that I ∗ 6|=O A, which\nimplies that there exists some S ⊕ p (or S p) appearing in λ and p(~c) ∈ I \\ I ∗ for some atom p(~c) since I |=O A, otherwise I ∗ |=O A.\nIt follows that, there exists an edge (h, h ′) in the positive strong dependency graph G of the dl-program (O ,ΓI−) where h ′ ∈ I−. Consequently, we can construct a sequence\n(h0, h1, . . . , hi , . . .)\nof atoms in I− such that, for any i ≥ 0, (hi , hi+1) is an edge of G . Since I− is finite, the constructed sequence must contain a loop. Furthermore, G has at least one terminating loop. Let L be a terminating loop of (O ,ΓI−), h ∈ L and\nr : h ← Pos\nbe an arbitrary rule in ΓI− . It is obvious that L ⊆ I−. Because L is a terminating loop of (O ,ΓI−), it follows that the following cases hold:\n• I− ∩ Pos ⊆ L, and • for any monotonic dl-atom DL[λ;Q ](~t) in Pos, if S ⊕ p (or S p) appear in λ for some S then we have p(~c) ∈ I− implies p(~c) ∈ L."
    }, {
      "heading" : "22 Y. Wang et al.",
      "text" : "Note that L is also a loop of K. Due to I ′ |=O sLF(L,K), L ⊆ I−, and I− ⊆ I ′, we have I ′ |=O ∨ L. Thus, P has at least one rule\nr ′ : h ′ ← Pos′,not Neg′\nsuch that h ′ ∈ L, Pos′ ∩ L = ∅ and\nI ′ |=O  ∧ A∈Pos′ γ(A,L) ∧ ∧ B∈Neg′ ¬B  · It implies that I |=O A for any nonmonotonic dl-atom A ∈ Pos′ and I 6|=O B for any B ∈ Neg′. Let (r ′′ : h ′ ← Pos′′) be the rule in sP IO that is obtained from r ′ by the strong dl-transformation. Clearly, r ′′ ∈ Γ by Lemma 1. Furthermore, due to h ′ ∈ L ⊆ I−, so we have\nr ′′ ∈ ΓI− ·\nNote that Pos′′ ∩ I− ⊆ L implies Pos′ ∩ I− ⊆ L. It follows that Pos′ ∩ I− = ∅ by Pos′ ∩ L = ∅. So we have Pos′ ∩ HBP ⊆ I ∗ since I |= A for any A ∈ Pos′ ∩ HBP . It implies that Pos′′∩HBP ⊆ I ∗. Since r ′′ ∈ ΓI− , Pos′′ must have a monotonic dl-atom A = DL[λ;Q ](~t) such that I ∗ 6|=O A, i.e., I \\ I− 6|=O A. By Lemma 1, we have I \\ L |=O A since I ′ |=O γ(A,L). Thus there must exist some atom p(~c) ∈ (I \\L)\\(I \\I−)(= I−\\L) and S ⊕ p (or S p) appears in λ since A is monotonic. However, we know that, for any such above atom p(~c), p(~c) ∈ I− implies p(~c) ∈ L. It follows that I \\ L 6|=O A by I \\ I− 6|=O A. It is a paradox.\nConsequently, I \\ I− = ∅. It implies that I ⊆ I ∗ = lfp(γKs,IΓ ). Note that Γ ⊆ sP I O . We have that lfp(γKs,IΓ ) ⊆ lfp(γKs,I ). It follows that I ⊆ lfp(γKs,I ). By Lemma 2, lfp(γKs,I ) ⊆ I since I |=O COMP(K). Consequently, I = lfp(γKs,I ). Thus I is a strong answer set of K.\nProposition 3 Let K = (O ,P) be a dl-program, I an interpretation of P and L a weak loop of K. Then we have I ′ |=O sLF(L,K) ⊃ wLF(L,K), where I ′ is the extension of I according to (4)."
    }, {
      "heading" : "Proof",
      "text" : "Suppose I ′ |=O sLF(L,K) and I ′ 6|=O wLF(L,K). We have that I ′ ∩ L 6= ∅ and, for any dl-rule (h ← Pos,not Neg) in P such that h ∈ L and Pos ∩ L = ∅,\nI ′ 6|=O ∧\nA∈Pos A ∧ ∧ B∈Neg ¬B ·\nNote that L is also a strong loop of K and I ′ |=O sLF(L,K). It implies that there exists at least one rule (h ′ ← Pos′,not Neg′) in P such that h ′ ∈ L, Pos′ ∩ L = ∅ and\nI ′ |=O ∧\nA′∈Pos′ γ(A′,L) ∧ ∧ B ′∈Neg′ ¬B ′·\nIt is clear that, for any formula ψ of LK, I ′ |=O ψ implies that I |=O ψ since ψ mentions\nLoop Formulas for Description Logic Programs13 23\nAlgorithm 1 Psup(A, I1, I2) I ∗ ← I2 M ← I2 \\ I1 for all h ∈ M ∩ I ∗ do h∗ ← h if I ∗ \\ {h∗} |=O A then\nI ∗ ← I ∗ \\ {h∗} continue\nend if break\nend for return (I ∗, h∗)\nonly the predicates occurring in K. Notice further that if A′ is a monotonic dl-atom then I |=O A by Lemma 1. It follows that\nI |=O ∧\nA′∈Pos′ A′ ∧ ∧ B ′∈Neg′ ¬B ′\nwhich contradicts with I 6|=O wLF(L,K).\nLemma 3 Let K = (O ,P) be a dl-program, A be a dl-atom appearing in P , I1 ⊂ I2 ⊆ HBP .\n(1) If I1 6|=O A and I2 |=O A then there exists an interpretation I ∗ and an atom h∗ ∈ I2 \\ I1 such that I1 ⊂ I ∗ ⊆ I2, I ∗ |=O A and I ∗ \\ {h∗} 6|=O A. (2) If A is nonmonotonic, I1 |=O A and I2 6|=O A then there exists an interpretation I ∗ and an atom h∗ ∈ I2 \\ I1 such that I1 ⊆ I ∗ ⊂ I2, I ∗ ∪ {h∗} 6|=O A and I ∗ |=O A."
    }, {
      "heading" : "Proof",
      "text" : "(1) It is clear that I2 \\ I1 6= ∅ by the assumption. We construct an interpretation I ∗ by Algorithm 1.\nSince both I2 and M are finite, the algorithm definitely terminates. Note that M is a nonempty subset of I2, the forall loop will run at least once. Suppose Psup(A, I1, I2) is terminated. There are only two cases leading to its termination:\n• There is no h ∈ M ∩ I ∗ (line 3). It implies that I ∗ = I1 and I ∗ |=O A. The latter contradicts with I1 6|=O A. Thus this case is impossible. • The “break” is executed (line 9). It implies that I ∗ ⊆ I2 and I ∗ \\ {h∗} 6|=O A.\nThus the above algorithm returns (I ∗, h∗) satisfying the condition I ∗ |=O A and I ∗ \\ {h∗} 6|=O A.\n(2) We have Algorithm 2 for this purpose. Similarly, since both M and I2 are finite then the algorithm Nsup definitely terminates and the forall loop will be executed at least once. Suppose Nsup(A, I1, I2) is executed and terminated. If Nsup terminates because of M \\ I ∗ = ∅ in the forall loop, in this case, we have I ∗ = I2 and I ∗ |=O A. The latter contradicts with I2 6|=O A. Thus the only case leading to the termination of Nsup is the"
    }, {
      "heading" : "24 Y. Wang et al.",
      "text" : "Algorithm 2 Nsup(A, I1, I2) I ∗ ← I1 M ← I2 \\ I1 for all h ∈ M \\ I ∗ do\nif I ∗ ∪ {h} |=O A then I ∗ ← I ∗ ∪ {h} continue end if h∗ ← h I ∗ ← I ∗ ∪ {h∗} break\nend for return (I ∗, h∗)\n“break” (line 10). In that case, we have that I ∗ ∪ {h∗} 6|=O A and I ∗ |=O A. It is obvious I1 ⊆ I ∗.\nLemma 4 Let K = (O ,P) be a dl-program, I ⊆ HBP , L a set of atoms and A = DL[λ;Q ](~t) a nonmonotonic dl-atom appearing in P .\n(1) If I ′ |=O pCF(A,L) then I \\ L |=O A, (2) If I ′ 6|=O nCF(A,L) then I \\ L 6|=O A,\nwhere I ′ is the extension of I according to (4)."
    }, {
      "heading" : "Proof",
      "text" : "Without loss of generality, let λ = (S1 ⊕ p1,S2 p2) for clarity.\n(1) Suppose p1 6= p2. There is no atom p2(~c) which is a positive nonmonotonic dependency of A. If there is no atom p1(~c) ∈ L such that p1(~c) is a positive nonmonotonic dependency of A then pCF(A,L) = A. It follows that I |=O A since I ′ |=O A and I ′ is the extension of I . Suppose I \\L 6|=O A. From (1) of Lemma 3, there is an atom h ∈ I \\(I \\L), i.e., h ∈ L, and an interpretation I ∗ such that I ∗ 6|=O A and I ∗ ∪ {h} |=O A. It is evident that h must mention the predicate p1. It implies that h is a positive nonmonotonic dependency of A which contradicts with the assumption. Thus I \\ L |=O A.\nSuppose there is some atom p1(~c) ∈ L such that p1(~c) is a positive nonmonotonic dependency of A. Note that p1L(~c) ∈ I ′ iff p1(~c) ∈ I \\ L according to (4). I ′ |=O pCF(A,L) ⇒ O ∪ {S1(~e)|p1L(~c) ∈ I ′} ∪ {¬S2(~e)|p2(~e) /∈ I ′} |= Q(~t) ⇒ O ∪ {S1(~e)|p1(~c) ∈ I \\ L} ∪ {¬S2(~e)|p2(~e) /∈ I } |= Q(~t) ⇒ O ∪ {S1(~e)|p1(~c) ∈ I \\ L} ∪ {¬S2(~e)|p2(~e) /∈ I \\ L} |= Q(~t) ⇒ I \\ L |=O DL[S1 ⊕ p1,S2 p2;Q ](~t) ⇒ I \\ L |=O A.\nIt is similar to show that I \\ L |=O A for the case p1 = p2. (2) Suppose p1 6= p2. There is no atom p1(~c) which is a negative nonmonotonic dependency of A. If there is no atom p2(~c) ∈ L such that p2(~c) is a negative nonmonotonic\nLoop Formulas for Description Logic Programs14 25\ndependency of A then nCF(A,L) = A. It implies that I 6|=O A since I ′ 6|=O A and I ′ is the extension of I . Suppose I \\L |=O A. By (2) of Lemma 3, there is some atom h ∈ I \\(I \\L), i.e., h ∈ L, and an interpretation I ∗ such that I ∗ |=O A and I ∗∪{h} 6|=O A. It is clear that h must mention the predicate p2. It implies that h is a negative nonmonotonic dependency of A which contradicts with the assumption. Thus I \\ L 6|=O A.\nSuppose there is some atom p2(~c) ∈ L such that p2(~c) is a negative nonmonotonic dependency of A. Note that p2L(~c) ∈ I ′ iff p2(~c) ∈ I \\ L according to (4). I ′ 6|= nCF(A,L) ⇒ O ∪ {S1(~e)|p1(~e) ∈ I ′} ∪ {¬S2(~e)|p2L(~e) 6∈ I ′} 6|= Q(~t) ⇒ O ∪ {S1(~e)|p1(~e) ∈ I } ∪ {¬S2(~e)|p2(~e) 6∈ I \\ L} 6|= Q(~t) ⇒ O ∪ {S1(~e)|p1(~e) ∈ I \\ L} ∪ {¬S2(~e)|p2(~e) 6∈ I \\ L} 6|= Q(~t) ⇒ I \\ L 6|=O DL[S1 ⊕ p1,S2 p2;Q ](~t) ⇒ I \\ L 6|=O A.\nIt is similar to show that I \\ L 6|=O A for the case p1 = p2.\nPlease note that the inverses of (1) and (2) do not generally hold. For example, let A = DL[S1⊕p1,S2 p2;S1u¬S2](a), I1 = {p1(a), p2(a)}, I2 = {p1(a)}, L1 = {p2(a)} and L2 = {p1(a)}. Because there is no interpretation I such that I 6|=O A and I ∪ L1 |=O A, it implies pCF(A,L1) = A. Similarly, we have nCF(A,L2) = A. Note that I1 \\L1 |=O A. However I ′1 6|=O pCF(A,L1) since I1 6|=O A. Similarly, we have that I2 \\ L2 6|=O A and I ′2 |=O nCF(A,L2) since I2 6|=O A.\nProposition 4 Let P be a normal logic program, L ⊆ HBP and M a model of the completion of P .\n(1) L is a loop of P if and only if L is a canonical loop of K = (∅,P). (2) M |= LF (L,P) if and only if M |=O cLF(L, I ,K) where LF (L,P) is the loop\nformula associated with L under P (Lin and Zhao 2004)) and O = ∅."
    }, {
      "heading" : "Proof",
      "text" : "(1) It is obvious since for any atom h there always has an interpretation I = {h} such that I |=O h and I \\ {h} 6|=O h .\n(2) M |=O cLF(L, I ,K) if and only if there is a rule (r : h ← Pos,not Neg) in P such that h ∈ L, Pos ∩ L = ∅, M |=O ∧ A∈Pos A ∧ ∧ B∈Neg ¬B and\nM |=O ∧\nA∈Pos δ1(A,L) ∧ ∧ B∈Neg ¬δ2(B ,L) · (9)\nSince r mentions no dl-atoms at all. It implies that δ1(A,L) = A and δ2(B ,L) = B . Thus equation (9) holds iff M |= ∧ A∈Pos A ∧ ∧ B∈Neg ¬B . Consequently, M |=O cLF(L, I ,K) iff M |= LF (L,P).\nProposition 5 Let K = (O ,P) be a dl-program and I a canonical answer set of K. Then I is minimal in the sense that K has no canonical answer set I ′ such that I ′ ⊂ I ."
    }, {
      "heading" : "26 Y. Wang et al.",
      "text" : ""
    }, {
      "heading" : "Proof",
      "text" : "Suppose there is a canonical answer set I1 of K such that I1 ⊂ I . Let M = I \\ I1. Please note that I |=O COMP(K) and I1 |=O COMP(K). For any atom h ∈ M , there is no rule (h ← Pos,not Neg) in P such that\nI1 |=O ∧\nA∈Pos A ∧ ∧ B∈Neg ¬B · (10)\nNote that there is at least one rule (h ← Pos′,not Neg′) in P such that\nI |=O ∧\nA∈Pos A ∧ ∧ B∈Neg ¬B ·\nIt implies that at least one of the following conditions hold:\n• There is an atom h ′ ∈ Pos′ such that h ′ ∈ M . • There is a dl-atom A ∈ Pos′ such that I1 6|=O A. But note that I |=O A. It implies that\nthere is some atom h ′ ∈ I \\ I1, i.e., h ′ ∈ M , and an interpretation I ∗ such that I ∗ 6|=O A and I ∗ ∪ {h ′} |=O A by (1) of Lemma 3. • There is a nonmonotonic dl-atom B ∈ Neg′ such that I1 |=O B . But note that I 6|=O B . It implies that there is some atom h ′ ∈ I \\ I1, i.e., h ′ ∈ M , and an interpretation I ∗ such that I ∗ |=O B and I ∗ ∪ {h ′} 6|=O B by (2) of Lemma 3.\nIt follows that (h, h ′) is an edge of GcK. Due to that h is an arbitrary atom in M and M is finite, there must exists a canonical loop L ofK such that L ⊆ M . We can further assume L is such a terminating one, i.e., (a) L is a maximal subset of M and (b) L is a canonical loop of K and (c) GcK has no path from one atom of L to an atom of another maximal canonical loop L′ of K with L′ ⊆ M . Note that I ′ |=O cLF(L, I ,K) where I ′ is the extension of I according to (4). It follows that there is at least one rule (h ← Pos′′,not Neg′′) in P such that h ∈ L, Pos′′ ∩ L = ∅,\nI |=O ∧\nA∈Pos′′ A ∧ ∧ B∈Neg′′ ¬B and I ′ |=O ∧ A∈Pos′′ δ1(A,L) ∧ ∧ B∈Neg′′ ¬δ2(B ,L)·\nBy Lemma 1 and 4, it implies that I \\ L |=O ∧\nA∈Pos′′ A ∧ ∧ B∈Neg′′ ¬B · (11)\nIf L ⊂ M then I1 ⊂ I \\ L. In terms of the previous analysis, there is some atom h ′′ ∈ (I \\ L) \\ I1, i.e., h ′′ ∈ M \\ L, such that (h, h ′′) is an edge of GcK. Thus GcK must have a path from h to another canonical loop L′′ of K, where L′′ ⊆ M , which contradicts with L is a terminating canonical loop. So we have L = M . According to equation (11), we have I1 |=O ∧ A∈Pos′′ A ∧ ∧ B∈Neg′′ ¬B which contradicts with the condition (10). Consequently, I1 cannot be a canonical answer set of K. Then we complete the proof.\nProposition 6 Let K = (O ,P) be a dl-program and I ⊆ HBP a canonical answer set of K. Then I is noncircular.\nLoop Formulas for Description Logic Programs15 27"
    }, {
      "heading" : "Proof",
      "text" : "Suppose I is circular, i.e., there exists M ⊆ I such that, for any (h ← Pos,not Neg) in P with h ∈ M and I |=O ∧ A∈Pos A ∧ ∧ B∈Neg ¬B , the following condition holds:\nI \\M 6|=O ∧\nA∈Pos A ∧ ∧ B∈Neg ¬B · (12)\nWithout loss of generality, we assume M is such a minimal one. It implies that at least one of the following cases hold:\n• Pos ∩M 6= ∅ which implies that there is some atom h ′ ∈ Pos ∩M . • There is a dl-atom A ∈ Pos such that I \\M 6|=O A. Knowing that I |=O A, it follows that\nthere is an interpretation I ∗ ⊆ I and an atom h ′ ∈ I \\ (I \\M ), i.e., h ′ ∈ M such that I ∗ |=O A and I ∗ \\ {h ′} 6|=O A by (1) of Lemma 3. So that h ′ is a positive nonmonotonic dependency of A. • There is a nonmonotonic dl-atom B ∈ Neg such that I \\M |=O B . Knowing that I 6|=O B , it follows that there is an interpretation I ∗ and an atom h ′ ∈ I \\ (I \\ M ), i.e., h ′ ∈ M such that I ∗ |=O B and I ∗ ∪ {h ′} 6|=O B by (2) of Lemma 3. So that h ′ is a negative nonmonotonic dependency of A.\nThus we have that (h, h ′) is an edge of the canonical dependency graph of K. Because the atom is an arbitrary one in M and M is finite,. there is a terminating canonical loop in the generated subgraph of GcK on M , i.e., the graph G\n′ = (V ,E ) where V = M and (u, v) ∈ E if (u, v) is an edge of GcK. Let L ⊆ M be such a terminating canonical loop.\nNote that I ′ |=O cLF(L, I ,K) and L ⊆ I . It implies that there is at least one rule (h ← Pos′,not Neg′) in P such that h ∈ L, L ∩ Pos′ = ∅,\nI |=O ∧\nA∈Pos′ A ∧ ∧ B∈Neg′ ¬B and I ′ |=O ∧ A∈Pos′ δ1(A,L) ∧ ∧ B∈Neg′ ¬δ2(B ,L)·\nIt implies that, by Lemma 1 and Lemma 4, I \\ L |=O ∧\nA∈Pos′ A ∧ ∧ B∈Neg′ ¬B ·\nThus I \\M ⊂ I \\ L by equation (12). However, using the above analysis, we have that G ′ has a path from one atom in L to another loop of G ′. It contradicts with the fact that L is a terminating canonical loop of G ′. Thus I must be noncircular.\nProposition 7 Let K = (O ,P) be a dl-program and I ⊆ HBP a canonical answer set of K. Then I is a strong answer set of K."
    }, {
      "heading" : "Proof",
      "text" : "Suppose I is not a strong answer set of K. Since I |= COMP(K), there must exist some strong loop L of K such that I ′ 6|=O sLF(L,K), where I ′ is the extension of I according to (4). It implies that, I ′ |=O ∨ L and\nI ′ 6|=O ∧\nA∈Pos γ(A,L) ∧ ∧ B∈Neg ¬B (13)"
    }, {
      "heading" : "28 Y. Wang et al.",
      "text" : "for any rule (h ← Pos,not Neg) in P with Pos ∩ L = ∅. Without loss of generality, we assume L is a minimal one such that I ′ 6|=O sLF(L,K).\nLet M = L ∩ I . It is evident that M 6= ∅ and I \\M = I \\ L. Let h ′ be an atom in M . Because h ′ ∈ I , there exists at least one rule (h ′ ← Pos′,not Neg′) in P such that\nI |=O ∧\nA∈Pos′ A ∧ ∧ B∈Neg′ ¬B ·\nIt implies that at least one of the following conditions holds:\n• Pos′ ∩ L 6= ∅. It shows that there is some atom h ′′ ∈ Pos′ ∩M . • There is a monotonic dl-atom A ∈ Pos′ such that I ′ 6|=O IF(A,L). It shows that I \\L 6|=O A by Lemma 1, i.e., I \\M 6|=O A. Note that I |=O A. There must have some interpretation I ∗ and an atom h ′′ ∈ I \\ (I \\M ), i.e., h ′′ ∈ M such that I ∗ |=O A and I ∗ \\ {h ′′} 6|=O A by (1) of Lemma 3.\nSo that (h ′, h ′′) is an edge of the canonical dependency graph ofK. Due to the arbitrariness of h ′ and that M is finite, the generated subgraph G ′ of GcK on M must have a terminating canonical loop M ′. It is clear that M ′ ⊆ M . Note that M ′ ⊆ I and I ′ |=O cLF(M ′, I ,K). It implies that there is at least one rule (h ′′ ← Pos′′,not Neg′′) in P such that h ′′ ∈ M ′, Pos′′ ∩M ′ = ∅,\nI |=O ∧\nA∈Pos′′ A ∧ ∧ B∈Neg′′ ¬B and I ′ |=O ∧ A∈Pos′′ δ1(A,M ′) ∧ ∧ B∈Neg′′ ¬δ2(B ,M ′)·\nIt follows that, by Lemmas 1 and 4,\nI \\M ′ |=O ∧\nA∈Pos′′ A ∧ ∧ B∈Neg′′ ¬B ·\nHowever, by equation (13) at least one of the following conditions hold:\n• Pos′′ ∩L∩ I 6= ∅, i.e., Pos′′ ∩M 6= ∅. It implies that there is an atom h∗ ∈ Pos′′ ∩M such that h∗ ∈ M \\M ′. • There is a monotonic dl-atom A ∈ Pos′′ such that I \\ M 6|=O A. But we know that I \\ M ′ |=O A by Lemma 4. It shows that there is an atom h∗ ∈ M \\ M ′ such that I ∗ 6|=O A and I ∗ ∪ {h∗} |=O A for some interpretation I ∗ by Lemma 3.\nIt follows that (h ′′, h∗) is also an edge of GcK. Since M is finite, G ′ must have a path from h ′′ to another canonical loop of G ′. It contradicts with M ′ is a terminating canonical loop of G ′. Consequently, I is a strong answer set of K.\nProposition 8 Let K = (O ,P) be a dl-program in which P does not mention the operator . Then I ⊆ HBP is a canonical answer set of K if and only if I is a strong answer set of K.\nLoop Formulas for Description Logic Programs16 29"
    }, {
      "heading" : "Proof",
      "text" : "By Proposition 7, it is sufficient to show that if I is a strong answer set of K then I is a canonical answer set of K. Suppose I is a strong answer set of K but I is not a canonical answer set of K. Since I |= COMP(K), it implies that there exists at least one canonical loop L of K such that I ′ 6|=O cLF(L, I ,K), where I ′ is the extension of I according to (4).\nSince P mentions no , all dl-atoms appearing in P must be monotonic. In particular, if A is a monotonic dl-atom and there is some atom p(~c) and an interpretation I ∗ such that I ∗ 6|=O A and I ∗ ∪ {p(~c)} |=O A then A must contain S ⊕ p (or S p) for some S . It implies that L is also a strong loop of K and then I ′ |=O sLF(L,K), i.e., P has at least one rule (h ← Pos,not Neg) such that h ∈ L, Pos ∩ L = ∅ and\nI ′ |=O ∧\nA∈Pos γ(A,L) ∧ ∧ B∈Neg ¬B ·\nNote that no dl-atoms mention . By Lemma 1, it follows that I ′ |=O ∧\nA∈Pos δ1(A,L) ∧ ∧ B∈Neg ¬δ2(B ,L) and I |=O ∧ A∈Pos A ∧ ∧ B∈Neg ¬B ·\nIt contradicts with I ′ 6|=O cLF(L, I ,K). Thus I is a canonical answer set of K."
    } ],
    "references" : [ {
      "title" : "The Description Logic Handbook: Theory, Implementation, and Applications , 2nd ed",
      "author" : [ "F. BAADER", "D. CALVANESE", "D.L. MCGUINNESS", "D. NARDI", "P.F. PATEL-SCHNEIDER" ],
      "venue" : "Cambridge University Press, New York, NY.",
      "citeRegEx" : "BAADER et al\\.,? 2007",
      "shortCiteRegEx" : "BAADER et al\\.",
      "year" : 2007
    }, {
      "title" : "The semantic web",
      "author" : [ "T. BERNERS-LEE", "J. HENDLER", "O. LASSILA" ],
      "venue" : "Scientific American Magazine 284, 5, 34–43.",
      "citeRegEx" : "BERNERS.LEE et al\\.,? 2001",
      "shortCiteRegEx" : "BERNERS.LEE et al\\.",
      "year" : 2001
    }, {
      "title" : "Equilibria in heterogeneous nonmonotonic multi-context systems",
      "author" : [ "G. BREWKA", "T. EITER" ],
      "venue" : "Proceedings of the Twenty-second AAAI Conference on Artificial Intelligence (AAAI 2007). AAAI Press, Vancouver, British Columbia, Canada, 385–390.",
      "citeRegEx" : "BREWKA and EITER,? 2007",
      "shortCiteRegEx" : "BREWKA and EITER",
      "year" : 2007
    }, {
      "title" : "Embedding non-ground logic programs into autoepistemic logic for knowledge-base combination",
      "author" : [ "J. BRUIJN", "T. EITER", "A. POLLERES", "H. TOMPITS" ],
      "venue" : "Proceedings of the 20th International Joint Conference On Artificial Intelligence (IJCAI-07). Hyderabad, India, 304–309.",
      "citeRegEx" : "BRUIJN et al\\.,? 2007",
      "shortCiteRegEx" : "BRUIJN et al\\.",
      "year" : 2007
    }, {
      "title" : "Declarative and computational properties of logic programs with aggregates",
      "author" : [ "F. CALIMERI", "W. FABER", "N. LEONE", "S. PERRI" ],
      "venue" : "Proceedings of the Nineteenth International Joint Conference on Artificial Intelligence (IJCAI 2005). Professional Book Center, Edinburgh, Scotland, UK, 406–411.",
      "citeRegEx" : "CALIMERI et al\\.,? 2005",
      "shortCiteRegEx" : "CALIMERI et al\\.",
      "year" : 2005
    }, {
      "title" : "First-order loop formulas for normal logic programs",
      "author" : [ "Y. CHEN", "F. LIN", "Y. WANG", "M. ZHANG" ],
      "venue" : "Proceedings of the 10th International Conference on Principles of Knowledge Representation and Reasoning (KR 2006). AAAI Press, Lake District of the United Kingdom, 298–307.",
      "citeRegEx" : "CHEN et al\\.,? 2006",
      "shortCiteRegEx" : "CHEN et al\\.",
      "year" : 2006
    }, {
      "title" : "Quantified equilibrium logic and hybrid rules",
      "author" : [ "J. DE BRUIJN", "D. PEARCE", "A. POLLERES", "A. VALVERDE" ],
      "venue" : "Web Reasoning and Rule Systems, First International Conference, RR 2007. Lecture Notes in Computer Science, vol. 4524. Springer, Innsbruck , Austria.",
      "citeRegEx" : "BRUIJN et al\\.,? 2007",
      "shortCiteRegEx" : "BRUIJN et al\\.",
      "year" : 2007
    }, {
      "title" : "Combining answer set programming with description logics for the semantic web",
      "author" : [ "T. EITER", "G. IANNI", "T. LUKASIEWICZ", "R. SCHINDLAUER", "H. TOMPITS" ],
      "venue" : "Artifical Intelligence 172, 12-13, 1495–1539.",
      "citeRegEx" : "EITER et al\\.,? 2008",
      "shortCiteRegEx" : "EITER et al\\.",
      "year" : 2008
    }, {
      "title" : "A proposal for an OWL rules language",
      "author" : [ "I. HORROCKS", "P.F. PATEL-SCHNEIDER" ],
      "venue" : "Proceedings of the 13th international conference on World Wide Web (WWW 2004). ACM, New York, NY, USA, 723–731.",
      "citeRegEx" : "HORROCKS and PATEL.SCHNEIDER,? 2004",
      "shortCiteRegEx" : "HORROCKS and PATEL.SCHNEIDER",
      "year" : 2004
    }, {
      "title" : "On loop formulas with variables",
      "author" : [ "J. LEE", "Y. MENG" ],
      "venue" : "Proceedings of the 11th International Conference on Principles of Knowledge Representation and Reasoning (KR 2008). AAAI Press, Sydney, Australia, 444–453.",
      "citeRegEx" : "LEE and MENG,? 2008",
      "shortCiteRegEx" : "LEE and MENG",
      "year" : 2008
    }, {
      "title" : "ASSAT: computing answer sets of a logic program by SAT solvers",
      "author" : [ "F. LIN", "Y. ZHAO" ],
      "venue" : "Artificial Intelligence 157, 1-2, 115–137.",
      "citeRegEx" : "LIN and ZHAO,? 2004",
      "shortCiteRegEx" : "LIN and ZHAO",
      "year" : 2004
    }, {
      "title" : "Lparse programs revisited: Semantics and representation of aggregates",
      "author" : [ "LIU G.", "YOU", "J.-H." ],
      "venue" : "Logic Programming, 24th International Conference (ICLP 2008). Lecture Notes in Computer Science, vol. 5366. Springer, Udine, Italy, 347–361.",
      "citeRegEx" : "G. et al\\.,? 2008",
      "shortCiteRegEx" : "G. et al\\.",
      "year" : 2008
    }, {
      "title" : "Stable models and an alternative logic programming paradigm",
      "author" : [ "V.W. MAREK", "M. TRUSZCZYNSKI" ],
      "venue" : "The Logic Programming Paradigm: A 25-Year Perspective, K. Apt, V. Marek, M. Truszczynski, and D. Warren, Eds. Springer-Verlag, Berlin, 375–398.",
      "citeRegEx" : "MAREK and TRUSZCZYNSKI,? 1999",
      "shortCiteRegEx" : "MAREK and TRUSZCZYNSKI",
      "year" : 1999
    }, {
      "title" : "Reconciling description logics and rules",
      "author" : [ "B. MOTIK", "R. ROSATI" ],
      "venue" : "Journal of the ACM 36, 165–228.",
      "citeRegEx" : "MOTIK and ROSATI,? 2010",
      "shortCiteRegEx" : "MOTIK and ROSATI",
      "year" : 2010
    }, {
      "title" : "Logic programs with stable model semantics as a constraint programming paradigm",
      "author" : [ "I. NIEMELÄ" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 25, 3-4, 241–273.",
      "citeRegEx" : "NIEMELÄ,? 1999",
      "shortCiteRegEx" : "NIEMELÄ",
      "year" : 1999
    }, {
      "title" : "On the decidability and complexity of integrating ontologies and rules",
      "author" : [ "R. ROSATI" ],
      "venue" : "Journal of Web Semantics 3, 1, 61–73.",
      "citeRegEx" : "ROSATI,? 2005",
      "shortCiteRegEx" : "ROSATI",
      "year" : 2005
    }, {
      "title" : "DL+log: Tight integration of description logics and disjunctive datalog",
      "author" : [ "R. ROSATI" ],
      "venue" : "Proceedings, Tenth International Conference on Principles of Knowledge Representation and Reasoning (KR2006). AAAI Press, Lake District of the United Kingdom, 68–78.",
      "citeRegEx" : "ROSATI,? 2006",
      "shortCiteRegEx" : "ROSATI",
      "year" : 2006
    }, {
      "title" : "The well-founded semantics for general logic programs",
      "author" : [ "A. VAN GELDER", "K.A. ROSS", "J.S. SCHLIPF" ],
      "venue" : "J. ACM 38, 3, 620–650.",
      "citeRegEx" : "GELDER et al\\.,? 1991",
      "shortCiteRegEx" : "GELDER et al\\.",
      "year" : 1991
    }, {
      "title" : "Loop formulas for description logic programs",
      "author" : [ "Y. WANG", "YOU", "J.-H.", "YUAN", "L.-Y.", "SHEN", "Y.-D." ],
      "venue" : "Theory and Practice of Logic Programming, 26th Int’l. Conference on Logic Programming (ICLP’10) Special Issue 10, 4-6, 531–545.",
      "citeRegEx" : "WANG et al\\.,? 2010",
      "shortCiteRegEx" : "WANG et al\\.",
      "year" : 2010
    } ],
    "referenceMentions" : [ {
      "referenceID" : 12,
      "context" : "Logic programming under the answer set semantics (ASP) is a nonmonotonic reasoning paradigm for declarative problem solving (Marek and Truszczynski 1999; Niemelä 1999).",
      "startOffset" : 124,
      "endOffset" : 167
    }, {
      "referenceID" : 1,
      "context" : "The Semantic Web is an evolving development of the World Wide Web in which the meaning of information and services on the web are defined, so that the web content can be precisely understood and used by agents (Berners-Lee et al. 2001).",
      "startOffset" : 210,
      "endOffset" : 235
    }, {
      "referenceID" : 0,
      "context" : "Description Logics (DLs) (Baader et al. 2007) provide a formal basis for the Web Ontology Language which is the standard of the Ontology Layer (W3C OWL Working Group 2009).",
      "startOffset" : 25,
      "endOffset" : 45
    }, {
      "referenceID" : 18,
      "context" : "∗ This is the full version of (Wang et al. 2010).",
      "startOffset" : 30,
      "endOffset" : 48
    }, {
      "referenceID" : 13,
      "context" : "The integration of DLs and (nonmonotonic) rules has been extensively investigated as a crucial problem in the study of the Semantic Web, such as Semantic Web Rule Language (SWRL) (Horrocks and PatelSchneider 2004), MKNF knowledge base (Motik and Rosati 2010), and Description Logic Programs (dl-programs) (Eiter et al.",
      "startOffset" : 235,
      "endOffset" : 258
    }, {
      "referenceID" : 7,
      "context" : "The integration of DLs and (nonmonotonic) rules has been extensively investigated as a crucial problem in the study of the Semantic Web, such as Semantic Web Rule Language (SWRL) (Horrocks and PatelSchneider 2004), MKNF knowledge base (Motik and Rosati 2010), and Description Logic Programs (dl-programs) (Eiter et al. 2008).",
      "startOffset" : 305,
      "endOffset" : 324
    }, {
      "referenceID" : 10,
      "context" : "In this paper, we generalize the notions of completion and loop formulas of logic programs (Lin and Zhao 2004) to dl-programs and show that weak and strong answer sets of a dl-program can be captured precisely by the models of its completion and the corresponding loop formulas.",
      "startOffset" : 91,
      "endOffset" : 110
    }, {
      "referenceID" : 7,
      "context" : "As commented by (Eiter et al. 2008), the reason to introduce strong answer sets is because some weak answer sets seem counterintuitive due to “self-supporting” loops.",
      "startOffset" : 16,
      "endOffset" : 35
    }, {
      "referenceID" : 7,
      "context" : "In this section, we briefly review the basic notations for description logics and description logic programs (Eiter et al. 2008).",
      "startOffset" : 109,
      "endOffset" : 128
    }, {
      "referenceID" : 0,
      "context" : "Due to space limitation, we introduce the basic description logic ALC (Baader et al. 2007), instead of the description logics SHIF and SHOIN described in (Eiter et al.",
      "startOffset" : 70,
      "endOffset" : 90
    }, {
      "referenceID" : 7,
      "context" : "2007), instead of the description logics SHIF and SHOIN described in (Eiter et al. 2008).",
      "startOffset" : 69,
      "endOffset" : 88
    }, {
      "referenceID" : 7,
      "context" : "2 Different from that of (Eiter et al. 2008), we consider ground atoms instead of literals for convenience.",
      "startOffset" : 25,
      "endOffset" : 44
    }, {
      "referenceID" : 7,
      "context" : "It has been shown that if a dl-program contains no nonmonotonic dl-atoms then its strong answer sets are minimal (Eiter et al. 2008).",
      "startOffset" : 113,
      "endOffset" : 132
    }, {
      "referenceID" : 7,
      "context" : "It is known that strong answer sets are always weak answer sets, but not vice versa (Eiter et al. 2008).",
      "startOffset" : 84,
      "endOffset" : 103
    }, {
      "referenceID" : 5,
      "context" : "on C (Chen et al. 2006) of the formula:",
      "startOffset" : 5,
      "endOffset" : 23
    }, {
      "referenceID" : 7,
      "context" : "it/ianni/swlp/; also see (Eiter et al. 2008) for the details of the implementation and interesting dl-programs",
      "startOffset" : 25,
      "endOffset" : 44
    }, {
      "referenceID" : 7,
      "context" : "(Eiter et al. 2008), some weak answer sets may be considered counterintuitive because of “self-supporting” loops.",
      "startOffset" : 0,
      "endOffset" : 19
    }, {
      "referenceID" : 4,
      "context" : "1991) and logic programs with aggregates (Calimeri et al. 2005).",
      "startOffset" : 41,
      "endOffset" : 63
    }, {
      "referenceID" : 10,
      "context" : "2, and a generalization of the notion of loops for normal logic programs (Lin and Zhao 2004).",
      "startOffset" : 73,
      "endOffset" : 92
    }, {
      "referenceID" : 10,
      "context" : "The next proposition shows that the canonical loops and canonical loop formulas for dl-programs are indeed a generalization of loops and loop formulas for normal logic programs (Lin and Zhao 2004) respectively.",
      "startOffset" : 177,
      "endOffset" : 196
    }, {
      "referenceID" : 10,
      "context" : "(2) M |= LF (L,P) if and only if M |=O cLF(L,M ,P), where LF (L,P) is the loop formula associated with L under P (Lin and Zhao 2004) and O = ∅.",
      "startOffset" : 113,
      "endOffset" : 132
    }, {
      "referenceID" : 13,
      "context" : "The first is to adopt a nonmonotonic formalism that covers both ASP and first-order logic (if not for the latter, then extend it to the first-order case) (Motik and Rosati 2010; Bruijn et al. 2007), where ontologies and rules are written in the same language, resulting in a tight coupling.",
      "startOffset" : 154,
      "endOffset" : 197
    }, {
      "referenceID" : 3,
      "context" : "The first is to adopt a nonmonotonic formalism that covers both ASP and first-order logic (if not for the latter, then extend it to the first-order case) (Motik and Rosati 2010; Bruijn et al. 2007), where ontologies and rules are written in the same language, resulting in a tight coupling.",
      "startOffset" : 154,
      "endOffset" : 197
    }, {
      "referenceID" : 7,
      "context" : "The second is a loose approach: An ontology knowledge base and the rules share the same constants but not the same predicates, and the communication is via a well-defined interface, such as dl-atoms (Eiter et al. 2008).",
      "startOffset" : 199,
      "endOffset" : 218
    }, {
      "referenceID" : 15,
      "context" : "The third is to combine ontologies with hybrid rules (Rosati 2005; Rosati 2006; de Bruijn et al. 2007), where predicates in the language of ontologies are interpreted classically, whereas those in the language of rules are interpreted nonmonotonically.",
      "startOffset" : 53,
      "endOffset" : 102
    }, {
      "referenceID" : 16,
      "context" : "The third is to combine ontologies with hybrid rules (Rosati 2005; Rosati 2006; de Bruijn et al. 2007), where predicates in the language of ontologies are interpreted classically, whereas those in the language of rules are interpreted nonmonotonically.",
      "startOffset" : 53,
      "endOffset" : 102
    }, {
      "referenceID" : 2,
      "context" : "One notices that dl-programs share similar characteristics with another recent interest, multi-context systems, in which knowledge bases of arbitrary logics communicate through bridge rules (Brewka and Eiter 2007).",
      "startOffset" : 190,
      "endOffset" : 213
    }, {
      "referenceID" : 13,
      "context" : "For example, although we know how to translate a dl-program without the nonmonotonic operator to an MKNF theory while preserving the strong answer set semantics (Motik and Rosati 2010), when is involved, no such a translation is known.",
      "startOffset" : 161,
      "endOffset" : 184
    }, {
      "referenceID" : 9,
      "context" : "2007), it is not clear how one would apply the loop formulas for logic programs with arbitrary sentences (Lee and Meng 2008) to dl-programs, since, to the best of our knowledge, there is no syntactic, semantics-preserving translation from dl-programs to logic programs with arbitrary sentences or to QEL.",
      "startOffset" : 105,
      "endOffset" : 124
    } ],
    "year" : 2017,
    "abstractText" : "Description Logic Programs (dl-programs) proposed by Eiter et al. constitute an elegant yet powerful formalism for the integration of answer set programming with description logics, for the Semantic Web. In this paper, we generalize the notions of completion and loop formulas of logic programs to description logic programs and show that the answer sets of a dl-program can be precisely captured by the models of its completion and loop formulas. Furthermore, we propose a new, alternative semantics for dl-programs, called the canonical answer set semantics, which is defined by the models of completion that satisfy what are called canonical loop formulas. A desirable property of canonical answer sets is that they are free of circular justifications. Some properties of canonical answer sets are also explored.",
    "creator" : "LaTeX with hyperref package"
  }
}