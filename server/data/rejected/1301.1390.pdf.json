{
  "name" : "1301.1390.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Eliminating Unfounded Set Checking for HEX-Programs",
    "authors" : [ "Thomas Eiter", "Michael Fink", "Thomas Krennwallner", "Christoph Redl", "Peter Schüller" ],
    "emails" : [ "eiter@kr.tuwien.ac.at", "fink@kr.tuwien.ac.at", "tkren@kr.tuwien.ac.at", "redl@kr.tuwien.ac.at", "ps@kr.tuwien.ac.at" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Keywords: Answer Set Programming, Nonmonotonic Reasoning, Unfounded Sets, FLP Semantics"
    }, {
      "heading" : "1 Introduction",
      "text" : "In the last years, Answer Set Programming (ASP) has emerged as an increasingly popular approach to declarative problem solving for a range of applications [2], thanks to expressive and efficient systems like SMODELS [20], DLV [19], cmodels [17], and CLASP [15]. However, recent developments in computing, in which context awareness, distribution and heterogeneous information sources gain importance, raised the need for access to external sources in programs, be it in the context of the Web to access web services, databases, or ontological information in different formats, in the context of agents to acquire sensor input, etc.\nTo cater for this need, HEX-programs [11] extend ASP with so called external atoms, through which the user can couple any external data source with a logic program. Roughly, such atoms pass information from the program, given by predicate extensions, ? This research has been supported by the Austrian Science Fund (FWF) project P20840, P20841,\nP24090, and by the Vienna Science and Technology Fund (WWTF) project ICT08-020.\nar X\niv :1\n30 1.\n13 90\nv1 [\ncs .L\nO ]\n8 J\nan 2\n01 3\ninto an external source which returns output values of an (abstract) function that it computes. This extension has been utilized for a range of applications, including querying data and ontologies on the Web, multi-context reasoning, and reasoning about actions and planning, to mention a few (cf. [5]). Notably, recursive data exchange between the rules and the external sources is supported, which makes the formalism powerful.\nThe semantics of a HEX-program Π is defined in terms of answer sets based on the FLP reduct [14]: an interpretation A is an answer set of Π , if and only if it is a ⊆-minimal model of the FLP-reduct fΠA of Π wrt. A, which is the set of all rules whose body is satisfied by A. For ordinary logic programs, this semantics coincides with the one where the canonical GL-reduct [16] is in place of fΠA, and it is more appealing for extensions with nonmonotonic aggregates [14], and the more general external atoms in HEX-programs.\nThe evaluation of a HEX-program Π in the DLVHEX1 solver proceeds in two steps as follows. In Step 1, external atoms are viewed as ordinary atoms (replacement atoms) and their truth values are guessed by choice rules that are added. The resulting ordinary ASP program Π̂ is then evaluated by an ordinary ASP solver and each of its answer sets Â is checked against the external sources, i.e., the guess is verified. After that, the guess for the non-replacement atoms, called A, is known to be a model of Π , and thus also of the reduct fΠA. Step 2 then checks whether A is a ⊆-minimal model or, equivalently, whether A is unfounded-free [13], i.e., there exists no unfounded set (UFS) of Π wrt. A.\nUnfortunately, Step 2 is computationally expensive in general, and it is intractable even for Horn programs with nonmonotonic external atoms of polynomial complexity, as follows from results in [14]. It is thus worthwhile to be aware of cases where this test is tractable, or even better, superfluous such that Step 2 can be skipped.\nMotivated by this issue, we consider in this paper programs Π for which the result of Step 1 is a ⊆-minimal model of the reduct fΠA. We provide a sound syntactic criterion for deciding whether the minimality check is needed, and in further elaboration, we describe how a program can be decomposed into program components such that unfoundedness checks can be delegated to the components, and the necessity of Step 2 thus be assessed on a finer-grained level.\nMore in detail, our main contributions are the following: • We present a syntactic decision criterion which can be used to decide whether a program possibly has unfounded sets. If the result of this check is negative, then the computationally expensive search for unfounded sets can be skipped. The criterion is based on atom dependency and, loosely speaking states that there are no cyclic dependencies of ground atoms through external atoms. This criterion can be efficiently checked for a given ground HEX-program using standard methods, and in fact applies to a range of applications, in particular, for input-stratified programs, where external sources are accessed in a workflow to produce input for the next stage of computation. However, there are relevant applications of HEX-programs where cycles through external atoms are essential, e.g., in encodings of problems on multi-context systems [1] or abstract argumentation systems [4], for which Step 2 cannot be skipped. • In further elaboration, we consider a decomposition of a program Π into components based on the dependency graph that is induced by the program. We show that Π has\n1 http://www.kr.tuwien.ac.at/research/systems/dlvhex/\nsome unfounded set with respect to the candidate answer set A if and only if (at least) one of the components ΠC in the decomposition has some unfounded set wrt. A; note that computing the decomposition is efficiently possible, and thus does not incur a large overhead. This allows us to apply the decision criterion for the necessity of Step 2 efficiently on a more fine-grained level, and the search for unfounded sets can be guided to relevant parts of the program. In particular, for the HEX-encoding of a Dung-style argumentation semantics [4] which we consider, the decomposition approach yields a considerable gain, as shown in a preliminary experimental evaluation.\nThis paper complements recent work on unfoundedness checking for HEX-programs in [7, 8], which is part of a larger effort to provide efficient evaluation of HEX-programs, based on new algorithms cf. [6]. By their wide applicability, our results are significant especially for many potential applications in practice."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "In this section, we start with some basic definitions, and then introduce syntax and semantics of HEX-programs and the notion of unfounded sets we are going to use.\nA (signed) literal is a positive or a negative formula Ta resp. Fa, where a is a ground atom of form p(c1, . . . , c`), with predicate p and constants c1, . . . , c`, abbreviated p(c). For a literal σ=Ta or σ=Fa, let σ denote its opposite, i.e., Ta=Fa and Fa=Ta.\nAn assignment is a consistent set of literals Ta or Fa, where Ta expresses that a∈A and Fa that a /∈A.A is complete, also called an interpretation, if no assignment A′⊃A exists. We denote by AT = {a | Ta∈A} and AF = {a | Fa∈A} the set of atoms that are true, resp. false in A, and by ext(q,A) = {c | Tq(c)∈A} the extension of a predicate q. Furthermore, A|q is the set of all literals over atoms of form q(c) in A. For a list q = q1, . . . , qk of predicates we write p ∈ q iff qi = p for some 1 ≤ i ≤ k, and let A|q = ⋃ jA|qj .\nA nogood is a set {L1, . . . , Ln} of literals Li, 1 ≤ i ≤ n. An interpretation A is a solution to a nogood δ (resp. a set ∆ of nogoods), iff δ 6⊆ A (resp. δ 6⊆ A for all δ ∈ ∆).\n2.1 HEX-Programs\nHEX-programs were introduced in [11] as a generalization of (disjunctive) extended logic programs under the answer set semantics [16]; for details and background see [11]. Syntax. HEX-programs extend ordinary ASP programs by external atoms, which enable a bidirectional interaction between a program and external sources of computation. External atoms have a list of input parameters (constants or predicate names) and a list of output parameters. Informally, to evaluate an external atom, the reasoner passes the constants and extensions of the predicates in the input tuple to the external source associated with the external atom. The external source computes output tuples which are matched with the output list. More formally, a ground external atom is of the form\n&g [p](c), (1) where p = p1, . . . , pk are constant input parameters (predicate names or object constants), and c = c1, . . . , cl are constant output terms.\nGround HEX-programs are then defined similar to ground ordinary ASP programs.\nDefinition 1 (Ground HEX-programs). A ground HEX-program consists of rules a1 ∨ · · · ∨ ak ← b1, . . . , bm,not bm+1, . . . ,not bn , (2) where each ai is an (ordinary) ground atom p(c1, . . . , c`) with constants ci, 1 ≤ i ≤ `, each bj is either an ordinary ground atom or a ground external atom, and k + n > 0.2\nThe head of a rule r is H(r) = {a1, . . . , an} and the body is B(r) = {b1, . . . , bm, not bm+1, . . . ,not bn}. We call b or not b in a rule body a default literal; B+(r) = {b1, . . . , bm} is the positive body, B−(r) = {bm+1, . . . , bn} is the negative body. For a program Π , let A(Π) be the set of all ordinary atoms occurring in Π .\nWe also use non-ground programs. However, as suitable safety conditions allow for using a grounding procedure [12], we limit our investigation to ground programs. Semantics and Evaluation. Intuitively, a ground external atom &g [p](c) is true, if the external source &g yields output tuple c when evaluated with input p. Formally, the semantics of a ground external atom &g [p](c) wrt. an interpretation A is given by the value of a 1+k+l-ary Boolean oracle function f&g that is defined for all possible values of A, p and c, where k is the length of p and l is the length of c. Thus, &g [p](c) is true relative to A if and only if it holds that f&g(A,p, c) = 1. Satisfaction of ordinary rules and ASP programs [16] is then extended to HEX-rules and programs in the obvious way, and the notion of extension ext(·,A) for external predicates &g with input lists p is naturally defined by ext(&g [p],A) = {c | f&g(A,p, c) = 1}.\nDefinition 2 (FLP-Reduct [14]). For an interpretation A over a program Π , the FLPreduct fΠA of Π wrt. A is the set {r ∈ Π | A |= b, for all b ∈ B(r)} of all rules whose body is satisfied under A.\nAn assignment A1 is smaller or equal to another assignment A2 wrt. a program Π , denoted A1 ≤Π A2 iff {Ta ∈ AT1 | a ∈ A(Π)} ⊆ {Ta ∈ AT2 | a ∈ A(Π)}.\nDefinition 3 (Answer Set). An answer set of Π is a ≤Π -minimal (complete) model A of fΠA.\nSince interpretations (and thus answer sets, etc.) are complete assignments, slightly abusing notation, we adopt the usual convention to uniquely identify them with the set of all positive literals they contain.\nExample 1. Consider the program Π = {p ← &id [p]()}, where &id [p]() is true iff p is true. Then Π has the answer set A1 = ∅, which is indeed a ≤Π -minimal model of fΠA1 = ∅.\nThe answer sets of a HEX-program Π are determined by the DLVHEX solver using a transformation to ordinary ASP programs as follows. Each external atom &g [p](c) in Π is replaced by an ordinary ground external replacement atom e&g[p](c) and a rule e&g[p](c)∨ ne&g[p](c)← is added to the program. The answer sets of the resulting guessing program Π̂ are determined by an ordinary ASP solver and projected to nonreplacement atoms. However, the resulting interpretations are not necessarily models\n2 For simplicity, we do not formally introduce strong negation but view, as customary, classical literals ¬a as new atoms together with a constraint← a,¬a.\nof Π , as the value of &g [p] under f&g can be different from the one of e&g[p](c). Each answer set of Π̂ is thus merely a candidate which must be checked against the external sources. If no discrepancy is found, the model candidate is a compatible set of Π . More precisely,\nDefinition 4 (Compatible Set). A compatible set of a programΠ is an interpretation Â such that\n(i) Â is an answer set [16] of the guessing program Π̂ , and (ii) f&g(Â,p, c) = 1 iff Te&g[p](c) ∈ Â for all external atoms &g [p](c) in Π , i.e. the\nguessed values coincide with the actual output under the input from Â.\nThe compatible sets ofΠ include (moduloA(Π)) all (FLP) answer sets. For each answer set A there is a compatible set Â such that A is the restriction of Â to non-replacement atoms, but not vice versa. To filter out the compatible sets which are not answer sets, the current evaluation algorithm proceeds as follows. Each compatible set A is fed to the minimality check, which is realized as a search for unfounded sets. This is justified by the following Definitions 5 and 6 and Theorem 1 from [7]. (These results lift unfounded sets for disjunctive logic programs with arbitrary aggregates [13] to HEX-programs.)\nDefinition 5 (Unfounded Set [7]). Given a program Π and an interpretation A, let X be any set of ordinary ground atoms appearing in Π . Then, X is an unfounded set for A iff, for each rule r having some atoms from X in the head, at least one of the following conditions holds, where A . ∪ ¬.X = (A \\ {Ta | a ∈ X}) ∪ {Fa | a ∈ X}:\n(i) some literal of B(r) is false wrt. A, (ii) some literal of B(r) is false wrt. A . ∪ ¬.X , or\n(iii) some atom of H(r) \\X is true wrt. A.\nDefinition 6 (Unfounded-free Interpretations [7]). An interpretation A of a program Π is unfounded-free iff AT ∩X = ∅, for all unfounded sets X of Π wrt. A.\nTheorem 1 (Characterization of Answer Sets [7]). A model A of a program Π is an answer set iff it is unfounded-free.\nExample 2 (cont’d). Reconsider the program Π = { p← &id [p]() } from above. Then the corresponding guessing program is Π̂ = {p← e&id[p](); e&id[p] ∨ ne&id[p] ←} and has the answer sets A1 = ∅ and A2 = {Tp,Te&id[p]}. While A1 does not intersect with any unfounded sets and is thus also a ≤Π -minimal model of fΠA1 = ∅, A2 intersects with the unfounded set U = {p} and is not an answer set.\nOur HEX implementation DLVHEX realizes the search for unfounded sets as a separate search problem using an encoding as a SAT instance. That is, for a program Π and an interpretation A we construct a set of nogoods ΓAΠ such that its solutions contain representations of all unfounded sets of Π wrt. A. A (relatively simple) post-check finds the unfounded sets among the solutions of ΓAΠ ."
    }, {
      "heading" : "3 Deciding the Necessity of the UFS Check",
      "text" : "An alternative to the search for unfounded sets is an explicit construction of the reduct and a search for smaller models. However, it turned out that the minimality check based\non unfounded sets is more efficient. Nevertheless the computational costs are still high. Moreover, during evaluation of Π̂ for computing the compatible set Â, the ordinary ASP solver has already made an unfounded set check, and we can safely assume that it is founded from its perspective. Hence, all remaining unfounded sets which were not discovered by the ordinary ASP solver have to involve external sources, as their behavior is not fully captured by the ASP solver.\nIn this section we formalize these ideas and define a decision criterion which allows us to decide whether a further UFS check is necessary for a given program. We eventually define a class of programs which does not require an additional unfounded set check. Intuitively, we show that every unfounded set that is not already detected during the construction of Â contains input atoms of external atoms which are involved in cycles. If no such input atom exists in the program, then the UFS check is superfluous.\nLet us therefore start with a definition of atom dependency.\nDefinition 7 (Atom Dependency). For a ground program Π , and ground atoms p(c) and q(d), we say that\n(i) p(c) depends on q(d), denoted p(c) → q(d), iff for some rule r ∈ Π we have p(c) ∈ H(r) and q(d) ∈ B+(r);\n(ii) p(c) depends externally on q(d), denoted p(c)→e q(d), iff for some rule r ∈ Π we have p(c) ∈ H(r) and there is a &g [q1, . . . , qn](e) ∈ B+(r) ∪ B−(r) with qi = q for some 1 ≤ i ≤ n.\nIn the following, we consider dependency graphs GRΠ for a ground program Π , where the set of vertices is the set of all ground atoms, and the set of edges is given by a binary relation R over ground atoms. If R is not explicitly mentioned, then it is assumed to consist of → ∪ →e, whose elemtents are also called ordinary edges and e-edges, respectively.\nThe next definition and lemma allow to restrict our attention to the “core” of an unfounded set, i.e., its most essential part. For our purpose, we can then focus on such cores, disregarding atoms in a cut which is defined as follows.\nDefinition 8 (Cut). Let U be an unfounded set of Π wrt. A. A set of atoms C ⊆ U is called a cut, iff\n(i) b 6→e a, for all a ∈ C and b ∈ U (C has no incoming or internal e-edges), and (ii) b 6→ a and a 6→ b, for all a ∈ C and b ∈ U \\ C (there are no ordinary edges\nbetween C and U \\ C).\nExample 3. Consider the program Π given as the following set of rules r ← &id [r]() p← &id [r]() p← q q ← p\nWe have p → q, q → p, r →e r and p →e r. Program Π has the unfounded set U = {p, q, r} wrt. A = {Tp,Tq,Tr}. Observe that C = {p, q} is a cut, and therefore we have that U \\ C = {r} is an unfounded set of Π wrt. A.\nWe first prove that cuts can be removed from unfounded sets and the resulting set is still an unfounded set.\nLemma 1 (Unfounded Set Reduction Lemma). Let U be an unfounded set of Π wrt. A, and let C be a cut. Then, Y = U \\ C is an unfounded set of Π wrt. A.\nProof (Sketch). If Y = ∅, then the result holds trivially. Otherwise, let r ∈ Π with H(r) ∩ Y 6= ∅. We show that one of the conditions in Definition 5 holds. Observe that H(r) ∩ U 6= ∅ because U ⊇ Y . Since U is an unfounded set of Π wrt. A, either\n(i) A 6|= b for some b ∈ B(r); or (ii) A . ∪ ¬.U 6|= b for some b ∈ B(r); or\n(iii) A |= h for some h ∈ H(r) \\ U If (i), then the condition also holds wrt. Y .\nIf (ii), let a ∈ H(r) such that a ∈ Y , and b ∈ B(r) such that A . ∪ ¬.U 6|= b. We\nmake a case distinction: either b is an ordinary literal or an external one. If it is an ordinary default-negated atom not c, then A . ∪ ¬.U 6|= b implies Tc ∈ A and c 6∈ U , and therefore also A . ∪ ¬.Y 6|= b. So assume b is an ordinary atom. If b 6∈ U then A 6|= b and case (i) applies, so assume b ∈ U . Because a ∈ H(r) and b ∈ B(r), we have a→ b and therefore either a, b ∈ C or a, b ∈ Y (because there are no ordinary edges between C and Y ). But by assumption a ∈ Y , and therefore b ∈ Y , hence A . ∪ ¬.Y 6|= b.\nIf b is an external literal, then there is no q ∈ U with a→e q and q 6∈ Y . Otherwise, this would imply q ∈ C and C would have an incoming e-edge, which contradicts the assumption that C is a cut. Hence, for all q ∈ U with a→e q, also q ∈ Y , and therefore the truth value of b under A . ∪ ¬.U and A . ∪ ¬.Y is the same. Hence A . ∪ ¬.Y 6|= b.\nIf (iii), then also A |= h for some h ∈ H(r) \\ Y because Y ⊆ U and therefore H(r) \\ Y ⊇ H(r) \\ U . 2\nNext we prove, intuitively, that for each unfounded set U of Π , either the input to some external atom is unfounded itself, or U is already detected when Π̂ is evaluated.\nLemma 2 (EA-Input Unfoundedness). Let U be an unfounded set of Π wrt. A. If there are no x, y ∈ U such that x→e y, then U is an unfounded set of Π̂ wrt. Â.\nProof (Sketch). If U = ∅, then the result holds trivially. Otherwise, let r̂ ∈ Π̂ such that H(r̂) ∩ U 6= ∅. Let a ∈ H(r̂) ∩ U . Observe that r̂ cannot be an external atom guessing rule because U contains only ordinary atoms. We show that one of the conditions in Definition 5 holds for r̂ wrt. Â.\nBecause r̂ is no external atom guessing rule, there is a corresponding rule r ∈ Π containing external atoms in place of replacement atoms. Because U is an unfounded set of Π and H(r) = H(r̂), either:\n(i) A 6|= b for some b ∈ B(r); or (ii) A . ∪ ¬.U 6|= b for some b ∈ B(r); or\n(iii) A |= h for some h ∈ H(r) \\ U If (i), let b ∈ B(r) such that A 6|= b and b̂ the corresponding literal in B(b̂) (which is the same if b is ordinary and the corresponding replacement literal if b is external). Then also Â 6|= b̂ because Â is compatible.\nFor (ii), we make a case distinction: either b is ordinary or external. If b is ordinary, then b ∈ B(r̂) and Â . ∪ ¬.U 6|= b holds because A and Â are\nequivalent for ordinary atoms.\nIf b is an external atom or default-negated external atom, then no atom p(c) ∈ U is input to it, i.e. p is not a predicate input parameter of b; otherwise we had a →e p(c), contradicting our assumption that U has no internal e-edges. But then A . ∪ ¬.U implies A 6|= b because the truth value of b under A . ∪ ¬.U and A is the same. Therefore we can apply case (i). If (iii), then also Â |= h for some h ∈ H(r̂) \\ U because H(r) = H(r̂) contains\nonly ordinary atoms and A is equivalent to Â for ordinary atoms. 2\nExample 4. Reconsider the program Π from Example 3. Then the unfounded set U ′ = {p, q} wrt. A′ = {Tp,Tq,Fr} is already detected when Π̂ consisting of\ne&id[r]() ∨ ne&id[r]()← r ← e&id[r]() p← e&id[r]() p← q q ← p\nis evaluated by the ordinary ASP solver because p 6→e q and q 6→e p. In contrast, the unfounded set U ′′ = {p, q, r} wrt. A′′ = {Tp,Tq,Tr} is not detected by the ordinary ASP solver because p, r ∈ U ′′ and p→e r.\nThe essential property of unfounded sets of Π wrt. A that are not recognized during the evaluation of Π̂ , is the existence of cyclic dependencies including input atoms of some external atom. Towards a formal characterization of a class of programs without this property, i.e., that do not require additional UFS checks, we define cycles as follows.\nDefinition 9 (Cycle). A cycle under a binary relation ◦ is a sequence of elements C = c0, c1, . . . , cn, cn+1 with n ≥ 0, such that (ci, ci+1) ∈ ◦ for all 0 ≤ i ≤ n and c0 = cn+1. We say that a set S contains a cycle under ◦, if there is a cycle C = c0, c1, . . . , cn, cn+1 under ◦ such that ci ∈ S for all 0 ≤ i ≤ n+ 1.\nThe following proposition states, intuitively, that each unfounded set U of Π wrt. A which contains no cycle through the input atoms to some external atom has a corresponding unfounded set U ′ of Π̂ wrt. Â. That is, the unfoundedness is already detected when Π̂ is evaluated.\nLet→d =→ ∪ ← ∪ →e, where← is the inverse of→, i.e.← = {(x, y) | (y, x) ∈ →}. A cycle c0, c1, . . . , cn, cn+1 under→d is called an e-cycle, iff it contains e-edges, i.e., iff (ci, ci+1) ∈→e for some 0 ≤ i ≤ n.\nProposition 1 (Relevance of e-cycles). Let U 6= ∅ be an unfounded set of Π wrt. A that does not contain any e-cycle under→d. Then, there exists a nonempty unfounded set of Π̂ wrt. Â.\nProof (Sketch). We define the reachable set R(a) from some atom a as R(a) = {b | (a, b) ∈ {→ ∪ ←}∗},\ni.e. the set of atoms b ∈ U reachable from a using edges from → ∪ ← only but no e-edges.\nWe first assume that U contains at least one e-edge, i.e. there are x, y ∈ U such that x →e y. Now we show that there is a u ∈ U with outgoing e-edge (i.e. u →e v\nfor some v ∈ U ), but such that R(u) has no incoming e-edges (i.e. for all v ∈ R(u) and b ∈ U , b 6→e v holds). Suppose to the contrary that for all a with outgoing eedges, the reachable set R(a) has an incoming e-edge. We now construct an e-cycle under →d, which contradicts our assumption. Start with an arbitrary node with an outgoing e-edge c0 ∈ U and let p0 be the (possibly empty) path (under → ∪ ←) from c0 to the node d0 ∈ R(c0) such that d0 has an incoming e-edge, i.e. there is a c1 such that c1 →e d0; note that c1 6∈ R(c0)3. By assumption, also some node d1 in R(c1) has an incoming e-edge (from some node c2 6∈ R(c1)). Let p1 be the path from c1 to d1, etc. By iteration we can construct the concatenation of the paths p0, (d0, c1), p1, (d1, c2), p2, . . . , pi, (di, ci+1), . . ., where the pi from ci to di are the paths within reachable sets, and the (di, ci+1) are the e-edges between reachable sets. However, as U is finite some nodes on this path must be equal, i.e., a prefix of the constructed sequence represents an e-cycle (in reverse order).\nThis proves that u is a node with outgoing e-edge but such thatR(u) has no incoming e-edges. We next show that R(u) is a cut. Condition (i) is immediately satisfied by definition of u. Condition (ii) is shown as follows. Let u′ ∈ R(u) and v′ ∈ U \\R(u). We have to show that u′ 6→ v′ and v′ 6→ u′. Suppose, towards a contradiction, that u′ → v′. Because of u′ ∈ R(u), there is a path from u to u′ under → ∪ ←. But if u′ → v′, then there would also be a path from u to v′ under→ ∪ ← and v′ would be in R(u), a contradiction Analogously, v′ → u′ would also imply that there is a path from u to v′ because there is a path from u to u′, again a contradiction.\nTherefore, R(u) is a cut of U , and by Lemma 1, it follows that U \\ R(u) is an unfounded set. Observe that U \\ R(u) contains one e-edge less than U because u has an outgoing e-edge. Further observe that U \\R(u) 6= ∅ because there is a w ∈ U such that u →e w but w 6∈ R(u). By iterating this argument, the number of e-edges in the unfounded set can be reduced to zero in a nonempty core. Eventually, Lemma 2 applies, proving that the remaining set is an unfounded set of Π̂ . 2\nCorollary 1. If there is no e-cycle under →d and Π̂ has no unfounded set wrt. Â, then A is unfounded-free for Π .\nProof (Sketch). Suppose there is an unfounded set U of Π wrt. A. Then it contains no e-cycle because there is no e-cycle under →d. Then by Proposition 1 there is an unfounded set of Π̂ wrt. Â, which contradicts our assumption. 2\nThis corollary can be used as follows to increase performance of an evaluation algorithm: if there is no cycle under→d containing e-edges, then an explicit unfounded set check is not necessary because the unfounded set check made during evaluation of Π̂ suffices. Note that this test can be done efficiently (in fact in linear time, similar to deciding stratifiability of an ordinary logic program). Moreover, in practice one can abstract from→d by using analogous relations on the level of predicate symbols instead of atoms. Clearly, if there is no e-cycle in the predicate dependency graph, then there can also be no e-cycle in the atom dependency graph. Hence, the predicate dependency graph can be used to decide whether the unfounded set check can be skipped.\n3 Whenever x →e y for x, y ∈ U , then there is no path from x to y under→ ∪ ←, because otherwise we would have an e-cycle under→d.\nExample 5. All example programs considered until here require an UFS check, but the program Π = {out(X)← &diff [set1, set2](X)} ∪ F does not for any set of facts F , because there is no e-cycle under→d, where diff computes the set difference of the extensions of set1 and set2.\nAlso Π = {str(Z) ← dom(Z), str(X), str(Y ),not&concat [X,Y ](Z)} (where &concat takes two constants and computes their string concatenation) does not need such a check; there is a cycle over an external atom, but no e-cycle under→d.\nMoreover, the following proposition states that, intuitively, if Π̂ has no unfounded sets wrt. Â, then any unfounded set U of Π wrt. A must contain an atom which is involved in a cycle under→d that has an e-edge.\nDefinition 10 (Cyclic Input Atoms). For a program Π , an atom a is a cyclic input atom, iff there is an atom b such that b→e a and there is a path from a to b under→d.\nLet CA(Π) denote the set of all cyclic input atoms of program Π .\nProposition 2 (Unfoundedness of Cyclic Input Atom). Let U 6= ∅ be an unfounded set ofΠ wrt. A such that U does not contain cyclic input atoms. Then, Π̂ has a nonempty unfounded set wrt. Â.\nProof (Sketch). If U contains no cyclic input atoms, then all cycles under→d containing e-edges in the atom dependency graph of Π are broken, i.e. U does not contain an e-cycle under→d. Then by Proposition 1 there is an unfounded set of Π̂ wrt. Â. 2\nProposition 2 allows for generating the additional nogood {Fa | a ∈ CA(Π)} and adding it to ΓAΠ . Again, considering predicate symbols instead of atoms is possible to reduce the overhead introduced by the dependency graph."
    }, {
      "heading" : "4 Program Decomposition",
      "text" : "It turns out that the usefulness of the decision criterion can be increased by decomposing the program into components, such that the criterion can be applied component-wise. This allows for restricting the unfounded set check to components with e-cycles, whereas e-cycle-free components can be ignored in the check.\nLet C be a partitioning of the ordinary atoms A(Π) of Π into subset-maximal strongly connected components under→ ∪ →e. We define for each partition C ∈ C the subprogram ΠC associated with C as ΠC = {r ∈ Π | H(r) ∩ C 6= ∅}.\nWe next show that if a program has an unfounded set U wrt. A, then U ∩C is an unfounded set wrt. A for the subprogram of some strongly connected component C.\nProposition 3. Let U 6= ∅ be an unfounded set of Π wrt. A. Then, for some ΠC with C ∈ C it holds that U ∩ C is a nonempty unfounded set of ΠC wrt. A.\nProof (Sketch). Let U be a nonempty unfounded set of Π wrt. A. Because C is a decomposition ofA(Π) into strongly connected components, the component dependency graph\n〈C, {(C1, C2) | C1, C2 ∈ C,∃a1 ∈ C1, a2 ∈ C2 : (a1, a2) ∈→ ∪ →e}〉\nis acyclic. Following the hierarchical component dependency graph from the nodes without predecessor components downwards, we can find a “first” component which has a nonempty intersection with U , i.e., there exists a component C ∈ C such that C ∩ U 6= ∅ but C ′ ∩ U = ∅ for all transitive predecessor components C ′ of C.\nWe show that U ∩ C is an unfounded set of ΠC wrt. A. Let r ∈ ΠC be a rule such that H(r) ∩ (U ∩ C) 6= ∅. We have to show that one of the conditions of Definition 5 holds for r wrt. A and U ∩ C.\nBecause U is an unfounded set of Π wrt. A and H(r) ∩ (U ∩ C) 6= ∅ implies H(r) ∩ U 6= ∅, we know that one of the conditions holds for r wrt. A and U . If this is condition (i) or (iii), then it trivially holds also wrt. A and U ∩ C because these conditions depend only on the assignment A, but not on the unfounded set U .\nIf it is condition (ii), then A . ∪ ¬.U 6|= b for some (ordinary or external) body literal b ∈ B(r). We show next that the truth value of all literals in B(r) is the same under A . ∪ ¬.U and A . ∪ ¬.(U ∩ C), which proves that condition (ii) holds also wrt. A and U ∩ C. If b = not a for some atom a, then Ta ∈ A and a 6∈ U and consequently a 6∈ U ∩C, hence A . ∪ ¬.(U ∩C) 6|= b. If b is an ordinary atom, then either Fb ∈ A, which implies immediatly that A . ∪ ¬.(U ∩ C) 6|= b, or b ∈ U . But in the latter case b is either in a predecessor component C ′ of C or in C itself (since h → b for all h ∈ H(r)). But since U ∩ C ′ = ∅ for all predecessor components of C, we know b ∈ C and therefore b ∈ (U ∩ C), which implies A . ∪ ¬.(U ∩ C) 6|= b.\nIf b is a positive or default-negated external atom, then all input atoms a to b are either in a predecessor componentC ′ ofC or inC itself (since h→e a for all h ∈ H(r)). We show with a similar argument as before that the truth value of each input atom a is the same under A . ∪ ¬.U and A . ∪ ¬.(U ∩ C): if A . ∪ ¬.U |= a, then Ta ∈ A and a 6∈ U , hence a 6∈ (U ∩ C) and therefore A . ∪ ¬.(U ∩ C) |= a. If A . ∪ ¬.U 6|= a, then either Fa ∈ A, which immediately implies A . ∪ ¬.(U ∩ C) 6|= a, or a ∈ U . But in the latter case a must be in C because U ∩ C ′ = ∅ for all predecessor components C ′ of C. Therefore a ∈ (U ∩ C) and consequently A . ∪ ¬.(U ∩ C) 6|= a. Because all input atoms a have the same truth value under A . ∪ ¬.U and A . ∪ ¬.(U ∩ C), the same holds also for the positive or default-negated external atom b itself. 2\nThis proposition states that a search for unfounded sets can be done independently for the subprograms ΠC for all C ∈ C. If there exists a global unfounded set, then there exists also one in at least one of the program components. However, we know by Corollary 1 that programs Π without e-cycles cannot contain unfounded sets, which are not already detected when Π̂ is solved. If we apply this proposition to the subprograms ΠC , we can safely ignore e-cycle-free program components.\nExample 6. Reconsider the program Π from Example 3. Then C contains the components C1 = {p, q} and C2 = {r} and we have ΠC1 = {p← &id [r ](); p← q; q ← p} and ΠC2 = {r ← &id [r ]()}. By Proposition 3, each unfounded set of Π wrt. some assignment can also detected over one of the components. Consider e.g. U = {p, q, r} wrt. A = {Tp,Tq,Tr}. Then U ∩ {r} = {r} is also an unfounded set of ΠC2 wrt. A.\nBy separate application of Corollary 1 to the components, we can conclude that there can be no unfounded sets over ΠC1 that are not already detected when Π̂ is evaluated (because it has no e-cycles). Hence, the additional unfounded set check is only necessary"
    }, {
      "heading" : "10 2 126.54 0 80.00 36.78% 40 278.98 16 214.81 23.00%",
      "text" : "for ΠC2 . Indeed, the only unfounded set which is not detected when Π̂ is evaluated is {r} of ΠC2 wrt. any interpretation A ⊇ {Tr}.\nFinally, one can also show that splitting, i.e., the component-wise check for foundedness, does not lead to spurious unfounded sets.\nProposition 4. If U is an unfounded set of ΠC wrt. A such that U ⊆ C, then U is an unfounded set of Π wrt. A.\nProof (Sketch). If U = ∅, then the result holds trivially. By definition of ΠC we have H(r) ∩ C = ∅ for all r ∈ Π \\ΠC . By precondition of the proposition we have U ⊆ C. But then H(r) ∩ U = ∅ for all r ∈ Π \\ΠC and U is an unfounded set of Π wrt. A. 2"
    }, {
      "heading" : "5 Implementation and Evaluation",
      "text" : "For implementing our technique, we integrated CLASP into our prototype system DLVHEX; we use CLASP as an ASP solver for computing compatible sets and as a SAT solver for solving the nogood set of the UFS check. We evaluated the implementation on a Linux server with two 12-core AMD 6176 SE CPUs with 128GB RAM. Argumentation Benchmarks. In this benchmark we compute ideal set extensions for randomized instances of abstract argumentation frameworks [4] of different sizes. In these instances, the cycles involve usually only small parts of the overall programs, hence the program decomposition is very effective. Table 1 shows results of our experimental evaluation on argumentation benchmark instances; for computing average times, we considered 300 seconds for instances that timed out. The encodings contain a cyclic part with cycles over external atoms, and a cyclic part with cycles that do not contain external atoms. Therefore in these instances our new approach can help in limiting the set of atoms for which unfounded sets must be checked, which explains the significant performance gain due to less time spent in the UFS check. Multi-Context System Benchmarks. MCSs [1] are a formalism for interlinking knowledge based systems; in [9], inconsistency explanations (IEs) for an MCS were defined.\nThis benchmark computes the IEs, which correspond 1-1 to answer sets of an encoding rich in cycles through external atoms (which evaluate local knowledge base semantics). We use random instances of different topologies created with an available benchmark generator. For the MCS benchmarks we tested 68 consistent and 88 inconsistent MCSs for which we compute inconsistency explanations [9]. This encoding contains saturation over external atoms, where nearly all cycles in the HEX-program contain at least one external atom. Therefore the methods we introduce in this work can only very rarely reduce the set of atoms for which the UFS check needs to be performed.\nThe benchmark result for MCS instances confirms that the syntactic check we introduce in this paper is very cheap and does not impede performance, even if an instance does not admit a considerable simplification for the UFS check: over all 156 instances, we had an overall runtime of 25357 seconds with the standard approach, and a runtime of 25115 seconds with our new approach; the gain is 242 seconds which is less than one percent speedup (for enumerating all inconsistency explanations) by applying our method. This is a very small gain, and there is no difference in the number of instances that timed out.\nDefault Reasoning over Description Logics Benchmarks. Another application of HEX-programs is the DL-plugin [10], which integrates description logics ontologies with rules. This allows, for instance, default reasoning over description logic knowledge bases, which is not possible in DL knowledge bases alone. Defaults require cyclic dependencies over external atoms. However, as all such dependencies involve default negated atoms, we have no cycles according to Definition 7, which respects only positive dependencies. Hence, the decision criterion comes to the conclusion that no UFS check is required.\nWe used variants of the benchmarks presented in [6], which query wines from an ontology and classify them as red or white wines, where a wine is assumed to be white unless the ontology explicitly entails the contrary. In this scenario, the decision criterion eliminates all unfounded set checks. However, as there is only one compatible set per instance, there would be only one unfounded set check anyway, hence the speedup due to the decision criterion is not significant. But the effect of the decision criterion can be increased by slightly modifying the scenario such that there are multiple compatible sets. This can be done, for instance, by nondeterministic default classifications, e.g., if a wine is not Italian, then it is either French or Spanish by default. Our experiments have shown that with a small number of compatible sets, the performance enhancement due to the decision criterion is marginal, but increases with larger numbers of compatible sets. For instance, for 243 compatible sets (and thus 243 unfounded set checks) we could observe a speedup from 13.59 to 12.19 seconds."
    }, {
      "heading" : "6 Conclusion",
      "text" : "The evaluation of HEX-programs requires a minimality check of model candidates which is realized as an equivalent search for unfounded sets (UFS). However, this check is computationally costly. Moreover, during construction of the model candidate, the ASP solver used as a backend has already performed a “restricted” form of unfounded set check, i.e., an UFS check over the program Π̂ , viewing external atoms as ordinary ones. Hence, it already excludes certain unfounded candidates. Redoing a complete UFS\nsearch is thus a waste of resources, and the goal is to minimize the number of additional foundedness checks.\nIn this paper we presented a syntactic criterion which can be efficiently tested and allows to decide whether an additional UFS check is necessary for a given program. It turned out that the essential property is the existence of cyclic dependencies of atoms which involve predicate inputs to external atoms. If no such dependencies exist, then there is no need for an additional check, and the check built into the ordinary ASP solver is already sufficient. In further elaboration, we have refined the basic idea by splitting the input program into components. This allows for independent applications of the decision criterion to the different components. Thus, the UFS check is restricted to relevant parts of the program, while it can safely be ignored for other parts.\nRelated to our work is [3], where a similar program decomposition is used, yet for ordinary programs only. While we consider e-cycles, which are specific for HEXprograms, the interest in [3] is with head-cycles with respect to disjunctive rule heads. In fact, our implementation may be regarded as an extension of the work in [3], since the evaluation of Π̂ follows their principles of performing UFS checks in case of head-cycles. Note however, that the applied component splitting does not generalize the well-known splitting theorem [18] as we consider only positive dependencies for ordinary atoms.\nAn interesting issue for further research is to consider refinements of the decision criterion, or alternative criteria. One direction for refinement is to dynamically take the model candidate into account, in addition to the program structure, which intuitively may prune dependencies and thus allow to skip the UFS check even in the presence of (syntactic) e-cycles. Another extension is to exploit additional semantic information on the external atoms, e.g., such as (anti-)monotonicity etc. Moreover, a more extensive experimental analysis is subject of our future work, where case studies may give rise to to alternative criteria and further optimizations."
    } ],
    "references" : [ {
      "title" : "Equilibria in Heterogeneous Nonmonotonic Multi-Context Systems",
      "author" : [ "G. Brewka", "T. Eiter" ],
      "venue" : "AAAI’07. pp. 385–390. AAAI Press",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Answer set programming at a glance",
      "author" : [ "G. Brewka", "T. Eiter", "M. Truszczyński" ],
      "venue" : "Commun. ACM 54(12), 92–103",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Conflict-driven disjunctive answer set solving",
      "author" : [ "C. Drescher", "M. Gebser", "T. Grote", "B. Kaufmann", "A. König", "M. Ostrowski", "T. Schaub" ],
      "venue" : "KR’08. pp. 422–432. AAAI Press",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games",
      "author" : [ "P.M. Dung" ],
      "venue" : "Artif. Intell. 77(2), 321–357",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Pushing efficient evaluation of HEX programs by modular decomposition",
      "author" : [ "T. Eiter", "M. Fink", "G. Ianni", "T. Krennwallner", "P. Schüller" ],
      "venue" : "LPNMR’11. pp. 93–106",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Conflict-driven ASP solving with external sources",
      "author" : [ "T. Eiter", "M. Fink", "T. Krennwallner", "C. Redl" ],
      "venue" : "Theory and Practice of Logic Programming: Special Issue ICLP",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2012
    }, {
      "title" : "Exploiting Unfounded Sets for HEX-Program Evaluation. In: JELIA’12",
      "author" : [ "T. Eiter", "M. Fink", "T. Krennwallner", "C. Redl", "P. Schüller" ],
      "venue" : null,
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2012
    }, {
      "title" : "Improving HEX-Program Evaluation based on Unfounded Sets",
      "author" : [ "T. Eiter", "M. Fink", "T. Krennwallner", "C. Redl", "P. Schüller" ],
      "venue" : "Tech. Rep. INFSYS RR-1843-12-08, Institut für Informationssysteme, Technische Universität Wien, A-1040 Vienna, Austria",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Finding explanations of inconsistency in Multi-Context Systems",
      "author" : [ "T. Eiter", "M. Fink", "P. Schüller", "A. Weinzierl" ],
      "venue" : "KR’10. pp. 329–339. AAAI Press",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Exploiting conjunctive queries in description logic programs",
      "author" : [ "T. Eiter", "G. Ianni", "T. Krennwallner", "R. Schindlauer" ],
      "venue" : "Ann. Math. Artif. Intell. 53(1–4),",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2008
    }, {
      "title" : "A Uniform Integration of Higher-Order Reasoning and External Evaluations in Answer-Set Programming",
      "author" : [ "T. Eiter", "G. Ianni", "R. Schindlauer", "H. Tompits" ],
      "venue" : "IJCAI’05. pp. 90–96. Professional Book Center",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Effective Integration of Declarative Rules with External Evaluations for Semantic-Web Reasoning",
      "author" : [ "T. Eiter", "G. Ianni", "R. Schindlauer", "H. Tompits" ],
      "venue" : "ESWC’06. pp. 273–287. Springer",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Unfounded sets for disjunctive logic programs with arbitrary aggregates",
      "author" : [ "W. Faber" ],
      "venue" : "LPNMR’05. pp. 40–52. Springer",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Semantics and complexity of recursive aggregates in answer set programming",
      "author" : [ "W. Faber", "N. Leone", "G. Pfeifer" ],
      "venue" : "Artif. Intell. 175(1), 278–298",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Conflict-driven answer set solving: From theory to practice",
      "author" : [ "M. Gebser", "B. Kaufmann", "T. Schaub" ],
      "venue" : "Artif. Intell. 187–188, 52–89",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Classical Negation in Logic Programs and Disjunctive Databases",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "New Generat. Comput. 9(3–4), 365–386",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Answer set programming based on propositional satisfiability",
      "author" : [ "E. Giunchiglia", "Y. Lierler", "M. Maratea" ],
      "venue" : "J. Autom. Reason. 36(4), 345–377",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Splitting a logic program",
      "author" : [ "V. Lifschitz", "H. Turner" ],
      "venue" : "ICLP’94. pp. 23–37",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "The DLV System for Knowledge Representation and Reasoning",
      "author" : [ "N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello" ],
      "venue" : "ACM Trans. Comput. Logic 7(3), 499–562",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Extending and Implementing the Stable Model Semantics",
      "author" : [ "P. Simons", "I. Niemelä", "T. Soininen" ],
      "venue" : "Artif. Intell. 138, 181–234",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2002
    } ],
    "referenceMentions" : [ {
      "referenceID" : 1,
      "context" : "In the last years, Answer Set Programming (ASP) has emerged as an increasingly popular approach to declarative problem solving for a range of applications [2], thanks to expressive and efficient systems like SMODELS [20], DLV [19], cmodels [17], and CLASP [15].",
      "startOffset" : 155,
      "endOffset" : 158
    }, {
      "referenceID" : 19,
      "context" : "In the last years, Answer Set Programming (ASP) has emerged as an increasingly popular approach to declarative problem solving for a range of applications [2], thanks to expressive and efficient systems like SMODELS [20], DLV [19], cmodels [17], and CLASP [15].",
      "startOffset" : 216,
      "endOffset" : 220
    }, {
      "referenceID" : 18,
      "context" : "In the last years, Answer Set Programming (ASP) has emerged as an increasingly popular approach to declarative problem solving for a range of applications [2], thanks to expressive and efficient systems like SMODELS [20], DLV [19], cmodels [17], and CLASP [15].",
      "startOffset" : 226,
      "endOffset" : 230
    }, {
      "referenceID" : 16,
      "context" : "In the last years, Answer Set Programming (ASP) has emerged as an increasingly popular approach to declarative problem solving for a range of applications [2], thanks to expressive and efficient systems like SMODELS [20], DLV [19], cmodels [17], and CLASP [15].",
      "startOffset" : 240,
      "endOffset" : 244
    }, {
      "referenceID" : 14,
      "context" : "In the last years, Answer Set Programming (ASP) has emerged as an increasingly popular approach to declarative problem solving for a range of applications [2], thanks to expressive and efficient systems like SMODELS [20], DLV [19], cmodels [17], and CLASP [15].",
      "startOffset" : 256,
      "endOffset" : 260
    }, {
      "referenceID" : 10,
      "context" : "To cater for this need, HEX-programs [11] extend ASP with so called external atoms, through which the user can couple any external data source with a logic program.",
      "startOffset" : 37,
      "endOffset" : 41
    }, {
      "referenceID" : 4,
      "context" : "[5]).",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 13,
      "context" : "The semantics of a HEX-program Π is defined in terms of answer sets based on the FLP reduct [14]: an interpretation A is an answer set of Π , if and only if it is a ⊆-minimal model of the FLP-reduct fΠ of Π wrt.",
      "startOffset" : 92,
      "endOffset" : 96
    }, {
      "referenceID" : 15,
      "context" : "For ordinary logic programs, this semantics coincides with the one where the canonical GL-reduct [16] is in place of fΠ, and it is more appealing for extensions with nonmonotonic aggregates [14], and the more general external atoms in HEX-programs.",
      "startOffset" : 97,
      "endOffset" : 101
    }, {
      "referenceID" : 13,
      "context" : "For ordinary logic programs, this semantics coincides with the one where the canonical GL-reduct [16] is in place of fΠ, and it is more appealing for extensions with nonmonotonic aggregates [14], and the more general external atoms in HEX-programs.",
      "startOffset" : 190,
      "endOffset" : 194
    }, {
      "referenceID" : 12,
      "context" : "Step 2 then checks whether A is a ⊆-minimal model or, equivalently, whether A is unfounded-free [13], i.",
      "startOffset" : 96,
      "endOffset" : 100
    }, {
      "referenceID" : 13,
      "context" : "Unfortunately, Step 2 is computationally expensive in general, and it is intractable even for Horn programs with nonmonotonic external atoms of polynomial complexity, as follows from results in [14].",
      "startOffset" : 194,
      "endOffset" : 198
    }, {
      "referenceID" : 0,
      "context" : ", in encodings of problems on multi-context systems [1] or abstract argumentation systems [4], for which Step 2 cannot be skipped.",
      "startOffset" : 52,
      "endOffset" : 55
    }, {
      "referenceID" : 3,
      "context" : ", in encodings of problems on multi-context systems [1] or abstract argumentation systems [4], for which Step 2 cannot be skipped.",
      "startOffset" : 90,
      "endOffset" : 93
    }, {
      "referenceID" : 3,
      "context" : "In particular, for the HEX-encoding of a Dung-style argumentation semantics [4] which we consider, the decomposition approach yields a considerable gain, as shown in a preliminary experimental evaluation.",
      "startOffset" : 76,
      "endOffset" : 79
    }, {
      "referenceID" : 6,
      "context" : "This paper complements recent work on unfoundedness checking for HEX-programs in [7, 8], which is part of a larger effort to provide efficient evaluation of HEX-programs, based on new algorithms cf.",
      "startOffset" : 81,
      "endOffset" : 87
    }, {
      "referenceID" : 7,
      "context" : "This paper complements recent work on unfoundedness checking for HEX-programs in [7, 8], which is part of a larger effort to provide efficient evaluation of HEX-programs, based on new algorithms cf.",
      "startOffset" : 81,
      "endOffset" : 87
    }, {
      "referenceID" : 5,
      "context" : "[6].",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 10,
      "context" : "HEX-programs were introduced in [11] as a generalization of (disjunctive) extended logic programs under the answer set semantics [16]; for details and background see [11].",
      "startOffset" : 32,
      "endOffset" : 36
    }, {
      "referenceID" : 15,
      "context" : "HEX-programs were introduced in [11] as a generalization of (disjunctive) extended logic programs under the answer set semantics [16]; for details and background see [11].",
      "startOffset" : 129,
      "endOffset" : 133
    }, {
      "referenceID" : 10,
      "context" : "HEX-programs were introduced in [11] as a generalization of (disjunctive) extended logic programs under the answer set semantics [16]; for details and background see [11].",
      "startOffset" : 166,
      "endOffset" : 170
    }, {
      "referenceID" : 11,
      "context" : "However, as suitable safety conditions allow for using a grounding procedure [12], we limit our investigation to ground programs.",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 15,
      "context" : "Satisfaction of ordinary rules and ASP programs [16] is then extended to HEX-rules and programs in the obvious way, and the notion of extension ext(·,A) for external predicates &g with input lists p is naturally defined by ext(&g [p],A) = {c | f&g(A,p, c) = 1}.",
      "startOffset" : 48,
      "endOffset" : 52
    }, {
      "referenceID" : 13,
      "context" : "Definition 2 (FLP-Reduct [14]).",
      "startOffset" : 25,
      "endOffset" : 29
    }, {
      "referenceID" : 15,
      "context" : "A compatible set of a programΠ is an interpretation Â such that (i) Â is an answer set [16] of the guessing program Π̂ , and (ii) f&g(Â,p, c) = 1 iff Te&g[p](c) ∈ Â for all external atoms &g [p](c) in Π , i.",
      "startOffset" : 87,
      "endOffset" : 91
    }, {
      "referenceID" : 6,
      "context" : "This is justified by the following Definitions 5 and 6 and Theorem 1 from [7].",
      "startOffset" : 74,
      "endOffset" : 77
    }, {
      "referenceID" : 12,
      "context" : "(These results lift unfounded sets for disjunctive logic programs with arbitrary aggregates [13] to HEX-programs.",
      "startOffset" : 92,
      "endOffset" : 96
    }, {
      "referenceID" : 6,
      "context" : "Definition 5 (Unfounded Set [7]).",
      "startOffset" : 28,
      "endOffset" : 31
    }, {
      "referenceID" : 6,
      "context" : "Definition 6 (Unfounded-free Interpretations [7]).",
      "startOffset" : 45,
      "endOffset" : 48
    }, {
      "referenceID" : 6,
      "context" : "Theorem 1 (Characterization of Answer Sets [7]).",
      "startOffset" : 43,
      "endOffset" : 46
    }, {
      "referenceID" : 3,
      "context" : "In this benchmark we compute ideal set extensions for randomized instances of abstract argumentation frameworks [4] of different sizes.",
      "startOffset" : 112,
      "endOffset" : 115
    }, {
      "referenceID" : 0,
      "context" : "MCSs [1] are a formalism for interlinking knowledge based systems; in [9], inconsistency explanations (IEs) for an MCS were defined.",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 8,
      "context" : "MCSs [1] are a formalism for interlinking knowledge based systems; in [9], inconsistency explanations (IEs) for an MCS were defined.",
      "startOffset" : 70,
      "endOffset" : 73
    }, {
      "referenceID" : 8,
      "context" : "For the MCS benchmarks we tested 68 consistent and 88 inconsistent MCSs for which we compute inconsistency explanations [9].",
      "startOffset" : 120,
      "endOffset" : 123
    }, {
      "referenceID" : 9,
      "context" : "Another application of HEX-programs is the DL-plugin [10], which integrates description logics ontologies with rules.",
      "startOffset" : 53,
      "endOffset" : 57
    }, {
      "referenceID" : 5,
      "context" : "We used variants of the benchmarks presented in [6], which query wines from an ontology and classify them as red or white wines, where a wine is assumed to be white unless the ontology explicitly entails the contrary.",
      "startOffset" : 48,
      "endOffset" : 51
    }, {
      "referenceID" : 2,
      "context" : "Related to our work is [3], where a similar program decomposition is used, yet for ordinary programs only.",
      "startOffset" : 23,
      "endOffset" : 26
    }, {
      "referenceID" : 2,
      "context" : "While we consider e-cycles, which are specific for HEXprograms, the interest in [3] is with head-cycles with respect to disjunctive rule heads.",
      "startOffset" : 80,
      "endOffset" : 83
    }, {
      "referenceID" : 2,
      "context" : "In fact, our implementation may be regarded as an extension of the work in [3], since the evaluation of Π̂ follows their principles of performing UFS checks in case of head-cycles.",
      "startOffset" : 75,
      "endOffset" : 78
    }, {
      "referenceID" : 17,
      "context" : "Note however, that the applied component splitting does not generalize the well-known splitting theorem [18] as we consider only positive dependencies for ordinary atoms.",
      "startOffset" : 104,
      "endOffset" : 108
    } ],
    "year" : 2013,
    "abstractText" : "HEX-programs are an extension of the Answer Set Programming (ASP) paradigm incorporating external means of computation into the declarative programming language through so-called external atoms. Their semantics is defined in terms of minimal models of the Faber-Leone-Pfeifer (FLP) reduct. Developing native solvers for HEX-programs based on an appropriate notion of unfounded sets has been subject to recent research for reasons of efficiency. Although this has lead to an improvement over naive minimality checking using the FLP reduct, testing for foundedness remains a computationally expensive task. In this work we improve on HEX-program evaluation in this respect by identifying a syntactic class of programs, that can be efficiently recognized and allows to entirely skip the foundedness check. Moreover, we develop criteria for decomposing a program into components, such that the search for unfounded sets can be restricted. Observing that our results apply to many HEX-program applications provides analytic evidence for the significance and effectiveness of our approach, which is complemented by a brief discussion of preliminary experimental validation.",
    "creator" : "TeX"
  }
}