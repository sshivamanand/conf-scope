{
  "name" : "1212.2314.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Tree Projections and Structural Decomposition Methods: Minimality and Game-Theoretic Characterization",
    "authors" : [ "Gianluigi Greco", "Francesco Scarcello" ],
    "emails" : [ "ggreco@mat.unical.it,", "scarcello@deis.unical.it" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n21 2.\n23 14\nv1 [\ncs .D\nM ]\nThe paper analyzes this framework, by focusing in particular on “minimal” tree projections, that is, on tree projections without useless redundancies. First, it is shown that minimal tree projections enjoy a number of properties that are usually required for normal form decompositions in various structural decomposition methods. In particular, they enjoy the same kind of connection properties as (minimal) tree decompositions of graphs, with the result being tight in the light of the negative answer that is provided to the open question about whether they enjoy a slightly stronger notion of connection property, defined to speed-up the computation of hypertree decompositions. Second, it is shown that tree projections admit a natural game-theoretic characterization in terms of the Captain and Robber game. In this game, as for the Robber and Cops game characterizing tree decompositions, the existence of winning strategies implies the existence of monotone ones. As a special case, the Captain and Robber game can be used to characterize the generalized hypertree decomposition method, where such a game-theoretic characterization was missing and asked for. Besides their theoretical interest, these results have immediate algorithmic applications both for the general setting and for structural decomposition methods that can be recast in terms of tree projections."
    }, {
      "heading" : "1 Introduction",
      "text" : ""
    }, {
      "heading" : "1.1 Structural Decomposition Methods and Open Questions",
      "text" : "Many NP-hard problems in different application areas, ranging, e.g., from AI [13] to Database Theory [6], are known to be efficiently solvable when restricted to instances whose underlying structures can be modeled via acyclic graphs or hypergraphs. Indeed, on these kinds of instances, solutions can usually be computed via dynamic programming, by incrementally processing the acyclic (hyper)graph, according to some of its topological orderings. However, structures arising from real applications are hardly precisely acyclic. Yet, they are often not very intricate and, in fact, tend to exhibit some limited degree of cyclicity, which suffices to retain most of the nice properties of acyclic ones. Therefore,\nseveral efforts have been spent to investigate invariants that are best suited to identify nearly-acyclic graph/hypergraphs, leading to the definition of a number of so-called structural decomposition methods, such as the (generalized) hypertree [14], fractional hypertree [23], spread-cut [8], and component hypertree [16] decompositions. These methods aim at transforming a given cyclic hypergraph into an acyclic one, by organizing its edges (or its nodes) into a polynomial number of clusters, and by suitably arranging these clusters as a tree, called decomposition tree. The original problem instance can then be evaluated over such a tree of subproblems, with a cost that is exponential in the cardinality of the largest cluster, also called width of the decomposition, and polynomial if this width is bounded by some constant.\nDespite their different technical definitions, there is a simple mathematical framework that encompasses all purely structural decomposition methods, which is the framework of the tree projections [18]. Roughly, given a pair of hypergraphs (H1,H2), a tree projection of H1 w.r.t. H2 is an acyclic hypergraph Ha such that each hyperedge of H1 is contained in some hyperedge of Ha, that is in its turn contained in a hyperedge of H2, which is called the resource hypergraph—see Figure 1 for an illustration.\nTherefore, in the tree projection framework, the resource hypergraph H2 is arbitrary. Whenever it is instead computed with some specific technique from the hypergraph H1, we obtain as special cases the so-called purely structural decomposition methods. Consider, for instance, the tree decomposition method [9, 12], based on the notion of treewidth [26], which is the most general decomposition method over classes of graphs (see, e.g, [13, 22]). Let k be a fixed natural number, and consider any (hyper)graph H1 over a set V of nodes. Let Htk1 be the hypergraph associated whose hyperedges are all possible sets of at most k + 1 variables. Then, a hypergrah H1 has treewidth bounded by k if, and only if, there is a tree projection of H1 w.r.t. Htk1 (see, e.g., [19, 20]). 1\nIn fact, our current understating of structural decompositions for binary (graph) instances is fairly complete. The situation pertaining decompositions methods for arbitrary (hypergraphs) instances is much more muddled instead. In particular, the following two questions have been posed in the literature for the general tree projection framework as well as for structural decomposition methods specifically\n1For the sake of completeness, observe that the only known structural technique that does not fit the general framework of tree projections is the one based on the submodular width [25], which is not purely structural. Indeed, this method, which is specifically tailored to solve constraint satisfaction problem (or conjunctive query) instances, identify a number of decompositions on the basis of both the given constraint hypergraph and the associated constraint relations.\ntailored to deal with classes of queries without a fixed arity bound. Such questions were in particular open for the generalized hypertree decomposition method, which on classes of unbounded-arity queries is a natural counterpart of the tree decomposition method.\n(Q2) Is there a natural notion of normal-form for tree projections? Whenever some tree projection of a pair (H1,H2) exists, in general there are also many tree projections with useless redundancies. Having a suitable notion of minimality may allow us to identify the most desirable tree projections. In fact, for several structural decomposition methods, normal forms have been defined to restrict the search space of decomposition trees, without loosing any useful decomposition.\nSuch a nice feature is however missing for the general case of tree projections. As a consequence, consider for instance the basic problem of deciding whether a tree projection of a hypergraph H1 with respect to a hypergraph H2 exists or not. Because every subset of any hyperedge of H2 may belong to the tree projection Ha we are looking for, this latter hypergraph might in principle consists of an exponential number of hyperedges (w.r.t. to the size of H1 and H2). Therefore, even proving that the existence problem is feasible in NP is not easy, without a notion of minimality that allows us to get rid of redundant hyperedges.\nFurthermore, in the case of tree decompositions, it is known that we can focus, w.l.o.g., on connected ones [11], that is, basically, on tree decompositions such that, for each set of connected vertices, the sub-hypergraph induced by the nodes covered in such vertices is connected in its turn. Again, connected decompositions provide us with a “normal form” for decomposition trees, which can be exploited to restrict the search space of the possible decompositions and, thus, to speed-up their computation [11]. However, no systematic study about connection properties of tree projections (and of decomposition methods other than tree decomposition) appeared in the literature. Algorithms have been implemented limiting the search space to a kind of connected (generalized) hypertree decompositions [29], but it was left open whether the resulting method is a heuristic one or it does give an exact solution.\n(Q2) Is there a natural game-theoretic characterization for tree projections? Tree decompositions have a nice game-theoretic characterization in terms of the Robber and Cops game [28]: A hypergraph H has treewidth bounded by k if, and only, if k + 1 Cops can capture a Robber that can run at great speed along the hyperedges of H, while being not permitted to run trough a node that is controlled by a Cop. In particular, the Cops can move over the nodes, and while they move, the Robber is fast and can run trough those nodes that are left or not yet occupied before the move is completed. An important property of this game is that there is no restriction on the strategy used by the Cops to capture the Robber. In particular, the Cops are not constrained to play monotone strategies, that is, to shrink the Robber’s escape space in a monotonically decreasing way. More precisely, playing non-monotone strategies gives no more power to the Cops [28]. In many results about treewidth (e.g., [5]), this property turns out to be very useful, because good strategies for the Robber may be easily characterized as those strategies that allow the Robber to run forever.\nHypertree decomposition is an efficiently recognizable structural method [15], which provides a 3- approximation for generalized hypertree decompositions [4]. This method is also known to have a nice game-theoretic characterization, in terms of the (monotone) Robber and Marshals game [15], which can be viewed as a natural generalization of the Robber and Cops games. The game is the same as the one characterizing acyclicity, but with k Marshals acting simultaneously to capture the Robber: A hypergraph H has hypertree width bounded by k if, and only if, k Marshals, each one with the ability of controlling a hyperedge of H, can capture a Robber that can run at great speed along the hyperedges, while being not permitted to run trough a node that belongs to a hyperedge controlled by a Marshal. Note that Marshals are more powerful than the Cops of the Robber and Cops game characterizing\ntreewidth, in that they can move over whole hyperedges. However, Marshals are now required to play monotonically, because non-monotone strategies give some extra-power that does not correspond to valid decompositions [1].\nDespite the similarities between hypertree and generalized hypertree decompositions as they are apparent from the original definitions by Gottlob et al. [15], game theoretic characterizations for generalized hypertree width were still missing. In [1], it is raised the question about whether there is a (natural) game theoretic characterization for generalized hypertree width, where non-monotonicity does not represent a source of additional power. Such a characterization is missing for the tree projection setting, too."
    }, {
      "heading" : "1.2 Contributions",
      "text" : "In this paper, we provide useful properties and characterizations of tree projections (and structural decomposition methods), by answering the two questions illustrated above. In particular,\n◮ We define and investigate minimal tree projections, where the minimal possible subsets of any view are employed. Intuitively, such tree projections typically correspond to more efficient decompositions. We show that some properties required for “normal form” decompositions in various notions of structural decomposition methods (see, e.g., [14]) are a consequence of minimality. In particular, minimal tree projections enjoy the same kind of connection property as tree decompositions.\n◮ We define a normal form for (minimal) tree projections. In particular, it turns out that, given any pair of hypergraphs (H1,H2), there always exists a tree projection of H1 w.r.t. H2 in normal form having polynomial size with respect to the size of the given hypergraphs. An immediate consequence of this result is that checking whether a tree projection exists or not is feasible in NP. In fact, this property has already been exploited in the NP-completeness proof of tree projections [16].\n◮ We give a negative answer to the question raised in [29] for (generalized) hypertree decomposition. We observe that the notion of connected decomposition proposed there differs from the one defined for tree decompositions and mentioned above. In particular, we show a hypergraph where this restriction leads to worse tree projections, more precisely, where all such connected (generalized) hypertree decompositions have width higher than the hypertree width of the considered hypergraph. Hence, the algorithm proposed in [29] for connected hypertree decompositions is not complete, as far as the computation of unrestricted decompositions is considered.\n◮ We define the Captain and Robber game to be played on pairs of hypergraphs, and we show that in this game the Captain has a winning strategy if, and only if, she has a monotone winning one. Then, we show that tree projections and thus, e.g., generalized hypertree decompositions, may be characterized in terms of the Captain and Robber game. Hence, these notions have now a natural game characterization where monotone and non-monotone strategies have the same power.\nOrganization. The rest of the paper is organized as follows. Section 2 illustrates some basic notions and concepts. The setting of minimal tree projections is discussed in Section 3. The game-theoretic characterization is illustrated in Section 4. A few final remarks and some further results are discussed in Section 5, by exploiting the properties of minimal tree projections and the game-theoretic characterization."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "Hypergraphs and Acyclicity. A hypergraph H is a pair (V,H), where V is a finite set of nodes and H is a set of hyperedges such that, for each h ∈ H , h ⊆ V . If |h| = 2 for each (hyper)edge h ∈ H , then H is a graph. For the sake of simplicity, we always denote V and H by nodes(H) and edges(H), respectively.\nA hypergraph H is acyclic (more precisely, α-acyclic [10]) if, and only if, it has a join tree [6]. A join tree JT for a hypergraph H is a tree whose vertices are the hyperedges of H such that, whenever a node X ∈ V occurs in two hyperedges h1 and h2 of H, then h1 and h2 are connected in JT , and X occurs in each vertex on the unique path linking h1 and h2 (see Figure 1 for an illustration). In words, the set of vertices in which X occurs induces a (connected) subtree of JT . We will refer to this condition as the connectedness condition of join trees.\nTree Decompositions. A tree decomposition [26] of a graph G is a pair 〈T, χ〉, where T = (N,E) is a tree, and χ is a labeling function assigning to each vertex v ∈ N a set of verticesχ(v) ⊆ nodes(G), such that the following conditions are satisfied: (1) for each node Y ∈ nodes(G), there exists p ∈ N such that Y ∈ χ(p); (2) for each edge {X,Y } ∈ edges(G), there exists p ∈ N such that {X,Y } ⊆ χ(p); and (3) for each node Y ∈ nodes(G), the set {p ∈ N | Y ∈ χ(p)} induces a (connected) subtree of T . The width of 〈T, χ〉 is the number maxp∈N (|χ(p)| − 1).\nThe Gaifman graph of a hypergraph H is defined over the set nodes(H) of the nodes of H, and contains an edge {X,Y } if, and only if, {X,Y } ⊆ h holds, for some hyperedge h ∈ edges(H). The treewidth of H is the minimum width over all the tree decompositions of its Gaifman graph. Deciding whether a given hypergraph has treewidth bounded by a fixed natural number k is known to be feasible in linear time [7].\n(Generalized) Hypertree Decompositions. A hypertree for a hypergraphH is a triple 〈T, χ, λ〉, where T = (N,E) is a rooted tree, and χ and λ are labeling functions which associate each vertex p ∈ N with two sets χ(p) ⊆ nodes(H) and λ(p) ⊆ edges(H). If T ′ = (N ′, E′) is a subtree of T , we define χ(T ′) = ⋃\nv∈N ′ χ(v). In the following, for any rooted tree T , we denote the set of vertices N of T by vertices(T ), and the root of T by root(T ). Moreover, for any p ∈ N , Tp denotes the subtree of T rooted at p.\nA generalized hypertree decomposition [15] of a hypergraph H is a hypertree HD = 〈T, χ, λ〉 for H such that: (1) for each hyperedge h ∈ edges(H), there exists p ∈ vertices(T ) such that h ⊆ χ(p); (2) for each node Y ∈ nodes(H), the set {p ∈ vertices(T ) | Y ∈ χ(p)} induces a (connected) subtree of T ; and (3) for each p ∈ vertices(T ), χ(p) ⊆ nodes(λ(p)). The width of a generalized hypertree decomposition 〈T, χ, λ〉 is maxp∈vertices(T )|λ(p)|. The generalized hypertree width ghw(H) of H is the minimum width over all its generalized hypertree decompositions.\nA hypertree decomposition [14] of H is a generalized hypertree decomposition HD = 〈T, χ, λ〉 where: (4) for each p ∈ vertices(T ), nodes(λ(p)) ∩ χ(Tp) ⊆ χ(p). Note that the inclusion in the above condition is actually an equality, because Condition (3) implies the reverse inclusion. The hypertree width hw(H) of H is the minimum width over all its hypertree decompositions. Note that, for any hypergraph H, it is the case that ghw(H) ≤ hw(H) ≤ 3× ghw(H) + 1 [4]. Moreover, for any fixed natural number k > 0, deciding whether hw(H) ≤ k is feasible in polynomial time (and, actually, it is highly-parallelizable) [14], while deciding whether ghw(H) ≤ k is NP-complete [16].\nTree Projections. For two hypergraphs H1 and H2, we write H1 ≤ H2 if, and only if, each hyperedge of H1 is contained in at least one hyperedge of H2. Let H1 ≤ H2; then, a tree projection of H1 with\nrespect to H2 is an acyclic hypergraph Ha such that H1 ≤ Ha ≤ H2. Whenever such a hypergraphHa exists, we say that the pair of hypergraphs (H1,H2) has a tree projection.\nNote that the notion of tree projection is more general than the above mentioned (hyper)graph based notions. For instance, consider the generalized hypertree decomposition approach. Given a hypergraph H and a natural number k > 0, let Hk denote the hypergraph over the same set of nodes as H, and whose set of hyperedges is given by all possible unions of k edges in H, i.e., edges(Hk) = {h1∪h2∪· · ·∪hk | {h1, h2, . . . , hk} ⊆ edges(H)}. Then, it is well known and easy to see that H has generalized hypertree width at most k if, and only if, there is a tree projection for (H,Hk).\nSimilarly, for tree decompositions, let Htk be the hypergraph over the same set of nodes as H, and whose set of hyperedges is given by all possible clusters B ⊆ nodes(H) of nodes such that |B| ≤ k+1. Then, H has treewidth at most k if, and only if, there is a tree projection for (H,Htk)."
    }, {
      "heading" : "3 Minimal Tree Projections",
      "text" : "In this section, a partial ordering of tree projections is defined. It is shown that minimal tree projections have nice properties with both theoretical and practical interest.\nLet H and H′ be two hypergraphs. We say that H is contained in H′, denoted by H ⊆ H′, if for each hyperedge h ∈ edges(H) − edges(H′), there is a hyperedge h′ ∈ edges(H′) − edges(H) with h ⊆ h′ (and hence h ⊂ h′). Moreover, we say that H is properly contained in H′, denoted by H ⊂ H′, if H ⊆ H′ and H 6= H′.\nNote that edges(H) ⊆ edges(H′) entails H ⊆ H′ (and hence edges(H) ⊂ edges(H′) entails H ⊂ H′). Moreover,H ⊆ H′ implies H ≤ H′, but the converse is not true. For example, if edges(H) = {h1, h2} with h2 ⊂ h1 and edges(H′) = {h1}, then H′ ⊆ H and H′ ≤ H hold, as edges(H′) ⊂ edges(H). Moreover, H ≤ H′ holds too, but H is not contained in H′ as there is no hyperedge h′ ∈ edges(H′)− edges(H) such that h2 ⊆ h′.\nDefinition 3.1 Let H1 and H2 be two hypergraphs. Then, a tree projection Ha for (H1,H2) is minimal if there is no tree projection H′a of H1 wr.t. H2 with H ′ a ⊂ Ha. ✷"
    }, {
      "heading" : "3.1 Basic Facts",
      "text" : "We first point out a number of basic important properties of tree projections of a given pair of hypergraphs (H1,H2).\nFact 3.2 The relationship ⊆ of Definition 3.1 induces a partial ordering over the tree projections of H1 w.r.t. H2.\nProof. Observe first that the relation ‘⊆’ over hypergraphs is reflexive. We next show that it is antisymmetric, too. Let H1 and H2 be two hypergraphs such that H1 ⊆ H2 and H2 ⊆ H1, and assume by contradiction that H1 6= H2. Thus, edges(H2) 6= edges(H1). Moreover, edges(H2) 6⊃ edges(H1) holds, for otherwise it is trivially impossible that H2 ⊆ H1. Then, let h1 be the largest hyperedge (with the maximum number of nodes) in edges(H1) \\ edges(H2). Since H1 ⊆ H2, it is the case that there is a hyperedge h2 ∈ edges(H2) \\ edges(H1) with h1 ⊂ h2. But we also know that H2 ⊆ H1 holds, and hence there is a hyperedge h′1 ∈ edges(H1) \\ edges(H2) with h2 ⊂ h ′ 1. Thus, h1 ⊂ h2 ⊂ h ′\n1, which is impossible due to the maximality of h1.\nEventually, we show that the relation ‘⊆’ over hyperedges is transitive. Indeed, assume H1 ⊆ H2 and H2 ⊆ H3. Let h1 be a hyperedge in edges(H1) \\ edges(H3). We distinguish two cases. If h1 ∈ edges(H2), and hence h1 ∈ edges(H2) \\ edges(H3), then there is a hyperedge h3 ∈ edges(H3) \\ edges(H2) such that h1 ⊆ h3. Otherwise, i.e., if h1 6∈ edges(H2), and hence h1 ∈ edges(H1) \\ edges(H2), then there is a hyperedge h2 ∈ edges(H2) \\ edges(H1) such that h1 ⊆ h2. Then, we have to consider two subcases. If h2 ∈ edges(H3), then we have that h2 is actually a hyperedge in edges(H3) \\ edges(H1) such that h1 ⊆ h2. Instead, if h2 6∈ edges(H3), and hence h2 ∈ edges(H2) \\ edges(H3), then there is a hyperedge h′3 ∈ edges(H3) \\ edges(H2) with h2 ⊆ h3. It follows that h1 ⊆ h2 ⊆ h′3. Putting it all together, we have shown that in all the possible cases, for each hyperedge h1 ∈ edges(H1) \\ edges(H3) there is a hyperedge h′ ∈ edges(H3) \\ edges(H1) such that h1 ⊆ h′. It follows that H1 ⊆ H3 holds.\nBy the above properties, ‘⊆’ is a partial order, and ‘⊂’ is a strict partial order over hypergraphs. ✷\nHence, minimal tree projections always exist, as long as a tree projection exists.\nFact 3.3 The pair (H1,H2) has a tree projection if, and only if, it has a minimal tree projection.\nA further property (again rather intuitive) is that minimal tree projections are reduced hypergraphs. Recall that a hypergraph Ha is reduced if edges(Ha) does not contain two hyperedges ha and h̄a such that ha ⊂ h̄a.\nFact 3.4 Every minimal tree projection is reduced.\nProof. Assume for the sake of contradiction that Ha is a minimal tree projection of H1 w.r.t. H2 such that Ha is not reduced. Let ha and h̄a be two hyperedges of Ha such that ha ⊂ h̄a. Consider the tree projectionH′a 6= Ha obtained by removing ha from Ha, and notice that H ′ a ≤ Ha ≤ H2 and H1 ≤ H ′\na. Thus, H′a is a tree projection of H1 w.r.t. H2. However, we have that edges(H ′\na) ⊂ edges(Ha), which entails that H′a ⊂ Ha holds, thereby contradicting the minimality of Ha. ✷\nThe last basic fact is rather trivial: minimal tree projections do not contain nodes that do not occur in H1.\nFact 3.5 Let Ha be a minimal tree projection of H1 w.r.t. H2. Then, nodes(Ha) = nodes(H1).\nProof. Let Ha be a minimal tree projection of H1 w.r.t. H2. Of course, nodes(Ha) ⊇ nodes(H1) clearly holds. On the other hand, if nodes(Ha) ⊃ nodes(H1), the hypergraphs H′a obtained by deleting from every hyperedge each node in nodes(Ha) \\ nodes(H1) is still an acyclic hypergraph, and H1 ≤ H′a ≤ Ha holds. Moreover, it is straightforward to check that H ′\na ⊂ Ha, which contradicts the minimality of Ha. ✷"
    }, {
      "heading" : "3.2 Component trees",
      "text" : "We now generalize to the setting of tree projections some properties of join trees that are required for efficiently computable decompositions in various notions of structural decomposition methods (see, e.g., [14]). To formalize these properties, we need to introduce some additional definitions, which will be intensively used in the following.\nAssume that a hypergraph H is given. Let V , W , and {X,Y } be sets of nodes. Then, X is said [V ]-adjacent (in H) to Y if there exists a hyperedge h ∈ edges(H) such that {X,Y } ⊆ (h − V ). A\n[V ]-path from X to Y is a sequence X = X0, . . . , Xℓ = Y of nodes such that Xi is [V ]-adjacent to Xi+1, for each i ∈ [0...ℓ-1]. We say that X [V ]-touches Y if X is [∅]-adjacent to Z ∈ nodes(H), and there is a [V ]-path from Z to Y ; similarly, X [V ]-touches the set W if X [V ]-touches some node Y ∈ W . We say that W is [V ]-connected if ∀X,Y ∈ W there is a [V ]-path from X to Y . A [V ]-component (of H) is a maximal [V ]-connected non-empty set of nodes W ⊆ (nodes(H) − V ). For any [V ]-component C, let edges(C) = {h ∈ edges(H) | h ∩ C 6= ∅}, and for a set of hyperedges H ⊆ edges(H), let nodes(H) denote the set of nodes occurring in H , that is nodes(H) = ⋃\nh∈H h. For any component C of H, we denote by Fr(C,H) the frontier of C (in H), i.e., the set nodes(edges(C)).2 Moreover, ∂(C,H) denote the border of C (in H), i.e., the set Fr(C,H) \\C. Note that C1 ⊆ C2 entails Fr(C1,H) ⊆ Fr(C2,H). We write simply Fr(C) or ∂C, whenever H is clear from the context.\nWe find often convenient to think at join trees as rooted trees: For each hyperedge h ∈ edges(H), the tree obtained by rooting JT at vertex h is denoted by JT [h] (if it is necessary to point out its root). Moreover, for each hyperedge h′ ∈ edges(H) with h′ 6= h, let JT [h]h′ denote the subtree of JT [h] rooted at h′, and let nodes(JT [h]h′) be the set of all nodes of H occurring in the vertices of JT [h]h′ .\nDefinition 3.6 Let H1 and Ha be two hypergraphs with the same set of nodes such that H1 ≤ Ha and Ha is acyclic. A join tree JT of Ha, rooted at some vertex root ∈ edges(Ha), is said an H1-component tree if the following conditions hold for each vertex hr ∈ edges(Ha) in JT :\nSUBTREES 7→COMPONENTS. For each child hs of hr in JT , there is exactly one [hr]-component of H1, denoted by C⊤(hs), such that nodes(JThs) = C⊤(hs) ∪ (hs ∩ hr). Moreover, hs ∩ C⊤(hs) 6= ∅ and hs ⊆ Fr(C⊤(hs),H1) hold.\nCOMPONENTS 7→SUBTREES. For each [hr]-component Cr of H1 such that Cr ⊆ C⊤(hr), with C⊤(root) being conventionally defined as nodes(H1), there is exactly one child hs of hr in JT such that Cr = C⊤(hs). ✷\nInterestingly, any reduced acyclic hypergraph Ha has such an Ha-component tree (i.e., H1 = Ha, here), as pointed out in the result below.\nTheorem 3.7 Let Ha be a reduced acyclic hypergraph (e.g., any minimal tree projection). For any hyperedge h ∈ edges(Ha), there exists a join tree JT rooted at h that is an Ha-component tree.\nProof. Let Ha be any reduced acyclic hypergraph and let h ∈ edges(Ha) be any of its hyperedges, and consider Definition 3.6, with its two parts: SUBTREES 7→COMPONENTS and COMPONENTS 7→SUBTREES.\nSUBTREES 7→COMPONENTS. We first show that there is a join tree JT for Ha such that, for each pair hr, hs ∈ edges(Ha) where hs is a child of hr in JT [h],\n(1) there is exactly one [hr]-component Cr of Ha, denoted by C⊤(hs), such that nodes(JT [h]hs) = C⊤(hs) ∪ (hs ∩ hr);\n(2) hs ∩ C⊤(hs) 6= ∅;\n(3) hs ⊆ Fr(C⊤(hs),Ha).\n2The choice of the term “frontier” to name the union of a component with its outer border is due to the role that this notion plays in hypergraph games, such as the one described in the subsequent section.\nSince Ha is a reduced acyclic hypergraph, the hypertree width of Ha is 1. In particular, from the results in [14] (in particular, from Theorem 5.4 in [14]) it follows that, for each hyperedge h ∈ edges(Ha), there is a width-1 hypertree decomposition HD = 〈T, χ, λ〉 for Ha, where T is rooted at a vertex root(T ) such that λ(root(T )) = {h} and, for each vertex r ∈ vertices(T ) and for each child s of r, the following conditions hold: (1) there is (exactly) one [χ(r)]-component Cr of Ha such that χ(Ts) = Cr ∪ (χ(s) ∩ χ(r)); (2) χ(s) ∩ Cr 6= ∅, where Cr is the [χ(r)]-component of Ha satisfying Condition (1); and (3) hs ∩Fr(Cr,Ha) 6= ∅ holds, where {hs} = λ(s) and Cr is the [χ(r)]-component of Ha satisfying Condition (1).\nLet us now denote by hp the unique (as the width is 1) hyperedge contained in λ(p), for each vertex p of T . Recall that h = hroot(T ) is the hyperedge associated with the root of T . Let JT [h] be the tree rooted at h obtained from T by replacing each vertex p with the corresponding hyperedge hp. Then, for each vertex r ∈ vertices(T ) and for each child s of r, the three conditions above that hold on HD can be rewritten as follows: (1) there is (exactly) one [hr]-component Cr of Ha such that nodes(JT [h]hs) = Cr ∪ (hs ∩ hr); (2) hs ∩ Cr 6= ∅, where Cr is the [hr]-component of Ha satisfying Condition (1); and (3) hs ⊆ Fr(Cr ,Ha), where Cr is the [hr]-component of Ha satisfying Condition (1).\nIt remains to show that JT is actually a join tree for Ha. To this end, we claim that the following two properties hold on HD.\nProperty P1: ∀p ∈ vertices(T ), χ(p) = nodes(λ(p)).\nProof. Recall that for each vertex r ∈ vertices(T ) and for each child s of r, the following conditions hold on the hypertree decomposition HD = 〈T, χ, λ〉 for Ha: (1) there is (exactly) one [χ(r)]-component Cr of Ha such that χ(Ts) = Cr ∪ (χ(s) ∩ χ(r)); (2) χ(s) ∩ Cr 6= ∅, where Cr is the [χ(r)]-component of Ha satisfying Condition (1); and (3) hs ∩ Fr(Cr) 6= ∅ holds, where {hs} = λ(s) and Cr is the [χ(r)]-component of Ha satisfying Condition (1). In fact, χ(s) 6⊆ χ(r) holds, as χ(r) ∩ Cr = ∅ while χ(s) ∩ Cr 6= ∅. Now, from Condition (4) in the definition of hypertree decompositions it follows that, for each vertex p ∈ vertices(T ), χ(p) = nodes(λ(p)) ∩ χ(Tp). Thus, for each node Y ∈ nodes(Ha), the vertex p̄ with Y ∈ χ(p̄) that is the closest to the root of T is such that χ(p̄) = nodes(λ(p̄)). Indeed, each node X ∈ hp̄, where λ(p̄) = {hp̄}, must occur in the χ-labeling of some vertex in the subtree rooted at p̄ together with Y in order to satisfy Condition (1) in the definition of hypertree decomposition. Thus, X ∈ χ(Tp̄). Hence, for the vertex root(T ), it is trivially the case that χ(root(T )) = nodes(λ(root(T ))). Consider now an arbitrary vertex r ∈ vertices(T ) and let s be a child of r. Thus, {hs} = λ(s), for some hyperedge hs. Recall that χ(s) 6⊆ χ(r), and take any node Y ∈ hs such that Y ∈ χ(s)\\χ(r). Because of Condition (2) in the definition of hypertree decomposition, Y cannot occur in the χ-labeling of any vertex in path connecting root(T ) and r in T . Thus, s is the vertex closest to the root where Y occurs. Hence, χ(s) = nodes(λ(s)). ⋄\nProperty P2: ∀p1, p2 ∈ vertices(T ), λ(p1) 6= λ(p2).\nProof. Assume for the sake of contradiction that there are two vertices p1 and p2 such that λ(p1) = λ(p2). Because of Property P1, nodes(λ(p1)) = nodes(λ(p2)) = χ(p1) = χ(p2). Then, by Condition (2) in the definition of hypertree decomposition, each vertex p in the path between p1 and p2 is such that nodes(λ(p)) = χ(p) = χ(p1) = χ(p2) (because the hypergraph is reduced). In particular, this property holds for one vertex r ∈ vertices(T ) and for one child s of r. However, χ(r) = χ(s) is impossible as we have observed in the proof of Property P1. ⋄\nNow, we show that hyperedges of Ha one-to-one correspond to vertices of JT , and that the connectedness condition holds on JT .\nFor the first property, note that each vertex p of T corresponds to the hyperedge hp, by construction. Moreover, by Property P2, each vertex of JT is mapped to a distinct hyperedge. Thus, it remains to show that for each hyperedge h̄ ∈ edges(Ha), there is a vertex p of T such that h̄ = hp. Indeed, note that by Condition (1) of hypertree decompositions, for each hyperedge h̄ ∈ edges(Ha), there is a vertex p in T such that h̄ ⊆ χ(p). By Property P1 above, this entails that there is a hyperedge hp ∈ edges(Ha) such that hp = χ(p) and h̄ ⊆ hp. However, since Ha is reduced, h̄ = hp holds.\nWe eventually observe that the connectedness condition holds on JT . Indeed, if a node Y ∈ nodes(Ha) occurs in a vertex hp of JT , i.e., Y ∈ hp, we have that Y ∈ χ(p) holds by Property P1. By Condition (2) of hypertree decompositions, the set {p ∈ vertices(T ) | Y ∈ χ(p)} induces a (connected) subtree of T . It follows that the set {hp ∈ edges(Ha) | Y ∈ hp} induces a connected subtree of JT .\nCOMPONENTS 7→SUBTREES. Let us now complete the proof by showing that the join tree JT also satisfies the part COMPONENTS 7→SUBTREES in Definition 3.6. Recall that C⊤(h) is defined as nodes(Ha) for the root h, and that C⊤(hs) is the unique [hr]-component with nodes(JT [h]hs) = C⊤(hs)∪(hs∩hr), where hs is a child of hr in JT [h]. In fact, to conclude the proof, we next show that, for each vertex hr in JT [h] and for each [hr]-component Cr of Ha such that Cr ⊆ C⊤(hr), there is exactly one child hs of hr such that Cr = C⊤(hs).\nLet Cr be an [hr]-component such that Cr ⊆ C⊤(hr). Assume, first, that hr is the child of a vertex hp ∈ edges(Ha) of JT [h], i.e., hr is distinct from the root h of JT [h]. Then, because of the part SUBTREES 7→COMPONENTS above, we have that nodes(JT [h]hr) = C⊤(hr) ∪ (hp ∩ hr). In particular, this entails that nodes(JT [h]hr) ⊇ C⊤(hr). Thus, nodes(JT [h]hr) ⊇ Cr. Then, since hr ∩ Cr = ∅, we have that for each node X ∈ Cr, X occurs in some vertex of a subtree of JT [h]hr rooted at a child hs(X) of hr, with X ∈ hs(X). In particular, because of the connectedness condition of join trees, there is precisely one such subtree, since X 6∈ hr. Now, we can apply the part SUBTREES 7→COMPONENTS above on hs(X) to observe that there is exactly one [hr]-component C⊤(hs) of Ha such that nodes(JT [h]hs(X)) = C⊤(hs) ∪ (hr ∩ hs(X)). However, since X 6∈ hr, X ∈ C⊤(hs) holds. Hence, Cr = C⊤(hs).\nFinally, consider now the case where hr is the root of JT [h], i.e., hr = h. Then, let Cr be an [hr]-component and let X ∈ Cr . Let hX be the hyperedge that is the closest to the root of JT [h] and such that X ∈ hX . Note that because of the connectedness condition, there is precisely one such hyperedge hX . By using the same line of reasoning as above, it follows that the child hs(X) of h such that X occurs in some vertex of JT [h]hs(X) is the only one satisfying the condition in the statement. ✷"
    }, {
      "heading" : "3.3 Preservation of Components",
      "text" : "In the light of Theorem 3.7, the connectivity of an arbitrary tree projection Ha for H1 (with respect to some hypergraph H2) is characterized in terms of its components. We next show that it can be also characterized in terms of the components of the original hypergraph H1. This is formalized in the following two lemmas.\nLemma 3.8 Let H1 and Ha be two hypergraphs with the same set of nodes such that H1 ≤ Ha. Then, for each h ∈ edges(Ha) and [h]-component C1 in H1, there is an [h]-component Ca of Ha such that C1 ⊆ Ca.\nProof. Since H1 ≤ Ha, for each hyperedge h′ ∈ edges(H1), there is a hyperedge ha ∈ edges(Ha) such that h1 ⊆ ha. Then, for any set of nodes h and any [h]-component C1 of H1, it follows that C1 is also [h]-connected in Ha. Hence, there is an [h]-component Ca of Ha such that C1 ⊆ Ca. ✷\nLemma 3.9 Let H1 and Ha be two hypergraphs with the same set of nodes such that H1 ≤ Ha. Then, for each h ∈ edges(Ha) and [h]-component Ca in Ha, there are C11 , ..., C n 1 [h]-components of H1 such that Ca = ⋃n i=1 C i 1.\nProof. After Lemma 3.8, the result follows from the fact that H1 and Ha are defined over the same set of nodes. Indeed, let X be a node in Ca. Then, since X 6∈ h, X belongs to an [h]-component C(X) of H1, and because of Lemma 3.8, C(X) ⊆ Ca holds. Thus, Ca = ⋃\nX∈Ca C(X). ✷\nAt a first sight, however, since each hyperedge in H1 is contained in a hyperedge of Ha, one may naturally be inclined at thinking that such a “bigger” hypergraphHa is characterized by a higher connectivity, because some nodes that are not (directly) connected by any edge in H1 may be included together in some edge of Ha. Indeed, in general, for any given set of nodes h, evaluating [h]-components of H1 gives proper subsets of the analogous components evaluated in Ha. Next, we show that this is not the case if minimal tree projections are considered.\nTheorem 3.10 Let Ha be a minimal tree projection of H1 w.r.t. H2. Then, for each hyperedge h ∈ edges(Ha), C is an [h]-component of Ha ⇔ C is an [h]-component of H1.\nProof. Let Ha be a minimal tree projection of H1 with respect to H2. Let h be in edges(Ha), and assume, by contradiction, that: C is an [h]-component of Ha 6⇔ C is an [h]-component of H1. From Lemma 3.8 and Lemma 3.9, it follows that there is an [h]-component Ca in Ha, and n > 1 [h]-components C11 , ..., C n 1 of H1 such that Ca = ⋃n i=1 C i 1. See Figure 2, for an illustration.\nLet H be the set of all hyperedges of Ha that intersect Ca, i.e., H = {ha | ha ∈ edges(Ha) ∧ ha ∩ Ca 6= ∅}, and consider the hypergraph H′a defined over the same set of nodes of Ha and such that:\nedges(H′a) = (edges(Ha)−H) ∪ {ha ∩ (C i 1 ∪ h) | ha ∈ H, i ∈ {1, . . . , n} }.\nNote that, since Ca = ⋃n i=1 C i 1 with n > 1, there is at least a hyperedge h̄a ∈ edges(Ha) such\nthat h̄a ∩ (Ci1 ∪ h) ⊂ h̄a, for some [h]-component C i 1. Thus, H ′ a 6= Ha. Let in fact h1 be any hyperedge in edges(H′a) \\ edges(Ha). Then, h1 ∈ {ha ∩ (C i 1 ∪ h) | ha ∈ H, i ∈ {1, . . . , n} }. That is, h1 = ha∩(C ī1∪h) for some hyperedgeha ∈ H and [h]-componentC ī 1 of H1. In particular, note that the case where h1 = ha = ha∩(C ī1∪h) is impossible, for otherwise we would have h1 ∈ edges(Ha). Thus, h1 = ha∩(C ī1∪h) ⊂ ha, which in turn entails that ha∩(C i 1∪h) ⊂ ha, for each [h]-componentC i 1. This property suffices to show that ha 6∈ edges(H′a). Indeed, assume by contradiction that ha ∈ edges(H ′\na). As ha ∈ H , there is a hyperedgeh′a ∈ H such that ha = h ′ a∩(C i 1∪h) for some [h]-componentC i 1, and therefore such that ha ⊆ h′a. However, since ha∩(C i 1∪h) ⊂ ha, we conclude that ha 6= h ′\na and, hence, ha ⊂ h′a. This is impossible since Ha is a minimal tree projection, and thus a reduced hypergraph by Fact 3.4. It follows that H′a ⊂ Ha, because for (the generic) hyperedge h1 ∈ (edges(H ′\na) \\ edges(Ha)) there exists ha ∈ (edges(Ha) \\ edges(H′a)) such that h1 ⊂ ha.\nWe now claim that the following three properties hold on H′a.\nProperty P1: H′a ≤ H2.\nProof. We have to show that for each hyperedge h′a ∈ edges(H ′ a), there is a hyperedge h2 ∈ edges(H2) such that h′a ⊆ h2. To this end, observe that for each hyperedge h ′ a ∈ edges(H ′\na), there is by definition of edges(H′a) a hyperedge ha ∈ edges(Ha) such that h ′\na ⊆ ha. Then, since Ha is a tree projection of H1 w.r.t. H2, there is in turn a hyperedge h2 ∈ edges(H2) such that ha ⊆ h2. That is, h′a ⊆ h2, for some h2 ∈ edges(H2). ⋄\nProperty P2: H1 ≤ H′a.\nProof. We have to show that for each hyperedge h1 ∈ edges(H1), there is a hyperedge h′a ∈ edges(H′a) such that h1 ⊆ h ′\na. Let h1 be a hyperedge of H1. Since Ha is a tree projection of H1, we have that there is a hyperedge ha ∈ edges(Ha) such that h1 ⊆ ha. In the case where h1 ∩Ca = ∅, we distinguish two subcases. Either h1 ⊆ h, or h1 \\ h 6= ∅. In the former scenario, we have just to observe that h occurs in edges(H′a), as h ∩ Ca = ∅, and hence h = ha. In the latter scenario, ha ∩ Ca must be empty, as ha is [h]-connected in Ha and h1 ⊆ ha. Again, we have that ha occurs in edges(H′a). Consider now the case where h1 ∩ Ca 6= ∅, and let X ∈ h1 ∩ Ca. Because of Lemma 3.9, X must belong to an [h]-component Ci1 in H1. Then, edges(H′a) contains, by definition, the hyperedge h ′ a = ha ∩ (C i 1 ∪h). In fact, since h1 ⊆ ha, we also have h1 ∩ (Ci1 ∪ h) ⊆ h ′ a. In order to conclude that h1 ⊆ h ′\na, it remains to observe that all the vertices in h1 \\ h are contained in Ci1 since h1 \\ h is [h]-connected in H1 and X ∈ h1 ∩C i 1. ⋄\nProperty P3: H′a is acyclic.\nProof. The proof of this property is rather technical, and hence we find convenient to illustrate its main ideas here, as they shed some light on the connectivity of minimal tree projections. From Theorem 3.7, we know that Ha has an Ha-component tree rooted at h, say JT [h]. For such a join tree, there is a one-to-one correspondence between components of Ha and subtrees of JT [h]. Accordingly, any such a component C, denote by JT [h]C the subtree rooted at the child hs of h such that C = C⊤(hs). Then, the line of the proof is to apply a normalization procedure\nover the subtree JT [h]Ca which is in charge of decomposing Ca, in order to build the subtrees JT ′[h]C1\n1\n,...,JT ′[h]Cn 1 , each one being in charge of decomposing an [h]-component in H1. An illustration is reported in Figure 2. The resulting tree JT ′[h] can be shown to be a join tree for H′a, thus witnessing that H ′ a is acyclic.\nLet us now prove formally the result. Recall that Ha is reduced because of Fact 3.4. From Theorem 3.7, we know that Ha has an Ha-component tree rooted at h, say JT [h]. For such a join tree, there is a one-to-one correspondence between components of Ha and subtrees of JT [h]. Accordingly, for any such a component C, denote by JT [h]C the subtree rooted at the child hs of h such that C = C⊤(hs).\nLet Ca, C1a , ..., C m a be the [h]-components of Ha, where Ca is the component such that Ca = ⋃n\ni=1 C i 1, with n > 1 and C 1 1 , ..., C n 1 are [h]-components of H1. Based on JT [h], we shall build\na tree JT ′[h] whose vertices are the hyperedges of H′a. In particular, JT ′[h] is a built as follows:\n– The root of JT ′[h] is the hyperedge h.\n– Each subtree JT [h]Ci a occurs in JT ′[h] as a subtree of h. – For each [h]-component Ci1 ⊆ Ca in H1, JT ′[h] contains, as a subtree of h, the subtree\nJT ′[h]Ci 1 that is built from JT [h]Ca by replacing each hyperedge ha with the hyperedge ha ∩ (Ci1 ∪ h).\n– No further vertices are in JT ′[h].\nNext, we show that JT ′[h] is a join tree. Actually, JT ′[h] may contain two vertices associated to the same hyperedge of H′a (because of different original hyperedges that may lead to the same intersections). Thus, formally JT ′[h] cannot be precisely a join tree, and we shall rather show that it is a hypertree decomposition of width 1 where χ(p) = nodes(λ(p)), for each vertex p, which of course entails the acyclicity of the considered hypergraph. However, for the sake of presentation, we keep the notation of join trees, avoiding the use of the χ and λ-labelings, and we allow that JT ′[h] contains two vertices associated with the same hyperedge of H′a.\n(i) For each vertex h′ in JT ′[h], h′ is in edges(H′a). Let h ′ be in JT ′[h]. In the case where h′ = h, or h′ occurs in a subtree of the form JT ′[h]Ci a , then h′ precisely coincides with a hyperedge of Ha such that h′ 6∈ H . Thus, h′ also belongs to edges(H′a), by definition. If h ′ occurs in a subtree of the form JT ′[h]Ci 1 , then h′ = ha ∩ (Ci1 ∪h), by construction of JT ′[h], for some hyperedge ha in JT [h]Ca which is, hence, such that h 6= ha. In particular, because of Theorem 3.7, ha \\ h ⊆ Ca. The case ha ⊆ h (actually, ha ⊂ h) is impossible, since ha and h are both hyperedges of Ha, which is minimal and hence reduced by Fact 3.4. Thus, ha ∩ Ca 6= ∅ and hence ha ∈ H . Then, the hyperedge h′ = ha ∩ (Ci1 ∪ h) is in edges(H ′ a).\n(ii) For each hyperedge h′ in edges(H′a), h ′ is in JT ′[h]. Let h′ 6= h be a hyperedge of H′a; indeed, for h′ = h the property trivially holds. If h′ is also a hyperedge of Ha, then either h′ 6∈ H , or h′ ∈ H and there is an [h]-component Ci1 with h\n′ = h′ ∩ (Ci1 ∪ h), i.e., with h′ ⊆ (Ci1 ∪ h). If h\n′ 6∈ H , then h′ ∩ Ca = ∅. Then, we have that h′ ∩ Cia 6= ∅ for some [h]-component Cia 6= Ca. Hence, due to Theorem 3.7, h ′ occurs in JT [h]Ci a . The result then follows since JT [h]Ci a\nalso occurs as a subtree of JT ′[h]. Consider now the case where h′ ∈ H and there is an [h]-componentCi1 with h ′ = h′∩ (Ci1∪h), i.e., with h ′ ⊆ (Ci1∪h). Since h\n′ 6⊆ h, it holds that h′ ∩Ci1 6= ∅ and hence, due to Lemma 3.9, h ′ ∩Ca 6= ∅. Then, h′ occurs in JT [h]Ca\nbecause of Theorem 3.7 and, by construction, h′ occurs in JT ′[h]Ci 1 . Finally, assume that h′ is not a hyperedge of Ha. Thus, h′ = ha ∩ (Ci1 ∪ h), for some hyperedge ha ∈ edges(Ha) and [h]-component Ci1 with ha ∩ Ca 6= ∅ and ha 6⊆ (C i 1 ∪ h). Due to Theorem 3.7, ha occurs in JT [h]Ca . Then, by construction, h ′ occurs in JT ′[h]Ci\n1\n.\n(iii) The connectedness condition holds on JT ′[h]. Let h′a1 and h ′ a2 be two hyperedges in H′a such that h′a2 occurs in the subtree of JT ′[h] rooted at h′a1 . Since subtrees of the form JT [h]Cia are not altered in the transformation, we can focus on the case where h′a2 occurs in some subtree of the form JT ′[h]Ci\n1\nand where either h′a1 = h or h ′ a1 occurs in the same subtree. In fact, h′a2 (resp.,\nh′a1) belonging to JT ′[h]Ci\n1\nentails that h′a2 = ha2 ∩ (C i 1 ∪ h) (resp., h ′ a1 = ha1 ∩ (C i 1 ∪ h)), for\nsome hyperedge ha2 ∈ edges(Ha) (resp., ha1 ∈ edges(Ha)). Note that to deal uniformly with the two cases above, if h′a1 = h, then we can just set ha1 = h. Now, let Y be a node in h ′ a1 ∩h′a2 . Then, Y belongs to ha2 ∩ ha1 . Consider a hyperedge h ′ a in the path between h ′ a1 and h′a2 . Again, h′a belonging to JT ′[h]Ci\n1\nentails that h′a = ha ∩ (C i 1 ∪ h), where ha is an edge occurring in the\npath between ha1 and ha2 in JT [h]. Since JT [h] is a join tree, Y also occurs in ha, and hence Y is in h′a. ⋄\nIn the light of the above properties, H′a is a tree projection of H1 w.r.t. H2 such that H ′ a ⊂ Ha, thereby contradicting the fact that Ha is a minimal tree projection. ✷"
    }, {
      "heading" : "3.4 Connected Tree Projections",
      "text" : "We next present another interesting property of minimal tree projections: they always admit join trees in a desirable form that we call connected. Such a form is based on the well known notion of connected decomposition defined for the treewidth (see, e.g., [11]). Let 〈T, χ〉 be a tree decomposition of a graph G. For any pair of adjacent vertices pr and ps of T , let Tr and Ts be the two connected subtrees obtained from T by removing the edge connecting pr and ps. Then, 〈T, χ〉 is connected if the subgraphs induced by the nodes covered be the χ-labeling in Tr and in Ts, respectively, are connected, for each pair of vertices pr and ps.\nNext, we define a natural extension of this notion to the more general framework of tree projections of hypergraph pairs.\nDefinition 3.11 A tree projection Ha of H1 w.r.t. H2 is connected if it has an H1-connected join tree, i.e., a join tree JT with the following property: For each pair of adjacent vertices hr, hs of JT , the sub-hypergraph of H1 induced by the nodes in nodes(JT [hr]hs) is [∅]-connected. ✷\nNote that the novel notion coincides with the original one whenever we considers the treewidth method, that is, whenever we look for tree projections of pairs of the form (H,Htk), for any fixed natural number k > 0, where Htk is the hypergraph whose hyperedges are all possible sets of at most k + 1 nodes in H.\nExample 3.12 The tree projection Ha of H1 w.r.t. H2 reported in Figure 1 is not connected, because it has no H1-connected join trees.\nFor instance, consider the join tree JTa depicted in the same figure, and let hr = {E,F,G,H, I, J,K} and hs = {A,D,E, F, J,K}. Then, the sub-hypergraph of H1 induced by nodes(JTa[hr]hs) consists of the hyperedges {D,F,E}, {K, J}, {A,B,C}, {C,D}, and {A,F},\nand thus {K, J} is clearly disconnected from the others. On the other hand, note that the join tree JT ′a for the minimal tree projection H′a reported in Figure 3 is H1-connected. ✁\nWe next show that such a connected join tree always exists for any minimal tree projection, as in the special case of the tree decomposition method. In order to establish the result, we shall exploit an algorithm, called make-it-connected, that has been described in [11] and that enjoys the following properties.\nProposition 3.13 (cf. [11]) Let 〈T, χ〉 be a width-k tree decomposition of a graph G. Then, Algorithm make-it-connected builds in polynomial time a connected width-k′ tree decomposition 〈T ′, χ′〉 of G, with k′ ≤ k, such that: (1) for each vertex p′ of T ′, there is a vertex p of T such that χ′(p′) ⊆ χ(p); and (2) if 〈T, χ〉 is not connected, then there is a vertex p̄ of T such that χ(p̄) 6= χ′(p′), for each vertex p′ of T ′.\nTheorem 3.14 If Ha is a minimal tree projection of H1 w.r.t. H2, then any join tree JT for Ha is H1-connected.\nProof. Assume that Ha is a minimal tree projection of H1 w.r.t. H2, hence from Fact 3.5 nodes(H1) = nodes(Ha). Let JT be a join tree for Ha, and let 〈T, χ〉 be a labeled tree whose vertices one-to-one correspond with the vertices of JT . In particular, for each hyperedge h ∈ edges(Ha), T contains the vertex ph, which is moreover such that χ(ph) = h. From the connectedness property of join trees and the fact that H1 ≤ Ha, it immediately follows that 〈T, χ〉 is a tree decomposition of (the Gaifman graph of) H1. Assume now, for the sake of contradiction, that JT is not H1-connected. Then, 〈T, χ〉 is not connected too. Thus, we can apply algorithm make-it-connected on 〈T, χ〉, which produces the connected tree decomposition 〈T ′, χ′〉, with T ′ = (N ′, E′) of (the Gaifman graph of) H1.\nLet H′a be the acyclic hypergraph such that nodes(H ′ a) = nodes(Ha) and edges(H ′ a) = {χ ′(p′) |\np′ ∈ N ′}, and let H′′a be the reduced hypergraph obtained from H ′ a by removing its hyperedges that are proper subsets of some hyperedge in H′a. Therefore, we have edges(H ′′ a) ⊆ edges(H ′ a) and H ′\na ≤ H′′a . Of course, H ′′ a is acyclic too. Moreover, we claim that H ′′\na ⊆ Ha. Indeed, for each hyperedge χ′(p′) ∈ edges(H′′a) \\ edges(Ha), by Proposition 3.13.(1), there is a hyperedge χ(p) ∈ edges(Ha) such that χ′(p′) ⊆ χ(p). Moreover, χ(p) cannot occur in edges(H′′a), as H ′′ a is reduced. Hence, χ(p) is\nin edges(Ha) \\ edges(H′′a), and we actually have χ ′(p′) ⊂ χ(p). That is, H′′a is an acyclic hypergraph with H′′a ⊆ Ha. Now, observe that since 〈T ′, χ′〉 is a tree decomposition of (the Gaifman graph of) H1 and since H′′a ⊆ Ha, we have H1 ≤ H ′ a ≤ H ′′ a ≤ Ha ≤ H2. Thus, H ′′\na is a tree projection of H1 w.r.t. H2. However, by Proposition 3.13.(2), there is a vertex p̄ of T such that χ(p̄) 6= χ′(p′), for each vertex p′ of T ′. Thus, H′′a 6= Ha. Hence, H ′′ a is a tree projection for (H1,H2) such that H ′′\na ⊂ Ha, which contradicts the minimality of Ha. ✷\nEventually, by exploiting Fact 3.3, we get the following corollary.\nCorollary 3.15 (H1,H2) has a tree projection if, and only if, (H1,H2) has a connected tree projection.\nRemark 3.16 A different notion of connected decomposition has been introduced in [29] for the special case of (generalized) hypertree decompositions, in order to speed-up their computation. According to [29], a (generalized) hypertree decomposition HD = 〈T, χ, λ〉 is connected if the root r of T is such that |λ(r)| = 1, and for each pair of nodes p and s, with s child of p in T , and for each h ∈ λ(s), h ∩ χ(s) ∩ χ(p) 6= ∅. The connected (generalized) hypertree width c(g)hw is the minimum width over all the possible connected (generalized) hypertree decompositions. Whether or not chw(H) = hw(H) for every hypergraph H was an open question [29].\nNext, we give a negative answer to this question by showing that the latter notion of connectedness gives a structural method that is weaker than the unrestricted (generalized) hypertree decomposition, even on graphs. Consider the graph Ghex in Figure 4. As shown in the same figure, there is a hypertree decomposition HDhex = 〈T, χ, λ〉 of this (hyper)graph having width 3, and thus hw(Ghex) ≤ 3. In HDhex, for each vertex p of T , χ(p) = nodes(λ(p)) holds, and thus Figure 4 shows only the λ-labeling of each vertex. Moreover, only the left branch is detailed, showing how to deal with the upper cluster of hexagons. The other subtrees are of the same form, and thus are not reported, for the sake of simplicity. Note that {0} and its child {0, 21, 42} violate the required connectedness property. In fact, it turns out that the only way to attack such hexagons is by using, at some vertex s of the decomposition tree, some nodes that are not directly connected to (the nodes occurring in) the parent vertex of s. Indeed, the reader can check there is neither a hypertree decomposition nor a generalized hypertree decomposition of Ghex that is connected according to [29] and has width 3. Thus, the following holds.\nFact 3.17 There is a graph Ghex such that cghw(Ghex) > hw(Ghex)."
    }, {
      "heading" : "3.5 Tree Projections in Normal Form",
      "text" : "We next show the main result of this section, where all the above ingredients are exploited together: all minimal tree projections have join trees in a suitable normal form. This normal form is of theoretical interest, since it can be exploited to establish further results on the setting (as its game-theoretic characterization discussed in Section 4). Moreover, it is of practical interest, since it can be used to prune the search space in solution approaches aimed at computing tree projections.\nDefinition 3.18 A join tree of a tree projection of H1 w.r.t. H2 is said in normal form if it is H1connected and it is an H1-component tree. ✷\nExample 3.19 Consider again the tree projection Ha and its join tree JTa illustrated in Figure 1. Consider the vertices hr = {E,F,G,H, I, J,K} and hs = {A,D,E, F, J,K} in\nJTa[{E,F,G,H, I, J,K}], and note that there is exactly one [hr]-component C⊤(hs) = {A,B,C,D} of H1 such that nodes(JT [h]hs) = {A,B,C,D,E, F, J,K} = C⊤(hs) ∪ (hs ∩ hr). However, Fr(C⊤(hs),H1) = {A,B,C,D,E, F} and hence hs 6⊆ Fr(C⊤(hs),H1). Thus, one condition in the (SUBTREES 7→COMPONENTS)-part of Theorem 3.20 is violated.\nIndeed, the tree projection Ha is not minimal. This is witnessed by the tree projection H′a for (H1,H2) that is reported on the left of Figure 3 and that is properly contained in Ha. A join tree JT ′a for H′a is reported on the right of the same figure. The careful reader may check that JT ′\na satisfies all conditions in Theorem 3.20. ✁\nTheorem 3.20 (Normal Form) Let Ha be a minimal tree projection of H1 w.r.t. H2. For any hyperedge h ∈ edges(Ha), there is a join tree for Ha in normal form rooted at h.\nProof. Let h ∈ edges(Ha) be any hyperedge of the tree projection Ha. Since minimal tree projections are reduced, Theorem 3.7 entails that Ha has a join tree JT that is an Ha-component tree rooted at h. Again from minimality and Theorem 3.10, we get that [h′]-components in Ha and [h′]-components in H1 do coincide, for each h′ ∈ edges(Ha). Thus, JT has the following properties:\nSUBTREES 7→COMPONENTS. For each vertex hr of JT [h] and each child hs of hr, there is exactly one [hr]-component C⊤(hs) of H1 such that nodes(JT [h]hs) = C⊤(hs) ∪ (hs ∩ hr). Moreover, hs ∩ C⊤(hs) 6= ∅ holds.\nCOMPONENTS 7→SUBTREES. For each vertex hr of JT [h] and each [hr]-component Cr of H1 such that Cr ⊆ C⊤(hr), there is exactly one child hs of hr such that Cr = C⊤(hs).\nHence, in order to prove that JT is an H1-component tree, it remains to show that, for each vertex hr of JT [h] and each child hs of hr, hs ⊆ Fr(C⊤(hs),H1) holds. Assume, for the sake of contradiction, that there is a vertex hr and a child hs of hr such that hs ⊆ Fr(C⊤(hs),H1) does not hold. From Theorem 3.7, we know that hs ⊆ Fr(C⊤(hs),Ha) holds. It follows that there exists a non-empty set W ⊆ hs \\ C⊤(hs) of nodes such that X 6∈ Fr(C⊤(hs),H1), for each X ∈ W . Moreover, as nodes(JT [h]hs) = C⊤(hs) ∪ (hs ∩ hr), we have that W ⊆ hs ∩ hr. Consider the hypergraph H ′ a obtained from Ha by replacing each hyperedge h̄ occurring in JT [h]hs with h̄ \\ W , and note that H′a ⊂ Ha. Of course, the tree JT ′ obtained from JT by replacing any such h̄ with h̄ \\ W is a join\ntree for H′a. Finally, H ′ a is again a tree projection for (H1,H2) because every hyperedge of H1 is still covered by some vertex in JT ′. Indeed, there is no hyperedge h ∈ edges(H1) such that both h∩W 6= ∅ and h∩C⊤(hs) 6= ∅, by construction of W . This contradicts the fact that Ha is a minimal tree projection for (H1,H2).\nFinally, from Theorem 3.14, JT is H1-connected. ✷"
    }, {
      "heading" : "4 Game-Theoretic Characterization",
      "text" : "The Robber and Captain game is played on a pair of hypergraphs (H1,H2) by a Robber and a Captain controlling some squads of cops, in charge of the surveillance of a number of strategic targets. The Robber stands on a node and can run at great speed along the edges of H1; however, she is not permitted to run trough a node that is controlled by a cop. Each move of the Captain involves one squad of cops, which is encoded as a hyperedge h ∈ edges(H2). The Captain may ask any cops in the squad h to run in action, as long as they occupy nodes that are currently reachable by the Robber, thereby blocking an escape path for the Robber. Thus, “second-lines” cops cannot be activated by the Captain. Note that the Robber is fast and may see cops that are entering in action. Therefore, while cops move, the Robber may run trough those positions that are left by cops or not yet occupied. The goal of the Captain is to place a cop on the node occupied by the Robber, while the Robber tries to avoid her capture.\nFor a comparison, observe that this game is somehow in the middle between the Robber and Marshals game of [15], where the marshals occupy a full hyperedge at each move, and the Robber and Cops game of [28], where each cop stands on a vertex and thus, if there are enough cops, any subset of any edge can be blocked at each move. Instead, the Captain cannot employ “second-lines” cops, but only cops whose positions are under possible Robber attacks.\nExample 4.1 Consider the Robber and Captain game played on the pair (H1,H2) of hypergraphs depicted in Figure 1, and the sequences of moves illustrated in Figure 5.\nInitially, the Robber stands on the node K , and each other node is reachable. The Captain selects the squad {E,F,G,H, I, J,K} and uses the three cops blocking E, F , and G. The Robber sees the cops and, while they enter in action, is fast enough to run on A. Note that, when the Robber is on A and nodes E, F , and G are blocked by the Captain, the Robber can move over {A,B,C,D}, while {E,F} are also under possible Robber attacks because they are adjacent to her escape space. All other nodes are no longer reachable by the Robber and no longer depicted. Hence, the Captain might ask cops to occupy some of the nodes in {A,B,C,D,E, F}, provided they are covered by some hyperedge. In fact, the strategy of the Captain is to select the hyperedge/squad {A,D,E, F, J,K}, and then to use those cops in this squad that block nodes A, D, E, and F . During this move of the cops, the potential escape door {E,F} for the Robber is still blocked, and hence its available space shrinks. Indeed, during the move of the Captain, the Robber can just move either on B or on C. Finally, the Captain uses the squad {A,B,C,D,H} and order its cops to move to A, B, C, and D, thereby capturing the Robber, as its potential escape door {A,D} remains blocked by the cops. ✁\nIn the rest of the section, we formalize and analyze the game. To this end, we intensively use the notions and the notations given in the previous section, by implicitly applying them to the hypergraph H1, unless stated otherwise.\nDefinition 4.2 (R&C Game) Let H1 and H2 be two hypergraphs. The Robber and Captain game on (H1,H2) (short: R&C(H1,H2) game) is formalized as follows. A position for the Captain is a set M\nof vertices where the cops stand such that M ⊆ h2, for some hyperedge (squad) h2 ∈ edges(H2). A configuration is a pair (M, v), where M is a position for the Captain, and v ∈ nodes(H1) is the node where the Robber stands. The initial configuration is ({}, v0), where v0 is a node arbitrarily picked by the Robber.\nLet (Mi, vi) be the configuration at step i. This is a capture configuration, where the Captain wins, if vi ∈ Mi. Otherwise, the Captain activates the cops in a novel position Mi+1 such that: ∀X ∈ Mi+1, X [Mi]-touches vi (in H1). Then, the Robber selects some available node vi+1 (if any) such that there is a [Mi ∩Mi+1]-path from vi to vi+1 (in H1). If the game continues forever, the Robber wins. ✷\nNote that it does not make sense for the Captain to assume that the Robber is on a particular node, given the ability of the Robber of changing positions before the cops land. Thus, given a configuration (Mi, vi), we may assume w.l.o.g. that the next Captain’s move is only determined by the [Mi]-component (of H1) that contains vi, rather than by vi itself. And, accordingly, positions can equivalently be written as (Mi, Ci), where Ci is an [Mi]-component. In this case, capture configurations have the form (M, {}), and the initial configuration has the form ({}, nodes(H1)).\nIn the following, assume that a R&C(H1,H2) game is given. Moreover recall that, for any component C (of H1), Fr(C,H1) is the frontier of C, i.e., (by omitting hereafter H1, which is understood) the set Fr(C) = nodes(edges(C)) = C ∪ {Z | ∃X ∈ C, h ∈ edges(H1) s.t. {X,Z} ⊆ h}. Then, observe that the moves of the Captain are confined in the frontier of the current component where the Robber stands.\nFact 4.3 Let Mi and Mi+1 be positions for the Captain and let Ci be an [Mi]-component. Then, ∀X ∈ Mi+1, X [Mi]-touches Ci if, and only if, Mi+1 ⊆ Fr(Ci).\nProof. In fact, a node X is in Fr(Ci) if, and only if, either X ∈ Ci, or X ∈ Mi and there is a node Z ∈ Ci with {X,Z} ⊆ h, for some edge h in edges(H1). But, this condition precisely coincides with the definition that X [Mi]-touches Ci. ✷\nDefinition 4.4 (Strategies) A strategy σ for R&C(H1,H2) is a function that encodes the moves of the Captain, i.e., given a configuration (Mi, Ci), with Ci 6= ∅, σ returns a position Mi+1 such that Mi+1 ⊆ Fr(Ci).\nA game-tree for σ is a rooted tree T (σ) defined over configurations as follows. Its root is the configuration (∅, nodes(H1)). Let (Mi, Ci) be a vertex in T (σ) and let Mi+1 = σ(Mi, Ci).3 Then, (Mi, Ci) has exactly one child (Mi+1, Ci+1), for each [Mi+1]-component Ci+1 such that Ci ∪Ci+1 is [Mi ∩Mi+1]-connected; we call such a Ci+1 an [(Mi, Ci),Mi+1]-option for the Robber. If there is no [(Mi, Ci),Mi+1]-option, then (Mi, Ci) has exactly one child (Mi+1, {}). No further edge or vertex is in T (σ).\nThen, σ is a winning strategy if T (σ) is a finite tree. Moreover, define a position Mi+1 to be a monotone move of the Captain in (Mi, Ci), if for each [(Mi, Ci),Mi+1]-option Ci+1, Ci+1 ⊆ Ci. We say that σ is a monotone strategy if, for each edge from (Mi, Ci) to (Mi+1, Ci+1), it holds that Mi+1 is a monotone move in (Mi, Ci). ✷\nExample 4.5 Consider again the exemplification of the Robber and Captain in Figure 5. In particular, the bottom-right part of the figure depicts a game-tree associated with a winning strategy: The Captain initially moves on {E,F,G}, and there are two connected components available to the Robber, namely {A,B,C,D} and {H, I, J,K}. The left branch of the tree illustrates the strategy when the Robber goes into the component {A,B,C,D}. Note that this branch precisely corresponds to the moves that are discussed in Example 4.1. The right branch addresses the case where the Robber goes into the component {H, I, J,K}. In both cases, the Captain will eventually capture the Robber. Observe that this winning strategy is monotone. ✁"
    }, {
      "heading" : "4.1 Monotone vs Non-monotone Strategies",
      "text" : "In this section, we show that there is no incentive for the Captain to play a strategy σ that is not monotone, since it is always possible to construct and play a monotone strategy σ′ that is equivalent to σ, i.e., such that σ′ is winning if, and only if, σ is winning. This crucial property conceptually relates our game with the Robber and Cops game characterizing the treewidth [28], and differentiates it from most of the hypergraph-based games in the literature, in particular, from the Robber and Marshals game, whose monotone strategies characterize hypertree decompositions [15], while non-monotone strategies do not correspond to valid decompositions [1].\n3Note the little abuse of notation: σ(Mi, Ci) instead of σ((Mi, Ci)).\nWe point out that the proof below does not apply to the traditional Robber and Cops game, because in our setting cops can be placed just on the positions that are reachable by the Robber. As a matter of fact, our techniques are substantially different from those used to show that non-monotonic moves provide no extra-power in the Robber and Cops game. We start by illustrating some properties of the novel game.\nIn the following, assume that σ and T (σ) are a strategy and a game tree for it, respectively. Moreover recall that, for any component C (of H1), ∂(C) denotes the border of C (in H1), i.e., the set Fr(C) \\C. Then, let the escape-door of the Robber in vi = (Mi, Ci) when attacked with Mi+1 be defined as ED(vi,Mi+1) = ∂(Ci)\\Mi+1. Note that this is equivalent to state that ED(vi,Mi+1) = Mi∩Fr(Ci)\\ Mi+1, because Ci is an [Mi]-component. Consider for instance Example 4.1 at the configuration v1 = ({E,F,G}, {A,B,C,D}), when the Robber is attacked by the Captain with the cops {A,D,E, F}. In this case, the frontier is Fr({A,B,C,D}) = {A,B,C,D,E, F}, hence the escape-door is {E,F} \\ {A,D,E, F} = ∅.\nIn the following lemma, we show that this set precisely characterizes those vertices trough which the Robber may escape from the current component Ci, when the Captain changes her position from Mi to Mi+1.\nLemma 4.6 Let Mi and Mi+1 be positions for the Captain, let Ci be an [Mi]-component, and let vi = (Mi, Ci). Then, Ci+1 is a [vi,Mi+1]-option if, and only if, Ci+1 is an [Mi+1]-component with Ci+1 ∩ (Ci ∪ ED(vi,Mi+1)) 6= ∅.\nProof. Recall from Definition 4.4 that Ci+1 is an [(Mi, Ci),Mi+1]-option if Ci+1 is an [Mi+1]-component such that Ci+1 ∪Ci is [Mi+1 ∩Mi]-connected.\n(if-part) Assume that Ci+1 is an [Mi+1]-component with Ci+1 ∩ (Ci ∪ ED(vi,Mi+1)) 6= ∅. Since Ci+1 (resp., Ci) is an [Mi+1]-component (resp., [Mi]-component), we have that Ci+1 (resp., Ci) is contained in an [Mi+1 ∩Mi]-component, say C′i+1 (resp., C ′\ni). Therefore, if Ci+1 ∩ Ci 6= ∅, we immediately can conclude that Ci+1 ∪ Ci is [Mi+1 ∩Mi]-connected, with C′i+1 = C ′\ni . Thus, let us consider the case where Ci+1 ∩ Ci = ∅ and, hence, Ci+1 ∩ ED(vi,Mi+1) 6= ∅. Consider now pi+1 ∈ Ci+1∩ED(vi,Mi+1). By definition of ED(vi,Mi+1), pi+1 belongs in particular to Mi∩Fr(Ci)\\Mi+1. Thus, pi+1 6∈ Mi+1 ∩ Mi. However, pi+1 ∈ Ci+1 and pi+1 ∈ Fr(Ci). From the latter, we have that there is a node Z ∈ Ci and a hyperedge h1 ∈ edges(H1) such that {pi+1, Z} ⊆ h1. It follows that there is an [Mi+1 ∩Mi]-path from pi+1 ∈ Ci+1 to Z ∈ Ci. Thus, Ci+1 ∪ Ci is [Mi+1 ∩Mi]-connected.\n(only-if-part) Assume that Ci+1 is an [Mi+1]-component such that Ci+1 ∪ Ci is [Mi+1 ∩Mi]-connected. Consider the case where Ci+1 ∩ Ci = ∅. Then, there is a node pi+1 ∈ Mi ∩ Fr(Ci) such that pi+1 ∈ Ci+1. Thus, pi+1 6∈ Mi+1. It follows that pi+1 ∈ Mi ∩ Fr(Ci) \\Mi+1, and hence Ci+1 ∩ ED(vi,Mi+1) 6= ∅. ✷\nMoreover, we next characterize monotone moves based on escape-doors.\nLemma 4.7 Let Mi and Mi+1 be positions for the Captain, let Ci be an [Mi]-component, and let vi = (Mi, Ci). Then, ED(vi,Mi+1) = ∅ if, and only if, for each [vi,Mi+1]-option Ci+1, Ci+1 ⊆ Ci.\nProof. (if-part) Assume that ∀ [vi,Mi+1]-option Ci+1, Ci+1 ⊆ Ci. Moreover, assume for the sake of contradiction that ED(vi,Mi+1) 6= ∅, and let X ∈ ED(vi,Mi+1) = Mi ∩Fr(Ci) \\Mi+1. In particular note that X 6∈ Mi+1, from which we conclude that there must be an [Mi+1]-component Ci+1 such that X ∈ Ci+1. Thus, X ∈ Ci+1 ∩ED(r,Mi+1) and hence we can apply Lemma 4.6 to conclude that Ci+1 is a [vi,Mi+1]-option. However, X is not in Ci, since X belongs to Mi (and Ci is an [Mi]-component). Thus, Ci+1 6⊆ Ci, which is impossible.\n(only-if-part) Assume that ED(vi,Mi+1) = ∅, and for the sake of contradiction that Ci+1 is a [vi,Mi+1]-option such that Ci+1 6⊆ Ci. Let Y be a node in Ci+1 \\ Ci, and observe that there must be a node X ∈ Ci+1 ∩ Ci, because of Lemma 4.6. Consider now an [Mi+1]-path from Y to X and let Z1, Z2 be two nodes in this path such that Z1 ∈ Ci+1∩Ci, Z2 ∈ Ci+1 \\Ci, and {Z1, Z2} ⊆ h for some hyperedge h ∈ edges(H1). Note that these two nodes exist because of the properties of the endpoints Y and X . Now, it must be the case that Z2 is in (Fr(Ci) \\ Ci) ∩ Ci+1. Since Mi ⊇ Fr(Ci) \\ Ci, the latter entails that Z2 ∈ Mi ∩Fr(Ci)∩Ci+1. Finally, since Ci+1 is an [Mi+1]-component, we conclude that Z2 ∈ Mi ∩ Fr(Ci) \\Mi+1, i.e., Z2 ∈ ED(vi,Mi+1) which is impossible. ✷\nThe lemma above easily leads us to characterize monotone strategies as those ones for which there are no escape-doors.\nCorollary 4.8 The strategy σ is monotone if, and only if, for each vertex vi = (Mi, Ci) in T (σ), and for each child (Mi+1, Ci+1) of vi, ED(vi,Mi+1) = ∅.\nAssume now that σ is a non-monotone winning strategy. Armed with the above notions and results, we shall show how σ can be transformed into a monotone winning strategy, by “removing” the various escape-doors.\nLet p = (Mp, Cp) be a configuration reached in T (σ) from (∅, nodes(H1)) by a (possibly empty) succession of moves π. Assume that Mr is the move of the Captain in p and that this move is monotone, i.e., for each [p,Mr]-option C, C ⊆ Cp (note that any move in the initial configuration is monotone). Let r = (Mr, Cr) be a child of p in T (σ), and let s = (Ms, Cs) be a child of r such that Cs 6⊆ Cr, i.e., such that ED(r,Ms) 6= ∅ (by Corollary 4.8). This witnesses that Ms is a non-monotone move—see Figure 6.\nLet M ′r = Mr \\ ED(r,Ms) ⊂ Mr, and consider the function σ ′ built as follows:\nσ′(M,C) =\n{\nM ′r if (M,C) = (Mp, Cp) σ(M,C) otherwise.\nIntuitively, we are removing from r the source of non-monotonicity that was suddenly evidenced while moving to s, i.e., the fact that ED(r,Ms) 6= ∅. Next, we show that this modification does not affect the final outcome of the game.\nLemma 4.9 σ′ is a winning strategy.\nProof. By definition, σ′ leaves unchanged the configurations of σ encoded in those subtrees of T (σ) that are not rooted below p = (Mp, Cp)—see Figure 6. Therefore, throughout this proof we have only to take care of what happens in the subtree of T (σ) rooted at (Mp, Cp). Indeed, the first crucial difference between σ′ and σ occurs when the Captain plays σ′(Mp, Cp) = M ′r. Beforehand, we note that this is a “valid” move, since M ′r ⊂ Mr ⊆ Fr(Cp) (cf. Fact 4.3).\nLet C′r be the [M ′ r]-component with Cr ∪ ED(r,Ms) ⊆ C ′ r. Note that such a component exists since ED(r,Ms) ⊆ Fr(Cr) and M ′r ⊆ Mr. In addition, we claim that C ′ r is a [p,M ′\nr]-option. Indeed, Cr is a [p,Mr]-option, for which therefore Cr ∩ (Cp ∪ ED(p,Mr)) 6= ∅ holds, by Lemma 4.6. Moreover, since M ′r ⊂ Mr, ED(p,Mr) ⊆ ED(p,M ′ r) holds. Hence, given that Cr ⊆ C ′\nr, it follows that C′r ∩ (Cp ∪ ED(p,M ′ r)) 6= ∅, and again by Lemma 4.6, that C ′ r is a [p,M ′\nr]-option. Thus, there is an edge from p to (M ′r, C ′ r) in T (σ ′). In order to complete the picture, we need the following two properties.\nProperty P1: For each [p,Mr]-option C, either C ⊆ C′r or C is a [p,M ′ r]-option.\nProof. We distinguish two cases depending on whether Fr(C) ∩ ED(r,Ms) is empty or not. In the case where Fr(C) ∩ ED(r,Ms) = ∅, then C is an [M ′r]-component given that M ′\nr = Mr \\ ED(r,Ms). Moreover, by Lemma 4.6, C is an [Mr]-component such that C ∩ (Cp ∪ ED(p,Mr)) 6= ∅. Hence, it trivially holds that C∩(Cp∪ED(p,M ′r)) 6= ∅, because ED(p,Mr) ⊆ ED(p,M ′r). Thus, by Lemma 4.6, C is a [p,M ′\nr]-option. Eventually, consider the case where Fr(C) ∩ ED(r,Ms) 6= ∅, and recall that C′r is the [M ′ r]-component with Cr ∪ ED(r,Ms) ⊆ C ′\nr. Since M ′r = Mr \\ ED(r,Ms), we then have that C ⊆ C ′ r. ⋄\nProperty P2: For each [p,M ′r]-option C ′ 6= C′r, C ′ is a [p,Mr]-option.\nProof. Let C′ 6= C′r be a [p,M ′ r]-option, hence in particular an [M ′ r]-component. Since ED(r,Ms) ⊆ C′r and C ′ r is also an [M ′ r]-component, we have that C ′ ∩ ED(r,Ms) = ∅. Moreover, C′ ∩ M ′r = ∅, with M ′ r = Mr \\ ED(r,Ms). Thus, C ′ ∩ Mr 6= ∅ and, hence, C′ is also an [Mr]-component. Then, in the light of Lemma 4.6, to conclude the proof, it suffices to show that C′ ∩ (Cp ∪ ED(p,Mr)) 6= ∅ holds. In the case where C′ ∩ Cp 6= ∅, we have concluded. Therefore, consider the case where C′ ∩ Cp = ∅. In this case, as C′ is a [p,M ′r]-option and, hence, C′ ∩ (Cp ∪ ED(p,M ′r)) 6= ∅ because of Lemma 4.6, we have C\n′ ∩ ED(p,M ′r) 6= ∅. Recall now that ED(p,Mr) = Mp ∩ Fr(Cp) \\Mr and ED(p,M ′r) = Mp ∩ Fr(Cp) \\M ′\nr. Thus, ED(p,M ′r) ⊆ (Mr \\M ′ r)∪ED(p,Mr), and then ED(p,M ′\nr) ⊆ ED(r,Ms)∪ED(p,Mr) holds, as M ′r = Mr \\ ED(r,Ms) by definition of the strategy σ\n′. Given that C′ ∩ ED(r,Ms) = ∅, we immediately can conclude that C′ ∩ ED(p,M ′r) ⊆ C\n′ ∩ ED(p,Mr). However, ED(p,Mr) ⊆ ED(p,M ′r), because M ′ r ⊂ Mr, and hence, C ′ ∩ ED(p,M ′r) = C\n′ ∩ ED(p,Mr) actually holds. Given that C′ ∩ ED(p,M ′r) 6= ∅, we have therefore that C\n′ ∩ ED(p,Mr) 6= ∅. Thus, C′ ∩ (Cp ∪ ED(p,Mr)) 6= ∅. ⋄\nNote that in the light of the two results above, the function σ′ encodes a winning strategy when attacking each [p,M ′r]-option C ′ 6= C′r, since these components remain completely unchanged when\nchanging σ with σ′. Thus, as illustrated in Figure 6, all subtrees of T (σ) rooted at the children of (Mp, Cp) and attacking options outside C′r are preserved in the game-tree T (σ\n′). Hence, we have only to take care of how σ′ attacks the remaining component C′r.\nBy definition of σ′, σ′(M ′r, C ′ r) = Ms, which is a valid position since Ms ⊆ Fr(C ′ r) because of the facts that σ is a strategy (and, hence, we can apply Fact 4.3 to conclude that Ms ⊆ Fr(Cr)) and C′r ⊇ Cr, so that Fr(Cr) ⊆ Fr(C ′\nr). Moreover, the following property holds, which guarantees that the novel move is actually monotone.\nProperty P3: ED(r′,Ms) = ∅.\nProof. Assume by contradiction that ED(r′,Ms) = ∂C′r \\ Ms 6= ∅, and let X ∈ ED(r ′,Ms). From ∂C′r ⊆ M ′\nr = Mr \\ED(r,Ms), we get that X ∈ Mr \\Fr(Cr). However, this is impossible because Mr ⊆ Fr(Cr), by definition of the Robber and Captain game. ⋄\nWe next show that applying Ms to C′r leads exactly to the same strategy obtained when attacking Cr with the same move Ms. Let r′ be the position (M ′r, C ′ r).\nProperty P4: For each [r,Ms]-option C, C is an [r′,Ms]-option.\nProof. Let C be an [r,Ms]-option and, hence, an [Ms]-component such that C ∩ (Cr ∪ ED(r,Ms)) 6= ∅, by Lemma 4.6. By definition, Cr ∪ ED(r,Ms) ⊆ C′r. Hence, C ∩ C ′\nr 6= ∅. Again by Lemma 4.6, we conclude that C is a [r′,Ms]-option. ⋄\nProperty P5: For each [r′,Ms]-option C, C is an [r,Ms]-option.\nProof. Let C be an [r′,Ms]-option and, hence, an [Ms]-component such that C ∩ (C′r ∪ ED(r′,Ms)) 6= ∅, by Lemma 4.6. Our goal is to show that C is also such that C ∩ (Cr ∪ ED(r,Ms)) 6= ∅, so that C is also an [r,Ms]-option (again by Lemma 4.6). By Property P3, ED(r′,Ms) = ∅ and, hence, C ∩ C′r 6= ∅. Let Y be any vertex in C ∩ C ′\nr and assume, for the sake of contradiction, that C ∩ (Cr ∪ ED(r,Ms)) = ∅. Then, since C is an [Ms]-component, Ms separates Y from the vertices in Cr ∪ ED(r,Ms), i.e., each path connecting Y with some vertex in Cr ∪ ED(r,Ms) must include a vertex belonging to Ms. 5 Let M̄s ⊆ Ms be the set of all such vertices blocking the paths from Y to Cr ∪ ED(r,Ms). Then, consider the set {Y }∪Cr∪ED(r,Ms) which is contained inC′r. Hence, {Y }∪Cr∪ED(r,Ms) is [M ′\nr]-connected, because C′r is an [M ′ r]-component. Therefore, the separator M̄s cannot be included in M ′\nr. It follows that there is a node p ∈ M̄s \\ M ′r. Recall, now, that M ′\nr = Mr \\ ED(r,Ms). Thus, p 6∈ Mr \\ ED(r,Ms) holds. In addition, since ED(r,Ms) = Mr ∩ Fr(Cr) \\ Ms, we have that Ms ∩ ED(r,Ms) = ∅. So, given that p ∈ M̄s ⊆ Ms, we have that p 6∈ ED(r,Ms). It follows that p 6∈ (Mr \\ ED(r,Ms)) ∪ ED(r,Ms) = Mr. Now observe that Ms ⊆ Fr(Cr) (because of Fact 4.3), while Fr(Cr) \\ Cr ⊆ Mr. Then, since p 6∈ Mr and p ∈ Ms, we conclude that p is in Cr. Thus, we can assume w.l.o.g that Y is in Fr(Cr). Since Y 6∈ Cr ∪ ED(r,Ms), because of the assumption that C ∩ (Cr ∪ ED(r,Ms)) = ∅ and the fact that Y ∈ C, we conclude that Y ∈ Fr(Cr) \\ Cr, i.e., Y ∈ Mr. And, actually, Y ∈ M ′r = Mr \\ ED(r,Ms), given that Y 6∈ ED(r,Ms). But, this is impossible, since Y ∈ C′r and C ′ r is an [M ′ r]-component. ⋄\nIt follows that after the move M ′r = σ ′(Mp, Cp), the set of options available to the Robber is precisely the set that the Robber would have obtained with the move Mr. Then, because σ′ attacks these options precisely as σ, we conclude that σ′ is still a winning strategy. ✷\nExample 4.10 For an example application of the above lemma, consider Figure 7. The figure reports two hyperedges H1 and H2, plus the game-tree for a winning strategy σ. In particular, note that σ is non-monotone, because the Robber is allowed to return on A and G, after that these nodes have been previously occupied by the Captain with the move Mr = {A,C,D,E,G}. In fact, the figure also reports the strategy σ′ that is obtained from σ, by turning the non-monotone move of the Captain (in the left branch of the tree) into a monotone one according to the construction of Lemma 4.9.\nNote that the novel move of the Captain is M ′r = {C,D,E,G} = Mr \\ {A}, with {A} = ED(r′, B, C) being the escape door for the Robber. In fact, this novel move does not affect the (winning) strategy of the Captain in the right branch. ✁\nNow that the transformation from σ to σ′ has been clarified, we can state the main result of this section, which is based on the fact that minimal winning strategies have to be monotone. For a strategy σ, let ||σ|| be the size of σ measured as total number of cops used over all the vertices of T (σ), i.e., ||σ|| = ∑\n(M,C)∈T (σ) |M |. Let σ1 and σ2 be two winning strategies. We write σ1 ≺ σ2 iff ||σ1|| < ||σ2||. We say that a winning strategy σ is minimal, if there is no winning strategy σ̄ such that σ̄ ≺ σ. Note that the existence of a winning strategy always entails the existence of a minimal winning one.\nTheorem 4.11 On the R&C(H1,H2) game, the existence of a winning strategy implies the existences of a monotone winning strategy.\nProof. We claim that minimal winning strategies must be monotone. Indeed, let σ be a non-monotone winning strategy and assume, for the sake of contradiction, that σ is minimal. Consider the transfor-\nmation from σ to σ′ discussed in the proof of Lemma 4.9, by recalling that σ′ is a winning strategy. Then, by definition of σ′ and the properties pointed out in that proof, we have that σ′ ≺ σ, which is impossible. ✷\nAs a remark, the transformation in the proof of Lemma 4.9 entails the existence of a constructive method to build a monotone strategy from a non-monotone one."
    }, {
      "heading" : "4.2 Tree Projections and the R&C Game",
      "text" : "In this section, we prove that the Robber and Captain game precisely characterizes the tree projection problem, in the sense that a winning strategy for R&C(H1,H2) exists if and only if (H1,H2) has a tree projection. Hence, any decomposition technique that can be restated in terms of tree projections is in turn characterized by R&C games. In particular, if we consider pairs of the form (H1,Hk1), we get a game characterization for the notion of k-width generalized hypertree decomposition, for which such a characterization was still missing in the literature.\nFor an exemplification of the results below, the reader may consider the game-tree illustrated in the bottom-right part of Figure 5 and the tree projection in Figure 3.\nTheorem 4.12 If there is a winning strategy in R&C(H1,H2), then (H1,H2) has a tree projection.\nProof. From Theorem 4.11, if there is a winning strategy in R&C(H1,H2), there exists a monotone winning strategy, say σ, for this game. Based on σ we build a hypergraphHa(σ) where, for each vertex (M,C) in T (σ) with M 6= ∅, edges(Ha(σ)) contains the hyperedge M ; and, no further hyperedge is in edges(Ha(σ)). Note that, by construction, Ha(σ) ≤ H2, since each position M is such that M ⊆ h2 for some hyperedge h2 ∈ edges(H2). Let h1 be a hyperedge in edges(H1). Since σ is a winning strategy, we trivially conclude that the Captain has necessarily covered in a complete form h1 in some position. Thus, H1 ≤ Ha(σ). Eventually, in order to show that Ha(σ) is a tree projection, it remains to check that Ha(σ) is acyclic.\nTo this end, we build a tree JT by exploiting the strategy T (σ). JT contains all the hyperedges in edges(Ha) and, for each pair of adjacent configurations (Ms, Cs) and (Mr, Cr) in T (σ), the vertices Ms and Mr of JT are connected with an edge in JT . We claim that JT is a join tree for Ha(σ). In the following, assume (for the sake of exposition) that JT is rooted at the hyperedge encoding the first move of the Captain (e.g., {E,F,G} in the game-tree depicted in Figure 5).\nNote first that by construction of JT and since σ is monotone, each vertex of JT has exactly one parent, but the root. Thus, JT is in fact an acyclic graph, and we have just to focus on showing that the connectedness condition is satisfied.\nLet h1 and h2 be two distinct vertices in JT and let X ∈ h1 ∩ h2. Let h be the vertex in the shortest path between h1 and h2 that is the closest to the root of JT . Assume, w.l.o.g., that h2 6= h and assume that h2 is a child of h′. Because of Fact 4.3, h2 ⊆ Fr(Ch′), where Ch′ is the [h′]-component such that (h,Ch′) is in T (σ) and where σ(h,Ch′) = h2. Thus, X ∈ Fr(Ch′). Assume, for the sake of contradiction, that X does not occur in a hyperedge in the path between h1 and h2, i.e., that the connectedness condition is violated. In particular, w.l.o.g., we may just focus on the case where X 6∈ h′. Then, since h′ ⊇ Fr(Ch′) \\ Ch′ , X ∈ Fr(Ch′) and X 6∈ h′ immediately entail that X is in Ch′ . Then, because of the monotonicity of σ, X also occurs in an [h]-component Ch such that (h,Ch) ∈ T (σ). Now, observe that the scenario h1 = h is impossible. Indeed, h1 containsX that would be also contained in an [h1]-component, which is impossible by the monotonicity of the strategy. Thus, assume that h1 is the child of an edge h̄′. By using the same line of reasoning as above, we conclude\nthat X occurs in an [h]-component C̄h such that (h, C̄h) ∈ T (σ). Thus, Ch = C̄h. By definition of JT , this means that h2 and h1 occur in a subtree rooted at some child of h, which is impossible since h is in the shortest path between h1 and h2. ✷\nWe now complete the picture by showing the converse result.\nTheorem 4.13 If (H1,H2) has a tree projection, then there is a winning strategy in R&C(H1,H2).\nProof. Assume that (H1,H2) has a tree projection. From Fact 3.3, it has a minimal tree projection, say Ha. Let JT be a join tree for Ha in normal form (cf. Theorem 3.20), and let h be any hyperedge in edges(Ha).\nBased on JT , we build a strategy σ as follows. Let h0 = ∅ and C0 = nodes(H1). The first move of the Captain is h. Recall from Section 3 that C⊤(hs) is the unique [hr]-component with nodes(JT [h]hs) = C⊤(hs) ∪ (hs ∩ hr), where hs is a child of hr in JT [h] (with C⊤(h) be defined as nodes(Ha)). Given the current position (hp, Cp) and the current move hr, assume that the following inclusion relationship holds: for each [(hp, Cp), hr]-option Cr, Cr ⊆ C⊤(hr). Then, σ(hr, Cr) is defined as the hyperedge hs that is the child of hr in JT [h] and that is such that Cr = C⊤(hs). It follows that the strategy σ is well-defined under this assumption, because such a hyperedge exists by Theorem 3.20. Now, note that we can set Cp = C⊤(hr) (for the first move, just recall that C⊤(h) = nodes(H1)).\nWe now show that the above inclusion relationship actually holds, that is, for each vertex hr of JT [h] and for each child hs of hr, we have C⊤(hs) ⊆ C⊤(hr). To see this is true, recall again by Theorem 3.20 that nodes(JT [h]hr) = C⊤(hr) ∪ (hr ∩ hp) and nodes(JT [h]hs) = C⊤(hs) ∪ (hs ∩ hr). Assume, for the sake of contradiction, that C⊤(hs) 6⊆ C⊤(hr) and let X ∈ C⊤(hs) \\ C⊤(hr). Since, nodes(JT [h]hs) ⊆ nodes(JT [h]hr), it follows that X ∈ hr ∩ hp. This is impossible, since C⊤(hs) is a [hr]-component, with X ∈ C⊤(hs).\nFinally, to complete the proof just notice that the above also entails that σ is a monotone strategy, eventually covering all the nodes in H1, hence it is a winning strategy. ✷"
    }, {
      "heading" : "5 Applications and Conclusion",
      "text" : "In this paper, we have analyzed structural decomposition methods to identify nearly-acyclic hypergraphs by focusing on the general concept of tree projections.\nWe defined and studied a natural notion of minimality for tree-projections of pairs of hypergraphs. It turns out that minimal tree-projections always exist (whenever some tree-projection exists), and that they enjoy some useful properties, such as the existence of join trees in a suitable normal form that is crucial for algorithmic applications. In particular, such join trees have polynomial size with respect to the given pair of hypergraphs. As an immediate consequence of these properties, we get that deciding whether a tree projection of a pair of hypergraphs (H1,H2) exists is an NP-problem. Note that this result is expected but not trivial, because in general a tree projection may employ any subset of every hyperedge of H2. In fact, the results proved in detail in the present paper have been (explicitly) used by [16] in the membership part of the proof that deciding the existence of a tree projection is an NP-complete problem, which closed the long-standing open question about its computational complexity [17, 18, 27, 24].\nMoreover, we provided a natural game-theoretic characterization of tree projections in terms of the Captain and Robber game, which was missing and asked for even in the special case of generalized hypertree decompositions. In this game, monotone strategies have the same power as non-monotone\nstrategies. Even this result is not just of theoretical interest. Indeed, by exploiting the power of nonmonotonicity for some easy-to-compute strategies in the game, called greedy strategies, larger islands of tractability for the homomorphism problem (hence, for the constraint satisfaction problem and for the problem of evaluating conjunctive queries, and so on) have been identified in [21]. In particular, for the special case of generalized hypertree decompositions, these strategies lead to the definition of a new tractable approximation, called greedy hypertree decomposition, which is strictly more powerful than the (standard) notion of hypertree decomposition."
    } ],
    "references" : [ {
      "title" : "Marshals, monotone marshals, and hypertree-width",
      "author" : [ "I. Adler" ],
      "venue" : "Journal of Graph Theory,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2004
    }, {
      "title" : "Width Functions for Hypertree Decompositions",
      "author" : [ "I. Adler" ],
      "venue" : "PhD Thesis, University of Freiburg,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2006
    }, {
      "title" : "Tree-Related Widths of Graphs and Hypergraphs",
      "author" : [ "I. Adler" ],
      "venue" : "SIAM Journal Discrete Mathematics,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2008
    }, {
      "title" : "Hypertree-Width and Related Hypergraph Invariants",
      "author" : [ "I. Adler", "G. Gottlob", "M. Grohe" ],
      "venue" : "European Journal of Combinatorics,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2007
    }, {
      "title" : "On the Power of k-Consistency",
      "author" : [ "A. Atserias", "A. Bulatov", "V. Dalmau" ],
      "venue" : "In Proc. of ICALP’07,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2007
    }, {
      "title" : "The power of natural semijoins",
      "author" : [ "P.A. Bernstein", "N. Goodman" ],
      "venue" : "SIAM Journal on Computing,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1981
    }, {
      "title" : "A Linear-Time Algorithm for Finding Tree-Decompositions of Small Treewidth",
      "author" : [ "H.L. Bodlaender", "F.V. Fomin" ],
      "venue" : "SIAM Journal on Computing,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 1996
    }, {
      "title" : "A unified theory of structural tractability for constraint satisfaction problems",
      "author" : [ "D.A. Cohen", "P. Jeavons", "M. Gyssens" ],
      "venue" : "Journal of Computer and System Sciences,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2008
    }, {
      "title" : "Tree clustering for constraint networks",
      "author" : [ "R. Dechter", "J. Pearl" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1989
    }, {
      "title" : "Degrees of acyclicity for hypergraphs and relational database schemes",
      "author" : [ "R. Fagin" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1983
    }, {
      "title" : "Connected Treewidth and Connected Graph Searching",
      "author" : [ "P. Fraigniaud", "N. Nisse" ],
      "venue" : "In Proc. of LATIN’06,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2006
    }, {
      "title" : "Complexity of K-tree structured constraint satisfaction problems",
      "author" : [ "E.C. Freuder" ],
      "venue" : "In Proc. of the 8th National Conference on Artificial Intelligence,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 1990
    }, {
      "title" : "A Comparison of Structural CSP Decomposition Methods",
      "author" : [ "G. Gottlob", "N. Leone", "F. Scarcello" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2000
    }, {
      "title" : "Hypertree decompositions and tractable queries",
      "author" : [ "G. Gottlob", "N. Leone", "F. Scarcello" ],
      "venue" : "Journal of Computer and System Sciences,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2002
    }, {
      "title" : "Robbers, marshals, and guards: game theoretic and logical characterizations of hypertree width",
      "author" : [ "G. Gottlob", "N. Leone", "F. Scarcello" ],
      "venue" : "Journal of Computer and System Sciences,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2003
    }, {
      "title" : "Generalized hypertree decompositions: NP-hardness and tractable variants",
      "author" : [ "G. Gottlob", "Z. Miklós", "T. Schwentick" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2009
    }, {
      "title" : "Syntactic characterization of tree database schemas",
      "author" : [ "N. Goodman", "O. Shmueli" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 1983
    }, {
      "title" : "The tree projection theorem and relational query processing",
      "author" : [ "N. Goodman", "O. Shmueli" ],
      "venue" : "Journal of Computer and System Sciences,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 1984
    }, {
      "title" : "Tree Projections: Hypergraph Games and Minimality",
      "author" : [ "G. Greco", "F. Scarcello" ],
      "venue" : "In Proc. of ICALP’08,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2008
    }, {
      "title" : "Structural Tractability of Enumerating CSP Solutions",
      "author" : [ "G. Greco", "F. Scarcello" ],
      "venue" : "In Proc. of CP’10,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2010
    }, {
      "title" : "Tree Projections and Structural Decomposition Methods: The Power of Local Consistency and Larger Islands of Tractability",
      "author" : [ "G. Greco", "F. Scarcello" ],
      "venue" : "CoRR Technical report available at http://arxiv.org/abs/1205.3321,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2012
    }, {
      "title" : "The complexity of homomorphism and constraint satisfaction problems seen from the other side",
      "author" : [ "M. Grohe" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2007
    }, {
      "title" : "Constraint solving via fractional edge covers",
      "author" : [ "M. Grohe", "D. Marx" ],
      "venue" : "In Proc. of SODA",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2006
    }, {
      "title" : "Acyclic hypergraph projections",
      "author" : [ "A. Lustig", "O. Shmueli" ],
      "venue" : "Journal of Algorithms,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 1999
    }, {
      "title" : "Tractable Hypergraph Properties for Constraint Satisfaction and Conjunctive Queries",
      "author" : [ "D. Marx" ],
      "venue" : "In Proc. of STOC’10,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2010
    }, {
      "title" : "Graph minors III: Planar tree-width",
      "author" : [ "N. Robertson", "P.D. Seymour" ],
      "venue" : "Journal of Combinatorial Theory, Series B,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 1984
    }, {
      "title" : "Solving Queries by Tree Projections",
      "author" : [ "Y. Sagiv", "O. Shmueli" ],
      "venue" : "ACM Transaction on Database Systems,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 1993
    }, {
      "title" : "Graph searching and a min-max theorem for tree-width",
      "author" : [ "P.D. Seymour", "R. Thomas" ],
      "venue" : "Journal of Combinatorial Theory, Series B,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 1993
    }, {
      "title" : "Backtracking Procedures for Hypertree, HyperSpread and Connected Hypertree Decomposition of CSPs",
      "author" : [ "S. Subbarayan", "H. Reif Andersen" ],
      "venue" : "In Proc. of IJCAI’07,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2007
    } ],
    "referenceMentions" : [ {
      "referenceID" : 12,
      "context" : ", from AI [13] to Database Theory [6], are known to be efficiently solvable when restricted to instances whose underlying structures can be modeled via acyclic graphs or hypergraphs.",
      "startOffset" : 10,
      "endOffset" : 14
    }, {
      "referenceID" : 5,
      "context" : ", from AI [13] to Database Theory [6], are known to be efficiently solvable when restricted to instances whose underlying structures can be modeled via acyclic graphs or hypergraphs.",
      "startOffset" : 34,
      "endOffset" : 37
    }, {
      "referenceID" : 13,
      "context" : "several efforts have been spent to investigate invariants that are best suited to identify nearly-acyclic graph/hypergraphs, leading to the definition of a number of so-called structural decomposition methods, such as the (generalized) hypertree [14], fractional hypertree [23], spread-cut [8], and component hypertree [16] decompositions.",
      "startOffset" : 246,
      "endOffset" : 250
    }, {
      "referenceID" : 22,
      "context" : "several efforts have been spent to investigate invariants that are best suited to identify nearly-acyclic graph/hypergraphs, leading to the definition of a number of so-called structural decomposition methods, such as the (generalized) hypertree [14], fractional hypertree [23], spread-cut [8], and component hypertree [16] decompositions.",
      "startOffset" : 273,
      "endOffset" : 277
    }, {
      "referenceID" : 7,
      "context" : "several efforts have been spent to investigate invariants that are best suited to identify nearly-acyclic graph/hypergraphs, leading to the definition of a number of so-called structural decomposition methods, such as the (generalized) hypertree [14], fractional hypertree [23], spread-cut [8], and component hypertree [16] decompositions.",
      "startOffset" : 290,
      "endOffset" : 293
    }, {
      "referenceID" : 15,
      "context" : "several efforts have been spent to investigate invariants that are best suited to identify nearly-acyclic graph/hypergraphs, leading to the definition of a number of so-called structural decomposition methods, such as the (generalized) hypertree [14], fractional hypertree [23], spread-cut [8], and component hypertree [16] decompositions.",
      "startOffset" : 319,
      "endOffset" : 323
    }, {
      "referenceID" : 17,
      "context" : "Despite their different technical definitions, there is a simple mathematical framework that encompasses all purely structural decomposition methods, which is the framework of the tree projections [18].",
      "startOffset" : 197,
      "endOffset" : 201
    }, {
      "referenceID" : 8,
      "context" : "Consider, for instance, the tree decomposition method [9, 12], based on the notion of treewidth [26], which is the most general decomposition method over classes of graphs (see, e.",
      "startOffset" : 54,
      "endOffset" : 61
    }, {
      "referenceID" : 11,
      "context" : "Consider, for instance, the tree decomposition method [9, 12], based on the notion of treewidth [26], which is the most general decomposition method over classes of graphs (see, e.",
      "startOffset" : 54,
      "endOffset" : 61
    }, {
      "referenceID" : 25,
      "context" : "Consider, for instance, the tree decomposition method [9, 12], based on the notion of treewidth [26], which is the most general decomposition method over classes of graphs (see, e.",
      "startOffset" : 96,
      "endOffset" : 100
    }, {
      "referenceID" : 12,
      "context" : "g, [13, 22]).",
      "startOffset" : 3,
      "endOffset" : 11
    }, {
      "referenceID" : 21,
      "context" : "g, [13, 22]).",
      "startOffset" : 3,
      "endOffset" : 11
    }, {
      "referenceID" : 18,
      "context" : ", [19, 20]).",
      "startOffset" : 2,
      "endOffset" : 10
    }, {
      "referenceID" : 19,
      "context" : ", [19, 20]).",
      "startOffset" : 2,
      "endOffset" : 10
    }, {
      "referenceID" : 24,
      "context" : "1For the sake of completeness, observe that the only known structural technique that does not fit the general framework of tree projections is the one based on the submodular width [25], which is not purely structural.",
      "startOffset" : 181,
      "endOffset" : 185
    }, {
      "referenceID" : 10,
      "context" : ", on connected ones [11], that is, basically, on tree decompositions such that, for each set of connected vertices, the sub-hypergraph induced by the nodes covered in such vertices is connected in its turn.",
      "startOffset" : 20,
      "endOffset" : 24
    }, {
      "referenceID" : 10,
      "context" : "Again, connected decompositions provide us with a “normal form” for decomposition trees, which can be exploited to restrict the search space of the possible decompositions and, thus, to speed-up their computation [11].",
      "startOffset" : 213,
      "endOffset" : 217
    }, {
      "referenceID" : 28,
      "context" : "Algorithms have been implemented limiting the search space to a kind of connected (generalized) hypertree decompositions [29], but it was left open whether the resulting method is a heuristic one or it does give an exact solution.",
      "startOffset" : 121,
      "endOffset" : 125
    }, {
      "referenceID" : 27,
      "context" : "(Q2) Is there a natural game-theoretic characterization for tree projections? Tree decompositions have a nice game-theoretic characterization in terms of the Robber and Cops game [28]: A hypergraph H has treewidth bounded by k if, and only, if k + 1 Cops can capture a Robber that can run at great speed along the hyperedges of H, while being not permitted to run trough a node that is controlled by a Cop.",
      "startOffset" : 179,
      "endOffset" : 183
    }, {
      "referenceID" : 27,
      "context" : "More precisely, playing non-monotone strategies gives no more power to the Cops [28].",
      "startOffset" : 80,
      "endOffset" : 84
    }, {
      "referenceID" : 4,
      "context" : ", [5]), this property turns out to be very useful, because good strategies for the Robber may be easily characterized as those strategies that allow the Robber to run forever.",
      "startOffset" : 2,
      "endOffset" : 5
    }, {
      "referenceID" : 14,
      "context" : "Hypertree decomposition is an efficiently recognizable structural method [15], which provides a 3approximation for generalized hypertree decompositions [4].",
      "startOffset" : 73,
      "endOffset" : 77
    }, {
      "referenceID" : 3,
      "context" : "Hypertree decomposition is an efficiently recognizable structural method [15], which provides a 3approximation for generalized hypertree decompositions [4].",
      "startOffset" : 152,
      "endOffset" : 155
    }, {
      "referenceID" : 14,
      "context" : "This method is also known to have a nice game-theoretic characterization, in terms of the (monotone) Robber and Marshals game [15], which can be viewed as a natural generalization of the Robber and Cops games.",
      "startOffset" : 126,
      "endOffset" : 130
    }, {
      "referenceID" : 0,
      "context" : "However, Marshals are now required to play monotonically, because non-monotone strategies give some extra-power that does not correspond to valid decompositions [1].",
      "startOffset" : 161,
      "endOffset" : 164
    }, {
      "referenceID" : 14,
      "context" : "[15], game theoretic characterizations for generalized hypertree width were still missing.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 0,
      "context" : "In [1], it is raised the question about whether there is a (natural) game theoretic characterization for generalized hypertree width, where non-monotonicity does not represent a source of additional power.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 13,
      "context" : ", [14]) are a consequence of minimality.",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 15,
      "context" : "In fact, this property has already been exploited in the NP-completeness proof of tree projections [16].",
      "startOffset" : 99,
      "endOffset" : 103
    }, {
      "referenceID" : 28,
      "context" : "◮ We give a negative answer to the question raised in [29] for (generalized) hypertree decomposition.",
      "startOffset" : 54,
      "endOffset" : 58
    }, {
      "referenceID" : 28,
      "context" : "Hence, the algorithm proposed in [29] for connected hypertree decompositions is not complete, as far as the computation of unrestricted decompositions is considered.",
      "startOffset" : 33,
      "endOffset" : 37
    }, {
      "referenceID" : 9,
      "context" : "A hypergraph H is acyclic (more precisely, α-acyclic [10]) if, and only if, it has a join tree [6].",
      "startOffset" : 53,
      "endOffset" : 57
    }, {
      "referenceID" : 5,
      "context" : "A hypergraph H is acyclic (more precisely, α-acyclic [10]) if, and only if, it has a join tree [6].",
      "startOffset" : 95,
      "endOffset" : 98
    }, {
      "referenceID" : 25,
      "context" : "A tree decomposition [26] of a graph G is a pair 〈T, χ〉, where T = (N,E) is a tree, and χ is a labeling function assigning to each vertex v ∈ N a set of verticesχ(v) ⊆ nodes(G), such that the following conditions are satisfied: (1) for each node Y ∈ nodes(G), there exists p ∈ N such that Y ∈ χ(p); (2) for each edge {X,Y } ∈ edges(G), there exists p ∈ N such that {X,Y } ⊆ χ(p); and (3) for each node Y ∈ nodes(G), the set {p ∈ N | Y ∈ χ(p)} induces a (connected) subtree of T .",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 6,
      "context" : "Deciding whether a given hypergraph has treewidth bounded by a fixed natural number k is known to be feasible in linear time [7].",
      "startOffset" : 125,
      "endOffset" : 128
    }, {
      "referenceID" : 14,
      "context" : "A generalized hypertree decomposition [15] of a hypergraph H is a hypertree HD = 〈T, χ, λ〉 for H such that: (1) for each hyperedge h ∈ edges(H), there exists p ∈ vertices(T ) such that h ⊆ χ(p); (2) for each node Y ∈ nodes(H), the set {p ∈ vertices(T ) | Y ∈ χ(p)} induces a (connected) subtree of T ; and (3) for each p ∈ vertices(T ), χ(p) ⊆ nodes(λ(p)).",
      "startOffset" : 38,
      "endOffset" : 42
    }, {
      "referenceID" : 13,
      "context" : "A hypertree decomposition [14] of H is a generalized hypertree decomposition HD = 〈T, χ, λ〉 where: (4) for each p ∈ vertices(T ), nodes(λ(p)) ∩ χ(Tp) ⊆ χ(p).",
      "startOffset" : 26,
      "endOffset" : 30
    }, {
      "referenceID" : 3,
      "context" : "Note that, for any hypergraph H, it is the case that ghw(H) ≤ hw(H) ≤ 3× ghw(H) + 1 [4].",
      "startOffset" : 84,
      "endOffset" : 87
    }, {
      "referenceID" : 13,
      "context" : "Moreover, for any fixed natural number k > 0, deciding whether hw(H) ≤ k is feasible in polynomial time (and, actually, it is highly-parallelizable) [14], while deciding whether ghw(H) ≤ k is NP-complete [16].",
      "startOffset" : 149,
      "endOffset" : 153
    }, {
      "referenceID" : 15,
      "context" : "Moreover, for any fixed natural number k > 0, deciding whether hw(H) ≤ k is feasible in polynomial time (and, actually, it is highly-parallelizable) [14], while deciding whether ghw(H) ≤ k is NP-complete [16].",
      "startOffset" : 204,
      "endOffset" : 208
    }, {
      "referenceID" : 13,
      "context" : ", [14]).",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 13,
      "context" : "In particular, from the results in [14] (in particular, from Theorem 5.",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 13,
      "context" : "4 in [14]) it follows that, for each hyperedge h ∈ edges(Ha), there is a width-1 hypertree decomposition HD = 〈T, χ, λ〉 for Ha, where T is rooted at a vertex root(T ) such that λ(root(T )) = {h} and, for each vertex r ∈ vertices(T ) and for each child s of r, the following conditions hold: (1) there is (exactly) one [χ(r)]-component Cr of Ha such that χ(Ts) = Cr ∪ (χ(s) ∩ χ(r)); (2) χ(s) ∩ Cr 6= ∅, where Cr is the [χ(r)]-component of Ha satisfying Condition (1); and (3) hs ∩Fr(Cr,Ha) 6= ∅ holds, where {hs} = λ(s) and Cr is the [χ(r)]-component of Ha satisfying Condition (1).",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 10,
      "context" : ", [11]).",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 10,
      "context" : "In order to establish the result, we shall exploit an algorithm, called make-it-connected, that has been described in [11] and that enjoys the following properties.",
      "startOffset" : 118,
      "endOffset" : 122
    }, {
      "referenceID" : 10,
      "context" : "[11]) Let 〈T, χ〉 be a width-k tree decomposition of a graph G.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 28,
      "context" : "16 A different notion of connected decomposition has been introduced in [29] for the special case of (generalized) hypertree decompositions, in order to speed-up their computation.",
      "startOffset" : 72,
      "endOffset" : 76
    }, {
      "referenceID" : 28,
      "context" : "According to [29], a (generalized) hypertree decomposition HD = 〈T, χ, λ〉 is connected if the root r of T is such that |λ(r)| = 1, and for each pair of nodes p and s, with s child of p in T , and for each h ∈ λ(s), h ∩ χ(s) ∩ χ(p) 6= ∅.",
      "startOffset" : 13,
      "endOffset" : 17
    }, {
      "referenceID" : 28,
      "context" : "Whether or not chw(H) = hw(H) for every hypergraph H was an open question [29].",
      "startOffset" : 74,
      "endOffset" : 78
    }, {
      "referenceID" : 28,
      "context" : "Indeed, the reader can check there is neither a hypertree decomposition nor a generalized hypertree decomposition of Ghex that is connected according to [29] and has width 3.",
      "startOffset" : 153,
      "endOffset" : 157
    }, {
      "referenceID" : 14,
      "context" : "For a comparison, observe that this game is somehow in the middle between the Robber and Marshals game of [15], where the marshals occupy a full hyperedge at each move, and the Robber and Cops game of [28], where each cop stands on a vertex and thus, if there are enough cops, any subset of any edge can be blocked at each move.",
      "startOffset" : 106,
      "endOffset" : 110
    }, {
      "referenceID" : 27,
      "context" : "For a comparison, observe that this game is somehow in the middle between the Robber and Marshals game of [15], where the marshals occupy a full hyperedge at each move, and the Robber and Cops game of [28], where each cop stands on a vertex and thus, if there are enough cops, any subset of any edge can be blocked at each move.",
      "startOffset" : 201,
      "endOffset" : 205
    }, {
      "referenceID" : 27,
      "context" : "This crucial property conceptually relates our game with the Robber and Cops game characterizing the treewidth [28], and differentiates it from most of the hypergraph-based games in the literature, in particular, from the Robber and Marshals game, whose monotone strategies characterize hypertree decompositions [15], while non-monotone strategies do not correspond to valid decompositions [1].",
      "startOffset" : 111,
      "endOffset" : 115
    }, {
      "referenceID" : 14,
      "context" : "This crucial property conceptually relates our game with the Robber and Cops game characterizing the treewidth [28], and differentiates it from most of the hypergraph-based games in the literature, in particular, from the Robber and Marshals game, whose monotone strategies characterize hypertree decompositions [15], while non-monotone strategies do not correspond to valid decompositions [1].",
      "startOffset" : 312,
      "endOffset" : 316
    }, {
      "referenceID" : 0,
      "context" : "This crucial property conceptually relates our game with the Robber and Cops game characterizing the treewidth [28], and differentiates it from most of the hypergraph-based games in the literature, in particular, from the Robber and Marshals game, whose monotone strategies characterize hypertree decompositions [15], while non-monotone strategies do not correspond to valid decompositions [1].",
      "startOffset" : 390,
      "endOffset" : 393
    }, {
      "referenceID" : 15,
      "context" : "In fact, the results proved in detail in the present paper have been (explicitly) used by [16] in the membership part of the proof that deciding the existence of a tree projection is an NP-complete problem, which closed the long-standing open question about its computational complexity [17, 18, 27, 24].",
      "startOffset" : 90,
      "endOffset" : 94
    }, {
      "referenceID" : 16,
      "context" : "In fact, the results proved in detail in the present paper have been (explicitly) used by [16] in the membership part of the proof that deciding the existence of a tree projection is an NP-complete problem, which closed the long-standing open question about its computational complexity [17, 18, 27, 24].",
      "startOffset" : 287,
      "endOffset" : 303
    }, {
      "referenceID" : 17,
      "context" : "In fact, the results proved in detail in the present paper have been (explicitly) used by [16] in the membership part of the proof that deciding the existence of a tree projection is an NP-complete problem, which closed the long-standing open question about its computational complexity [17, 18, 27, 24].",
      "startOffset" : 287,
      "endOffset" : 303
    }, {
      "referenceID" : 26,
      "context" : "In fact, the results proved in detail in the present paper have been (explicitly) used by [16] in the membership part of the proof that deciding the existence of a tree projection is an NP-complete problem, which closed the long-standing open question about its computational complexity [17, 18, 27, 24].",
      "startOffset" : 287,
      "endOffset" : 303
    }, {
      "referenceID" : 23,
      "context" : "In fact, the results proved in detail in the present paper have been (explicitly) used by [16] in the membership part of the proof that deciding the existence of a tree projection is an NP-complete problem, which closed the long-standing open question about its computational complexity [17, 18, 27, 24].",
      "startOffset" : 287,
      "endOffset" : 303
    }, {
      "referenceID" : 20,
      "context" : "Indeed, by exploiting the power of nonmonotonicity for some easy-to-compute strategies in the game, called greedy strategies, larger islands of tractability for the homomorphism problem (hence, for the constraint satisfaction problem and for the problem of evaluating conjunctive queries, and so on) have been identified in [21].",
      "startOffset" : 324,
      "endOffset" : 328
    } ],
    "year" : 2012,
    "abstractText" : "Tree projections provide a mathematical framework that encompasses all the various (purely) structural decomposition methods that have been proposed in the literature to single out classes of nearly-acyclic (hyper)graphs, such as the tree decomposition method, which is the most powerful decomposition method on graphs, and the (generalized) hypertree decomposition method, which is its natural counterpart on arbitrary hypergraphs. The paper analyzes this framework, by focusing in particular on “minimal” tree projections, that is, on tree projections without useless redundancies. First, it is shown that minimal tree projections enjoy a number of properties that are usually required for normal form decompositions in various structural decomposition methods. In particular, they enjoy the same kind of connection properties as (minimal) tree decompositions of graphs, with the result being tight in the light of the negative answer that is provided to the open question about whether they enjoy a slightly stronger notion of connection property, defined to speed-up the computation of hypertree decompositions. Second, it is shown that tree projections admit a natural game-theoretic characterization in terms of the Captain and Robber game. In this game, as for the Robber and Cops game characterizing tree decompositions, the existence of winning strategies implies the existence of monotone ones. As a special case, the Captain and Robber game can be used to characterize the generalized hypertree decomposition method, where such a game-theoretic characterization was missing and asked for. Besides their theoretical interest, these results have immediate algorithmic applications both for the general setting and for structural decomposition methods that can be recast in terms of tree projections.",
    "creator" : "LaTeX with hyperref package"
  }
}