{
  "name" : "0806.4686.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Sparse Online Learning via Truncated Gradient",
    "authors" : [ "John Langford", "Lihong Li" ],
    "emails" : [ "jl@yahoo-inc.com", "lihong@cs.rutgers.edu", "tongz@rci.rutgers.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "We propose a general method called truncated gradient to induce sparsity in the weights of online learning algorithms with convex loss functions. This method has several essential properties:\n1. The degree of sparsity is continuous a parameter controls the rate of sparsi cation from\nno sparsi cation to total sparsi cation.\n2. The approach is theoretically motivated, and an instance of it can be regarded as an online\ncounterpart of the popular L1-regularization method in the batch setting. We prove that small rates of sparsi cation result in only small additional regret with respect to typical online learning guarantees.\n3. The approach works well empirically.\nWe apply the approach to several datasets and nd that for datasets with large numbers of features, substantial sparsity is discoverable."
    }, {
      "heading" : "1 Introduction",
      "text" : "We are concerned with machine learning over large datasets. As an example, the largest dataset we use here has over 107 sparse examples and 109 features using about 1011 bytes. In this setting, many common approaches fail, simply because they cannot load the dataset into memory or they are not su ciently e cient. There are roughly two approaches which can work:\n1. Parallelize a batch learning algorithm over many machines (e.g., [3]).\n2. Stream the examples to an online learning algorithm (e.g., [8], [9], [2], and [5]).\nThis paper focuses on the second approach. Typical online learning algorithms have at least one weight for every feature, which is too much in some applications for a couple reasons:\n1. Space constraints. If the state of the online learning algorithm over ows RAM it can not e ciently run. A similar problem occurs if the state over ows the L2 cache.\n1\nar X\niv :0\n80 6.\n46 86\nv1 [\ncs .L\nG ]\n2 8\nJu n\n2. Test time constraints on computation. Substantially reducing the number of features can yield substantial improvements in the computational time required to evaluate a new sample.\nThis paper addresses the problem of inducing sparsity in learned weights while using an online learning algorithm. There are several ways to do this wrong for our problem. For example:\n1. Simply adding L1 regularization to the gradient of an online weight update doesn't work because gradients don't induce sparsity. The essential di culty is that a gradient update has the form a+b where a and b are two oats. Very few oat pairs add to 0 (or any other default value) so there is little reason to expect a gradient update to accidentally produce sparsity.\n2. Simply rounding weights to 0 is problematic because a weight may be small due to being useless or small because it has been updated only once (either at the beginning of training or because the set of features appearing is also sparse). Rounding techniques can also play havoc with standard online learning guarantees.\n3. Black-box wrapper approaches which eliminate features and test the impact of the elimination are not e cient enough. These approaches typically run an algorithm many times which is particularly undesirable with large datasets."
    }, {
      "heading" : "1.1 What Others Do",
      "text" : "The Lasso algorithm [12] is commonly used to achieve L1 regularization for linear regression. This algorithm does not work automatically in an online fashion. There are two formulations of L1 regularization. Consider a loss function L(w, zi) which is convex in w, where zi = (xi, yi) is an input/output pair. One is the convex constraint formulation\nŵ = arg min w n∑ i=1 L(w, zi) subject to ‖w‖1 ≤ s, (1)\nwhere s is a tunable parameter. The other is soft-regularization, where\nŵ = arg min w n∑ i=1 L(w, zi) + λ‖w‖1. (2)\nWith appropriately chosen λ, the two formulations are equivalent. The convex constraint formulation has a simple online version using the projection idea in [14]. It requires the projection of weight w into an L1 ball at every online step. This operation is di cult to implement e ciently for large-scale data where we have examples with sparse features and a large number of features. In such situation, we require that the number of operations per online step to be linear with respect to the number of nonzero features, and independent of the total number of features. Our method, which works with the soft-regularization formulation (2), satis es the requirement. Additional details can be found in Section 5. In addition to L1 regularization formulation (2), the family of online algorithms we consider in this paper also include some nonconvex sparsi cation techniques.\nThe Forgetron algorithm [4] is an online learning algorithm that manages memory use. It operates by decaying the weights on previous examples and then rounding these weights to zero when they become small. The Forgetron is stated for kernelized online algorithms, while we are concerned with the simple linear setting. When applied to a linear kernel, the Forgetron is not computationally or space competitive with approaches operating directly on feature weights.\n2\n1.2 What We Do\nAt a high level, the approach we take is weight decay to a default value. This simple approach enjoys a strong performance guarantee, as discussed in section 3. For instance, the algorithm never performs much worse than a standard online learning algorithm, and the additional loss due to sparsi cation is controlled continuously with a single real-valued parameter. The theory gives a family of algorithms with convex loss functions for inducing sparsity one per online learning algorithm. We instantiate this for square loss and show how to deal with sparse examples e ciently in section 4.\nAs mentioned in the introduction, we are mainly interested in sparse online methods for large scale problems with sparse features. For such problems, our algorithm should satisfy the following requirements:\n• The algorithm should be computationally e cient: the number of operations per online step should be linear in the number of nonzero features, and independent of the total number of features.\n• The algorithm should be memory e cient: it needs to maintain a list of active features, and can insert (when the corresponding weight becomes nonzero) and delete (when the corresponding weight becomes zero) features dynamically.\nThe implementation details, showing that our methods satisfy the above requirements, are provided in section 5.\nTheoretical results stating how much sparsity is achieved using this method generally require additional assumptions which may or may not be met in practice. Consequently, we rely on experiments in section 6 to show that our method achieves good sparsity practice. We compare our approach to a few others, including L1 regularization on small data, as well as online rounding of coe cients to zero."
    }, {
      "heading" : "2 Online Learning with GD",
      "text" : "In the setting of standard online learning, we are interested in sequential prediction problems where repeatedly from i = 1, 2, . . .:\n1. An unlabeled example xi arrives.\n2. We make a prediction based on existing weights wi ∈ Rd.\n3. We observe yi, let zi = (xi, yi), and incur some known loss L(wi, zi) convex in parameter wi.\n4. We update weights according to some rule: wi+1 ← f(wi).\nWe want to come up with an update rule f , which allows us to bound the sum of losses\nt∑ i=1 L(wi, zi)\nas well as achieving sparsity. For this purpose, we start with the standard stochastic gradient descent rule, which is of the form:\nf(wi) = wi − η∇1L(wi, zi), (3)\n3\nwhere ∇1L(a, b) is a sub-gradient of L(a, b) with respect to the rst variable a. The parameter η > 0 is often referred to as the learning rate. In our analysis, we only consider constant learning rate with xed η > 0 for simplicity. In theory, it might be desirable to have a decaying learning rate ηi which becomes smaller when i increases to get the so called no-regret bound without knowing T in advance. However, if T is known in advance, one can select a constant η accordingly so that the regret vanishes as T → ∞. Since our focus is on sparsity, not how to choose learning rate, for clarity, we use a constant learning rate in the analysis because it leads to simpler bounds.\nThe above method has been widely used in online learning such as [9] and [2]. Moreover, it is argued to be e cient even for solving batch problems where we repeatedly run the online algorithm over training data multiple times. For example, the idea has been successfully applied to solve large-scale standard SVM formulations [10, 13]. In the scenario outlined in the introduction, online learning methods are more suitable than some traditional batch learning methods.\nHowever, a main drawback of (3) is that it does not achieve sparsity, which we address in this paper. Note that in the literature, this particular update rule is often referred to as gradient descent (GD) or stochastic gradient descent (SGD). There are other variants, such as exponentiated gradient descent (EG). Since our focus in this paper is sparsity, not GD versus EG, we shall only consider modi cations of (3) for simplicity."
    }, {
      "heading" : "3 Sparse Online Learning",
      "text" : "In this section, we examine several methods for achieving sparsity in online learning. The rst idea is simple coe cient rounding, which is the most natural method. We will then consider its full online implementation, and another method which is the online counterpart of L1 regularization in batch learning. As we shall see, all these ideas are closely related."
    }, {
      "heading" : "3.1 Simple Coe cient Rounding",
      "text" : "In order to achieve sparsity, the most natural method is to round small coe cients (that are no larger than a threshold θ > 0) to zero after every K online steps. That is, if i/K is not an integer, we use the standard GD rule in (3); if i/K is an integer, we modify the rule as:\nf(wi) = T0(wi − η∇1L(wi, zi), θ), (4)\nwhere for a vector v = [v1, . . . , vd] ∈ Rd, and a scalar θ ≥ 0, T0(v, θ) = [T0(v1, θ), . . . , T0(vd, θ)], with\nT0(vj , θ) = { 0 if |vj | ≤ θ vj otherwise .\nThat is, we rst perform a standard stochastic gradient descent rule, and then round the updated coe cients toward zero. The e ect is to remove nonzero and small components in the weight vector.\nIn general, we should not take K = 1, especially when η is small, since each step modi es wi by only a small amount. If a coe cient is zero, it remains small after one online update, and the rounding operation pulls it back to zero. Consequently, rounding can be done only after every K steps (with a reasonably large K); in this case, nonzero coe cients have su cient time to go above the threshold θ. However, if K is too large, then in the training stage, we will need to keep many more nonzero features in the intermediate steps before they are rounded to zero. In the extreme\n4\ncase, we may simply round the coe cients in the end, which does not solve the storage problem in the training phase. The sensitivity in choosing appropriate K is a main drawback of this method; another drawback is the lack of theoretical guarantee for its online performance.\nThe above mentioned issues motivate us to consider more principled sparse online learning methods. In section 3.3, we derive an online version of rounding using an idea called truncated gradient for which regret bounds hold."
    }, {
      "heading" : "3.2 A Sub-gradient Algorithm for L1 Regularization",
      "text" : "In our experiments, we combine rounding-in-the-end-of-training with a simple online sub-gradient method for L1 regularization with a regularization parameter g > 0:\nf(wi) = wi − η∇1L(wi, zi)− ηg sgn(wi), (5)\nwhere for a vector v = [v1, . . . , vd], sgn(v) = [sgn(v1), . . . , sgn(vd)], and sgn(vj) = 1 when vj > 0, sgn(vj) = −1 when vj < 0, and sgn(vj) = 0 when vj = 0. In the experiments, the online method (5) plus rounding in the end is used as a simple baseline. One should note that this method does not produce sparse weights online. Therefore it does not handle large-scale problems for which we cannot keep all features in memory."
    }, {
      "heading" : "3.3 Truncated Gradient",
      "text" : "In order to obtain an online version of the simple rounding rule in (4), we observe that the direct rounding to zero is too aggressive. A less aggressive version is to shrink the coe cient to zero by a smaller amount. We call this idea truncated gradient.\nThe amount of shrinkage is measured by a gravity parameter gi > 0:\nf(wi) = T1(wi − η∇1L(wi, zi), ηgi, θ), (6)\nwhere for a vector v = [v1, . . . , vd] ∈ Rd, and a scalar g ≥ 0, T1(v, α, θ) = [T1(v1, α, θ), . . . , T1(vd, α, θ)], with\nT1(vj , α, θ) =  max(0, vj − α) if vj ∈ [0, θ] min(0, vj + α) if vj ∈ [−θ, 0] vj otherwise .\nAgain, the truncation can be performed every K online steps. That is, if i/K is not an integer, we let gi = 0; if i/K is an integer, we let gi = Kg for a gravity parameter g > 0. This particular choice is equivalent to (4) when we set g such that ηKg ≥ θ. This requires a large g when η is small. In practice, one should set a small, xed g, as implied by our regret bound developed later.\nIn general, the larger the parameters g and θ are, the more sparsity is incurred. Due to the extra truncation T1, this method can lead to sparse solutions, which is con rmed in our experiments described later. In those experiments, the degree of sparsity discovered varies with the problem.\nA special case, which we use in the experiment, is to let g = θ in (6). In this case, we can use only one parameter g to control sparsity. Since ηKg θ when ηK is small, the truncation operation is less aggressive than the rounding in (4). At rst sight, the procedure appears to be an ad-hoc way to x (4). However, we can establish a regret bound for this method, showing that it is theoretically sound.\n5\nAnother important special case of (6) is setting θ =∞. This leads to the following update rule for every K-th online step\nf(wi) = T (wi − η∇1L(wi, zi), giη), (7)\nwhere for a vector v = [v1, . . . , vd] ∈ Rd, and a scalar g ≥ 0, T (v, α) = [T (v1, α), . . . , T (vd, α)], with\nT (vj , α) = { max(0, vj − α) if vj > 0 min(0, vj + α) otherwise .\nThe method is a modi cation of the standard sub-gradient online method for L1 regularization in (5). The parameter gi ≥ 0 controls the sparsity that can be achieved with the algorithm. Note that when gi = 0, the update rule is identical to the standard stochastic gradient descent rule. In general, we may perform a truncation every K steps. That is, if i/K is not an integer, we let gi = 0; if i/K is an integer, we let gi = Kg for a gravity parameter g > 0. The reason for doing so (instead of a constant g) is that we can perform a more aggressive truncation with gravity parameter Kg after each K steps. This can potentially lead to better sparsity.\nThe procedure in (7) can be regarded as an online counterpart of L1 regularization in the sense that it approximately solves an L1 regularization problem in the limit of η → 0. Truncated gradient descent for L1 regularization is di erent from the naive application of stochastic gradient descent rule (3) with an added L1 regularization term. As pointed out in the introduction, the latter fails because it rarely leads to sparsity. Our theory shows that even with sparsi cation, the prediction performance is still comparable to that of the standard online learning algorithm. In the following, we develop a general regret bound for this general method, which also shows how the regret may depend on the sparsi cation parameter g."
    }, {
      "heading" : "3.4 Regret Analysis",
      "text" : "Throughout the paper, we use ‖ · ‖1 for 1-norm, and ‖ · ‖ for 2-norm. For reference, we make the following assumption regarding the loss function:\nAssumption 3.1 We assume that L(w, z) is convex in w, and there exist non-negative constants A and B such that (∇1L(w, z))2 ≤ AL(w, z) +B for all w ∈ Rd and z ∈ Rd+1.\nFor linear prediction problems, we have a general loss function of the form L(w, z) = φ(wTx, y). The following are some common loss functions φ(·, ·) with corresponding choices of parameters A and B (which are not unique), under the assumption that supx ‖x‖ ≤ C.\n• Logistic: φ(p, y) = ln(1 + exp(−py)); A = 0 and B = C2. This loss is for binary classi cation problems with y ∈ {±1}.\n• SVM (hinge loss): φ(p, y) = max(0, 1 − py); A = 0 and B = C2. This loss is for binary classi cation problems with y ∈ {±1}.\n• Least squares (square loss): φ(p, y) = (p−y)2; A = 4C2 and B = 0. This loss is for regression problems.\nOur main result is Theorem 3.1 that is parameterized by A and B. The proof is left to the appendix. Specializing it to particular losses yields several corollaries. The one that can be applied to the least squares loss will be given later in Corollary 4.1.\n6\nTheorem 3.1 (Sparse Online Regret) Consider sparse online update rule (7) with w1 = 0 and η > 0. If Assumption 3.1 holds, then for all w̄ ∈ Rd we have\n1− 0.5Aη T T∑ i=1 [ L(wi, zi) + gi 1− 0.5Aη ‖wi+1 · I(wi+1 ≤ θ)‖1 ]\n≤η 2 B +\n‖w̄‖2\n2ηT + 1 T T∑ i=1 [L(w̄, zi) + gi‖w̄ · I(wi+1 ≤ θ)‖1],\nwhere for vectors v = [v1, . . . , vd] and v′ = [v′1, . . . , v ′ d], we let\n‖v · I(|v′| ≤ θ)‖1 = d∑\nj=1\n|vj |I(|v′j | ≤ θ),\nwhere I(·) is the set indicator function.\nWe state the theorem with a constant learning rate η. As mentioned earlier, it is possible to obtain a result with variable learning rate where η = ηi decays as i increases. Although this may lead to a no-regret bound without knowing T in advance, it introduces extra complexity to the presentation of the main idea. Since our focus is on sparsity rather than optimizing learning rate, we do not include such a result for clarity. If T is known in advance, then in the above bound, one can simply take η = O(1/ √ T ) and the regret is of order O(1/ √ T ).\nIn the above theorem, the right-hand side involves a term gi‖w̄ · I(wi+1 ≤ θ)‖1 that depends on wi+1 which is not easily estimated. To remove this dependency, a trivial upper bound of θ = ∞ can be used, leading to L1 penalty gi‖w̄‖1. In the general case of θ < ∞, we cannot remove the wi+1 dependency because the e ective regularization condition (as shown on the left-hand side) is the non-convex penalty gi‖w · I(|w| ≤ θ)‖1. Solving such a non-convex formulation is hard both in the online and batch settings. In general, we only know how to e ciently discover a local minimum which is di cult to characterize. Without a good characterization of the local minimum, it is not possible for us to replace gi‖w̄ · I(wi+1 ≤ θ)‖1 on the right-hand side by gi‖w̄ · I(w̄ ≤ θ)‖1 because such a formulation would have implied that we could e ciently solve a non-convex problem with a simple online update rule. Still, when θ <∞, one naturally expects that the right-hand side penalty gi‖w̄ · I(wi+1 ≤ θ)‖1 is much smaller than the corresponding L1 penalty gi‖w̄‖1, especially when wj has many components that are close to 0. Therefore the situation with θ <∞ can potentially yield better performance on some data. This is con rmed in our experiments.\nTheorem 3.1 also implies a trade-o between sparsity and regret performance. We may simply consider the case where gi = g is a constant. When g is small, we have less sparsity but the regret term g‖w̄ · I(wi+1 ≤ θ)‖1 ≤ g‖w̄‖1 on the right-hand side is also small. When g is large, we are able to achieve more sparsity but the regret g‖w̄ · I(wi+1 ≤ θ)‖1 on the right-hand side also becomes large. Such a trade-o (sparsity versus prediction accuracy) is empirically studied in Section 6. Our observation suggests that we can gain signi cant sparsity with only a small decrease of accuracy (that is, using a small g).\nNow consider the case θ = ∞ and gi = g. When T → ∞, if we let η → 0 and ηT → ∞, then Theorem 3.1 implies that\n1 T T∑ i=1 [L(wi, zi) + g‖wi‖1] ≤ inf w̄∈Rd [ 1 T T∑ i=1 L(w̄, zi) + 2g‖w̄‖1 ] + o(1).\n7\nIn other words, if we let L′(w, z) = L(w, z)+g‖w‖1 be the L1 regularized loss, then the L1 regularized regret is small when η → 0 and T → ∞. This implies that our procedure can be regarded as the online counterpart of L1-regularization methods. In the stochastic setting where the examples are drawn iid from some underlying distribution, the sparse online gradient method proposed in this paper solves the L1 regularization problem."
    }, {
      "heading" : "3.5 Stochastic Setting",
      "text" : "Stochastic-gradient-based online learning methods can be used to solve large-scale batch optimization problems, often quite successfully [10, 13]. In this setting, we can go through training examples one-by-one in an online fashion, and repeat multiple times over the training data. In this section, we analyze the performance of such a procedure using Theorem 3.1.\nTo simplify the analysis, instead of assuming that we go through the data one by one, we assume that each additional data point is drawn from the training data randomly with equal probability. This corresponds to the standard stochastic optimization setting, in which observed samples are iid from some underlying distributions. The following result is a simple consequence of Theorem 3.1. For simplicity, we only consider the case with θ =∞ and constant gravity gi = g.\nTheorem 3.2 Consider a set of training data zi = (xi, yi) for i = 1, . . . , n, and let\nR(w, g) = 1 n n∑ i=1 L(w, zi) + g‖w‖1\nbe the L1 regularized loss over training data. Let ŵ1 = w1 = 0, and de ne recursively for t = 1, 2, . . .\nwt+1 = T (wt − η∇1(wt, zit), gη), ŵt+1 = ŵt + (wt+1 − ŵt)/(t+ 1),\nwhere each it is drawn from {1, . . . , n} uniformly at random. If Assumption 3.1 holds, then at any time T , the following inequalities are valid for all w̄ ∈ Rd:\nEi1,...,iT\n[ (1− 0.5Aη)R ( ŵT ,\ng\n1− 0.5Aη )] ≤Ei1,...,iT [ 1− 0.5Aη\nT\nT∑ i=1 R ( wi,\ng\n1− 0.5Aη\n)]\n≤η 2 B +\n‖w̄‖2\n2ηT +R(w̄, g).\nProof. Note that the recursion of ŵt implies that\nŵT = 1 T T∑ t=1 wt\nfrom telescoping the update rule. Because R(w, g) is convex in w, the rst inequality follows directly from Jensen's inequality. In the following we only need to prove the second inequality. Theorem 3.1 implies the following:\n1− 0.5Aη T T∑ t=1 [ L(wt, zit) +\ng\n1− 0.5Aη ‖wt‖1\n] ≤ g‖w̄‖1 + η\n2 B +\n‖w̄‖2\n2ηT + 1 T T∑ t=1 L(w̄, zit). (8)\n8\nObserve that\nEit [ L(wt, zit) +\ng\n1− 0.5Aη ‖wt‖1\n] = R ( wt,\ng\n1− 0.5Aη ) and\ng‖w̄‖1 + Ei1,...,iT [ 1 T T∑ t=1 L(w̄, zit) ] = R(w̄, g).\nThe second inequality is obtained by taking the expectation with respect to Ei1,...,iT in (8). If we let η → 0 and ηT →∞, the bound in Theorem 3.2 becomes\nE [R(ŵT , g)] ≤ E [ 1 T T∑ t=1 R(wt, g) ] ≤ inf w̄ R(w̄, g) + o(1).\nThat is, on average ŵT approximately solves the L1 regularization problem\ninf w [ 1 n n∑ i=1 L(w, zi) + g‖w‖1 ] .\nIf we choose a random stopping time T , then the above inequalities says that on average R(wT ) also solves this L1 regularization problem approximately. Therefore in our experiment, we use the last solution wT instead of the aggregated solution ŵT .\nSince 1-norm regularization is frequently used to achieve sparsity in the batch learning setting, the connection to 1-norm regularization can be regarded as an alternative justi cation for the sparse-online algorithm developed in this paper."
    }, {
      "heading" : "4 Truncated Gradient Algorithm for Least Squares",
      "text" : "The method in Section 3 can be directly applied to least squares regression. This leads to Algorithm 1 which implements sparsi cation for square loss according to equation (7). In the description, we use superscripted symbol wj to denote the j-th component of vector w (in order to di erentiate from wi, which we have used to denote the i-th weight vector). For clarity, we also drop the index i from wi. Although we keep the choice of gravity parameters gi open in the algorithm description, in practice, we only consider the following choice:\ngi =\n{ Kg if i/K is an integer\n0 otherwise .\nThis may give a more aggressive truncation (thus sparsity) after every K-th iteration. Since we do not have a theorem formalizing how much more sparsity one can gain from this idea, its e ect will only be examined through experiments.\nIn many online learning situations (such as web applications), only a small subset of the features have nonzero values for any example x. It is thus desirable to deal with sparsity only in this small subset rather than all features, while simultaneously inducing sparsity on all feature weights. Moreover, it is important to store only features with non-zero coe cients (if the number of features is so large that it cannot be stored in memory, this approach allows us to use a hashtable to track\n9\nAlgorithm 1 Truncated Gradient\nInputs:\n• threshold θ ≥ 0\n• gravity sequence gi ≥ 0\n• learning rate η ∈ (0, 1)\n• example oracle O\ninitialize weights wj ← 0 (j = 1, . . . , d) for trial i = 1, 2, . . .\n1. Acquire an unlabeled example x = [x1, x2, . . . , xd] from oracle O\n2. forall weights wj (j = 1, . . . , d)\n(a) if wj > 0 and wj ≤ θ then wj ← max{wj − giη, 0} (b) elseif wj < 0 and wj ≥ −θ then wj ← min{wj + giη, 0}\n3. Compute prediction: ŷ = ∑\nj w jxj\n4. Acquire the label y from oracle O\n5. Update weights for all features j: wj ← wj + 2η(y − ŷ)xj\nonly the nonzero coe cients). We describe how this can be implemented e ciently in the next section.\nFor reference, we present a specialization of Theorem 3.1 in the following corollary that is directly applicable to Algorithm 1.\nCorollary 4.1 (Sparse Online Square Loss Regret) If there exists C > 0 such that for all x, ‖x‖ ≤ C, then for all w̄ ∈ Rd, we have\n1− 2C2η T T∑ i=1 [ (wTi xi − yi)2 + gi 1− 2C2η ‖wi · I(|wi| ≤ θ)‖1 ]\n≤‖w̄‖ 2\n2ηT + 1 T T∑ i=1 [ (w̄Txi − yi)2 + gi+1‖w̄ · I(|wi+1| ≤ θ)‖1 ] ,\nwhere wi = [w1, . . . , wd] ∈ Rd is the weight vector used for prediction at the i-th step of Algorithm 1; (xi, yi) is the data point observed at the i-step.\nThis corollary explicitly states that the average square loss incurred by the learner (left term) is bounded by the average square loss of the best weight vector w̄, plus a term related to the size of w̄ which decays as 1/T and an additive o set controlled by the sparsity threshold θ and the gravity parameter gi.\n10"
    }, {
      "heading" : "5 E cient Implementation",
      "text" : "We altered a standard gradient-descent implementation (Vowpal Wabbit [6]) according to algorithm 1. Vowpal Wabbit optimizes square loss on a linear representation w ·x via gradient descent (3) with a couple caveats:\n1. The prediction is normalized by the square root of the number of nonzero entries in a sparse vector, w · x/|x|0.50 . This alteration is just a constant rescaling on dense vectors which is e ectively removable by an appropriate rescaling of the learning rate.\n2. The prediction is clipped to the interval [0, 1], implying that the loss function is not square loss for unclipped predictions outside of this dynamic range. Instead the update is a constant value, equivalent to the gradient of a linear loss function.\nThe learning rate in Vowpal Wabbit is controllable, supporting 1/i decay as well as a constant learning rate (and rates in-between). The program operates in an entirely online fashion, so the memory footprint is essentially just the weight vector, even when the amount of data is very large.\nAs mentioned earlier, we would like the algorithm's computational complexity to depend linearly on the number of nonzero features of an example, rather than the total number of features. The approach we took was to store a time-stamp τj for each feature j. The time-stamp was initialized to the index of the example where feature j was nonzero for the rst time. During online learning, we simply went through all nonzero features j of example i, and could simulate the shrinkage of wj after τj in a batch mode. These weights are then updated, and their time stamps are reset to i. This lazy-update idea of delaying the shrinkage calculation until needed is the key to e cient implementation of truncated gradient. Speci cally, instead of using update rule (6) for weight wj , we shrunk the weights of all nonzero feature j di erently by the following:\nf(wj) = T1 ( wj + 2η(y − ŷ)xj , ⌊ i− τj K ⌋ Kηg, θ ) ,\nand τj is updated by\nτj ← τj + ⌊ i− τj K ⌋ K.\nWe note that such a lazy-update trick by maintaining the time-stamp information can be applied to the other two algorithms given in section 3. In the coe cient rounding algorithm (4), for instance, for each nonzero feature j of example i, we can rst perform a regular gradient descent on the square loss, and then do the following: if |wj | is below the threshold θ and i ≥ τj + K, we round wj to 0 and set τj to i.\nThis implementation shows that the truncated gradient method satis es the following requirements needed for solving large scale problems with sparse features.\n• The algorithm is computationally e cient: the number of operations per online step is linear in the number of nonzero features, and independent of the total number of features.\n• The algorithm is memory e cient: it maintains a list of active features, and a feature can be inserted when observed, and deleted when the corresponding weight becomes zero.\n11\nIf we apply the online projection idea in [14] to solve (1), then in the update rule (7), one has to pick the smallest gi ≥ 0 such that ‖wi+1‖1 ≤ s. Unfortunately, we do not know any e cient method to nd this speci c gi using operations independent of the total number of features. A standard implementation relies on sorting all weights, which requires O(d ln d) operations, where d is the total number of features. This complexity is unacceptable for our purpose. The theoretical analysis presented in this paper shows that we can obtain a meaningful regret bound by picking an arbitrary gi. This is important because the resulting method is much simpler and can be e ciently implemented. Moreover, our method allows non-convex updates that are closely related to the simple coe cient rounding idea."
    }, {
      "heading" : "6 Empirical Results",
      "text" : "We applied Vowpal Wabbit with the e ciently implemented sparsify option, as described in the previous section, to a selection of datasets, including eleven datasets from the UCI repository [1], the much larger dataset rcv1 [7], and a private large-scale dataset Big_Ads related to ad interest prediction. While UCI datasets are useful for benchmark purposes, rcv1 and Big_Ads are more interesting since they embody real-world datasets with large numbers of features, many of which are less informative for making predictions than others. The datasets are summarized in Table 1.\nThe UCI datasets we used do not have many features, and it is expected that a large fraction of these features are useful for making predictions. For comparison purposes as well as to better demonstrate the behavior of our algorithm, we also added 1000 random binary features to those datasets. Each feature has value 1 with probability 0.05 and 0 otherwise.\n12"
    }, {
      "heading" : "6.1 Feature Sparsi cation of Truncated Gradient Descent",
      "text" : "In the rst set of experiments, we are interested in how much reduction in the number of features is possible without a ecting learning performance signi cantly; speci cally, we require the accuracy be reduced by no more than 1% for classi cation tasks, and the total square loss be increased by no more than 1% for regression tasks. As common practice, we allowed the algorithm to run on the training data set for multiple passes with decaying learning rate. For each dataset, we performed 10-fold cross validation over the training set to identify the best set of parameters, including the learning rate η, the sparsi cation rate g, number of passes of the training set, and the decay of learning rate across these passes. This set of parameters was then used to train Vowpal Wabbit on the whole training set. Finally, the learned classi er/regressor is evaluated on the test set. We xed K = 1 and θ =∞ in these experiments, and will study the e ects of K and θ in later subsections.\nFigure 1 shows the fraction of reduced features after sparsi cation is applied to each dataset. For UCI datasets with randomly added features, Vowpal Wabbit is able to reduce the number of features by a fraction of more than 90%, except for the ad dataset in which only 71% reduction is observed. This less satisfying result might be improved by a more extensive parameter search in cross validation. However, if we can tolerate 1.3% decrease in accuracy (instead of 1% as for other datasets) during cross validation, Vowpal Wabbit is able to achieve 91.4% reduction, indicating that a large reduction is still possible at the tiny additional cost of 0.3% accuracy loss. With this slightly more aggressive sparsi cation, the test-set accuracy drops from 95.9% (when only 1% loss in accuracy is allowed in cross validation) to 95.4%, while the accuracy without sparsi cation is 96.5%.\nEven for the original UCI datasets without arti cially added features, Vowpal Wabbit manages to lter out some of the less useful features while maintaining the same level of performance. For example, for the ad dataset, a reduction of 83.4% is achieved. Compared to the results above, it seems the most e ective feature reductions occur on datasets with a large number of less useful features, exactly where sparsi cation is needed.\nFor rcv1, more than 75% of features are removed after the sparsi cation process, indicating the e ectiveness of our algorithm in real-life problems. We were not able to try many parameters in cross validation because of the size of rcv1. It is expected that more reduction is possible when a more thorough parameter search is performed.\nThe previous results do not exercise the full power of the approach presented here because they are applied to datasets where standard Lasso regularization [12] is or may be computationally viable. We have also applied this approach to a large non-public dataset Big_Ads where the goal is predicting which of two ads was clicked on given context information (the content of ads and query information). Here, accepting a 0.009 increase in classi cation error allows us to reduce the number of features from about 3× 109 to about 24× 106, a factor of 125 decrease in the number of features.\nFor classi cation tasks, we also study how our sparsi cation solution a ects AUC (Area Under the ROC Curve), which is a standard metric for classi cation.1 Using the same sets of parameters from 10-fold cross validation described above, we nd that the criterion is not a ected signi cantly by sparsi cation and in some cases, they are actually slightly improved. The reason may be that our sparsi cation method remove some of the features that could have confused Vowpal Wabbit . The ratios of the AUC with and without sparsi cation for all classi cation tasks are plotted in Figures 2. It is often the case that these ratios are above 98%.\n1We use AUC here and in later subsections because it is insensitive to threshold, which is unlike accuracy.\n13"
    }, {
      "heading" : "6.2 The E ects of K",
      "text" : "As we argued before, using a K value larger than 1 may be desired in truncated gradient and the rounding algorithms. This advantage is empirically demonstrated here. In particular, we try K = 1, K = 10, and K = 20 in both algorithms. As before, cross validation is used to select parameters in the rounding algorithm, including learning rate η, number of passes of data during training, and learning rate decay over training passes.\nFigures 3 and 4 give the AUC vs. number-of-feature plots, where each data point is generated by running respective algorithm using a di erent value of g (for truncated gradient) and θ (for the rounding algorithm). We used θ =∞ in truncated gradient.\nFor truncated gradient, the performances with K = 10 or 20 are at least as good as those with K = 1, and for the spambase dataset further feature reduction is achieved at the same level of performance, reducing the number of features from 76 (when K = 1) to 25 (when K = 10 or 20) with of an AUC of about 0.89.\nSuch an e ect is even more remarkable in the rounding algorithm. For instance, in the ad dataset the algorithm using K = 1 achieves an AUC of 0.94 with 322 features, while 13 and 7 features are needed using K = 10 and K = 20, respectively."
    }, {
      "heading" : "6.3 The E ects of θ in Truncated Gradient",
      "text" : "In this subsection, we empirically study the e ect of θ in truncated gradient. The rounding algorithm is also included for comparison due to its similarity to truncated gradient when θ = g. As before, we used cross validation to choose parameters for each θ value tried, and focused on the AUC metric in the eight UCI classi cation tasks, except the degenerate one of wpbc. We xed K = 10 in both algorithm.\nFigure 5 gives the AUC vs. number-of-feature plots, where each data point is generated by\n14\nrunning respective algorithms using a di erent value of g (for truncated gradient) and θ (for the rounding algorithm). A few observations are in place. First, the results verify the observation that the behavior of truncated gradient with θ = g is similar to the rounding algorithm. Second, these results suggest that, in practice, it may be desired to use θ = ∞ in truncated gradient because it avoids the local minimum problem."
    }, {
      "heading" : "6.4 Comparison to Other Algorithms",
      "text" : "The next set of experiments compares truncated gradient descent to other algorithms regarding their abilities to tradeo feature sparsi cation and performance. Again, we focus on the AUC metric in UCI classi cation tasks except wpdc. The algorithms for comparison include:\n• The truncated gradient algorithm: We xed K = 10 and θ = ∞, used crossed-validated parameters, and altered the gravity parameter g.\n• The rounding algorithm described in section 3.1: We xed K = 10, used cross-validated parameters, and altered the rounding threshold θ.\n• The subgradient algorithm described in section 3.2: We xed K = 10, used cross-validated parameters, and altered the regularization parameter g.\n• The Lasso [12] for batch L1 regularization: We used a publicly available implementation [11].\nNote that we do not attempt to compare these algorithms on rcv1 and Big_Ads simply because their sizes are too large for the Lasso and subgradient descent (c.f., section 5).\nFigure 6 gives the results. First, it is observed that truncated gradient is consistently competitive with the other two online algorithms and signi cantly outperformed them in some problems. This suggests the e ectiveness of truncated gradient.\n15\nSecond, it is interesting to observe that the qualitative behavior of truncated gradient is often similar to that of LASSO, especially when very sparse weight vectors are allowed (the left sides in the graphs). This is consistent with theorem 3.2 showing the relation between these two algorithms. However, LASSO usually has worse performance when the allowed number of nonzero weights is set too large (the right side of the graphs). In this case, LASSO seems to over t. In contrast, truncated gradient is more robust to over tting. The robustness of online learning is often attributed to early stopping, which has been extensively discussed in the literature (e.g., in [13]).\nFinally, it is worth emphasizing that the experiments in this subsection try to shed some light on the relative strengths of these algorithms in terms of feature sparsi cation. For large datasets such as Big_Ads only truncated gradient, coe cient rounding, and the sub-gradient algorithms are applicable to large-scale problems with sparse features. As we have shown and argued, the rounding algorithm is quite ad hoc and may not work robustly in some problems, and the subgradient algorithm does not lead to sparsity in general during training."
    }, {
      "heading" : "7 Conclusion",
      "text" : "This paper covers the rst sparsi cation technique for large-scale online learning with strong theoretical guarantees. The algorithm, truncated gradient, is the natural extension of Lasso-style regression to the online-learning setting. Theorem 3.1 proves that the technique is sound: it never harms performance much compared to standard stochastic gradient descent in adversarial situations. Furthermore, we show that the asymptotic solution of one instance of the algorithm is essentially equivalent to Lasso regression, and thus justifying the algorithm's ability to produce sparse weight vectors when the number of features is intractably large.\nThe theorem is veri ed experimentally in a number of problems. In some cases, especially for problems with many irrelevant features, this approach achieves a one or two order of magnitude reduction in the number of features."
    }, {
      "heading" : "A Proof of Theorem 3.1",
      "text" : "The following lemma is the essential step in our analysis.\nLemma A.1 For update rule (6) applied to weight vector w on example z = (x, y) with gravity parameter gi = g, resulting in a weight vector w′. If Assumption 3.1 holds, then for all w̄ ∈ Rd, we have\n(1− 0.5Aη)L(w, z) + g‖w′ · I(|w′| ≤ θ)‖1\n≤L(w̄, z) + g‖w̄ · I(|w′| ≤ θ)‖1 + η\n2 B +\n‖w̄ − w‖2 − ‖w̄ − w′‖2\n2η .\nProof. Consider any target vector w̄ ∈ Rd and let w̃ = w − η∇1L(w, z). We have w′ = T1(w̃, gη, θ). Let\nu(w̄, w′) = g‖w̄ · I(|w′| ≤ θ)‖1 − g‖w′ · I(|w′| ≤ θ)‖1.\n17\nThen the update equation implies the following:\n‖w̄ − w′‖2\n≤‖w̄ − w′‖2 + ‖w′ − w̃‖2 =‖w̄ − w̃‖2 − 2(w̄ − w′)T (w′ − w̃) ≤‖w̄ − w̃‖2 + 2ηu(w̄, w′) =‖w̄ − w‖2 + ‖w − w̃‖2 + 2(w̄ − w)T (w − w̃) + 2ηu(w̄, w′) =‖w̄ − w‖2 + η2‖∇1L(w, z)‖2 + 2η(w̄ − w)T∇1L(w, z) + 2ηu(w̄, w′) ≤‖w̄ − w‖2 + η2‖∇1L(w, z)‖2 + 2η(L(w̄, z)− L(w, z)) + 2ηu(w̄, w′) ≤‖w̄ − w‖2 + η2(AL(w, z) +B) + 2η(L(w̄, z)− L(w, z)) + 2ηu(w̄, w′).\nHere, the rst and second equalities follow from algebra, and the third from the de nition of w̃. The rst inequality follows because a square is always non-negative. The second inequality follows because w′ = T1(w̃, gη, θ), which implies that (w′− w̃)Tw′ = −gη‖w′ · I(|w′| ≤ θ)‖1 and |w′j− w̃j | ≤ gηI(|w′j | ≤ θ). Therefore\n−(w̄ − w′)T (w′ − w̃) =− w̄T (w′ − w̃) + w′T (w′ − w̃)\n≤ d∑\nj=1\n|w̄j ||w′j − w̃j |+ (w′ − w̃)Tw′\n≤gη d∑\nj=1\n|w̄j |I(|w′j | ≤ θ) + (w′ − w̃)Tw′ = ηu(w̄, w′).\nThe third inequality follows from the de nition of sub-gradient of a convex function, which implies that\n(w̄ − w)T∇1L(w, z) ≤ L(w̄, z)− L(w, z)\nfor all w and w̄. The fourth inequality follows from Assumption 3.1. Rearranging the above inequality leads to the desired bound. Proof. (of theorem 3.1) Apply Lemma A.1 to the update on trial i, we have\n(1− 0.5Aη)L(wi, zi) + gi‖wi+1 · I(|wi+1| ≤ θ)‖1\n≤L(w̄, zi) + ‖w̄ − wi‖2 − ‖w̄ − wi+1‖2\n2η + gi‖w̄ · I(|wi+1| ≤ θ)‖1 +\nη 2 B.\n18\nNow summing over i = 1, 2, . . . , T , we obtain\nT∑ i=1 [(1− 0.5Aη)L(wi, zi) + gi‖wi+1 · I(|wi+1| ≤ θ)‖1]\n≤ T∑\ni=1\n[ ‖w̄ − wi‖2 − ‖w̄ − wi+1‖2\n2η + L(w̄, zi) + gi‖w̄ · I(|wi+1| ≤ θ)‖1 +\nη 2 B\n]\n= ‖w̄ − w1‖2 − ‖w̄ − wT ‖2 2η + η 2 TB + T∑ i=1 [L(w̄, zi) + gi‖w̄ · I(|wi+1| ≤ θ)‖1]\n≤ ‖w̄‖ 2 2η + η 2 TB + T∑ i=1 [L(w̄, zi) + gi‖w̄ · I(|wi+1| ≤ θ)‖1].\nThe rst equality follows from the telescoping sum and the second inequality follows from the initial condition (all weights are zero) and dropping negative quantities. The theorem follows by dividing with respect to T and rearranging terms.\n19"
    } ],
    "references" : [ {
      "title" : "University of California, Irvine, School of Information and Computer Sciences, http://www.ics.uci.edu/∼mlearn/MLRepository.html",
      "author" : [ "Arthur Asuncion", "David J. Newman" ],
      "venue" : "UCI machine learning repository,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2007
    }, {
      "title" : "Worst-case quadratic loss bounds for prediction using linear functions and gradient descent",
      "author" : [ "Nicolò Cesa-Bianchi", "Philip M. Long", "Manfred Warmuth" ],
      "venue" : "IEEE Transactions on Neural Networks,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 1996
    }, {
      "title" : "Map-reduce for machine learning on multicore",
      "author" : [ "Cheng-Tao Chu", "Sang Kyun Kim", "Yi-An Lin", "YuanYuan Yu", "Gary Bradski", "Andrew Y. Ng", "Kunle Olukotun" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2008
    }, {
      "title" : "Exponentiated gradient versus gradient descent for linear predictors",
      "author" : [ "Jyrki Kivinen", "Manfred K. Warmuth" ],
      "venue" : "Information and Computation,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 1997
    }, {
      "title" : "RCV1: A new benchmark collection for text categorization research",
      "author" : [ "David D. Lewis", "Yiming Yang", "Tony G. Rose", "Fan Li" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2004
    }, {
      "title" : "Learning quickly when irrelevant attributes abound: A new linear-threshold algorithms",
      "author" : [ "Nick Littlestone" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 1988
    }, {
      "title" : "On-line learning of linear functions",
      "author" : [ "Nick Littlestone", "Philip M. Long", "Manfred K. Warmuth" ],
      "venue" : "Computational Complexity,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1995
    }, {
      "title" : "Pegasos: Primal Estimated sub- GrAdient SOlver for SVM",
      "author" : [ "Shai Shalev-Shwartz", "Yoram Singer", "Nathan Srebro" ],
      "venue" : "In Proceedings of the Twenty-Fourth International Conference on Machine Learning",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2007
    }, {
      "title" : "Matlab implementation of LASSO, LARS, the elastic net and SPCA",
      "author" : [ "Karl Sjöstrand" ],
      "venue" : "Version 2.0,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2005
    }, {
      "title" : "Regression shrinkage and selection via the lasso",
      "author" : [ "Robert Tibshirani" ],
      "venue" : "Journal of the Royal Statistical Society,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 1996
    }, {
      "title" : "Solving large scale linear prediction problems using stochastic gradient descent algorithms",
      "author" : [ "Tong Zhang" ],
      "venue" : "In Proceedings of the Twenty-First International Conference on Machine Learning",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2004
    } ],
    "referenceMentions" : [ {
      "referenceID" : 2,
      "context" : ", [3]).",
      "startOffset" : 2,
      "endOffset" : 5
    }, {
      "referenceID" : 5,
      "context" : ", [8], [9], [2], and [5]).",
      "startOffset" : 2,
      "endOffset" : 5
    }, {
      "referenceID" : 6,
      "context" : ", [8], [9], [2], and [5]).",
      "startOffset" : 7,
      "endOffset" : 10
    }, {
      "referenceID" : 1,
      "context" : ", [8], [9], [2], and [5]).",
      "startOffset" : 12,
      "endOffset" : 15
    }, {
      "referenceID" : 3,
      "context" : ", [8], [9], [2], and [5]).",
      "startOffset" : 21,
      "endOffset" : 24
    }, {
      "referenceID" : 9,
      "context" : "1 What Others Do The Lasso algorithm [12] is commonly used to achieve L1 regularization for linear regression.",
      "startOffset" : 37,
      "endOffset" : 41
    }, {
      "referenceID" : 6,
      "context" : "The above method has been widely used in online learning such as [9] and [2].",
      "startOffset" : 65,
      "endOffset" : 68
    }, {
      "referenceID" : 1,
      "context" : "The above method has been widely used in online learning such as [9] and [2].",
      "startOffset" : 73,
      "endOffset" : 76
    }, {
      "referenceID" : 7,
      "context" : "For example, the idea has been successfully applied to solve large-scale standard SVM formulations [10, 13].",
      "startOffset" : 99,
      "endOffset" : 107
    }, {
      "referenceID" : 10,
      "context" : "For example, the idea has been successfully applied to solve large-scale standard SVM formulations [10, 13].",
      "startOffset" : 99,
      "endOffset" : 107
    }, {
      "referenceID" : 7,
      "context" : "5 Stochastic Setting Stochastic-gradient-based online learning methods can be used to solve large-scale batch optimization problems, often quite successfully [10, 13].",
      "startOffset" : 158,
      "endOffset" : 166
    }, {
      "referenceID" : 10,
      "context" : "5 Stochastic Setting Stochastic-gradient-based online learning methods can be used to solve large-scale batch optimization problems, often quite successfully [10, 13].",
      "startOffset" : 158,
      "endOffset" : 166
    }, {
      "referenceID" : 0,
      "context" : "The prediction is clipped to the interval [0, 1], implying that the loss function is not square loss for unclipped predictions outside of this dynamic range.",
      "startOffset" : 42,
      "endOffset" : 48
    }, {
      "referenceID" : 0,
      "context" : "We applied Vowpal Wabbit with the e ciently implemented sparsify option, as described in the previous section, to a selection of datasets, including eleven datasets from the UCI repository [1], the much larger dataset rcv1 [7], and a private large-scale dataset Big_Ads related to ad interest prediction.",
      "startOffset" : 189,
      "endOffset" : 192
    }, {
      "referenceID" : 4,
      "context" : "We applied Vowpal Wabbit with the e ciently implemented sparsify option, as described in the previous section, to a selection of datasets, including eleven datasets from the UCI repository [1], the much larger dataset rcv1 [7], and a private large-scale dataset Big_Ads related to ad interest prediction.",
      "startOffset" : 223,
      "endOffset" : 226
    }, {
      "referenceID" : 9,
      "context" : "The previous results do not exercise the full power of the approach presented here because they are applied to datasets where standard Lasso regularization [12] is or may be computationally viable.",
      "startOffset" : 156,
      "endOffset" : 160
    }, {
      "referenceID" : 9,
      "context" : "• The Lasso [12] for batch L1 regularization: We used a publicly available implementation [11].",
      "startOffset" : 12,
      "endOffset" : 16
    }, {
      "referenceID" : 8,
      "context" : "• The Lasso [12] for batch L1 regularization: We used a publicly available implementation [11].",
      "startOffset" : 90,
      "endOffset" : 94
    }, {
      "referenceID" : 10,
      "context" : ", in [13]).",
      "startOffset" : 5,
      "endOffset" : 9
    } ],
    "year" : 2017,
    "abstractText" : "We propose a general method called truncated gradient to induce sparsity in the weights of online learning algorithms with convex loss functions. This method has several essential properties: 1. The degree of sparsity is continuous a parameter controls the rate of sparsi cation from no sparsi cation to total sparsi cation. 2. The approach is theoretically motivated, and an instance of it can be regarded as an online counterpart of the popular L1-regularization method in the batch setting. We prove that small rates of sparsi cation result in only small additional regret with respect to typical online learning guarantees. 3. The approach works well empirically. We apply the approach to several datasets and nd that for datasets with large numbers of features, substantial sparsity is discoverable.",
    "creator" : "LaTeX with hyperref package"
  }
}