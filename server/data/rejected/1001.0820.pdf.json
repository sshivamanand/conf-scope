{
  "name" : "1001.0820.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ ],
    "emails" : [ "yuliya@cs.utexas.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n00 1.\n08 20\nv1 [\ncs .A\nI] 6\nJ an\n2 01\n0"
    }, {
      "heading" : "Abstract Answer Set Solvers with Backjumping",
      "text" : "and Learning (long version)"
    }, {
      "heading" : "YULIYA LIERLER",
      "text" : "Department of Computer Science\nUniversity of Texas at Austin\n1 University Station C0500\nTaylor Hall 2.124\nAustin, USA\nE-mail: yuliya@cs.utexas.edu"
    }, {
      "heading" : "Abstract",
      "text" : "Nieuwenhuis, Oliveras, and Tinelli (2006) showed how to describe enhancements of the Davis-Putnam-Logemann-Loveland algorithm using transition systems, instead of pseudocode. We design a similar framework for several algorithms that generate answer sets for logic programs: smodels, smodelscc , asp-sat with Learning (cmodels), and a newly designed and implemented algorithm sup. This approach to describing answer set solvers makes it easier to prove their correctness, to compare them, and to design new systems.\nKEYWORDS: answer set programming, inference, learning"
    }, {
      "heading" : "1 Introduction",
      "text" : "Answer Set Programming (ASP) is a methodology commonly used for solving combinatorial search problems (Lifschitz 2008). In the development of ASP solvers, computational ideas behind SAT solvers (Gomes et al. 2008) play an important role. Influence of SAT solvers development on ASP systems is twofold. On the one hand, such ASP solvers as assat1 and cmodels2 follow the so called SAT-based approach where a SAT solver is invoked for search, possibly multiple times. On the other hand, “native” ASP solvers that implement search procedures specifically suited for logic programs often adopt computational techniques from SAT solvers. For instance, dlv3 implements backjumping (Ricca et al. 2006), and smodelscc 4 (Ward and Schlipf 2004) extends the answer set solver smodels5 by introducing restarts, conflict-driven\n1 http://assat.cs.ust.hk/ . 2 http://www.cs.utexas.edu/users/tag/cmodels . 3 http://www.dbai.tuwien.ac.at/proj/dlv/ . 4 http://www.nku.edu/∼wardj1/Research/smodels cc.html . 5 http://www.tcs.hut.fi/Software/smodels/ .\nbackjumping, learning, and forgetting – techniques widely used in SAT solvers. The ASP solver sup6 (Lierler 2008) implements these features also.\nIn this paper our main goal is to show how the “abstract” approach to describing SAT solvers proposed in (Nieuwenhuis et al. 2006) can be extended to ASP solvers that use these sophisticated features. Usually computation procedures are described in terms of pseudocode. In (Nieuwenhuis et al. 2006), the authors proposed an alternative approach to describing dpll-like procedures. They introduced an abstract framework that captures what ”states of computation” are, and what transitions between states are allowed. In this way, it defines a directed graph such that every execution of the dpll procedure corresponds to a path in this graph. Some edges may correspond to unit propagation steps, some to branching, some to backtracking. This allows the authors to model a dpll-like algorithm by a mathematically simple and elegant object, graph, rather than a collection of pseudocode statements. In (Lierler 2008), we extended this framework for describing such ASP algorithms as smodels, asp-sat with Backtracking, and sup without Learning. In this paper, we expand our previous work on abstract answer set solvers to cover such features as backjumping and learning (and also forgetting and restart). We start by introducing an abstract framework that captures a general mechanism of these sophisticated features in ASP solvers. For instance, this framework provides the transition underlying the process of learning a clause, but it does not suggest which clause shall be learned. Similarly, it provides a general description of backjumping but it does not supply the means for computing a “backjump clause” necessary for an answer set solver to perform backjumping. We then enhance this abstract framework to capture enough information about a state of computation for deriving a backjump clause.\nUsually, dpll-like procedures implement conflict-driven backjumping and learning where a particular learning schema such as, for instance, Decision or FirstUIP (Mitchell 2005) is applied for computing a special kind of a backjump clause. There are two common methods for describing a backjump clause construction. One employs the implication graph (Marques-Silva and Sakallah 1996) and the other employs resolution (Mitchell 2005). Ward and Schlipf (2004) extended the notion of an implication graph to the smodels algorithm. They then defined an algorithm for computing FirstUIP backjump clauses utilized by smodelscc to implement conflict-driven backjumping and learning. In this paper we introduce the algorithms BackjumpClause and BackjumpClauseFirstUIP based on resolution and the enhanced abstract framework that compute Decision and FirstUIP7 backjump clauses respectively.\nIn (Lierler 2008), we introduced the basic algorithm underlining the system sup but neglected some of its features: conflict-driven backjumping, learning, forgetting, and restarts. Here we account for these techniques and use an abstract framework designed in this paper for describing system sup. We emphasize that the work on this abstract framework helped us to develop ASP solver sup, to incorporate\n6 http://www.cs.utexas.edu/users/tag/sup . 7 The names of the backjump clauses follow (Mitchell 2005).\nlearning into its algorithm, and to prove its correctness. We analyzed performance of sup against such answer set solvers as cmodels, smodels, smodelscc, and clasp8. Overall, sup performs well against these rival systems.\nWe start the paper with Section 2 that reviews the abstract DPLL framework introduced in (Nieuwenhuis et al. 2006) and some logic programming concepts. In Section 3, we define a graph representing the application of the algorithm for finding supporting models of a logic program. This paves the way to defining a graph representing the application of the smodels algorithm to a program in Section 4. Section 4.2 elaborates on the relationship between previously defined abstract frameworks. Section 5 extends the abstract DPLL framework by introducing an additional inference rule so that the generate and test algorithm of the SAT-based ASP system cmodels may be characterized by this graph. In Section 6, we review the abstract framework that describes DPLL enhanced by backjumping and learning. In Section 7, we define a general abstract framework for describing ASP algorithms that implement such phenomena as backjumping and learning. In Section 7.2 we describe the algorithms of systems smodelscc and sup by means of this framework. In Section 8 we extend the abstract generate and test framework to accommodate backjumping and learning, and in Section 8.2 we use these findings to describe the cmodels algorithm. Section 9 extends the framework to capture additional information about a computation state of a solver, states the correctness results, and describes how the frameworks are related to each other. Section 10 provides the proofs for these results. In Section 10.3 and 11 we introduce the algorithms based on the extended framework for computing a backjump clause that are important in implementing conflict-driven backjumping and learning. In Section 12 we introduce the concept of an extended graph for the generate and test abstract framework and state the correctness results. Section 13 provides the proofs for these results. At last, in Section 14 we provide the experimental analysis that compares performance of sup with other answer set solvers."
    }, {
      "heading" : "2 Review: Abstract DPLL and Logic Programs",
      "text" : ""
    }, {
      "heading" : "2.1 Abstract Classical DPLL",
      "text" : "For a set σ of atoms, a record M relative to σ is a list of literals over σ where\n(i) some literals in M are annotated by ∆ that marks them as decision literals,\n(ii) M contains no repetitions.\nThe concatenation of two such lists is denoted by juxtaposition. Frequently, we consider a record as a set of literals, ignoring both the annotations and the order between its elements. A literal l is unassigned by a record if neither l nor its complement l belongs to it.\n8 http://www.cs.uni-potsdam.de/clasp/ .\nA state relative to σ is either a distinguished state FailState or a record relative\nto σ. For instance, the states relative to a singleton set {a} of atoms are\nFailState, ∅, a, ¬a, a∆, ¬a∆, a¬a, a∆¬a,\na¬a∆, a∆¬a∆,¬aa, ¬a∆a, ¬aa∆, ¬a∆a∆,\nwhere by ∅ we denote the empty list.\nIf C is a disjunction (conjunction) of literals then by C we understand the conjunction (disjunction) of the complements of the literals occurring in C . We will sometimes identify C with the multi-set of its elements.\nFor any CNF formula F (a finite set of clauses), we will define its DPLL graph dpF . The nodes of dpF are the states relative to the set of atoms occurring in F . We use the terms “state” and “node” interchangeably. Recall that a node is called terminal in a graph if there is no edge leaving this node in the graph. If a state is consistent and complete then it represents a truth assignment for F .\nThe set of edges of dpF is described by a set of “transition rules.” Each transition rule is an expressionM =⇒ M ′ followed by a condition, where M and M ′ are nodes of dpF . Whenever the condition is satisfied, the graph contains an edge from nodeM to M ′. Generally, an edge in the graph may be justified by several transition rules. Figure 1 presents four transition rules that characterize the edges of dpF .\nThis graph can be used for deciding the satisfiability of a formula F simply by constructing an arbitrary path leading from node ∅ until a terminal node M is reached. The following proposition shows that this process always terminates, that F is unsatisfiable if M is FailState, and that M is a model of F otherwise.\nProposition 1 For any CNF formula F ,\n(a) graph dpF is finite and acyclic,\n(b) any terminal state of dpF other than FailState is a model of F , (c) FailState is reachable from ∅ in dpF if and only if F is unsatisfiable.\nFor instance, let F be the set consisting of the clauses\na ∨ b ¬a ∨ c.\nHere is a path in dpF :\n∅ =⇒ (Decide) a∆ =⇒ (Unit Propagate) a∆c =⇒ (Decide) a∆cb∆\n(1)\nThe name of the transition rule after each =⇒ shows which rule justifies the presence of this edge in the graph. Since the state a∆cb∆ is terminal, Proposition 1(b) asserts that {a, c, b} is a model of F . Here is another path in dpF from ∅ to the same terminal node:\n∅ =⇒ (Decide) a∆ =⇒ (Decide) a∆¬c∆ =⇒ (Unit Propagate) a∆¬c∆c =⇒ (Backtrack) a∆c =⇒ (Decide) a∆cb∆\n(2)\nPath (1) corresponds to an execution of dpll in the sense of (Davis et al. 1962); path (2) does not, because it applies Decide to a∆ even though Unit Propagate could be applied in this state.\nNote that the graph dpF is a modification of the classical DPLL graph defined in (Nieuwenhuis et al. 2006, Section 2.3). It is different in three ways. First, its states are pairs M ||F for all CNF formulas F . For the purposes of this section, it is not necessary to include F . Second, the description of the classical DPLL graph involves a “PureLiteral” transition rule. We dropped this rule because it does not correspond to any of the propagation rules used in answer set solvers whose algorithms we will model in this paper. Third, in the definition of that graph, each M is required to be consistent. In case of DPLL, due to the simple structure of a clause, it is possible to characterize the applicability of Backtrack in a simple manner: when some of the clauses become inconsistent with the current partial assignment, Backtrack is applicable. In ASP, it is not easy to describe the applicability of Backtrack if only consistent states are taken into account. We introduced inconsistent states in the graph dpF to facilitate our work on extending this graph to model algorithms of answer set solvers.\nIn the rest of this section we give a proof of Proposition 1.\nLemma 1 For any CNF formula F and any state l1 . . . ln reachable from ∅ in dpF , every model X of F satisfies li if it satisfies all decision literals l ∆ j with j ≤ i ."
    }, {
      "heading" : "Proof",
      "text" : "By induction on the path from ∅ to l1 . . . ln . The property of X that we need to prove trivially holds in the initial state ∅, and we will prove that all transition rules of dpF preserve it.\nTake a model X of F , and consider an edge M =⇒ M ′ where M is a list l1 . . . lk such that X satisfies li if it satisfies all decision literals l ∆ j with j ≤ i .\nIt is clear that the rule justifying the transition from M to M ′ is different from Fail . For each of the other three rules,M ′ is obtained from a prefix ofM by appending a list of literals containing at most one decision literal. Due to the inductive hypothesis, it is sufficient to show that if X satisfies all decision literals in M ′ then X satisfies all M ′.\nUnit Propagate: M ′ is M l . By the inductive hypothesis, for every literal in M the property in question holds. We need to show that X |= l . From the definition of Unit Propagate, for some clause C ∨ l ∈ F , C ⊆ M . Consequently, M |= ¬C . From the inductive hypothesis and the assumption that X satisfies all decision literals in M ′ and hence in M , it follows that X |= M . Since X is a model of F , we conclude that X |= l .\nDecide: M ′ is M l∆. Obvious. Backtrack : M has the form P l∆Q where Q contains no decision literals. M ′ is P l . By the inductive hypothesis, it trivially follows that for every literal in P the property in question holds. We need to show that X |= l . Assume that X |=l . Since Q does not contain decision literals, and the assumption that X satisfies all decision literals in M ′ and hence in P , X satisfies all decision literals in P l∆Q , that is M . By the inductive hypothesis, it follows that X satisfies M . This is impossible because M is inconsistent.\nıProof of Proposition 1\n(a) The finiteness of dpF is obvious. For any list N of literals by |N | we denote the length of N . Any state M other than FailState has the form M0 l ∆ 1 M1 . . . l ∆ p Mp , where l∆1 . . . l ∆ p are all decision literals of M ; we define α(M ) as the sequence of nonnegative integers |M0|, |M1|, . . . , |Mp |, and α(FailState) = ∞. By the definition of the transition rules defining the edges of dpF , if there is an edge from a state M to M ′ in dpF then α(M ) < α(M ′), where < is understood as the lexicographical order. It follows that if a state M ′ is reachable from M then α(M ) < α(M ′). Consequently the graph is acyclic.\n(b) Consider any terminal state M other than FailState. From the fact that Decide is not applicable, we conclude that M has no unassigned literals. Since neither Backtrack nor Fail is applicable,M is consistent. ConsequentlyM is an assignment. It follows that for any clause C ∨ l ∈ F if C 6⊆ M then C ∩M 6= ∅. Furthermore, since Unit Propagate is not applicable, we conclude that if C ⊆ M then l ∈ M . Consequently, M |= C ∨ l . Hence M is a model of F .\n(c) Left-to-right: Since FailState is reachable from ∅, there is an inconsistent stateM without decision literals that is reachable from ∅. By Lemma 1, any model of F satisfies M . Since M is inconsistent we conclude that F has no models.\nRight-to-left: From (a) it follows that there is a path from ∅ to some terminal state. By (b), this state cannot be different from FailState, because F is unsatisfiable."
    }, {
      "heading" : "2.2 Logic Programs",
      "text" : "We consider programs consisting of finitely many rules of the form\na ← b1, . . . , bl , not bl+1, . . . , not bm (3)\nwhere a is an atom or symbol ⊥, and each bi (1 ≤ i ≤ m) is an atom. We will identify the body of (3) with the conjunction\nb1 ∧ . . . ∧ bl ∧ ¬bl+1 ∧ . . .¬ ∧ bm (4)\nand also with the set of its conjunctive terms. If the head a of a rule (3) is an atom then we will identify (3) with the clause\na ∨ ¬b1 ∨ . . . ∨ ¬bl ∨ bl+1 ∨ . . . ∨ bm . (5)\nIf a is ⊥ then we call rule (3) a constraint and identify (3) with the clause\n¬b1 ∨ . . . ∨ ¬bl ∨ bl+1 ∨ . . . ∨ bm . (6)\nWe will often omit the symbol ⊥ when referring to a constraint.\nWe will use two abbreviated forms for a rule (3): The first is\na ← B\nwhere B stands for b1, . . . , bl , not bl+1, . . . , not bm . The second abbreviation is\na ← D ,F (7)\nwhere D stands for the positive part of the body b1, . . . , bl , and F stands for the negative part of the body not bl+1, . . . , not bm .\nThe reduct ΠX of a program Π with respect to a set X of atoms is obtained\nfrom Π by\n• removing each rule (7) such that F ∩ X 6= ∅, and • replacing each remaining rule (7) by a ← D .\nA set X of atoms is an answer set for a program Π if X is minimal (with respect to\nset inclusion) among the sets of atoms that satisfy the reduct ΠX (Gelfond and Lifschitz 1988).\nFor example, let Π be the program\na ← not b b ← not a c ← a d ← d .\n(8)\nConsider set {a, c}. Reduct Π{a,c} is\na ← c ← a d ← d .\n(9)\nSet {a, c} satisfies the reduct and is minimal, hence {a, c} is an answer set of Π. Consider set {a, c, d}. The reduct Π{a,c,d} is (9). Set {a, c, d} satisfies the reduct but is not minimal and hence it is not an answer set of Π.\nBy Bodies(Π, a) we denote the set of the bodies of all rules of Π with head a. For any set M of literals, by M+ we denote the set of positive literals from M . For any consistent and complete set M of literals (that is, an assignment), if M+ is an answer set for a program Π, then M is a model of Π. Moreover, in this case M is a supported model of Π, in the sense that for every atom a ∈ M , M |= B for some B ∈ Bodies(Π, a).\nA set U of atoms occurring in a programΠ is said to be unfounded (Van Gelder et al. 1991)\non a consistent set M of literals w.r.t. Π if for every a ∈ U and every B ∈ Bodies(Π, a), B ∩ M 6= ∅ or U ∩ B+ 6= ∅. There is a tight relation between unfounded sets and answer sets: For any model M of a program Π, M+ is an answer set for Π if and only if M contains no non-empty subsets unfounded on M w.r.t. Π (Corollary 2 from (Saccá and Zaniolo 1990)9).\nFor instance, let Π be program (8) and let M be a consistent set {a,¬b, c, d} of literals. We already demonstrated that M+ = {a, c, d} is not an answer set of Π. Accordingly, its subset {d} is unfounded on {a,¬b, c, d} w.r.t. Π, because the only rule in Π with d in the head\nd ← d\nis such that U ∩ B+ = {d} ∩ {d} 6= ∅.\nWe say that a program Π entails a formula F when for any consistent and complete set M of literals, if M+ is an answer set for Π, then M |= F . For instance, any program Π entails each rule occurring in Π."
    }, {
      "heading" : "3 Generating Supported Models",
      "text" : "In Section 4 we will define, for an arbitrary program Π, a graph smΠ representing the application of the smodels algorithm to Π; the terminal nodes of smΠ are answer sets of Π. As a step in this direction, we describe here a simpler graph atleastΠ."
    }, {
      "heading" : "3.1 Graph atleastΠ",
      "text" : "The terminal nodes of atleastΠ are supported models of Π. The transition rules defining atleastΠ are closely related to procedure Atleast (Simons 2000, Sections 4.1), which is one of the core procedures of the smodels algorithm.\nThe nodes of atleastΠ are the states relative to the set of atoms occurring in Π. The edges of the graph atleastΠ are described by the transition rules Decide, Fail , Backtrack introduced in Section 2.1 and the additional transition rules10 presented\n9 The Corollary 2 from (Saccá and Zaniolo 1990) refers to ”assumption sets” rather than unfounded sets. But as the authors noted, in the context of this corollary the two concepts are equivalent.\n10 The names of some of these rules follow (Ward 2004).\nin Figure 2. Note that each of the rules Unit Propagate LP and Backchain False is similar to Unit Propagate: the former corresponds to Unit Propagate on C ∨ l where l is the head of the rule, and the latter corresponds to Unit Propagate on C ∨ l where l is an element of the body of the rule.\nThis graph can be used for deciding whether program Π has a supported model\nby constructing a path from ∅ to a terminal node:\nProposition 2 For any program Π,\n(a) graph atleastΠ is finite and acyclic, (b) any terminal state of atleastΠ other than FailState is a supported model\nof Π, (c) FailState is reachable from ∅ in atleastΠ if and only if Π has no supported\nmodels.\nFor instance, let Π be program (8). Here is a path in atleastΠ:\n∅ =⇒ (Decide) a∆ =⇒ (Unit Propagate LP) a∆c =⇒ (All Rules Cancelled) a∆c¬b =⇒ (Decide) a∆c¬bd∆\n(10)\nSince the state a∆c¬bd∆ is terminal, Proposition 2(b) asserts that {a, c,¬b, d} is a supported model of Π.\nThe assertion of Proposition 2 will remain true if we drop the transition rules\nBackchain True and Backchain False from the definition of atleastΠ.\nIn the rest of this section we give a proof of Proposition 2.\nLemma 2 For any program Π and any state l1 . . . ln reachable from ∅ in atleastΠ, every supported model X for Π satisfies li if it satisfies all decision literals l ∆ j with j ≤ i ."
    }, {
      "heading" : "Proof",
      "text" : "By induction on the path from ∅ to l1 . . . ln . Similar to the proof of Lemma 1. We will show that the property in question is preserved when the transition from M to M ′ is justified by any of the four new rules.\nTake a supported model X for Π, and consider an edge M =⇒ M ′ where M is a\nlist l1 . . . lk such that X satisfies li if it satisfies all decision literals l ∆ j with j ≤ i .\nAssume that X satisfies all decision literals in M ′. Unit Propagate LP : M ′ is M a. By the inductive hypothesis, for every literal in M the property in question holds. We need to show that X |= a. By the definition of Unit Propagate LP , B ⊆ M for some rule a ← B . Consequently, M |= B . From the inductive hypothesis and the assumption that X satisfies all decision literals in M ′ and hence in M , it follows that X |= M . Since X is a model of Π we conclude that X |= a.\nAll Rules Cancelled : M ′ is M ¬a and B ∩ M 6= ∅ for every B ∈ Bodies(Π, a). Consequently, M |= ¬B for every B ∈ Bodies(Π, a). By the inductive hypothesis, for every literal in M the property in question holds. We need to show that X |= ¬a. By contradiction. Assume that X |= a. From the inductive hypothesis and the assumption that X satisfies all decision literals in M ′ and hence in M , it follows that X |= M . Since M |= ¬B for every B ∈ Bodies(Π, a), it follows that X |= ¬B . We conclude that X is not a supported model of Π.\nBackchain True: M ′ is M l . By the inductive hypothesis, for every literal in M the property in question holds. We need to show that X |= l . By contradiction. Assume X |= l . Consider the rule a ← B corresponding to this application of Backchain True. Since l ∈ B , X |= ¬B . By the definition of Backchain True, B ′ ∩M 6= ∅ for every B ′ in Bodies(Π, a) \\B . Consequently, M |= ¬B ′ for every B ′ in Bodies(Π, a) \\ B . From the inductive hypothesis and the assumption that X satisfies all decision literals in M ′ and hence in M , it follows that X |= M . We conclude that X |= ¬B ′ for every B ′ in Bodies(Π, a)\\B . Hence X is not supported by Π.\nBackchain False: M ′ isM l . By the inductive hypothesis, for every literal inM the property in question holds. We need to show that X |= l . By contradiction. Assume that X |= l . By the definition of Backchain False there exists a rule a ← l ,B in Π such that ¬a ∈ M and B ⊆ M . Consequently, M |= ¬a and M |= B . From the inductive hypothesis and the assumption that X satisfies all decision literals in M ′ and hence in M , it follows that X |= M . We conclude that X |= ¬a and X |= B . From the fact that X |= l , it follows that X does not satisfy the rule a ← l ,B , so that it is not a model of Π.\nıProof of Proposition 2 Parts (a) and (c) are proved as in the proof of Proposition 1, using Lemma 2. (b) Let M be a terminal state so that none of the rules are applicable. From the\nfact that Decide is not applicable, we conclude that M assigns all literals. Since neither Backtrack nor Fail is applicable, M is consistent. Consequently, M is an assignment. Since Unit Propagate LP is not applicable, it follows that for every rule a ← B ∈ Π, if B ⊆ M then a ∈ M . Consequently, if M |= B then M |= a. We conclude that M is a model of Π. We will now show that M is a supported model of Π. By contradiction. Suppose that M is not a supported model. Then, there is an atom a ∈ M such that M 6|= B for every B ∈ Bodies(Π, a). Since M is consistent, B ∩ M 6= ∅ for every B ∈ Bodies(Π, a). Consequently, All Rules Cancelled is applicable. This contradicts the assumption that M is terminal.\nThe fact that the assertion of Proposition 2 remains true if we drop the transition rules Backchain True and Backchain False from the definition of atleastΠ follows from the proof of Proposition 2 (b) that does not refer to those rules.\n3.2 Relation between dpF and atleastΠ\nIt is well known that the supported models of a program can be characterized as models of program’s completion in the sense of (Clark 1978). It turns out that the graph atleastΠ is identical to the graph dpF , where F is the (clausified) completion of Π. To make this claim precise, we first review the notion of completion.\nFor any program Π, its completion consists of Π and the formulas that can be\nwritten as\n¬a ∨ ∨\nB∈Bodies(Π,a)\nB (11)\nfor every atom a in Π. ıCNF − Comp(Π) is the completion converted to CNF using straightforward equivalent transformations. In other words, ıCNF − Comp(Π) consists of clauses of two kinds:\n1. the rules a ← B of the program written as clauses\na ∨ B , (12)\n2. formulas (11) converted to CNF using the distributivity of disjunction over\nconjunction11.\nProposition 3 For any program Π, the graphs atleastΠ and dpCNF-Comp(Π) are equal.\nFor instance, let Π be the program\na ← b, not c b. (13)\nIts completion is\n(a ↔ b ∧ ¬c) ∧ b ∧ ¬c, (14)\n11 It is essential that repetitions are not removed in the process of clausification. For instance, ıCNF − Comp(a ← not a) is the formula (a ∨ a) ∧ (¬a ∨ ¬a).\nand ıCNF − Comp(Π) is\n(a ∨ ¬b ∨ c) ∧ (¬a ∨ b) ∧ (¬a ∨ ¬c) ∧ b ∧ ¬c. (15)\nProposition 3 asserts that atleastΠ coincides with dpCNF-Comp(Π).\nFrom Proposition 3, it follows that applying the Atleast algorithm to a program\nessentially amounts to applying dpll to its completion.\nIn the rest of this section we give a proof of Proposition 3.\nIt is easy to see that the states of the graphs atleastΠ and dpCNF-Comp(Π) coincide. We will now show that the edges of atleastΠ and dpCNF-Comp(Π) coincide also.\nIt is clear that there is an edge M =⇒ M ′ in atleastΠ justified by the rule Decide if and only if there is an edge M =⇒ M ′ in dpCNF-Comp(Π) justified by Decide. The same holds for the transition rules Fail and Backtrack .\nWe will now show that if there is an edge from a state M to a state M ′ in the graph dpCNF-Comp(Π) justified by the transition rule Unit Propagate then there is an edge from M to M ′ in atleastΠ. Consider a clause C ∨ l ∈ ıCNF − Comp(Π) such that C ⊆ M . We will consider two cases, depending on whether C ∨ l comes from (12) or from the CNF of (11).\nCase 1. C ∨ l is a ∨ B corresponding to a rule a ← B . Case 1.1. l is a. Then there is an edge from M to M ′ in atleastΠ justified by\nthe transition rule Unit Propagate LP .\nCase 1.2. l is an element of B . Then B has the form l ,D and C is a ∨D . From C ⊆ M we conclude that D ⊆ M and ¬a ∈ M . There is an edge from M to M ′ in the graph atleastΠ justified by the following instance of Backchain False:\nM =⇒ M l if\n\n\n\na ← l ,D ∈ Π, ¬a ∈ M , D ⊆ M .\nCase 2. C ∨ l has the form ¬a ∨D , where D is one of the clauses of the CNF of ∨\nB∈Bodies(Π,a)\nB .\nThen D has the form ∨\nB∈Bodies(Π,a)\nf (B)\nwhere f is a function that maps every B ∈ Bodies(Π, a) to an element of B .\nCase 2.1. l is ¬a. Then C is D , so that D ⊆ M . Consequently f (B) ∈ B ∩ D ⊆ B ∩M , so that B ∩M 6= ∅ for every B ∈ Bodies(Π, a). There is an edge from M to M ′ in atleastΠ justified by All Rules Cancelled .\nCase 2.2. l is an element of D . From the construction of D , it follows that l =\nf (B) ∈ B for some rule a ← B . Then C is\n¬a ∨ ∨\nB ′∈Bodies(Π,a)\\B\nf (B ′).\nFrom C ⊆ M we conclude that a ∈ M and that f (B ′) ∈ M for every B ′ ∈\nBodies(Π, a)\\B . Since f (B ′) is a conjunctive term of B ′, it follows that B ′∩M 6= ∅. Then there is an edge from M to M ′ in atleastΠ justified by Backchain True.\nWe will now show that if there is an edge from a state M to a state M ′ in the graph atleastΠ justified by one of the transition rules Unit Propagate LP , All Rules Cancelled , Backchain True, and Backchain False then there is an edge from M to M ′ in dpCNF-Comp(Π).\nCase 1. The edge is justified byUnit Propagate LP . Then there is a rule a ← B ∈ Π\nwhere B ⊆ M , and M ′ is M a. By the construction of ıCNF − Comp(Π), a ∨ B ∈ ıCNF − Comp(Π). There is an edge from M to M ′ in dpCNF-Comp(Π) justified by the following instance of Unit Propagate:\nM =⇒ M a if\n{\nB ∨ a ∈ ıCNF − Comp(Π) and B ⊆ M .\nCase 2. The edge is justified by All Rules Cancelled . By the definition of All Rules Cancelled , there is an atom a such that for all B ∈ Bodies(Π, a), B ∩M 6= ∅; and M ′ is M ¬a. Consequently, M contains the complement of some literal in B . Denote one of such literals by f (B), so that f (B) ∈ M . From the construction of ıCNF − Comp(Π),\n¬a ∨ ∨\nB∈Bodies(Π,a)\nf (B)\nbelongs to ıCNF − Comp(Π). By the choice of f ,\n∨\nB∈Bodies(Π,a)\nf (B) ⊆ M .\nThere is an edge from M to M ′ in dpCNF-Comp(Π) justified by the following instance of Unit Propagate:\nM =⇒ M ¬a if\n\n     \n     \n∨\nB∈Bodies(Π,a)\nf (B) ∨ ¬a ∈ ıCNF − Comp(Π),\n∨\nB∈Bodies(Π,a)\nf (B) ⊆ M .\nCase 3. The edge is justified by Backchain True. By the definition of Backchain True, there is a rule a ← B ∈ Π and a literal l ∈ B such that a ∈ M ; for all B ′ ∈ Bodies(Π, a) \\ B , B ′ ∩M 6= ∅; and M ′ is M l . Let f (B ′) be an element of B ′ such that f (B ′) ∈ M . From the construction of ıCNF − Comp(Π),\n¬a ∨ l ∨ ∨\nB ′∈Bodies(Π,a)\\B\nf (B ′)\nbelongs to ıCNF − Comp(Π). By the choice of f ,\n∨\nB ′∈Bodies(Π,a)\\B\nf (B ′) ⊆ M .\nThere is an edge from M to M ′ in dpCNF-Comp(Π) justified by the following instance\nof Unit Propagate:\nM =⇒ M l if\n\n     \n     \n¬a ∨ l ∨ ∨\nB ′∈Bodies(Π,a)\\B\nf (B ′) ∈ ıCNF − Comp(Π),\n(¬a ∨ ∨\nB ′∈Bodies(Π,a)\\B\nf (B ′)) ⊆ M .\nCase 4. The edge is justified by Backchain False. By the definition of Backchain False, there is a rule a ← l ,B ∈ Π such that ¬a ∈ M , B ⊆ M , and M ′ is M l . By the construction of ıCNF − Comp(Π), a ∨ B ∨ l ∈ ıCNF − Comp(Π). There is an edge from M to M ′ in dpCNF-Comp(Π) justified by the following instance of Unit Propagate:\nM =⇒ M l if\n{\na ∨ B ∨ l ∈ ıCNF − Comp(Π) and\na ∨ B ⊆ M ."
    }, {
      "heading" : "4 Answer Set Solver Smodels",
      "text" : ""
    }, {
      "heading" : "4.1 Abstract Smodels",
      "text" : "We now describe the graph smΠ that represents the application of the smodels algorithm to program Π. smΠ is a graph whose nodes are the same as the nodes of the graph atleastΠ. The edges of smΠ are described by the transition rules of atleastΠ and the additional transition rule:\nUnfounded :\nM =⇒ M ¬a if\n{\nM is consistent, and a ∈ U for a set U unfounded on M w.r.t. Π.\nThis transition rule of smΠ is closely related to procedure Atmost (Simons 2000, Sections 4.2), which together with the procedure Atleast forms the core of the smodels algorithm.\nThe graph smΠ can be used for deciding whether program Π has an answer set\nby constructing a path from ∅ to a terminal node:\nProposition 4 For any program Π,\n(a) graph smΠ is finite and acyclic, (b) for any terminal state M of smΠ other than FailState, M + is an answer set\nof Π,\n(c) FailState is reachable from ∅ in smΠ if and only if Π has no answer sets.\nTo illustrate the difference between smΠ and atleastΠ, assume again that Π is program (8). Path (10) in the graph atleastΠ is also a path in smΠ. But state a∆c¬bd∆, which is terminal in atleastΠ, is not terminal in smΠ. This is not\nsurprising, since {a, c,¬b, d}+ = {a, c, d} is not an answer set of Π. To get to a state that is terminal in smΠ, we need two more steps:\n... a∆c¬bd∆ =⇒ (Unfounded, U = {d}) a∆c¬bd∆¬d =⇒ (Backtrack) a∆c¬b¬d\n(16)\nProposition 4(b) asserts that {a, c} is an answer set of Π.\nThe assertion of Proposition 4 will remain true if we drop the transition rules All Rules Cancelled , Backchain True, and Backchain False from the definition of smΠ.\nIn the rest of this section we give a proof of Proposition 4. We say that a model M of a program Π is unfounded-free if no non-empty subset\nof M is an unfounded set on M w.r.t. Π.\nLemma 3 (Corollary 2 from (Saccá and Zaniolo 1990)) For any model M of a program Π, M+ is an answer set for Π if and only if M is unfounded-free.\nLemma 4 For any unfounded set U on a consistent set M of literals w.r.t. a program Π, and any assignment X , if X |= M and X ∩U 6= ∅, then X+ is not an answer set for Π."
    }, {
      "heading" : "Proof",
      "text" : "Assume that X+ is an answer set for Π. Then X is a model of Π. By Lemma 3, it follows that X is unfounded-free. Hence any non-empty subset of X including X ∩ U is not unfounded on X . This means that for some rule a ← B in Π such that a ∈ X ∩ U , B ∩ X = ∅ and X ∩ U ∩ B+ = ∅. From X |= M (M ⊆ X ) and B ∩X = ∅ we conclude that B ∩M = ∅. Since B ∩X = ∅ and X is an assignment, B ⊆ X . It follows that B+ ⊆ X . Consequently U ∩ B+ = X ∩ U ∩ B+ = ∅. This contradicts the assumption that U is an unfounded set on M .\nLemma 5 For any program Π, any state l1 . . . ln reachable from ∅ in smΠ, and any assignment X , if X+ is an answer set for Π then X satisfies li if it satisfies all decision literals l∆j with j ≤ i ."
    }, {
      "heading" : "Proof",
      "text" : "By induction on the path from ∅ to l1 . . . ln . Recall that for any assignment X , if X+ is an answer set for Π, then X is a supported model of Π, and that the transition system smΠ extends atleastΠ only by the transition rule Unfounded . Given our proof of Lemma 2, we only need to demonstrate that application of Unfounded preserves the property.\nConsider a transition M =⇒ M ′ justified by Unfounded , where M is a sequence l1 . . . lk . M ′ is M ¬a, such that a ∈ U , where U is an unfounded set on M w.r.t Π. Take any assignment X such that X+ is an answer set for Π and X satisfies all\ndecision literals l∆j with j ≤ k . By the inductive hypothesis, X |= M . Then X |= ¬a. Indeed, otherwise a would be a common element of X and U , and X ∩ U would be non-empty, which contradicts Lemma 4.\nıProof of Proposition 4 Parts (a) and (c) are proved as in the proof of Proposition 1, using Lemma 5. (b) As in the proof of Proposition 2(b) we conclude that M is a model of Π. Assume that M+ is not an answer set. Then, by Lemma 3, there is a non-empty unfounded set U on M w.r.t. Π such that U ⊆ M . It follows that Unfounded is applicable (with an arbitrary a ∈ U ). This contradicts the assumption that M is terminal.\nThe fact that the assertion of Proposition 4 remains true if we drop the transition rules All Rules Cancelled , Backchain True, and Backchain False from the definition of smΠ follows from the proof of Proposition 4 (b) that does not refer to those rules."
    }, {
      "heading" : "4.2 Smodels Algorithm",
      "text" : "We can view a path in the graph smΠ as a description of a process of search for an answer set for a program Π by applying inference rules. Therefore, we can characterize the algorithm of an answer set solver that utilizes the inference rules of smΠ by describing a strategy for choosing a path in smΠ. A strategy can be based, in particular, on assigning priorities to some or all inference rules of smΠ, so that a solver will never apply a transition rule in a state if a rule with higher priority is applicable to the same state.\nWe use this method to describe the smodels algorithm. System smodels assigns\npriorities to the inference rules of smΠ as follows:\nBacktrack,Fail ≫ Unit Propagate LP,All Rules Cancelled,Backchain True,Backchain False ≫ Unfounded ≫ Decide.\nFor example, let Π be program (8). The smodels algorithm may follow a path\n∅ =⇒ (Decide) a∆ =⇒ (Unit Propagate LP) a∆c =⇒ (All Rules Cancelled) a∆c¬b =⇒ (Unfounded) a∆c¬b¬d\nin the graph smΠ, whereas it may never follow path (10), because Unfounded has a higher priority than Decide."
    }, {
      "heading" : "4.3 Tight Programs",
      "text" : "We will now review the definitions of a positive dependency graph and a tight program. The positive dependency graph of a program Π is the directed graph G such that\n• the nodes of G are the atoms occurring in Π, and • G contains the edges from a to bi (1 ≤ i ≤ l) for each rule\na ← b1, . . . , bl , not bl+1, . . . , not bm\nin Π where a is an atom.\nA program is tight if its positive dependency graph is acyclic. For instance, program (8) is not tight since its positive dependency graph has a cycle due to the rule d ← d . On the other hand, the program constructed from (8) by removing this rule is tight.\nRecall that for any program Π and any assignmentM , ifM+ is an answer set of Π then M is a supported model of Π. For the case of tight programs, the converse holds also: M+ is an answer set for Π if and only if M is a supported model of Π (Fages 1994) or, in other words, is a model of the completion of Π.\nIt turns out that for tight programs the graph smΠ is “almost identical” to the graph dpF , where F is the clausified completion of Π. To make this claim precise, we need the following terminology.\nWe say that an edge M =⇒ M ′ in the graph smΠ is singular if\n• the only transition rule justifying this edge is Unfounded , and • some edge M =⇒ M ′′ can be justified by a transition rule other than Un-\nfounded or Decide.\nFor instance, let Π be the program\na ← b b ← c.\nThe edge\na∆b∆¬c∆ =⇒ (Unfounded, U = {a, b}) a∆b∆¬c∆¬a\nin the graph smΠ is singular, because the edge\na∆b∆¬c∆ =⇒ (All Rules Cancelled) a∆b∆¬c∆¬b\nbelongs to smΠ also.\nWith respect to the actual smodels algorithm (Simons 2000), singular edges of the graph smΠ are inessential: in view of priorities for choosing a path in smΠ described in Section 4.2 smodels never follows a singular edge. Indeed, the transition rule Unfounded has the lower priority than any other transition rule but Decide. By sm−Π we denote the graph obtained from smΠ by removing all singular edges.\nProposition 5 For any tight program Π, the graph sm−Π is equal to each of the graphs atleastΠ and dpCNF-Comp(Π).\nFor instance, let Π be the program (13). This program is tight, its completion is (14), and ıCNF − Comp(Π) is formula (15). Proposition 5 asserts that, sm−Π coincides with dpCNF-Comp(Π) and with atleastΠ.\nFrom Proposition 5, it follows that applying the smodels algorithm to a tight program essentially amounts to applying dpll to its completion. A similar relationship, in terms of pseudocode representations of smodels and dpll, is established in (Giunchiglia and Maratea 2005).\nIn the rest of this section we give a proof of Proposition 5.\nLemma 6\nFor any tight program Π and any non-empty unfounded set U on a consistent set M of literals w.r.t. Π there is an atom a ∈ U such that for every B ∈ Bodies(Π, a), B ∩M 6= ∅."
    }, {
      "heading" : "Proof",
      "text" : "By contradiction. Assume that, for every a ∈ U there exists B ∈ Bodies(Π, a) such that B ∩M = ∅. By the definition of an unfounded set it follows that for every atom a ∈ U there is B ∈ Bodies(Π, a) such that U ∩B+ 6= ∅. Consequently the subgraph of the positive dependency graph of Π induced by U has no terminal nodes. Then, the program Π is not tight.\nıProof of Proposition 5 In view of Proposition 3, it is sufficient to prove that sm−Π equals atleastΠ; or, in other words, that every edge of smΠ justified by the rule Unfounded only is singular. Consider such an edge M =⇒ M ′. We need to show that some transition rule other than Unfounded or Decide is applicable to M . By the definition of Unfounded , M is consistent and there exists a non-empty set U unfounded on M w.r.t. Π. By Lemma 6, it follows that there is an atom a ∈ U such that for every B ∈ Bodies(Π, a), B ∩M 6= ∅. Therefore, the transition rule All Rules Cancelled is applicable to M ."
    }, {
      "heading" : "5 Generate and Test",
      "text" : "In this section, we present a modification of the graph dpF (Section 2.1) that includes testing “partial” assignments of F found by dpll.\nLet F be a CNF formula, and let G be a formula formed from atoms occurring in F . The terminal nodes of the graph gtF ,G defined below are models of formula F ∧G.\nThis modification of the graph dpF is of interest, for example, in connection with the fact that answer sets of a program Π can be characterized as models of its completion extended by so called loop formulas of Π (Lin and Zhao 2002). If ıCNF − Comp(Π), as above, is the completion converted to CNF, and LF (Π) is the conjunction of all loop formulas of Π, then for any assignment M , M+ is an answer set of Π iff M is a model of ıCNF − Comp(Π)∧LF (Π). Hence, the terminal nodes of the graph gtCNF-Comp(Π),LF(Π) will correspond to answer sets of Π.\nThe nodes of the graph gtF ,G are the same as the nodes of the graph dpF . The edges of gtF ,G are described by the transition rules of dpF and the additional\ntransition rule:\nTest :\nM =⇒ M l if\n\n\n\nM is consistent, G |= M , l ∈ M\nIt is easy to see that the graph dpF is a subgraph of gtF ,G . The latter graph can be used for deciding whether a formula F ∧ G has a model by constructing a path from ∅ to a terminal node:\nProposition 6 For any CNF formula F and a formula G formed from atoms occurring in F ,\n(a) graph gtF ,G is finite and acyclic, (b) any terminal state of gtF ,G other than FailState is a model of F ∧G, (c) FailState is reachable from ∅ in gtF ,G if and only if F ∧G is unsatisfiable.\nNote that to verify the applicability of the new transition rule Test we need a procedure for testing whether G entails a clause, but there is no need to explicitly write out G. This is important because LF (Π) can be very long (Lin and Zhao 2002).\nFor instance, let Π be the nontight program\nd ← d .\nIts completion is\nd ↔ d ,\nand ıCNF − Comp(Π) is\n(d ∨ ¬d).\nThis program has one loop formula\nd → ⊥.\nProposition 6 asserts that a terminal state ¬d of gtCNF-Comp(Π),d→⊥ is a model of ıCNF − Comp(Π)∧LF (Π). It follows that {¬d}+ = ∅ is an answer set of Π. To compare with the graph dpCNF-Comp(Π): state d is a terminal state in dpCNF-Comp(Π) whereas d is not a terminal state in gtCNF-Comp(Π),d→⊥ because the transition rule Test is applicable to this state.\nasp-sat with Backtracking (Giunchiglia et al. 2006) is a procedure that computes models of the completion of the given program using dpll, and tests them until an answer set is found. The application of this procedure to a program Π can be viewed as constructing a path from ∅ to a terminal node in the graph gtCNF-Comp(Π),LF(Π) by adopting a strategy that Test is applied to a state M only when M is an assignment.\nIn the rest of this section we give a proof of Proposition 6.\nLemma 7 For any CNF formula F , a formula G formed from atoms occurring in F , and a path from ∅ to a state l1 . . . ln in gtF ,G , any model X of F ∧ G satisfies li if it satisfies all decision literals l∆j with j ≤ i ."
    }, {
      "heading" : "Proof",
      "text" : "By induction on the path from ∅ to l1 . . . ln . Similar to the proof of Lemma 1. We will show that the property in question is preserved by the transition rule Test .\nTake a model X of F ∧ G and consider an edge M =⇒ M ′ where M is a list\nl1 . . . lk such that X satisfies li if it satisfies all decision literals l ∆ j with j ≤ i .\nAssume that X satisfies all decision literals from M . By the inductive hypothesis, X |= M . We will show that the rule justifying the transition from M to M ′ is different from Test . By contradiction. M ′ is M l . By the definition of Test , G |= M . Since X is a model of F ∧G it follows that X |= M . This contradicts the fact that X |= M .\nıProof of Proposition 6 Part (a) and part (c) Right-to-left are proved as in the proof of Proposition 1. (b) Let M be any terminal state other than FailState. As in the proof of Proposition 1(b) it follows thatM is a model of F . The transition rule Test is not applicable. Hence G 6|= M . In other words M is a model of G. We conclude that M is a model of F ∧G (c) Left-to-right: Since FailState is reachable from ∅, there is a state M without decision literals such that M is reachable from ∅ and the transition rule Fail is applicable in M . Then, M is inconsistent. By Lemma 7, any model of F ∧ G satisfies M . Since M is inconsistent we conclude F ∧G is unsatisfiable."
    }, {
      "heading" : "6 Review: Abstract DPLL with Learning",
      "text" : "Most modern SAT solvers implement such sophisticated techniques as backjumping and learning:\nBackjumping: Chronological Backtracking (used in classical dpll) can be seen as a prototype of Backjumping. Unlike Backtracking that undoes only the previously made decision, Backjumping is generally able to backtrack further in the search tree by undoing several decisions at once. Learning: Most modern SAT solvers implement so called conflict-driven backjumping and learning: whenever backjumping is performed they add (learn) a “backjump clause” to the clause database of a solver. Learning backjump clauses prevents a solver from reaching “similar“ inconsistent states.\nIn this section we will extend the graph dpF to capture the ideas behind backjumping and learning. The new graph will be closely related to the DPLL System with Learning graph introduced in (Nieuwenhuis et al. 2006, Section 2.4).\nWe first note that the graph dpF is not adequate to capture such technique as learning since it is incapable to reflect a change in a state of computation related to newly learned clauses. We start by redefining a state so that it incorporates information about changes performed on a clause database.\nFor a CNF formula F , an augmented state relative to F is either a distinguished state FailState or a pair M ||Γ where M is a record relative to the set of atoms occurring in F , and Γ is a (multi-)set of clauses over atoms of F that are entailed by F .\nWe now define a graph dplF for any CNF formula F . Its nodes are the augmented states relative to F . The transition rules Decide and Fail of dpF are extended to dplF as follows: M ||Γ =⇒ M ′||Γ (M ||Γ =⇒ FailState) is an edge in dplF justified by Decide (Fail) if and only if M =⇒ M ′ (M =⇒ FailState) is an edge in dpF justified by Decide (Fail). Figure 3 presents the other transition rules of dplF . We refer to the transition rules Unit Propagate λ, Backjump, Decide, and Fail of the graph dplF as Basic. We say that a node in the graph is semi-terminal if no rule other than Learn is applicable to it.\nWe will omit the word “augmented” before “state” when this is clear from a\ncontext.\nThe graph dplF can be used for deciding the satisfiability of a formula F simply\nby constructing an arbitrary path from node ∅||∅ to a semi-terminal node:\nProposition 7\nFor any CNF formula F ,\n(a) every path in dplF contains only finitely many edges justified by Basic tran-\nsition rules,\n(b) for any semi-terminal state M ||Γ of dplF reachable from ∅||∅, M is a model\nof F ,\n(c) FailState is reachable from ∅||∅ in dplF if and only if F is unsatisfiable.\nOn the one hand, Proposition 7 (a) asserts that if we construct a path from ∅||∅ so that Basic transition rules periodically appear in it then some semi-terminal state will be eventually reached. On the other hand, Proposition 7 (b) and (c) assert that as soon as a semi-terminal state is reached the problem of deciding whether formula F is satisfiable is solved. The proof of this proposition is similar to the proof of Theorem 2.12 from (Nieuwenhuis et al. 2006).\nFor instance, let F be the formula\na ∨ b ¬a ∨ c.\nHere is a path in dplF :\n∅||∅ =⇒ (Learn) ∅||b ∨ c =⇒ (Decide) ¬b∆||b ∨ c =⇒ (Unit Propagate λ) ¬b∆c||b ∨ c =⇒ (Unit Propagate λ) ¬b∆ca||b ∨ c\n(17)\nSince the state ¬b∆ca is semi-terminal, Proposition 7 (b) asserts that {¬b, c, a} is a model of F .\nRecall that the transition rule Backtrack of the graph dpF – a prototype of Backjump – is applicable in any inconsistent state with a decision literal in dpF . The transition rule Backjump, on the other hand, is applicable in any inconsistent state with a decision literal that is reachable from ∅||∅ (the proof of this statement is similar to the proof of Lemma 2.8 from (Nieuwenhuis et al. 2006)). The application of Backjump where l∆ is the last decision literal and l ′ is l can be seen as an application of Backtrack . This fact shows that Backjump is essentially a generalization of Backtrack . The subgraph of dpF induced by the nodes reachable from ∅ is basically a subgraph of dplF ."
    }, {
      "heading" : "7 Answer Set Solver with Learning",
      "text" : "In this section we will extend the graph smΠ to capture backjumping and learning. As a result we will be able to model the algorithms of systems smodelscc and sup."
    }, {
      "heading" : "7.1 Graph smlΠ",
      "text" : "An (augmented) state relative to a program Π is either a distinguished state FailState or a pair of the form M ||Γ where M is a record relative to the set of atoms occurring in Π, and Γ is a (multi-)set of constraints formed from atoms occurring in Π that are entailed by Π.\nFor any program Π, we will define a graph smlΠ. Its nodes are the augmented states relative to Π. The transition rules Unit Propagate LP, All Rules Cancelled, Backchain True, Unfounded, Decide and Fail of smΠ are extended to smlΠ as follows: M ||Γ =⇒ M ′||Γ (M ||Γ =⇒ FailState) is an edge in smlΠ justified by a transition rule T if and only if M =⇒ M ′ (M =⇒ FailState) is an edge in smΠ justified by T . Figure 4 presents the other transition rules of smlΠ.\nWe refer to the transition rulesUnit Propagate LP, All Rules Cancelled, Backchain True, Backchain False λ, Unfounded, Backjump LP, Decide, and Fail of the graph smlΠ as Basic. We say that a node in the graph is semi-terminal if no rule other than Learn LP is applicable to it.\nThe graph smlΠ can be used for deciding whether a program Π has an answer\nset by constructing a path from ∅||∅ to a semi-terminal node:\nProposition 8 For any program Π,\n(a) every path in smlΠ contains only finitely many edges labeled by Basic tran-\nsition rules,\n(b) for any semi-terminal state M ||Γ of smlΠ reachable from ∅||∅, M + is an\nanswer set of Π,\n(c) FailState is reachable from ∅||∅ in smlΠ if and only if Π has no answer sets.\nThus if we construct a path from ∅||∅ so that Basic transition rules periodically appear in it then some semi-terminal state will be eventually reached; as soon as a semi-terminal state is reached the problem of finding an answer set is solved.\nFor instance, let Π be program (8). Here is a path in smlΠ with every edge annotated by the name of a transition rule that justifies the presence of this edge in the graph :\n∅||∅ =⇒ (Decide) a∆||∅ =⇒ (Unit Propagate LP) a∆c||∅ =⇒ (All Rules Cancelled) a∆c¬b||∅ =⇒ (Decide) a∆c¬bd∆||∅ =⇒ (Unfounded) a∆c¬bd∆¬d ||∅ =⇒ (Backjump LP) a∆c¬b¬d ||∅ =⇒ (Learn LP) a∆c¬b¬d ||¬a ∨ ¬c ∨ b ∨ ¬d\n(18)\nSince the state a∆c¬b¬d is semi-terminal, Proposition 8 (b) asserts that\n{a, c,¬b,¬d}+ = {a, c}\nis an answer set for Π.\nProof of Proposition 8 is in Section 10. As in case of the graphs dpF and dplF , Backjump LP is applicable in any inconsistent state with a decision literal that is reachable from ∅||∅ (Proposition 11 from Section 9), and is essentially a generalization of the transition rule Backtrack of the graph smΠ.\nModern SAT solvers often implement such sophisticated techniques as restart\nand forgetting in addition to backjumping and learning:\nRestart: A solver restarts the dpll procedure whenever the search is not making “enough” progress. The idea is that upon a restart a solver will explore a new part of the search space using the clauses that have been learned. Forgetting: This technique is usually implemented in relation with conflictdriven backjumping and learning. When a solver “notes” that earlier learned clauses are not helpful anymore it removes (forgets) them from the clause database. Forgetting allows a solver to avoid a possible exponential space blow-up introduced by learning.\nWe may extend the graph smlΠ with the following transition rules that capture\nthe ideas behind these technique:\nRestart : M ||Γ =⇒ ∅||Γ\nForget LP : M || ← B , Γ =⇒ M ||Γ.\nThe transition rules Restart and Forget LP are similar to the analogous rules in (Nieuwenhuis et al. 2006) for extending dpll procedure with restart and forgetting techniques. It is easy to prove a result similar to Proposition 8 for the graph smlΠ with Restart and Forget LP (for such graph a state is semi-terminal if no rule other than Learn LP , Restart , Forget LP is applicable to it.)\n7.2 Smodelscc and Sup Algorithms\nIn Section 4.2 we demonstrated a method for specifying the algorithm of an answer set solver by means of the graph smΠ. In particular, we described the smodels algorithm by assigning priorities to transition rules of smΠ. In this section we use this method to describe the smodelscc (Ward and Schlipf 2004) and sup (Lierler 2008) algorithms by means of smlΠ.\nSystem smodelscc enhances the smodels algorithm with conflict-driven backjumping and learning. Its strategy for choosing a path in the graph smlΠ is similar to that of smodels. System smodelscc assigns priorities to inference rules of smlΠ as follows:\nBackjump LP,Fail ≫ Unit Propagate LP,All Rules Cancelled,Backchain True,Backchain False λ ≫ Unfounded ≫ Decide.\nAlso, smodelscc always applies the transition rule Learn LP in a non-semiterminal state reached by an application of Backjump LP , because it implements conflict-driven backjumping and learning.12 In Section 11 we discuss details on which clause is being learned during the application of Learn LP .\n12 System smodelscc (sup) also implements restarts and forgetting that may be modeled by the transition rules Restart and Forget LP . An application of these transition rules in smlΠ relies on particular heuristics implemented by the solver.\nIn (Lierler 2008), we introduced the simplified sup algorithm that relies on backtracking rather than conflict-driven backjumping and learning that are actually implemented in the system. We now present the sup algorithm that takes these sophisticated techniques into account.\nSystem sup assigns priorities to inference rules of smlΠ as follows:\nBackjump LP,Fail ≫ Unit Propagate LP,All Rules Cancelled,Backchain True,Backchain False λ ≫ Decide ≫ Unfounded.\nSimilarly to smodelscc, sup always applies the transition rule Learn LP in a\nnon-semi-terminal state reached by an application of Backjump LP .\nFor example, let Π be program (8). Path (18) corresponds to an execution of system sup, but does not correspond to any execution of smodelscc because for the latter Unfounded is a rule of higher priority than Decide. Here is another path in smlΠ from ∅||∅ to the same semi-terminal node:\n∅||∅ =⇒ (Decide) a∆||∅ =⇒ (Unit Propagate LP) a∆c||∅ =⇒ (All Rules Cancelled) a∆c¬b||∅ =⇒ (Unfounded) a∆c¬b¬d ||∅\n(19)\nPath (19) corresponds to an execution of system smodelscc, but does not correspond to any execution of system sup because for the latter Decide is a rule of higher priority than Unfounded .\nThe strategy of sup of assigning the transition rule Unfounded the lowest priority may be reasonable for many problems. For instance, it is easy to see that transition rule Unfounded is redundant for tight programs. The sup algorithm is similar to SAT-based answer set solvers such as assat (Lin and Zhao 2004) and cmodels (Giunchiglia et al. 2006) (see Section 8.2) in the fact that it will first compute a supported model of a program and only then will test whether this model is indeed an answer set, i.e., whether Unfounded is applicable in this state."
    }, {
      "heading" : "8 Generate and Test with Learning",
      "text" : "In this section we model backjumping and learning for the generate and test procedure by defining a graph gtlF ,G that extends gtF ,G (Section 5) in a similar manner as dplF (Section 6) extends dpF .\n8.1 Graph gtlF ,G\nAn (augmented) state relative to a CNF formula F and a formula G formed from atoms occurring in F is either a distinguished state FailState or a pair of the form M ||Γ, where M is a record (Section 2.1) relative to the set of atoms occurring in F , and Γ is a (multi-)set of clauses formed from atoms occurring in F that are entailed by F ∧G.\nThe nodes of the graph gtlF ,G are the augmented states relative to a CNF formula F and a formula G formed from atoms occurring in F . The edges of gtlF ,G are described by the transition rules Unit Propagate λ, Decide, Fail of dplF , the transition rules\nBackjump GT :\nP l∆Q ||Γ =⇒ P l ′||Γ if\n{\nP l∆Q is inconsistent and F ∧G |= l ′ ∨ P\nLearn GT :\nM ||Γ =⇒ M ||C , Γ if\n{\nevery atom in C occurs in F and F ∧G |= C\nand the transition rule Test of gtF ,G that is extended to gtlF ,G as follows: M ||Γ =⇒ M ′||Γ is an edge in gtlF ,G justified by Test if and only if M =⇒ M ′ is an edge in gtF ,G justified by Test .\nWe refer to the transition rules Unit Propagate λ, Test, Decide, Fail , Backjump GT of the graph gtlF ,G as Basic. We say that a node in the graph is semi-terminal if no rule other than Learn GT is applicable to it.\nThe graph gtlF ,G can be used for deciding whether a formula F ∧G has a model\nby constructing a path from ∅||∅ to a terminal node:\nProposition 9 For any CNF formula F and a formula G formed from atoms occurring in F ,\n(a) every path in gtlF ,G contains only finitely many edges labeled by Basic\ntransition rules,\n(b) for any semi-terminal state M ||Γ of gtlF ,G reachable from ∅||∅, M is a model\nof F ∧G,\n(c) FailState is reachable from ∅||∅ in gtlF ,G if and only if F ∧G is unsatisfiable.\nAs in case of the graph dplF , the transition rule Backjump GT is applicable in any inconsistent state with a decision literal that is reachable from ∅||∅. We call such states backjump states.\nProposition 10 For any CNF formula F and a formula G formed from atoms occurring in F , the transition rule Backjump GT is applicable in any backjump state in gtlF ,G .\nProofs of Propositions 9 and 10 are given in Section 13."
    }, {
      "heading" : "8.2 Cmodels Algorithm",
      "text" : "System cmodels implements an algorithm called asp-sat with Learning (Giunchiglia et al. 2006) that extends asp-sat with Backtracking by backjumping and learning.\nThe application of cmodels to a program Π can be viewed as constructing a\npath from ∅||∅ to a terminal node in the graph gtlF ,G , where\n• F is the completion of Π converted to conjunctive normal form, and • G is LF (Π).\nIn Sections 4.2 we demonstrated a method for specifying the algorithm of an answer set solver by means of the graph smΠ. We use this method to describe the cmodels algorithm using the graph gtlF ,G . System cmodels assigns priorities to the inference rules of gtlF ,G as follows:\nBackjump GT,Fail ≫ Unit Propagate λ ≫ Decide ≫ Test.\nAlso, cmodels always applies the transition rule Learn GT in a non-semi-\nterminal state reached by an application of Backjump GT .\nThe priorities imposed on the rules by cmodels guarantee that the transition rule Test is applied to a model of F∪Γ (clausified completion F extended by learned clauses Γ). This allows cmodels to proceed with its search in case if a found model is not an answer set. Furthermore, the cmodels strategy guarantees that in a state reached by an application of Test , first Backjump GT will be applied and then in the resulting state Learn GT will be applied. The clause learned due to this application of Learn GT is derived by means of loop formulas (see (Giunchiglia et al. 2006)). In this sense cmodels uses loop formulas to guide its search.\nSystems sag (Lin et al. 2006) and clasp (Gebser et al. 2007) are answer set solvers that are enhancements of cmodels. First, they compute and clausify program’s completion and then use unit propagate on resulting propositional formula as an inference mechanism. Second, they guide their search by means of loop formulas. Third, they implement conflict-driven backjumping and learning. Also, sag uses SAT solvers for search. The systems differ from cmodels in the following:\n• they maintain the data structure representing an input logic program through\nout the whole computation,\n• in addition to implementing inference rules of the graph gtlF ,G they also\nimplement the inference rule Unfounded of smΠ. A hybrid graph combining the inference rule Unfounded of smΠ and the inference rules of gtlF ,G may be used to describe the sag and clasp algorithms.\nSystem sag assigns the same priorities to the inference rules of the hybrid graph as cmodels. Also, sag at random decides whether to apply the inference rule Unfounded in a state.\nOn the other hand, system clasp assigns priorities to the inference rules of the\nhybrid graph as follows:\nBackjump GT,Fail ≫ Unit Propagate λ,Unfounded ≫ Decide.\nLike cmodels, both sag and clasp always apply the transition rule Learn GT\nin a non-semi-terminal state reached by an application of Backjump GT ."
    }, {
      "heading" : "9 Backjumping and Extended Graph",
      "text" : "Recall the transition rule Backjump LP of smlΠ\nBackjump LP :\nP l∆Q ||Γ =⇒ P l ′||Γ if\n{\nP l∆Q is inconsistent and Π entails l ′ ∨ P .\nA state in the graph smlΠ is a backjump state if it is inconsistent, contains a decision literal, and is reachable from ∅||∅. Note that it may be not clear a priori whether Backjump LP is applicable to a backjump state and if so to which state the edge due to the application of Backjump LP leads. These questions are important if we want to base an algorithm on this framework. It turns out that Backjump LP is always applicable to a backjump state:\nProposition 11 For a program Π, the transition rule Backjump LP is applicable to any backjump state in smlΠ.\nProposition 11 guarantees that a backjump state in smlΠ is never semi-terminal. In the end of this section we show how Proposition 11 can be derived from the results proved later in this paper. Next question to answer is how to continue choosing a path in the graph after reaching a backjump state. To answer this question we introduce the notions of reason and extended graph.\nFor a program Π, we say that a clause l ∨ C is a reason for l to be in a list of literals P lQ w.r.t Π if Π entails l ∨ C and C ⊆ P . We can equivalently restate the second condition of Backjump LP “Π entails l ′ ∨ P” as “there exists a reason for l ′ to be in P l ′ w.r.t. Π” (note that l ′ ∨ P is a reason for l ′ to be in P l ′). We call a reason for l ′ to be in P l ′ a backjump clause. Note that Proposition 11 asserts that a backjump clause always exists for a backjump state. It is clear that we may continue choosing a path in the graph after reaching a backjump state if we know how to compute a backjump clause for this state. We now define a graph sml↑Π that shares many properties of smlΠ but allows us to give a simpler procedure for computing a backjump clause.\nAn extended record M relative to a program Π is a list of literals over the set of\natoms occurring in Π where\n(i) each literal l in M is annotated either by ∆ or by a reason for l to be in M\nw.r.t. Π,\n(ii) M contains no repetitions,\n(iii) for any inconsistent prefix of M its last literal is annotated by a reason.\nFor instance, let Π be the program\na ← not b c.\nThe list of literals\nb∆a∆¬b¬b∨¬a\nis an extended record relative to Π. On the other hand, the lists of literals\na∆¬a∆ a∆¬b¬b∨¬a b∆ b∆a∆¬b¬b∨¬a c∆\nare not extended records.\nAn extended state relative to a program Π is either a distinguished state FailState or a pair of the form M ||Γ where M is an extended record relative to Π, and Γ is the same as in the definition of an augmented state (i.e., Γ is a (multi-)set of constraints formed from atoms occurring in Π that are entailed by Π.) It is easy to see that for any extended state S relative to a program Π, the result of removing annotations from all nondecision literals of S is a state of smlΠ: we will denote this state by S ↓.\nFor instance, consider program a ← not b. All pairs\nFailState ∅||∅ a∆¬b¬b∨¬a ||∅ ¬a∆bb∨a ||∅\nare among valid extended states relative to this program. The corresponding states S ↓ are\nFailState ∅||∅ a∆¬b||∅ ¬a∆b||∅.\nWe now define a graph sml↑Π for any program Π. Its nodes are the extended states relative to Π. The transition rules of smlΠ are extended to sml ↑ Π as follows: S1 =⇒ S2 is an edge in sml ↑ Π justified by a transition rule T if and only if S ↓ 1 =⇒ S ↓ 2 is an edge in smlΠ justified by T .\nWe will omit the word “extended” before “record” and “state” when this is clear\nfrom a context.\nThe following lemma formally states the relationship between nodes of the graphs\nsmlΠ and sml ↑ Π:\nLemma 8 For any program Π, if S ′ is a state reachable from ∅||∅ in the graph smlΠ then there is a state S in the graph sml↑Π such that S ↓ = S ′.\nThe definitions of Basic transition rules and semi-terminal states in sml↑Π are\nsimilar to their definitions for smlΠ. Proposition 8↑ For any program Π,\n(a) every path in sml↑Π contains only finitely many edges labeled by Basic tran-\nsition rules,\n(b) for any semi-terminal state M ||Γ of sml↑Π, M + is an answer set of Π, (c) sml↑Π contains an edge leading to FailState if and only if Π has no answer\nsets.\nNote that Proposition 8↑ (b), unlike Proposition 8 (b), is not limited to semiterminal states that are reachable from ∅||∅. As in the case of the graph smlΠ, sml ↑ Π can be used for deciding whether a program Π has an answer set. Furthermore, the new graph provides the means for computing a backjump clause that permits practical application of the transition rule Backjump LP : Sections 10.3\nand 11 describe the BackjumpClause (Algorithm 1) and BackjumpClauseFirstUIP (Algorithm 2) procedures that compute Decision and FirstUIP backjump clauses respectively.\nWe say that a state in the graph sml↑Π is a backjump state if its record is inconsistent and contains a decision literal. Unlike the definition of a backjump state in smlΠ, this definition does not require a backjump state to be reachable from ∅||∅ in sml↑Π. As in case of the graph smlΠ, any backjump state in sml ↑ Π is not semiterminal:\nProposition 11↑ For a program Π, the transition rule Backjump LP is applicable to any backjump state in sml↑Π.\nProposition 8 (b), (c) and Proposition 11 easily follow from Lemma 8 and Proposition 8↑ (b), (c) and Proposition 11↑ respectively. Proof of Proposition 8 (a) is similar to the proof of Proposition 8↑ (a).\nNext section will present the proofs for Proposition 8↑, Lemma 8, and Proposition 11↑. It is interesting to note that the proofs of Lemma 8 and Proposition 11↑ implicitly provide the means for choosing a path in the graph sml↑Π:\n• given a state M ||Γ and a transition rule Unit Propagate LP, All Rules Can-\ncelled, Backchain True, Backchain False λ, or Unfounded applicable to M ||Γ, the proof of Lemma 8 describes a clause that may be used to construct a record M ′ so that there is an edge M ||Γ =⇒ M ′||Γ due to this transition rule, • given a backjump state M ||Γ, the proof of Proposition 11↑ describes a back-\njump clause that can be used to construct a record M ′ so that there is an edge M ||Γ =⇒ M ′||Γ due to Backjump LP .\nFurthermore, the construction of the proof of Proposition 11↑ paves the way for procedure BackjumpClause presented in Algorithm 1."
    }, {
      "heading" : "10 Proofs of Proposition 8↑, Lemma 8, Proposition 11↑",
      "text" : "10.1 Proof of Proposition 8↑\nLemma 9 For any program Π, an extended record M relative to Π, and every assignment X such that X+ is an answer set for Π, if X satisfies all decision literals in M then X |= M ."
    }, {
      "heading" : "Proof",
      "text" : "By induction on the length ofM . The property trivially holds for ∅. We assume that the property holds for any state with n elements. Consider any state M with n +1 elements. Let X be an assignment such that X+ is an answer set for Π and X satisfies all decision literals in M . We will now show that X |= M .\nCase 1. M has the form P l∆. By the inductive hypothesis, X |= P . Since X\nsatisfies all decision literals in M , X |= l .\nCase 2. M has the form P l l∨C . By the inductive hypothesis, X |= P . By the definition of a reason, (i) Π entails l ∨ C and (ii) C ⊆ P . From (ii) it follows that P |= ¬C . Consequently, X |= ¬C . From (i) it follows that for any assignment X such that X+ is an answer set, X |= l ∨ C . Consequently, X |= l .\nThe proof of Proposition 8↑ assumes the correctness of Proposition 11↑ that we\ndemonstrate in Section 10.3. Proposition 8↑ For any program Π,\n(a) every path in sml↑Π contains only finitely many edges labeled by Basic tran-\nsition rules,\n(b) for any semi-terminal state M ||Γ of sml↑Π, M + is an answer set of Π, (c) sml↑Π contains an edge leading to FailState if and only if Π has no answer\nsets."
    }, {
      "heading" : "Proof",
      "text" : "(a) For any list N of literals by |N | we denote the length of N . Any state M ||Γ has the form M0 l ∆ 1 M1 . . . l ∆ p Mp ||Γ, where l ∆ 1 . . . l ∆ p are all decision literals of M ; we define α(M ||Γ) as the sequence of nonnegative integers |M0|, |M1|, . . . , |Mp |, and α(FailState) = ∞. For any states S and S ′ of sml↑Π, we understand α(S ) < α(S ′) as the lexicographical order. We first note that for any state M ||Γ, value of α is based only on the first component M of the state. Second, there is a finite number of distinct values of α due to the fact that there is a finite number of distinct M s over Π. We conclude that there is a finite number of distinct values of α for the states of sml↑Π, even though the number of distinct states in sml ↑ Π is infinite.\nBy the definition of the transition rules of sml↑Π, if there is an edge from M ||Γ to M ′||Γ′ in sml↑Π formed by any Basic transition rule then α(M ||Γ) < α(M ′||Γ′). Then, due to the fact that there is a finite number of distinct values of α, it follows that there is only a finite number of edges due to the application of Basic rules possible in any path. (b) Let M ||Γ be a semi-terminal state so that none of the Basic rules are applicable. From the fact that Decide is not applicable, we conclude that M assigns all literals.\nFurthermore, M is consistent. Indeed, assume that M is inconsistent. Then, since Fail is not applicable, M contains a decision literal. Consequently, M ||Γ is a backjump state. By Proposition 11↑, the transition rule Backjump LP is applicable in M ||Γ. This contradicts our assumption that M ||Γ is semi-terminal.\nAlso, M is a model of Π: since Unit Propagate LP is not applicable in M ||Γ, it\nfollows that for every rule a ← B ∈ Π, if B ⊆ M then a ∈ M .\nAssume that M+ is not an answer set. Then, by Lemma 3, there is a non-empty unfounded set U on M w.r.t. Π such that U ⊆ M . It follows that Unfounded is applicable (with an arbitrary a ∈ U ) in M ||Γ. This contradicts the assumption that M ||Γ is semi-terminal. (c) Left-to-right: There is a state M ||Γ in sml↑Π such that there is an edge between M ||Γ and FailState. By the definition of sml↑Π, this edge is due to the transition rule Fail . Consequently, state M ||Γ is such that M is inconsistent and contains\nno decision literals. By Lemma 9, for every assignment X such that X+ is an answer set for Π, X satisfies M . Since M is inconsistent we conclude that Π has no answer sets.\nRight-to-left: Consider the process of constructing a path consisting only of edges due to Basic transition rules. By (a), it follows that this path will eventually reach a semi-terminal state. By (b), this semi-terminal state cannot be different from FailState, because Π has no answer sets. We conclude that there is an edge leading to FailState."
    }, {
      "heading" : "10.2 Proof of Lemma 8",
      "text" : "The proof uses the notion of loop formula (Lin and Zhao 2004).\nGiven a set A of atoms by Bodies(Π,A) we denote the set that consists of the elements of Bodies(Π, a) for all a in A. Let Π be a program. For any set Y of atoms, the external support formula (Lee 2005) for Y is\n∨\nB∈Bodies(Π,Y ),B+∩Y=∅\nB . (20)\nWe will denote the external support formula by ESΠ,Y . For any set Y of atoms, the loop formula for Y is the implication ∨\na∈Y\na → ESΠ,Y .\nWe can rewrite this formula as the disjunction ∧\na∈Y\n¬a ∨ ESΠ,Y . (21)\nFrom the Main Theorem in (Lee 2005) we conclude:"
    }, {
      "heading" : "Lemma on Loop Formulas",
      "text" : "For any program Π, Π entails loop formulas (21) for all sets Y of atoms that occur in Π.\nFor a state S in the graph sml↑Π, we say that S ↓ in smlΠ is the image of S .\nLemma 8 For any program Π, if S ′ is a state reachable from ∅||∅ in the graph smlΠ then there is a state S in the graph sml↑Π such that S ↓ = S ′."
    }, {
      "heading" : "Proof",
      "text" : "Since the property trivially holds for the initial state ∅||∅, we only need to prove that all transition rules of smlΠ preserve it.\nConsider an edge M ||Γ =⇒ M ′||Γ′ in the graph smlΠ such that there is a state\nM1||Γ in the graph sml ↑ Π satisfying the condition (M1||Γ) ↓ = M ||Γ. We need to show that there is a state in the graph sml↑Π such that M ′||Γ′ is its image in smlΠ. Consider several cases that correspond to a transition rule leading from M ||Γ to M ′||Γ′:"
    }, {
      "heading" : "Unit Propagate LP :",
      "text" : "M ||Γ =⇒ M a||Γ if\n{\na ← B ∈ Π and B ⊆ M .\nM ′||Γ′ is M a||Γ. It is sufficient to prove that M1aa∨B ||Γ is a state of sml ↑ Π. It is enough to show that a clause a ∨B is a reason for a to be in M a. By applicability conditions of Unit Propagate LP , B ⊆ M . Since Π entails its rule a ← B , Π entails a ∨ B .\nAll Rules Cancelled :\nM ||Γ =⇒ M ¬a||Γ if B ∩M 6= ∅ for all B ∈ Bodies(Π, a).\nM ′||Γ′ is M ¬a||Γ. Consider any B ∈ Bodies(Π, a). Since B ∩M 6= ∅, B contains a literal from M : call it f (B). It is sufficient to show that\n¬a ∨ ∨\nB∈Bodies(Π,a)\nf (B) (22)\nis a reason for ¬a to be in M ¬a.\nFirst, by the choice of f (B), f (B) ∈ M ; consequently, ∨\nB∈Bodies(Π,a)\nf (B) ⊆ M .\nSecond, since f (B) ∈ B , the loop formula ¬a ∨ ESΠ,{a} entails (22). By Lemma\non Loop Formulas, it follows that Π entails (22).\nBackchain True:\nM ||Γ =⇒ M l ||Γ if\n\n  \n  \na ← B ∈ Π, a ∈ M , B ′ ∩M 6= ∅ for all B ′ ∈ Bodies(Π, a) \\ {B}, l ∈ B .\nM ′||Γ′ is M l ||Γ. Consider any B ′ ∈ Bodies(Π, a)\\B . Since B ′ ∩M 6= ∅, B ′ contains a literal from M : call it f (B ′). A clause\nl ∨ ¬a ∨ ∨\nB ′∈Bodies(Π,a)\\B\nf (B ′) · (23)\nis a reason for l to be in M l . The proof of this statement is similar to the case of All Rules Cancelled .\nBackchain False λ:\nM ||Γ =⇒ M l ||Γ if\n\n\n\na ← l ,B ∈ Π ∪ Γ, ¬a ∈ M or a = ⊥, B ⊆ M .\nM ′||Γ′ is M l ||Γ. A clause l ∨B ∨ a is a reason for l to be in M l . The proof of this statement is similar to the case of Unit Propagate LP .\nUnfounded :\nM ||Γ =⇒ M ¬a||Γ if\n{\nM is consistent and a ∈ U for a set U unfounded on M w.r.t. Π.\nM ′||Γ′ is M ¬a||Γ. Consider any B ∈ Bodies(Π,U ) such that U ∩B+ = ∅. By the definition of an unfounded set, it follows that B ∩M 6= ∅. Consequently, B contains a literal from M : call it f (B). The clause\n¬a ∨ ∨\nBodies(Π,U ),B+∩U=∅\nf (B) (24)\nis a reason for ¬a to be in M ¬a. The proof of this statement is similar to the case of All Rules Cancelled .\nBackjump LP , Decide, Fail , and Learn LP : obvious.\nThe process of turning a state of smlΠ reachable from ∅||∅ into a corresponding\nstate of sml↑Π can be illustrated by the following example: Consider a program Π\na ← not b b ← not a, not c c ← not f ← k , d k ← l , not b ← m, not l , not b m ← not k , not l\n(25)\nand a path in smlΠ\n∅||∅ =⇒ (Decide) a∆||∅ =⇒ (All Rules Cancelled) a∆¬b||∅ =⇒ (Decide) a∆¬bc∆||∅ =⇒ (Backchain True) a∆¬bc∆¬f ||∅ =⇒ (Decide) a∆¬bc∆¬f d∆||∅ =⇒ (Backchain False λ) a∆¬bc∆¬f d∆¬k ||∅ =⇒ (Backchain False λ) a∆¬bc∆¬f d∆¬k¬l ||∅ =⇒ (Backchain False λ) a∆¬bc∆¬f d∆¬k¬l¬m||∅ =⇒ (Unit Propagate LP) a∆¬bc∆¬f d∆¬k¬l¬mm||∅\n(26)\nThe construction in the proof of Lemma 8 applied to the nodes in this path gives following states of sml↑Π:\n∅||∅ a∆||∅ a∆¬b¬b∨¬a ||∅ a∆¬b¬b∨¬a c∆||∅ a∆¬b¬b∨¬a c∆¬f ¬f∨¬c||∅ a∆¬b¬b∨¬a c∆¬f ¬f∨¬cd∆||∅ a∆¬b¬b∨¬a c∆¬f ¬f∨¬cd∆¬k¬k∨¬d ||∅ a∆¬b¬b∨¬a c∆¬f ¬f∨¬cd∆¬k¬k∨¬d¬l¬l∨b∨k ||∅ a∆¬b¬b∨¬a c∆¬f ¬f∨¬cd∆¬k¬k∨¬d¬l¬l∨b∨k¬m¬m∨l∨b ||∅ a∆¬b¬b∨¬a c∆¬f ¬f∨¬cd∆¬k¬k∨¬d¬l¬l∨b∨k¬m¬m∨l∨bmm∨k∨l ||∅\n(27)\nIt is clear that these nodes form a path in sml↑Π with every edge justified by the\nsame transition rule as the corresponding edge in path (26) in smlΠ."
    }, {
      "heading" : "10.3 Proof of Proposition 11↑",
      "text" : "In this section Π is an arbitrary and fixed logic program.\nFor a record M , by lcp(M ) we denote its largest consistent prefix. We say that a clause C is conflicting on a list M of literals if Π entails C , and C ⊆ lcp(M ). For example, let M be the first component of the last state in (27):\na∆¬b¬b∨¬a c∆¬f ¬f∨¬cd∆¬k¬k∨¬d¬l¬l∨b∨k¬m¬m∨l∨bmm∨k∨l . (28)\nThen, lcp(M ) is obtained by dropping the last element mm∨k∨l of M . It is clear that the reason m ∨ k ∨ l for m to be in M is a conflicting clause on M .\nLemma 10\nThe literal that immediately follows lcp(M ) in an inconsistent record M , has the form lC where C is a conflicting clause on M ."
    }, {
      "heading" : "Proof",
      "text" : "By the requirement (iii) of the definition of an extended record, the literal that immediately follows lcp(M ) may not be annotated by ∆. Consequently, the literal has the form lC . We now show that C is a conflicting clause on M . Since C is a reason for l to be in lcp(M )lC , it immediately follows that Π entails C , C can be written as l∨C ′, and C ′ ⊆ lcp(M ). Since l immediately follows the largest consistent prefix of M , l ∈ lcp(M ). Consequently, C ⊆ lcp(M ). We conclude that C is indeed a conflicting clause on M .\nFor any inconsistent record l1 · · · ln and any conflicting clause C on this record, by βl1···ln (C ) we denote the set of numbers i such that li ∈ C . (It is clear that every element from C equals to one of the literals in l1 · · · ln .) The relation I < J between subsets I , J of {1 · · ·n} is understood here as the lexicographical order between I and J sorted in descending order. For instance, {2 6 7} < {6 7 8} because {7 6 2} < {8 7 6} in lexicographical order.\nRecall that the resolution rule can be applied to clauses C ∨ l and C ′ ∨ ¬l and\nproduces the clause C ∨ C ′, called the resolvent of C ∨ l and C ′ ∨ ¬l on l .\nLemma 11 Let M be a record and let lB be a nondecision literal from lcp(M ). If clause D is the resolvent of B and a clause C conflicting on M then\n(i) D is a clause conflicting on M ,\n(ii) βM (D) < βM (C ).\nFor instance, let M be (28), let reason ¬m ∨ l ∨ b for ¬m in lcp(M ) be B , and let conflicting clause m ∨ k ∨ l on M be C . Then D , the result of resolving B together with C , is clause k ∨ l ∨ b. Lemma 11 asserts that k ∨ l ∨ b is a conflicting clause on M and that βM (D) < βM (C ). Indeed, βM (D) = {2 6 7} and βM (C ) = {6 7 8}."
    }, {
      "heading" : "Proof",
      "text" : "(i) Clause D is a resolvent of B and C on some literal l ′. Then, for some literal l ′ ∈ B , l ′ ∈ C . The clause C can be written as l ′ ∨ C ′.\nIn order to demonstrate that D is a conflicting clause we need to show that\nD ⊆ lcp(M ) and Π entails D .\nSince B is a reason for l to be in lcp(M ), Π entails B and B has the form l ∨B ′ where B ′ ⊆ lcp(M ). Since C is a conflicting clause on M , C ⊆ lcp(M ) and Π entails C . From the fact that lcp(M ) is consistent, it follows that there is no literal in B ′ such that its complement occurs in C . Consequently, l ′ 6∈ B ′ so that l ′ is l and D is B ′∨C ′. We conclude that D ⊆ lcp(M ). From the fact that Π entails B , Π entails C , and the construction of D , it follows that Π entails D .\n(ii) From the proof of (i) it follows that D is a resolvent of B and C on l where B has the form l ∨ B ′. Since B is a reason for l to be in lcp(M ), every literal in B ′ precedes l in lcp(M ). Since D is derived by replacing l in C with B ′, βM (D) < βM (B).\nLet record M be l1 · · · li · · · ln , the decision level of a literal li is the number of decision literals in l1 · · · li : we denote it by decM (li). We will also use this notation to denote the decision level of a set of literals: For a set P ⊆ M of literals, decM (P) is the decision level of the literal in P that occurs latest in M . For record M and a decision level j by M j we denote the prefix of M that consists of the literals in M that belong to decision level less than j and by M j ] we denote the prefix of M that consists of the literals in M that belong to decision level less than or equal to j . For instance, let M be record (28) then decM (¬k) = 3, decM (¬b c ¬k) = 3, M 3 is a∆¬b¬b∨¬a c∆¬f ¬f∨¬c, and M 3] is M itself.\nLemma 12\nFor an inconsistent record M and a conflicting clause l ∨ C on M , if decM (l) > decM (c) for all c ∈ C then lcp(M )decM (C )] l l∨C is a record."
    }, {
      "heading" : "Proof",
      "text" : "We need to show that (i) l 6∈ lcp(M )dec(C )] and (ii) l ∨ C is a reason for l to be in lcp(M )dec(C )] l , i.e, Π entails l ∨C and C ⊆ lcp(M )dec(C )].\nSince l ∨ C is conflicting on M , l ∨ C ⊆ lcp(M ). From the consistency of lcp(M ) and the fact that l ∈ lcp(M ), it follows that l 6∈ lcp(M ). Consequently, l 6∈ lcp(M )dec(C )].\nSince l∨C is conflicting on M , Π entails l∨C and l ∨ C ⊆ lcp(M ). Consequently, C ⊆ lcp(M ). From the definition of decM (C ), it follows that decM (C ) is the decision level of the literal in C that occurs latest in lcp(M ). By the definition of a decision level, C ⊆ lcp(M )decM (C )].\nProposition 11↑ For a program Π, the transition rule Backjump LP is applicable to any backjump state in sml↑Π."
    }, {
      "heading" : "Proof",
      "text" : "LetM ||Γ be a backjump state in sml↑Π. Let R be the list of reasons that are assigned to the nondecision literals in lcp(M ).\nConsider the process of building a sequence C1,C2, . . . of clauses so that\n• C1 is the reason of the member of M that immediately follows lcp(M ), and • Cj (j > 1) is a resolvent of Cj−1 and some clause in R\nwhile derivation of new clauses is possible. From Lemma 11 (i) and the choice of C1 and R, it follows that any clause in C1,C2 . . . is conflicting. By Lemma 11 (ii) we conclude that βM (Cj ) < βM (Cj−1) (j > 1). It is clear that this process will terminate after deriving some clause Cm , since the number of conflicting clauses on M is finite. It is clear that clause Cm cannot be resolved against any clause in R.\nCase 1. Cm is the empty clause. Since M ||Γ is a backjump state, M contains a decision literal l∆. By part (iii) of the definition of a record, l belongs to lcp(M ). Consequently, M can be represented in the form lcp(M )decM (l) l∆Q .\nBy the choice of C1, C1 is a reason and must consist of at least one literal. Consequently, m > 1. Clause Cm is derived from clauses Cm−1 and some clause in R. Since Cm is empty, Cm−1 is a unit clause l ′. We will show that\nlcp(M )decM (l) l∆Q ||Γ =⇒ lcp(M )decM (l) l ′l ′ ||Γ\nis an application of Backjump LP . It is sufficient to demonstrate that lcp(M )decM (l) l ′l ′ is a record. Since lcp(M )decM (l) l∆Q is a record, we only need to show that l ′ 6∈ lcp(M )decM (l) and clause l ′ is a reason for l ′ to be in lcp(M )decM (l) l ′. Recall that Cm−1, i.e., l ′, is a conflicting clause. Consequently, Π entails l ′ and l ′ ∈ lcp(M ). Since lcp(M ) is consistent, l ′ 6∈ lcp(M ) so that l ′ 6∈ lcp(M )decM (l). On the other hand, from the fact that Π entails l ′ it immediately follows that clause l ′ is a reason for l ′ to be in lcp(M )decM (l) l ′.\nCase 2. Cm is not empty. Since Cm is a conflicting clause on M , the complement of any literal in Cm belongs to lcp(M ). Furthermore, every such complement is a decision literal in lcp(M ). Indeed, if this complement is l l∨B ∈ lcp(M ) then l ∨ B is one of the clauses Bi , and it can be resolved against Cm .\nBy the definition of a decision level, there is at most one decision literal that belongs to any decision level. It follows that Cm can be written as l ∨ C ′m so that decM (l) > decM (c) for any c ∈ C ′m . Consequently, M can be written as lcp(M )decM (l) l ∆ Q . Note that\nlcp(M )decM (l) l ∆ Q ||Γ =⇒ lcp(M )decM (C ′ m)] lCm ||Γ\nis an application of Backjump LP . Indeed, by Lemma 12 lcp(M )decM (C ′ m)] lCm is a record.\nAlgorithm 1 presents procedure BackjumpClause that computes a backjump clause for any backjump state in the graph sml↑Π. The algorithm follows from the construction of the proof of Proposition 11↑. It is based on the iterative application of the resolution rule on reasons of the smallest inconsistent prefix of a state. The"
    }, {
      "heading" : "BackjumpClause (M ||Γ);",
      "text" : "Arguments : M ||Γ is a backjump state in sml↑ Π Return Value : C is a backjump clause begin\nC ← the reason of the member of M that immediately follows lcp(M ); N ← the list of the nondecision literals in lcp(M ); R ← the list of the reasons that are assigned to the literals in N ; while C ∩ N 6= ∅ do l ← a literal in C ∩N ; B ← the clause in R that contains l ; C ′ ← the resolvent of C and B on l ; if C ′ = ∅ then\nreturn C\nC ← C ′ return C ;\nAlgorithm 1: A procedure for generating a backjump clause.\nproof of Proposition 11↑ allows to conclude the termination of BackjumpClause and asserts that a clause returned by the procedure is a backjump clause on a backjump state.\nFor instance, let Π be (25). Consider an execution of BackjumpClause on Π and backjump state (28). The table below gives the values of lcp(M ), C , N , and R during the execution of the BackjumpClause algorithm. By Ci we denote a value of C before the i-th iteration of the while loop.\nlcp(M ) a∆¬b¬b∨¬a c∆¬f ¬f∨¬cd∆¬k¬k∨¬d¬l¬l∨b∨k¬m¬m∨l∨b C1 m ∨ k ∨ l N ¬b¬b∨¬a ¬f ¬f∨¬c¬k¬k∨¬d ¬l¬l∨b∨k ¬m¬m∨l∨b R ¬b ∨ ¬a, ¬f ∨ ¬c, ¬k ∨ ¬d , ¬l ∨ b ∨ k , ¬m ∨ l ∨ b\nC2 k ∨ l ∨ b is the resolvent of C1 and ¬m ∨ l ∨ b C3 k ∨ b is the resolvent of C2 and ¬l ∨ b ∨ k C4 ¬d ∨ b is the resolvent of C3 and ¬k ∨ ¬d C5 ¬d ∨ ¬a is the resolvent of C4 and ¬b ∨ ¬a\n(29)\nThe algorithm will terminate with the clause ¬d ∨ ¬a. Proof of Proposition 11↑ asserts that (i) this clause is a backjump clause such that d and a are decision literals in M and (ii) the transition\na∆¬b¬b∨¬a c∆¬f ¬f∨¬cd∆¬k¬k∨¬d¬l¬l∨b∨k¬m¬m∨l∨bmm∨k∨l ||∅ =⇒ a∆¬b¬b∨¬a¬d¬d∨¬a ||∅ (30)\nin sml↑Π is an application of Backjump LP . Indeed, by Lemma 12 lcp(M ) decM (¬a)]¬d¬d∨¬a , in other words a∆¬b¬b∨¬a¬d¬d∨¬a , is a record.\nNote that a backjump clause may be derived in other ways than captured by BackjumpClause algorithm: the transition rule Backjump LP is applicable with an arbitrary backjump clause. Usually, dpll-like procedures implement conflictdriven backjumping and learning where a particular learning schema such as, for\ninstance, Decision or FirstUIP (Mitchell 2005) is applied for computing a special kind of a backjump clause. It turns out that the BackjumpClause algorithm captures the Decision learning schema for ASP. Typically, SAT solvers impose an order for resolving the literals during the process of Decision backjump clause derivation. We can impose similar order by replacing the line\nl ← a literal in C ∩ N\nin the algorithm BackjumpClause with\nl ← a literal in C ∩ N that occurs latest in lcp(M ).\nIn fact, the sample application of BackjumpClause algorithm described in (29) follows this ordering.\nThis section introduced BackjumpClause algorithm that derives a Decision backjump clause for an arbitrary backjump state. In the next section we will introduce an algorithm that will compute an ASP counterpart of FirstUIP backjump clause."
    }, {
      "heading" : "11 FirstUIP Conflict-Driven Backjumping and Learning",
      "text" : "Conflict-driven backjumping and learning proved to be a highly successful technique in modern SAT solving. Furthermore, in (Zhang et al. 2001) the authors investigated the performance of various learning schemes and established experimentally that FirstUIP clause is the most useful single clause to learn. Success of conflict-driven learning led to the implementation of its ASP counterpart in systems smodelscc, clasp, and sup. There are two common methods for describing a backjump clause construction in the SAT literature. The first one employes the implication graph (Marques-Silva and Sakallah 1996) and the second one employes resolution (Mitchell 2005). Ward and Schlipf (Ward and Schlipf 2004) extended the definition of an implication graph to the smodels algorithm and implemented FirstUIP learning schema in answer set solver smodelscc. In the previous section we used sml ↑ Π formalism and resolution to describe the BackjumpClause algorithm for computing an ASP counterpart of a Decision backjump clause. In (Gebser et al. 2007) the authors used the concepts from constraint processing to implement FirstUIP learning schema in answer set solver clasp.\nThis section presents the BackjumpClauseFirstUIP algorithm for computing an ASP counterpart of a FirstUIP backjump clause by means of sml↑Π formalism and resolution. The BackjumpClauseFirstUIP algorithm is employed by the system sup in its implementation of conflict-driven backjumping and learning.\nThe Algorithm 2 presents procedure BackjumpClauseFirstUIP that computes a\nFirstUIP backjump clause for any backjump state in the graph sml↑Π.\nWe now state the correctness of the algorithm BackjumpClauseFirstUIP . We start by showing its termination. By C1 we will denote the initial value assigned to clause C . From Lemma 11 (i) and the choice of C1 we conclude that at any point of computation clause C is conflicting on M . By Lemma 11 (ii), the value of βM (C ) decreases with each new assignment of clause C in the while loop. It follows that the while loop will terminate since the number of conflicting clauses C on M such"
    }, {
      "heading" : "BackjumpClauseFirstUIP (M ||Γ);",
      "text" : "Arguments : M ||Γ is a backjump state in sml↑ Π Return Value : C is a backjump clause begin\nC ← the reason of the member of M that immediately follows lcp(M ); l ← the literal in C that occurs latest in lcp(M ); P ← the sublist of lcp(M ) that consists of the literals that belong to the decision level dec(l); R ← the list of the reasons that are assigned to the literals in P ; while |C ∩ P | > 1 do l ← the literal in C that occurs latest in P ; B ← the clause in R that contains l ; C ← the resolvent of C and B on l ;\nreturn C ;\nAlgorithm 2: A procedure for generating a FirstUIP backjump clause.\nthat |C ∩ P | > 1 is finite. By Cm we will denote the clause C with which the while loop terminates. In other words BackjumpClauseFirstUIP returns Cm . We now show that Cm is indeed a backjump clause. We already concluded that Cm is a conflicting clause on M . Furthermore, from the termination condition of the while loop |Cm ∩P | ≤ 1. From the choice of C1 and P it follows that |Cm ∩P | = 1. Consequently, Cm can be written as l ∨ C ′m where l is in singleton Cm ∩ P . By Lemma 11 (ii), β(Cm ) ≤ β(C1). From the definition of β and the choice of P it follows that decM (l) > decM (c) for all c ∈ C ′ m . By Lemma 12, lcp(M ) decM (C ′m)] lCm is a record. In other words, transition\nM ||Γ =⇒ lcp(M )decM (C ′ m)] lCm ||Γ\nis an application of Backjump LP . Consequently, Cm is a backjump clause.\nFor instance, let Π be (25). Consider an execution of BackjumpClauseFirstUIP on Π and a backjump state (28). The table below gives the values of lcp(M ), C , P , and R during the execution of BackjumpClauseFirstUIP . By Ci we denote a value of C before the i-th iteration of the while loop.\nlcp(M ) a∆¬b¬b∨¬a c∆¬f ¬f∨¬cd∆¬k¬k∨¬d¬l¬l∨b∨k¬m¬m∨l∨b C1 m ∨ k ∨ l P d∆¬k¬k∨¬d ¬l¬l∨b∨k ¬m¬m∨l∨b R ¬k ∨ ¬d , ¬l ∨ b ∨ k , ¬m ∨ l ∨ b\nC2 k ∨ l ∨ b is the resolvent of C1 and ¬m ∨ l ∨ b C3 k ∨ b is the resolvent of C2 and ¬l ∨ b ∨ k .\nThe BackjumpClauseFirstUIP algorithm will terminate with the clause k ∨ b. The proof of the correctness of BackjumpClauseFirstUIP asserts that k∨b is a backjump clause and the transition\na∆¬b¬b∨¬a c∆¬f ¬f∨¬cd∆¬k¬k∨¬d¬l¬l∨b∨k¬m¬m∨l∨bmm∨k∨l =⇒ a∆¬b¬b∨¬a kk∨b ||∅ (31)\nin sml↑Π is an application of Backjump LP ."
    }, {
      "heading" : "12 Extended Graph: Generate and Test",
      "text" : "In this section we introduce an extended graph gtl↑F ,G for the generate and test abstract framework gtlF ,G similar as in Section 9 we introduced sml ↑ Π for smlΠ.\nFor a formula H , we say that a clause l ∨C is a reason for l to be in a list P lQ\nof literals w.r.t. H if H |= l ∨ C and C ⊆ P .\nAn (extended) record M relative to a formula H is a list of literals over the set\nof atoms occurring in H where\n(i) each literal l in M is annotated either by ∆ or by a reason for l to be in M\nw.r.t. H ,\n(ii) M contains no repetitions,\n(iii) for any inconsistent prefix of M its last literal is annotated by a reason.\nAn (extended) state relative to a CNF formula F , and a formula G formed from atoms occurring in F is either a distinguished state FailState or a pair of the form M ||Γ, where M is an extended record relative to F ∧ G, and Γ is the same as in the definition of an augmented state (i.e., Γ is a (multi-)set of clauses formed from atoms occurring in F that are entailed by F ∧G.) For any extended state S relative to F and G, the result of removing annotations from all nondecision literals of S is a state of gtlF ,G : we will denote this state by S ↓.\nFor a CNF formula F and a formula G formed from atoms occurring in F , we will define a graph gtl↑F ,G . The set of the nodes of gtl ↑ F ,G consists of the extended states relative to F and G. The transition rules of gtlF ,G are extended to gtl ↑ F ,G as follows: S1 =⇒ S2 is an edge in gtl ↑ F ,G justified by a transition rule T if and only if S ↓1 =⇒ S ↓ 2 is an edge in gtlF ,G justified by T .\nThe lemma below formally states the relationship between nodes of the graphs\ngtlF ,G and gtl ↑ F ,G :\nLemma 13 For any CNF formula F and a formula G formed from atoms occurring in F , if S ′ is a state reachable from ∅||∅ in the graph gtlF ,G then there is a state S in the graph gtl↑F ,G such that S ↓ = S ′.\nThe definitions of Basic transition rules and semi-terminal states in gtl↑F ,G are\nsimilar to their definitions for gtlF ,G . Proposition 9↑ For any CNF formula F and a formula G formed from atoms occurring in F ,\n(a) every path in gtl↑F ,G contains only finitely many edges labeled by Basic\ntransition rules,\n(b) for any semi-terminal state M ||Γ of gtl↑F ,G , M is a model of F ∧G, (c) gtl↑F ,G contains an edge leading to FailState if and only if F ∧G is unsatis-\nfiable.\nWe say that a state in the graph gtl↑F ,G is a backjump state if its record is inconsistent and contains a decision literal. As in case of the graph gtlF ,G , any backjump state in gtl↑F ,G is not semi-terminal: Proposition 10↑ For any CNF formula F and a formula G formed from atoms occurring in F , the transition rule Backjump GT is applicable in any backjump state in gtl↑F ,G .\nProposition 9 (b), (c) and Proposition 10 easily follow from Lemma 13 and Proposition 9↑ (b), (c) and Proposition 10↑ respectively. Proof of Proposition 9 (a) is similar to the proof of Proposition 9↑ (a)."
    }, {
      "heading" : "13 Proofs of Proposition 9↑, Lemma 13, Proposition 10↑",
      "text" : "13.1 Proof of Proposition 9↑\nLemma 14\nFor any CNF formula F , a formula G formed from atoms occurring in F , an extended record M relative to F ∧ G, and any model X of F ∧ G, if X satisfies all decision literals in M then X |= M ."
    }, {
      "heading" : "Proof",
      "text" : "By induction on the length ofM . The property trivially holds for ∅. We assume that the property holds for any state with n elements. Consider any state M with n +1 elements. Let X be a model of F ∧G such that X satisfies all decision literals in M .\nCase 1. M has the form P l∆. By the inductive hypothesis, X |= P . Since X\nsatisfies all decision literals in M , X |= l∆.\nCase 2. M has the form P l l∨C . By the inductive hypothesis, X |= P . By the definition of a reason (i) F ∧ G entails l ∨ C and (ii) C ⊆ P . From (ii) it follows that P |= ¬C . Consequently, X |= ¬C . From (i) it follows that X |= l ∨ C . We conclude that X |= l .\nThe proof of Proposition 9↑ assumes the correctness of Proposition 10↑ that we\ndemonstrate in Section 13.3.\nıProof of Proposition 9↑ Parts (a) and (c) are proved as in the proof of Proposition 8↑, using Lemma 14. (b) Let M ||Γ be a semi-terminal state so that none of the Basic rules are applicable. From the fact that Decide is not applicable, we conclude that M assigns all literals.\nFurthermore, M is consistent. Indeed, assume that M is inconsistent. Then, since Fail is not applicable, M contains a decision literal. Consequently, M ||Γ is a backjump state. By Proposition 10↑, the transition rule Backjump GT is applicable in M ||Γ. This contradicts our assumption that M ||Γ is semi-terminal.\nAlso, M is a model of F : since Unit Propagate λ is not applicable, it follows that for every clause C ∨ l ∈ F ∪ Γ if C ⊆ M then l ∈ M . Consequently, M |= C ∨ l . Furthermore, M is a model of G: since Test is not applicable, then G 6|= M . We conclude that M |= G. Consequently, M is a model of F ∧G."
    }, {
      "heading" : "13.2 Proof of Lemma 13",
      "text" : "For a state S in the graph gtl↑F ,G , we say that S ↓ in gtlF ,G is the image of S . Lemma 13 For any CNF formula F and a formula G formed from atoms occurring in F , if S ′ is a state reachable from ∅||∅ in the graph gtlF ,G then there is a state S in the graph gtl↑F ,G such that S ↓ = S ′."
    }, {
      "heading" : "Proof",
      "text" : "Since the property trivially holds for the initial state ∅||∅, we only need to prove that all transition rules of gtlF ,G preserve it.\nConsider an edge M ||Γ =⇒ M ′||Γ′ in the graph gtlF ,G such that there is a\nstate M1||Γ in the graph gtl ↑ F ,G satisfying the condition (M1||Γ) ↓ = M ||Γ. We need to show that there is a state in the graph gtl↑F ,G such that M ′||Γ′ is its image in gtlF ,G . Consider several cases that correspond to a transition rule leading from M ||Γ to M ′||Γ′:\nUnit Propagate λ:\nM ||Γ =⇒ M l ||Γ if\n{\nC ∨ l ∈ F ∪ Γ and C ⊆ M .\nM ′||Γ′ is M l ||Γ. It is sufficient to prove that M1 l C∨l ||Γ is a state of gtl↑F ,G . It is enough to show that a clause C ∨ l is a reason for l to be in M l w.r.t. F ∧G, i.e, F∧G |= C ∨l and C ⊆ M . By applicability conditions of Unit Propagate λ, C ⊆ M . By the definition of a state F ∧G entails Γ. Since C ∨ l ∈ F ∩ Γ, F ∧G |= C ∨ l .\nTest :\nM ||Γ =⇒ M l ||Γ if\n\n\n\nM is consistent, G |= M , l ∈ M .\nM ′||Γ′ is M l ||Γ. It is sufficient to prove that M1 l M ||Γ is a state of gtl↑F ,G . M has the form l ∨ C . It is enough to show that a clause l ∨ C is a reason for l to be in M l w.r.t. F ∧ G. It is trivial that C ⊆ M . By applicability condition of the rule, G |= l ∨ C .\nBackjump GT , Decide, Fail , and Learn GT : obvious."
    }, {
      "heading" : "13.3 Proof of Proposition 10↑",
      "text" : "For a state M lC ||Γ, we say that a reason C is a backjump clause if there is a transition Backjump GT leading to M lC ||Γ in gtlF ,G .\nIn this section F is an arbitrary and fixed CNF formula and G is an arbitrary\nand fixed formula formed from atoms occurring in F .\nFor a record M , by lcp(M ) we denote its largest consistent prefix. We say that a clause C is conflicting on a list M of literals if F ∧G entails C , and C ⊆ lcp(M ).\nLemmas 10, 11, 12 hold for the case of extended record relative to a formula. The\nproofs of the lemmas have to be modified only by replacing Π with F ∧G.\nProposition 10↑ is proved as Proposition 11↑.\nAlgorithms BackjumpClause and BackjumpClauseFirstUIP are applicable to the\nbackjump states of the graph gtl↑F ,G ."
    }, {
      "heading" : "14 Experiments with Sup",
      "text" : "Here we present experimental analysis that compares performance of the system sup versus cmodels, clasp, smodels, and smodelscc. We start by describing the implementation details of sup.\nThe implementation of sup utilizes\n• the interface of SAT-solver minisat (v1.12b) that supports non-clausal con-\nstraints described in (Een and Sörensson 2003) in order to introduce additional inference possibilities, but unit propagation. In particular, sup implements Backchain True and All Rules Cancelled by means of non-clausal constraints and it uses the unit propagate of minisat to capture Unit Propagate LP and Backchain False. • parts of cmodels code that eliminate weight and choice rules; perform model\nverification; and compute loop formulas. In particular, sup uses the latter two parts of cmodels code to capture Unfounded .\nIn the experiments we used the following versions of the systems: sup v. 0.1, sup v. 0.2, cmodels v. 3.77 usingminisat v. 1.12b, clasp v. 1.0.5, smodels v. 2.32, smodelscc v. 1.08 (implemented on top of smodels v. 2.26). System sup (v. 0.1 and v. 0.2) extends the implementation of minisat v. 1.12b. Therefore, we compare sup performance against cmodels that uses minisat 1.12b for its inference. System sup v. 0.1 stands for a version of sup that implements Unit Propagate LP, All Rules Cancelled, and Backchain False λ propagation rules, and does not implement Backchain True. System sup v 0.2, on the other hand, also implements Backchain True.\nAll considered solvers use preprocessor lparse (see Footnote 5) to ground the problems so that the systems are run on identical ground instances. Grounding time is not accounted for in solving time. All times are reported in seconds. Symbol tout stands for the fact that a system did not terminate with a solution after 10 minutes. Sup 0.1, Sup, Cm, Cl, Smcc, and Sm stand for sup v. 0.1, sup v. 0.2, cmodels, clasp, smodelscc, and smodels respectively. The symbol −t abbreviates the flag −temp that allows sup to forget learnt clauses due to loop formulas (by default sup adds these clauses into permanent clause database). The symbol −a abbreviates the flag −atomreason that forces cmodels, like sup, to add only a clause implied by some loop formula and unsatisfied by a current model rather than the complete loop formula unsatisfied by the model. By default, cmodels adds a complete loop formula unsatisfied by the model. All experiments were run on Intel(R) Pentium(R) D CPU 3.00GHz, 2 cpu cores, cache size 1024 KB, running Linux.\nTable 1 presents the experiments run on tight programs. Recall that for tight programs (i) the transition rule Unfounded of sup is never used for inference and (ii) the transition rule Test of cmodels is never used for inference.\nTable 2 presents the experiments run on nontight programs:\nOverall the results demonstrated by sup place the system in the class of highly\nefficient answer set solvers."
    }, {
      "heading" : "15 Related Work",
      "text" : "Simons (2000) andWard (2004) described the smodels and smodelscc algorithms, respectively, by means of pseudocode and demonstrated their correctness. In this paper we designed an abstract framework that was used as an alternative method for describing these algorithms and demonstrating their correctness.\nGebser and Schaub (2006) provided a deductive system for describing inferences involved in computing answer sets by tableaux methods. The abstract framework presented here can be viewed as a deductive system also, but of a very different kind. First, it accounts for phenomena such as backjumping and learning (and also forgetting and restart) whereas the Gebser-Schaub system does not. Second, we describe backtracking by an inference rule, and the Gebser-Schaub system does not. Accordingly, the derivations considered in this paper describe search process, and derivations in the Gebser-Schaub system do not. Also, the abstract framework\ndiscussed here does not have any inference rule similar to Cut; this is why its derivations are paths, rather than trees."
    }, {
      "heading" : "16 Conclusions",
      "text" : "In this paper we showed how to model advanced algorithms for computing answer sets of a program by means of simple mathematical objects, graphs. We extended the abstract frameworks proposed in (Lierler 2008) for describing native and SATbased ASP algorithms to capture such sophisticated features as backjumping and learning. We characterized the algorithms of systems smodelscc, sup, and cmodels that implement these features. We note that the work on this abstract framework suggested the implementation of answer set solver sup and the experimental analysis presented here demonstrates that sup is a competitive representative in the family of answer set solvers. The abstract framework simplifies the analysis of the correctness of algorithms and allows us to study the relationship between various algorithms by analyzing the differences in strategies of choosing a path in the graph. For example, the description of the smodelscc and sup algorithms in this framework reflects their differences in a simple manner via distinct assignments of priorities to edges of the graph that characterize these systems. Also we used this framework to describe two algorithms for computing Decision and FirstUIP backjump clauses for the implementation of conflict-driven backjumping and learning. This formalism provided the transparent means for specifying these algorithms. We believe that the development of this abstract framework powerful enough to describe advanced features of answer set solvers in a simple manner will promote the use of these sophisticated features in more solvers. This work helped us design the new solver sup, and we hope that in the future it will suggest designs of other systems for computing answer sets."
    }, {
      "heading" : "Acknowledgments",
      "text" : "We are grateful to Marco Maratea for bringing to our attention the work by Nieuwenhuis et al. (2006), to Vladimir Lifschitz for the numerous discussions, to Martin Gebser, Michael Gelfond, and Miros law Truszczyński for valuable ideas and comments, to anonymous referees for their suggestions. The author was supported by the National Science Foundation under Grant IIS-0712113."
    } ],
    "references" : [ {
      "title" : "Negation as failure",
      "author" : [ "K. Clark" ],
      "venue" : "Logic and Data Bases, H. Gallaire and J. Minker, Eds. Plenum Press, New York, 293–322.",
      "citeRegEx" : "Clark,? 1978",
      "shortCiteRegEx" : "Clark",
      "year" : 1978
    }, {
      "title" : "A machine program for theorem proving",
      "author" : [ "M. Davis", "G. Logemann", "D. Loveland" ],
      "venue" : "Communications of the ACM 5(7), 394–397.",
      "citeRegEx" : "Davis et al\\.,? 1962",
      "shortCiteRegEx" : "Davis et al\\.",
      "year" : 1962
    }, {
      "title" : "An extensible sat-solver",
      "author" : [ "N. Een", "N. Sörensson" ],
      "venue" : "SAT.",
      "citeRegEx" : "Een and Sörensson,? 2003",
      "shortCiteRegEx" : "Een and Sörensson",
      "year" : 2003
    }, {
      "title" : "Consistency of Clark’s completion and existence of stable models",
      "author" : [ "F. Fages" ],
      "venue" : "Journal of Methods of Logic in Computer Science 1, 51–60.",
      "citeRegEx" : "Fages,? 1994",
      "shortCiteRegEx" : "Fages",
      "year" : 1994
    }, {
      "title" : "Conflict-driven answer set solving",
      "author" : [ "M. Gebser", "B. Kaufmann", "A. Neumann", "T. Schaub" ],
      "venue" : "Proceedings of 20th International Joint Conference on Artificial Intelligence (IJCAI’07). MIT Press, 386–392.",
      "citeRegEx" : "Gebser et al\\.,? 2007",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2007
    }, {
      "title" : "Tableau calculi for answer set programming",
      "author" : [ "M. Gebser", "T. Schaub" ],
      "venue" : "Proceedings of 22nd International Conference on Logic Programming (ICLP’06). Springer, 11–25.",
      "citeRegEx" : "Gebser and Schaub,? 2006",
      "shortCiteRegEx" : "Gebser and Schaub",
      "year" : 2006
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "Proceedings of International Logic Programming Conference and Symposium, R. Kowalski and K. Bowen, Eds. MIT Press, 1070–1080.",
      "citeRegEx" : "Gelfond and Lifschitz,? 1988",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1988
    }, {
      "title" : "Answer set programming based on propositional satisfiability",
      "author" : [ "E. Giunchiglia", "Y. Lierler", "M. Maratea" ],
      "venue" : "Journal of Automated Reasoning 36, 345–377.",
      "citeRegEx" : "Giunchiglia et al\\.,? 2006",
      "shortCiteRegEx" : "Giunchiglia et al\\.",
      "year" : 2006
    }, {
      "title" : "On the relation between answer set and SAT procedures (or, between smodels and cmodels)",
      "author" : [ "E. Giunchiglia", "M. Maratea" ],
      "venue" : "Proceedings of 21st International Conference on Logic Programming (ICLP’05). Springer, 37–51.",
      "citeRegEx" : "Giunchiglia and Maratea,? 2005",
      "shortCiteRegEx" : "Giunchiglia and Maratea",
      "year" : 2005
    }, {
      "title" : "Satisfiability solvers",
      "author" : [ "C.P. Gomes", "H. Kautz", "A. Sabharwal", "B. Selman" ],
      "venue" : "Handbook of Knowledge Representation, F. van Harmelen, V. Lifschitz, and B. Porter, Eds. Elsevier, 89–134.",
      "citeRegEx" : "Gomes et al\\.,? 2008",
      "shortCiteRegEx" : "Gomes et al\\.",
      "year" : 2008
    }, {
      "title" : "A model-theoretic counterpart of loop formulas",
      "author" : [ "J. Lee" ],
      "venue" : "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI). Professional Book Center, 503–508.",
      "citeRegEx" : "Lee,? 2005",
      "shortCiteRegEx" : "Lee",
      "year" : 2005
    }, {
      "title" : "Abstract answer set solvers",
      "author" : [ "Y. Lierler" ],
      "venue" : "Proceedings of International Conference on Logic Programming (ICLP’08). Springer, 377–391.",
      "citeRegEx" : "Lierler,? 2008",
      "shortCiteRegEx" : "Lierler",
      "year" : 2008
    }, {
      "title" : "What is answer set programming? In Proceedings of the AAAI Conference on Artificial Intelligence",
      "author" : [ "V. Lifschitz" ],
      "venue" : "MIT Press, 1594–1597.",
      "citeRegEx" : "Lifschitz,? 2008",
      "shortCiteRegEx" : "Lifschitz",
      "year" : 2008
    }, {
      "title" : "ASSAT: Computing answer sets of a logic program by SAT solvers",
      "author" : [ "F. Lin", "Y. Zhao" ],
      "venue" : "Proceedings of National Conference on Artificial Intelligence (AAAI). MIT Press, 112–117.",
      "citeRegEx" : "Lin and Zhao,? 2002",
      "shortCiteRegEx" : "Lin and Zhao",
      "year" : 2002
    }, {
      "title" : "ASSAT: Computing answer sets of a logic program by SAT solvers",
      "author" : [ "F. Lin", "Y. Zhao" ],
      "venue" : "Artificial Intelligence 157, 115–137.",
      "citeRegEx" : "Lin and Zhao,? 2004",
      "shortCiteRegEx" : "Lin and Zhao",
      "year" : 2004
    }, {
      "title" : "Fast SAT-based answer set solver",
      "author" : [ "Z. Lin", "Y. Zhang", "H. Hernandez" ],
      "venue" : "Proceedings of National Conference on Artificial Intelligence (AAAI). MIT Press, 92–97.",
      "citeRegEx" : "Lin et al\\.,? 2006",
      "shortCiteRegEx" : "Lin et al\\.",
      "year" : 2006
    }, {
      "title" : "Conflict analysis in search algorithms for propositional satisfiability",
      "author" : [ "J.P. Marques-Silva", "K.A. Sakallah" ],
      "venue" : "Proceedings of IEEE Conference on Tools with Artificial Intelligence.",
      "citeRegEx" : "Marques.Silva and Sakallah,? 1996",
      "shortCiteRegEx" : "Marques.Silva and Sakallah",
      "year" : 1996
    }, {
      "title" : "A SAT solver primer",
      "author" : [ "D.G. Mitchell" ],
      "venue" : "EATCS Bulletin (The Logic in Computer Science Column). Vol. 85. 112–133.",
      "citeRegEx" : "Mitchell,? 2005",
      "shortCiteRegEx" : "Mitchell",
      "year" : 2005
    }, {
      "title" : "Solving SAT and SAT modulo theories: From an abstract Davis-Putnam-Logemann-Loveland procedure to DPLL(T)",
      "author" : [ "R. Nieuwenhuis", "A. Oliveras", "C. Tinelli" ],
      "venue" : "Journal of the ACM 53(6), 937–977.",
      "citeRegEx" : "Nieuwenhuis et al\\.,? 2006",
      "shortCiteRegEx" : "Nieuwenhuis et al\\.",
      "year" : 2006
    }, {
      "title" : "A backjumping technique for disjunctive logic programming",
      "author" : [ "F. Ricca", "W. Faber", "N. Leone" ],
      "venue" : "AI Commun. 19, 2, 155–172.",
      "citeRegEx" : "Ricca et al\\.,? 2006",
      "shortCiteRegEx" : "Ricca et al\\.",
      "year" : 2006
    }, {
      "title" : "Stable models and non-determinism in logic programs with negation",
      "author" : [ "D. Saccá", "C. Zaniolo" ],
      "venue" : "Proceedings of ACM Symposium on Principles of Database Systems (PODS). 205–217.",
      "citeRegEx" : "Saccá and Zaniolo,? 1990",
      "shortCiteRegEx" : "Saccá and Zaniolo",
      "year" : 1990
    }, {
      "title" : "Extending and implementing the stable model semantics",
      "author" : [ "P. Simons" ],
      "venue" : "Ph.D. thesis, Helsinki University of Technology. Adviser-Niemelä, Ilkka.",
      "citeRegEx" : "Simons,? 2000",
      "shortCiteRegEx" : "Simons",
      "year" : 2000
    }, {
      "title" : "The well-founded semantics for general logic programs",
      "author" : [ "A. Van Gelder", "K. Ross", "J. Schlipf" ],
      "venue" : "Journal of ACM 38, 3, 620–650.",
      "citeRegEx" : "Gelder et al\\.,? 1991",
      "shortCiteRegEx" : "Gelder et al\\.",
      "year" : 1991
    }, {
      "title" : "Answer set programming with clause learning",
      "author" : [ "J. Ward" ],
      "venue" : "Ph.D. thesis. AdviserLong, Timothy J. and Adviser-Schlipf, Johns S.",
      "citeRegEx" : "Ward,? 2004",
      "shortCiteRegEx" : "Ward",
      "year" : 2004
    }, {
      "title" : "Answer set programming with clause learning",
      "author" : [ "J. Ward", "J. Schlipf" ],
      "venue" : "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’04). 302–313.",
      "citeRegEx" : "Ward and Schlipf,? 2004",
      "shortCiteRegEx" : "Ward and Schlipf",
      "year" : 2004
    }, {
      "title" : "Efficient conflict driven learning in a boolean satisfiability solver",
      "author" : [ "L. Zhang", "C.F. Madigan", "M.W. Moskewicz", "S. Malik" ],
      "venue" : "Proceedings ICCAD-01. 279–285.",
      "citeRegEx" : "Zhang et al\\.,? 2001",
      "shortCiteRegEx" : "Zhang et al\\.",
      "year" : 2001
    } ],
    "referenceMentions" : [ {
      "referenceID" : 12,
      "context" : "Answer Set Programming (ASP) is a methodology commonly used for solving combinatorial search problems (Lifschitz 2008).",
      "startOffset" : 102,
      "endOffset" : 118
    }, {
      "referenceID" : 9,
      "context" : "In the development of ASP solvers, computational ideas behind SAT solvers (Gomes et al. 2008) play an important role.",
      "startOffset" : 74,
      "endOffset" : 93
    }, {
      "referenceID" : 19,
      "context" : "For instance, dlv implements backjumping (Ricca et al. 2006), and smodelscc 4 (Ward and Schlipf 2004) extends the answer set solver smodels by introducing restarts, conflict-driven",
      "startOffset" : 41,
      "endOffset" : 60
    }, {
      "referenceID" : 24,
      "context" : "2006), and smodelscc 4 (Ward and Schlipf 2004) extends the answer set solver smodels by introducing restarts, conflict-driven",
      "startOffset" : 23,
      "endOffset" : 46
    }, {
      "referenceID" : 11,
      "context" : "The ASP solver sup (Lierler 2008) implements these features also.",
      "startOffset" : 19,
      "endOffset" : 33
    }, {
      "referenceID" : 18,
      "context" : "In this paper our main goal is to show how the “abstract” approach to describing SAT solvers proposed in (Nieuwenhuis et al. 2006) can be extended to ASP solvers that use these sophisticated features.",
      "startOffset" : 105,
      "endOffset" : 130
    }, {
      "referenceID" : 18,
      "context" : "In (Nieuwenhuis et al. 2006), the authors proposed an alternative approach to describing dpll-like procedures.",
      "startOffset" : 3,
      "endOffset" : 28
    }, {
      "referenceID" : 11,
      "context" : "In (Lierler 2008), we extended this framework for describing such ASP algorithms as smodels, asp-sat with Backtracking, and sup without Learning.",
      "startOffset" : 3,
      "endOffset" : 17
    }, {
      "referenceID" : 17,
      "context" : "Usually, dpll-like procedures implement conflict-driven backjumping and learning where a particular learning schema such as, for instance, Decision or FirstUIP (Mitchell 2005) is applied for computing a special kind of a backjump clause.",
      "startOffset" : 160,
      "endOffset" : 175
    }, {
      "referenceID" : 16,
      "context" : "One employs the implication graph (Marques-Silva and Sakallah 1996) and the other employs resolution (Mitchell 2005).",
      "startOffset" : 34,
      "endOffset" : 67
    }, {
      "referenceID" : 17,
      "context" : "One employs the implication graph (Marques-Silva and Sakallah 1996) and the other employs resolution (Mitchell 2005).",
      "startOffset" : 101,
      "endOffset" : 116
    }, {
      "referenceID" : 11,
      "context" : "In (Lierler 2008), we introduced the basic algorithm underlining the system sup but neglected some of its features: conflict-driven backjumping, learning, forgetting, and restarts.",
      "startOffset" : 3,
      "endOffset" : 17
    }, {
      "referenceID" : 11,
      "context" : "The ASP solver sup (Lierler 2008) implements these features also. In this paper our main goal is to show how the “abstract” approach to describing SAT solvers proposed in (Nieuwenhuis et al. 2006) can be extended to ASP solvers that use these sophisticated features. Usually computation procedures are described in terms of pseudocode. In (Nieuwenhuis et al. 2006), the authors proposed an alternative approach to describing dpll-like procedures. They introduced an abstract framework that captures what ”states of computation” are, and what transitions between states are allowed. In this way, it defines a directed graph such that every execution of the dpll procedure corresponds to a path in this graph. Some edges may correspond to unit propagation steps, some to branching, some to backtracking. This allows the authors to model a dpll-like algorithm by a mathematically simple and elegant object, graph, rather than a collection of pseudocode statements. In (Lierler 2008), we extended this framework for describing such ASP algorithms as smodels, asp-sat with Backtracking, and sup without Learning. In this paper, we expand our previous work on abstract answer set solvers to cover such features as backjumping and learning (and also forgetting and restart). We start by introducing an abstract framework that captures a general mechanism of these sophisticated features in ASP solvers. For instance, this framework provides the transition underlying the process of learning a clause, but it does not suggest which clause shall be learned. Similarly, it provides a general description of backjumping but it does not supply the means for computing a “backjump clause” necessary for an answer set solver to perform backjumping. We then enhance this abstract framework to capture enough information about a state of computation for deriving a backjump clause. Usually, dpll-like procedures implement conflict-driven backjumping and learning where a particular learning schema such as, for instance, Decision or FirstUIP (Mitchell 2005) is applied for computing a special kind of a backjump clause. There are two common methods for describing a backjump clause construction. One employs the implication graph (Marques-Silva and Sakallah 1996) and the other employs resolution (Mitchell 2005). Ward and Schlipf (2004) extended the notion of an implication graph to the smodels algorithm.",
      "startOffset" : 20,
      "endOffset" : 2322
    }, {
      "referenceID" : 17,
      "context" : "7 The names of the backjump clauses follow (Mitchell 2005).",
      "startOffset" : 43,
      "endOffset" : 58
    }, {
      "referenceID" : 18,
      "context" : "We start the paper with Section 2 that reviews the abstract DPLL framework introduced in (Nieuwenhuis et al. 2006) and some logic programming concepts.",
      "startOffset" : 89,
      "endOffset" : 114
    }, {
      "referenceID" : 1,
      "context" : "Path (1) corresponds to an execution of dpll in the sense of (Davis et al. 1962); path (2) does not, because it applies Decide to a even though Unit Propagate could be applied in this state.",
      "startOffset" : 61,
      "endOffset" : 80
    }, {
      "referenceID" : 6,
      "context" : "A set X of atoms is an answer set for a program Π if X is minimal (with respect to set inclusion) among the sets of atoms that satisfy the reduct Π (Gelfond and Lifschitz 1988).",
      "startOffset" : 148,
      "endOffset" : 176
    }, {
      "referenceID" : 20,
      "context" : "Π (Corollary 2 from (Saccá and Zaniolo 1990)).",
      "startOffset" : 20,
      "endOffset" : 44
    }, {
      "referenceID" : 20,
      "context" : "9 The Corollary 2 from (Saccá and Zaniolo 1990) refers to ”assumption sets” rather than unfounded sets.",
      "startOffset" : 23,
      "endOffset" : 47
    }, {
      "referenceID" : 23,
      "context" : "10 The names of some of these rules follow (Ward 2004).",
      "startOffset" : 43,
      "endOffset" : 54
    }, {
      "referenceID" : 0,
      "context" : "It is well known that the supported models of a program can be characterized as models of program’s completion in the sense of (Clark 1978).",
      "startOffset" : 127,
      "endOffset" : 139
    }, {
      "referenceID" : 20,
      "context" : "Lemma 3 (Corollary 2 from (Saccá and Zaniolo 1990)) For any model M of a program Π, M is an answer set for Π if and only if M is unfounded-free.",
      "startOffset" : 26,
      "endOffset" : 50
    }, {
      "referenceID" : 3,
      "context" : "For the case of tight programs, the converse holds also: M is an answer set for Π if and only if M is a supported model of Π (Fages 1994) or, in other words, is a model of the completion of Π.",
      "startOffset" : 125,
      "endOffset" : 137
    }, {
      "referenceID" : 21,
      "context" : "With respect to the actual smodels algorithm (Simons 2000), singular edges of the graph smΠ are inessential: in view of priorities for choosing a path in smΠ described in Section 4.",
      "startOffset" : 45,
      "endOffset" : 58
    }, {
      "referenceID" : 8,
      "context" : "A similar relationship, in terms of pseudocode representations of smodels and dpll, is established in (Giunchiglia and Maratea 2005).",
      "startOffset" : 102,
      "endOffset" : 132
    }, {
      "referenceID" : 13,
      "context" : "This modification of the graph dpF is of interest, for example, in connection with the fact that answer sets of a program Π can be characterized as models of its completion extended by so called loop formulas of Π (Lin and Zhao 2002).",
      "startOffset" : 214,
      "endOffset" : 233
    }, {
      "referenceID" : 13,
      "context" : "This is important because LF (Π) can be very long (Lin and Zhao 2002).",
      "startOffset" : 50,
      "endOffset" : 69
    }, {
      "referenceID" : 7,
      "context" : "asp-sat with Backtracking (Giunchiglia et al. 2006) is a procedure that computes models of the completion of the given program using dpll, and tests them until an answer set is found.",
      "startOffset" : 26,
      "endOffset" : 51
    }, {
      "referenceID" : 18,
      "context" : "12 from (Nieuwenhuis et al. 2006).",
      "startOffset" : 8,
      "endOffset" : 33
    }, {
      "referenceID" : 18,
      "context" : "8 from (Nieuwenhuis et al. 2006)).",
      "startOffset" : 7,
      "endOffset" : 32
    }, {
      "referenceID" : 18,
      "context" : "The transition rules Restart and Forget LP are similar to the analogous rules in (Nieuwenhuis et al. 2006) for extending dpll procedure with restart and forgetting techniques.",
      "startOffset" : 81,
      "endOffset" : 106
    }, {
      "referenceID" : 24,
      "context" : "In this section we use this method to describe the smodelscc (Ward and Schlipf 2004) and sup (Lierler 2008) algorithms by means of smlΠ.",
      "startOffset" : 61,
      "endOffset" : 84
    }, {
      "referenceID" : 11,
      "context" : "In this section we use this method to describe the smodelscc (Ward and Schlipf 2004) and sup (Lierler 2008) algorithms by means of smlΠ.",
      "startOffset" : 93,
      "endOffset" : 107
    }, {
      "referenceID" : 11,
      "context" : "In (Lierler 2008), we introduced the simplified sup algorithm that relies on backtracking rather than conflict-driven backjumping and learning that are actually implemented in the system.",
      "startOffset" : 3,
      "endOffset" : 17
    }, {
      "referenceID" : 14,
      "context" : "The sup algorithm is similar to SAT-based answer set solvers such as assat (Lin and Zhao 2004) and cmodels (Giunchiglia et al.",
      "startOffset" : 75,
      "endOffset" : 94
    }, {
      "referenceID" : 7,
      "context" : "The sup algorithm is similar to SAT-based answer set solvers such as assat (Lin and Zhao 2004) and cmodels (Giunchiglia et al. 2006) (see Section 8.",
      "startOffset" : 107,
      "endOffset" : 132
    }, {
      "referenceID" : 7,
      "context" : "System cmodels implements an algorithm called asp-sat with Learning (Giunchiglia et al. 2006) that extends asp-sat with Backtracking by backjumping and learning.",
      "startOffset" : 68,
      "endOffset" : 93
    }, {
      "referenceID" : 7,
      "context" : "The clause learned due to this application of Learn GT is derived by means of loop formulas (see (Giunchiglia et al. 2006)).",
      "startOffset" : 97,
      "endOffset" : 122
    }, {
      "referenceID" : 15,
      "context" : "Systems sag (Lin et al. 2006) and clasp (Gebser et al.",
      "startOffset" : 12,
      "endOffset" : 29
    }, {
      "referenceID" : 4,
      "context" : "2006) and clasp (Gebser et al. 2007) are answer set solvers that are enhancements of cmodels.",
      "startOffset" : 16,
      "endOffset" : 36
    }, {
      "referenceID" : 14,
      "context" : "The proof uses the notion of loop formula (Lin and Zhao 2004).",
      "startOffset" : 42,
      "endOffset" : 61
    }, {
      "referenceID" : 10,
      "context" : "For any set Y of atoms, the external support formula (Lee 2005) for Y is",
      "startOffset" : 53,
      "endOffset" : 63
    }, {
      "referenceID" : 10,
      "context" : "From the Main Theorem in (Lee 2005) we conclude: Lemma on Loop Formulas For any program Π, Π entails loop formulas (21) for all sets Y of atoms that occur in Π.",
      "startOffset" : 25,
      "endOffset" : 35
    }, {
      "referenceID" : 17,
      "context" : "instance, Decision or FirstUIP (Mitchell 2005) is applied for computing a special kind of a backjump clause.",
      "startOffset" : 31,
      "endOffset" : 46
    }, {
      "referenceID" : 25,
      "context" : "Furthermore, in (Zhang et al. 2001) the authors investigated the performance of various learning schemes and established experimentally that FirstUIP clause is the most useful single clause to learn.",
      "startOffset" : 16,
      "endOffset" : 35
    }, {
      "referenceID" : 16,
      "context" : "The first one employes the implication graph (Marques-Silva and Sakallah 1996) and the second one employes resolution (Mitchell 2005).",
      "startOffset" : 45,
      "endOffset" : 78
    }, {
      "referenceID" : 17,
      "context" : "The first one employes the implication graph (Marques-Silva and Sakallah 1996) and the second one employes resolution (Mitchell 2005).",
      "startOffset" : 118,
      "endOffset" : 133
    }, {
      "referenceID" : 24,
      "context" : "Ward and Schlipf (Ward and Schlipf 2004) extended the definition of an implication graph to the smodels algorithm and implemented FirstUIP learning schema in answer set solver smodelscc.",
      "startOffset" : 17,
      "endOffset" : 40
    }, {
      "referenceID" : 4,
      "context" : "In (Gebser et al. 2007) the authors used the concepts from constraint processing to implement FirstUIP learning schema in answer set solver clasp.",
      "startOffset" : 3,
      "endOffset" : 23
    }, {
      "referenceID" : 2,
      "context" : "12b) that supports non-clausal constraints described in (Een and Sörensson 2003) in order to introduce additional inference possibilities, but unit propagation.",
      "startOffset" : 56,
      "endOffset" : 80
    }, {
      "referenceID" : 5,
      "context" : "Gebser and Schaub (2006) provided a deductive system for describing inferences involved in computing answer sets by tableaux methods.",
      "startOffset" : 0,
      "endOffset" : 25
    }, {
      "referenceID" : 11,
      "context" : "We extended the abstract frameworks proposed in (Lierler 2008) for describing native and SATbased ASP algorithms to capture such sophisticated features as backjumping and learning.",
      "startOffset" : 48,
      "endOffset" : 62
    }, {
      "referenceID" : 17,
      "context" : "We are grateful to Marco Maratea for bringing to our attention the work by Nieuwenhuis et al. (2006), to Vladimir Lifschitz for the numerous discussions, to Martin Gebser, Michael Gelfond, and Miros law Truszczyński for valuable ideas and comments, to anonymous referees for their suggestions.",
      "startOffset" : 75,
      "endOffset" : 101
    } ],
    "year" : 2010,
    "abstractText" : "Answer Set Solvers with Backjumping and Learning (long version)",
    "creator" : "LaTeX with hyperref package"
  }
}