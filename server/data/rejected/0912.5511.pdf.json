{
  "name" : "0912.5511.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ ],
    "emails" : [ "jim@cs.sfu.ca.", "torsten@cs.uni-potsdam.de." ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :0\n91 2.\n55 11\nv1 [\ncs .A\nI] 3\n0 D\nec 2\n00 9\nA General Approach to Belief Change in Answer Set Programming\nJAMES DELGRANDE Simon Fraser University TORSTEN SCHAUB Universität Potsdam and HANS TOMPITS and STEFAN WOLTRAN Technische Universität Wien\nWe address the problem of belief change in (nonmonotonic) logic programming under answer set semantics. Unlike previous approaches to belief change in logic programming, our formal techniques are analogous to those of distance-based belief revision in propositional logic. In developing our results, we build upon the model theory of logic programs furnished by SE models. Since SE models provide a formal, monotonic characterisation of logic programs, we can adapt techniques from the area of belief revision to belief change in logic programs.\nWe first consider belief revision: given logic programs P and Q, the goal is to determine a program R that corresponds to the revision of P by Q, denoted P ∗ Q. We investigate several specific operators, including (logic program) expansion and two revision operators based on the distance between the SE models of logic programs. It proves to be the case that expansion is an interesting operator in its own right, unlike in classical AGM-style belief revision where it is relatively uninteresting. Expansion and revision are shown to satisfy a suite of interesting properties; in particular, our revision operators satisfy the majority of the AGM postulates for revision.\nSecond, we consider approaches for merging logic programs. Given logic programs P1, . . . , Pn, the goal is to provide characterisations of the merging of these programs. Again, our formal techniques are based on notions of relative distance between the underlying SE models of the logic programs. Two approaches are examined. The first informally selects those models of the programs that vary the least from the models of the other programs. The second approach informally selects those models of a program P0 that are closest to the models of programs P1, . . . , Pn. In this case, P0 can be thought of as analogous to a set of database integrity constraints. We examine properties of these operators with regards to how they satisfy relevant postulate sets.\nWe also present encodings for computing the revision as well as the merging of logic programs within the same logic programming framework, giving rise to a direct implementation of our approach in terms of off-the-shelf answer set solvers. These encodings reflect in turn the fact that our change operators do not increase the complexity of the base formalism.\nThe first author was supported by a Canadian NSERC Discovery Grant. The second author was supported by the German Science Foundation (DFG) under grant SCHA 550/8-1. The third author was supported by the Austrian Science Fund (FWF) under project P21698. Authors’ address: J. Delgrande, Simon Fraser University, Burnaby, B.C., Canada, V5A 1S6, e-mail: jim@cs.sfu.ca. T. Schaub, Universität Potsdam, August-Bebel-Straße 89, D-14482 Potsdam, Germany, e-mail: torsten@cs.uni-potsdam.de. H. Tompits and S. Woltran, Technische Universität Wien, Favoritenstraße 9-11, A-1040 Vienna, Austria, e-mail: tompits@kr.tuwien.ac.at, woltran@dbai.tuwien.ac.at. Permission to make digital/hard copy of all or part of this material without fee for personal or classroom use provided that the copies are not made or distributed for profit or commercial advantage, the ACM copyright/server notice, the title of the publication, and its date appear, and notice is given that copying is by permission of the ACM, Inc. To copy otherwise, to republish, to post on servers, or to redistribute to lists requires prior specific permission and/or a fee. c© 20YY ACM 1529-3785/20YY/0700-0001 $5.00\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY, Pages 1–44.\nCategories and Subject Descriptors: I.2.3 [Artificial Intelligence]: Deduction and Theorem Proving—logic programming; nonmonotonic reasoning and belief revision; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods—representation languages; F.4.1 [Mathematical Logic and Formal Languages]: Mathematical Logic—logic and constraint programming\nGeneral Terms: Theory\nAdditional Key Words and Phrases: Answer set programming, belief revision, belief merging, strong equivalence"
    }, {
      "heading" : "1. INTRODUCTION",
      "text" : "Answer set programming (ASP) [Gelfond and Lifschitz 1988; Baral 2003] has emerged as a major area of research in knowledge representation and reasoning (KRR). On the one hand, ASP has an elegant and conceptually simple theoretical foundation, while on the other hand efficient implementations of ASP solvers exist which have been finding applications to practical problems. However, as is the case with any large program or body of knowledge, a logic program is not a static object in general, but rather it will evolve and be subject to change, whether as a result of correcting information in the program, adding to the information already present, or in some other fashion modifying the knowledge represented in the program.\nSince knowledge is continually evolving and subject to change, there is a need to be able to revise logic programs as new information is received. In KRR, the area of belief revision [Alchourrón et al. 1985; Gärdenfors 1988] addresses just such change to a knowledge base. In AGM belief revision (named after the aforecited developers of the approach) one has a knowledge baseK and a formulaα, and the issue is how to consistently incorporateα inK to obtain a new knowledge base K ′. The interesting case is whenK ∪ {α} is inconsistent, since beliefs have to be dropped from K before α can be consistently added. Hence, a fundamental issue concerns how such change should be managed.\nIn classical propositional logic, specific belief revision operators have been proposed based on the distance between models of a knowledge base and a formula for revision. That is, a characterisation of the revision of a knowledge base K by formula α is to set the models of the revised knowledge base K ′ to be the models of α that are “closest” to those of K . Of course the notion of “closest” needs to be pinned down, but natural definitions based on the Hamming distance [Dalal 1988] and set containment with regards to propositional letters [Satoh 1988] are well known.\nIn addition to belief revision (along with the dual notion of belief contraction), a second major class of belief change operators addresses the merging of knowledge bases. The problem of merging multiple, potentially conflicting bodies of information arises in various different contexts. For example, an agent may receive reports from differing sources of knowledge, or from sets of sensors that need to be reconciled. As well, an increasingly common phenomenon is that collections of data may need to be combined into a coherent whole. In these cases, the problem is that of combining knowledge sets that may be jointly inconsistent in order to get a consistent set of merged beliefs. Again, as in belief revision, specific operators for merging knowledge bases have been developed based on the distance between models of the underlying knowledge bases [Baral et al. 1992; Revesz 1993; Liberatore and Schaerf 1998; Meyer 2001; Konieczny and Pino Pérez 2002; Konieczny et al. 2002].\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nIt is natural then to consider belief change in the context of logic programs. Indeed, there has been substantial effort in developing approaches to so-called logic program updating under answer set semantics (we discuss previous work in the next section). Unfortunately, given the nonmonotonic nature of answer set programs, the problem of change in logic programs has appeared to be intrinsically more difficult than in a monotonic setting. In this paper, our goal is to reformulate belief change in logic programs in a manner analogous to belief change in classical propositional logic, and to investigate specific belief revision and merging operators for extended logic programs. Central for our approach are SE models [Turner 2003], which are semantic structures characterising strong equivalence between programs [Lifschitz et al. 2001]. This particular kind of equivalence plays a major role for different problems in logic programming—in particular, in program simplifications and modularisation. This is due to the fact that strong equivalence gives rise to a substitution principle in the sense that, for all programs P,Q, the programsP ∪R andQ∪R have the same answer sets, for any programR. As is well known, ordinary equivalence between programs (which holds if two programs have the same answer sets) does not yield a substitution principle. Hence, strong equivalence can be seen as the logic programming analogue of ordinary equivalence in classical logic. The important aspect of strong equivalence is that it coincides with equivalence in a specific monotonic logic, the logic of here and there (HT), which is intermediate between intuitionistic logic and classical logic. As shown by Turner [2003], equivalence between programs in HT corresponds in turn to equality between sets of SE models. Details on these concepts are given in the next section; the key point is that logic programs can be expressed in terms of a non-classical but monotonic logic, and it is this point that we exploit here.\nMore specifically, given this monotonic characterisation (via sets of SE models) of strong equivalence, we adapt techniques for belief change in propositional logic to belief change in logic programs. Hence we come up with specific operators for belief change in ASP analogous to operators in propositional logic. We first consider an expansion operator. In classical logic, the expansion of knowledge base K by formula α amounts to the deductive closure of K ∪ {α}. Hence it is not a very interesting operator, serving mainly as a tool for expressing concepts in belief revision and its dual, contraction. In logic programs however, expansion appears to be a more useful operator, perhaps due to the apparent “looser” notion of satisfiability provided by SE models. As well, it has appealing properties. We next develop revision operators based on notions of distance between SE models, and, following this, merging operators.\nIn characterising the merging of logic programs, the central idea is that the SE models of the merged program are again those that are in some sense “closest” to the SE models of the programs to be merged. However, as with merging knowledge bases expressed in classical logic, there is no single preferred notion of distance nor closeness, and consequently different approaches have been defined for combining sources of information. We introduce two merging operators for logic programs under answer set semantics. Both operators take an arbitrary (multi)set of logic programs as argument. The first operator can be regarded an instance of what Liberatore and Schaerf [1998] call arbitration. Basically (SE) models are selected from among the SE models of the programs to be merged; in a sense this operator is a natural extension of our belief revision operator. The second merging operator can be regarded as an instance of the one discussed by Konieczny and Pino Pérez [2002]. Here, models of a designated program (representing information analogous\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nto database integrity constraints) are selected that are closest to (or perhaps, informally, represent the best compromise among) the models of the programs to be merged.\nNotably, in our approaches there is effectively no mention of answer sets; rather definitions of expansion and revision are given entirely with respect to logic programs. Notably too, our operators are syntax independent, which is to say, they are independent of how a logic program is expressed; hence, our operators deal with the logical content of a logic program.\nFollowing an introductory background section, we show that there is a ready mapping between concepts in belief revision in classical logic and in ASP; this serves to place belief revision in ASP firmly in the “standard” belief revision camp. After this we describe in Section 3 our approaches to belief expansion and revision in ASP. We then employ these techniques in the following section to address the merging of logic programs. In either case, we discuss central properties and give complexity results. Then, in Section 5, we show how we can in fact express the process of belief change in ASP itself, giving a direct way to compute our introduced belief change operators. We conclude with a discussion. Proofs of results are contained in an appendix."
    }, {
      "heading" : "2. BACKGROUND AND FORMAL PRELIMINARIES",
      "text" : ""
    }, {
      "heading" : "2.1 Answer Set Programming",
      "text" : "2.1.1 Syntax and Semantics. A (generalised) logic program1 (GLP) over an alphabet A is a finite set of rules of the form\na1; . . . ; am;∼bm+1; . . . ;∼bn ← cn+1, . . . , co,∼do+1, . . . ,∼dp, (1)\nwhere ai, bj , ck, dl ∈ A are atoms, for 1 ≤ i ≤ m < j ≤ n < k ≤ o < l ≤ p. Operators ‘;’ and ‘,’ express disjunctive and conjunctive connectives. A default literal is an atom a or its (default) negation ∼a. A rule r as in (1) is called a fact if p = 1, normal if n = 1, positive if m = n and o = p, disjunctive if m = n, and an integrity constraint if n = 0, yielding an empty disjunction, sometimes denoted by ⊥ for convenience. Accordingly, a program is called disjunctive (or a DLP) if it consists of disjunctive rules only. Likewise, a program is normal (resp., positive) iff all rules in it are normal (resp., positive). We furthermore define the head and body of a rule, H(r) and B(r), by:\nH(r) = {a1, . . . , am,∼bm+1, . . . ,∼bn} and\nB(r) = {cn+1, . . . , co,∼do+1, . . . ,∼dp}.\nMoreover, given a set X of literals, we define\nX+ = {a ∈ A | a ∈ X},\nX− = {a ∈ A | ∼a ∈ X}, and\n∼X = {∼a | a ∈ X ∩ A}.\nFor simplicity, we sometimes use a set-based notation, expressing a rule as in (1) as H(r)+;∼H(r)−← B(r)+,∼B(r)−.\nIn what follows, we restrict ourselves to a finite alphabet A. An interpretation is represented by the subset of atoms in A that are true in the interpretation. A (classical) model\n1Such programs were first considered by Lifschitz and Woo [1992] and called generalised disjunctive logic programs by Inoue and Sakama [1998].\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nof a program P is an interpretation in which all of the rules in P are true according to the standard definition of truth in propositional logic, and where default negation is treated as classical negation. By Mod(P ) we denote the set of all classical models of P . An answer set Y of a program P is a subset-minimal model of\n{H(r)+← B(r)+ | r ∈ P, H(r)− ⊆ Y, B(r)− ∩ Y = ∅}.\nThe set of all answer sets of a program P is denoted by AS(P ). For example, the program P = {a←, c; d← a,∼b} has answer sets AS(P ) = {{a, c}, {a, d}}.\n2.1.2 SE Models. As defined by Turner [2003], an SE interpretation is a pair (X,Y ) of interpretations such thatX ⊆ Y ⊆ A. An SE interpretation is an SE model of a program P if Y |= P andX |= PY . The set of all SE models of a programP is denoted by SE (P ). Note that Y is an answer set of P iff (Y, Y ) ∈ SE (P ) and no (X,Y ) ∈ SE (P ) with X ⊂ Y exists. Also, we have (Y, Y ) ∈ SE (P ) iff Y ∈ Mod(P ).\nA program P is satisfiable just if SE (P ) 6= ∅. Two programs P and Q are strongly equivalent, symbolically P ≡s Q, iff SE (P ) = SE (Q). Alternatively, P ≡s Q holds iff AS(P ∪ R) = AS (Q ∪ R), for every program R [Lifschitz et al. 2001]. We also write P |=s Q iff SE (P ) ⊆ SE (Q). For simplicity, we often drop set-notation within SE interpretations and simply write, e.g., (a, ab) instead of ({a}, {a, b}).\nOne feature of SE models is that they contain “more information” than answer sets, which makes them an appealing candidate for problems where programs are examined with respect to further extension (in fact, this is what strong equivalence is about). We illustrate this issue with the following well-known example, involving programs\nP = {p; q ←} and Q =\n{\np← ∼q q ← ∼p\n}\n.\nHere, we have AS(P ) = AS(Q) = {{p}, {q}}. However, the SE models (we list them for A = {p, q}) differ:\nSE (P ) = {(p, p), (q, q), (p, pq), (q, pq), (pq, pq)}; SE (Q) = {(p, p), (q, q), (p, pq), (q, pq), (pq, pq), (∅, pq)}.\nThis is to be expected, since P andQ behave differently with respect to program extension (and thus are not strongly equivalent). ConsiderR = {p← q, q ← p}. ThenAS(P∪R) = {{p, q}}, while AS (Q ∪R) has no answer set.\nA set S of SE interpretations is well-defined if, for each (X,Y ) ∈ S, also (Y, Y ) ∈ S. A well-defined set S of SE interpretations is complete if, for each (X,Y ) ∈ S, also (X,Z) ∈ S, for any Y ⊆ Z with (Z,Z) ∈ S. We have the following properties:\n—For each GLP P , SE (P ) is well-defined.\n—For each DLP P , SE (P ) is complete.\nFurthermore, for each well-defined set S of SE interpretations, there exists a GLP P such that SE(P ) = S, and for each complete set S of SE interpretations, there exists a DLP P such that SE (P ) = S. Programs meeting these conditions can be constructed thus [Eiter et al. 2005; Cabalar and Ferraris 2007]: In case S is a well-defined set of SE interpretations over a (finite) alphabet A, define P by adding\n(1) the rule rY : ⊥ ← Y,∼(A \\ Y ), for each (Y, Y ) /∈ S, and\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\n(2) the rule rX,Y : (Y \\X);∼Y ← X,∼(A \\ Y ), for eachX ⊆ Y such that (X,Y ) /∈ S and (Y, Y ) ∈ S.\nIn case S is complete, define P by adding\n(1) the rule rY , for each (Y, Y ) /∈ S, as above, and (2) the rule r′X,Y : (Y \\X) ← X,∼(A \\ Y ), for each X ⊆ Y such that (X,Y ) /∈ S and\n(Y, Y ) ∈ S.\nWe call the resulting programs canonical. For illustration, consider\nS = {(p, p), (q, q), (p, pq), (q, pq), (pq, pq), (∅, p)}\nover A = {p, q}. Note that S is not complete. The canonical GLP is as follows:\nr∅ : ⊥ ← ∼p,∼q; r∅,q : q;∼q ← ∼p; r∅,pq : p; q;∼p;∼q ← .\nFor obtaining a complete set, we have to add (∅, pq) to S. Then, the canonical DLP is as follows:\nr∅ : ⊥ ← ∼p,∼q; r∅,q : q ← ∼p.\nWe conclude this subsection by introducing definitions for ordering SE models that will be needed when we come to define our belief change operators. Let ⊖ denote the symmetric difference operator between sets, i.e., X ⊖Y = (X \\ Y )∪ (Y \\X) for every set X,Y . We extend ⊖ so that it is defined for ordered pairs, as follows:\nDEFINITION 1. For every pair (X1, X2), (Y1, Y2),\n(X1, X2)⊖ (Y1, Y2) = (X1 ⊖ Y1, X2 ⊖ Y2).\nSimilarly, we define a notion of set containment, suitable for ordered pairs, as follows:\nDEFINITION 2. For every pair (X1, X2), (Y1, Y2),\n(X1, X2) ⊆ (Y1, Y2) iff X2 ⊆ Y2, and if X2 = Y2 then X1 ⊆ Y1.\nFurthermore, (X1, X2) ⊂ (Y1, Y2) iff (X1, X2) ⊆ (Y1, Y2) and not (Y1, Y2) ⊆ (X1, X2).\nAs will be seen, these definitions are appropriate for SE interpretations, as they give preference to the second element of a SE interpretation.\nSet cardinality is denoted as usual by | · |. We define a cardinality-based ordering over ordered pairs of sets as follows:\nDEFINITION 3. For every pair (X1, X2), (Y1, Y2),\n|(X1, X2)| ≤ |(Y1, Y2)| iff |X2| ≤ |Y2| and if |X2| = |Y2| then |X1| ≤ |Y1|.\nFurthermore, |(X1, X2)| < |(Y1, Y2)| iff |(X1, X2)| ≤ |(Y1, Y2)| and not |(Y1, Y2)| ≤ |(X1, X2)|.\nAs with Definition 2, this definition gives preference to the second element of an ordered pair. It can be observed that the definition yields a total preorder over ordered pairs. In the next section we return to the suitability of this definition, once our revision operators have been presented.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY."
    }, {
      "heading" : "2.2 Belief Change",
      "text" : "2.2.1 Belief Revision. The best known and, indeed, seminal work in belief revision is the AGM approach [Alchourrón et al. 1985; Gärdenfors 1988], in which standards for belief revision and contraction functions are given. In the revision of a knowledge base K by a formula φ, the intent is that the resulting knowledge contains φ, be consistent (unless φ is not), while keeping whatever information from K can be “reasonably” retained. Belief contraction is a dual notion, in which information is removed from a knowledge base; given that it is of limited interest with respect to our approach, we do not consider it further. Moreover, it is generally accepted that a contraction function can be obtained from a revision function by the so-called Harper identity, and the reverse obtained via the Levi identity; see Gärdenfors [1988] for details. In the AGM approach it is assumed that a knowledge base is receiving information concerning a static2 domain. Belief states are modelled by logically closed sets of sentences, called belief sets. A belief set is a set K of sentences which satisfies the constraint\nif K logically entails β, then β ∈ K.\nK can be seen as a partial theory of the world. For belief set K and formula α, K + α is the deductive closure of K ∪ {α}, called the expansion of K by α. K⊥ is the inconsistent belief set (i.e., K⊥ is the set of all formulas).\nSubsequently, Katsuno and Mendelzon [1992] reformulated the AGM approach so that a knowledge base was represented by a formula in some language L. The following postulates comprise Katsuno and Mendelzon’s reformulation of the AGM revision postulates, where ∗ is a function from L × L to L:\n(R1). ψ ∗ µ ⊢ µ.\n(R2). If ψ ∧ µ is satisfiable, then ψ ∗ µ↔ ψ ∧ µ.\n(R3). If µ is satisfiable, then ψ ∗ µ is also satisfiable.\n(R4). If ψ1 ↔ ψ2 and µ1 ↔ µ2, then ψ1 ∗ µ1 ↔ ψ2 ∗ µ2.\n(R5). (ψ ∗ µ) ∧ φ ⊢ ψ ∗ (µ ∧ φ).\n(R6). If (ψ ∗ µ) ∧ φ is satisfiable, then ψ ∗ (µ ∧ φ) ⊢ (ψ ∗ µ) ∧ φ.\nThus, revision is successful (R1), and corresponds to conjunction when the knowledge base and formula for revision are jointly consistent (R2). Revision leads to inconsistency only when the formula for revision is unsatisfiable (R3). Revision is also independent of syntactic representation (R4). Last, (R5) and (R6) express that revision by a conjunction is the same as revision by a conjunct conjoined with the other conjunct, when the result is satisfiable.\n2.2.2 Specific Belief Revision Operators. In classical belief change, the revision of a knowledge base represented by formula ψ by a formula µ, ψ ∗ µ, is a formula φ such that the models of φ are just those models of µ that are “closest” to those of ψ. There are two main specific approaches to distance-based revision. Both are related to the Hamming distance between two interpretations, that is on the set of atoms on which the interpretations\n2 Note that “static” does not imply “with no mention of time”. For example, one could have information in a knowledge base about the state of the world at different points in time, and revise information at these points in time.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\ndisagree. The first, by Satoh [1988], is based on set containment. The second, due to Dalal [1988], uses a distance measure based on the number of atoms with differing truth values in two interpretations. A set containment-based approach seems more appropriate in the context of ASP, since answer sets are defined in terms of subset-minimal interpretations. Hence, we focus on the method of Satoh [1988], although we also consider Dalal-style revision, since it has some technical interest with respect to ASP revision.\nThe Satoh revision operator, ψ ∗s µ, is defined as follows. For formulas α and β, define ⊖min(α, β) as\nmin⊆({w ⊖ w ′ | w ∈ Mod(α), w′ ∈ Mod(β)}).\nFurthermore, define Mod(ψ ∗s µ) as\n{w ∈ Mod(µ) | ∃w′∈Mod(ψ) s.t. w ⊖ w′ ∈ ⊖min(ψ, µ)}.\nThe cardinality-based or Dalal revision operator, ψ ∗d µ, is defined as follows. For formulas α and β, define |⊖|min(α, β) as\nmin≤({|w ⊖ w ′| | w ∈ Mod(α), w′ ∈ Mod(β)}).\nThen, Mod(ψ ∗d µ) is given as\n{w ∈ Mod(µ) | ∃w′∈Mod(ψ) s.t. |w ⊖ w′| = |⊖|min(ψ, µ)}.\n2.2.3 Belief Merging. Earlier work on merging operators includes approaches by Baral et al. [1992] and Revesz [1993]. The former authors propose various theory merging operators based on the selection of maximum consistent subsets in the union of the belief bases. The latter proposes an “arbitration” operator (see below) that, intuitively, selects from among the models of the belief sets being merged. Lin and Mendelzon [1999] examine majority merging, in which, if a plurality of knowledge bases hold φ to be true, then φ is true in the merging. Liberatore and Schaerf [1998] address arbitration in general, while Konieczny and Pino Pérez [2002] consider a general approach in which merging takes place with respect to a set of global constraints, or formulas that must hold in the merging. We examine these latter two approaches in detail below.\nKonieczny et al. [2002] describe a very general framework in which a family of merging operators is parametrised by a distance between interpretations and aggregating functions. More or less concurrently, Meyer [2001] proposed a general approach to formulating merging functions based on ordinal conditional functions [Spohn 1988]. Booth [2002] also considers the problem of an agent merging information from different sources, via what is called social contraction. Last, much work has been carried out in merging possibilistic knowledge bases; we mention here, e.g., the method by Benferhat et al. [2003].\nWe next describe the approaches by Liberatore and Schaerf [1998] and by Konieczny and Pino Pérez [2002], since we use the intuitions underlying these approaches as the basis for our merging technique. First, Liberatore and Schaerf [1998] consider merging two belief bases built on the intuition that models of the merged bases should be taken from those of each belief base closest to the other. This is called an arbitration operator (Konieczny and Pino Pérez [2002] call it a commutative revision operator). They consider a propositional language over a finite set of atoms; consequently their merging operator can be expressed as a binary operator on formulas. The following postulates characterise this operator:\nDEFINITION 4. ⋄ is an arbitration operator if ⋄ satisfies the following postulates.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\n(LS1). α ⋄ β ≡ β ⋄ α.\n(LS2). α ∧ β implies α ⋄ β.\n(LS3). If α ∧ β is satisfiable then α ⋄ β implies α ∧ β.\n(LS4). α ⋄ β is unsatisfiable iff α is unsatisfiable and β is unsatisfiable.\n(LS5). If α1 ≡ α2 and β1 ≡ β2 then α1 ⋄ β1 ≡ α2 ⋄ β2.\n(LS6). α ⋄ (β1 ∨ β2) =\n\n\n α ⋄ β1 or α ⋄ β2 or (α ⋄ β1) ∨ (α ⋄ β2).\n(LS7). (α ⋄ β) implies (α ∨ β).\n(LS8). If α is satisfiable then α ∧ (α ⋄ β) is satisfiable.\nThe first postulate asserts that merging is commutative, while the next two assert that, for mutually consistent formulas, merging corresponds to their conjunction. (LS5) ensures that the operator is independent of syntax, while (LS6) provides a “factoring” postulate, analogous to a similar factoring result in (AGM-style) belief revision and contraction. Postulate (LS7) can be taken as distinguishing ⋄ from other such operators; it asserts that the result of merging implies the disjunction of the original formulas. The last postulate informally constrains the result of merging so that each operator “contributes to” (i.e., is consistent with) the final result.\nNext, Konieczny and Pino Pérez [2002] consider the problem of merging possibly contradictory belief bases. To this end, they consider finite multisets of the form Ψ = {K1, . . . ,Kn}. They assume that the belief sets Ki are consistent and finitely representable, and so representable by a formula. Kn is the multiset consisting of n copies of K . Following Konieczny and Pino Pérez [2002], let ∆µ(Ψ) denote the result of merging the multiset Ψ of belief bases given the entailment-based integrity constraint expressed by µ. The intent is that ∆µ(Ψ) is the belief base closest to the belief multiset Ψ. They provide the following set of postulates (multiset union is denoted by ∪):\nDEFINITION 5. Let Ψ be a multiset of sets of formulas, and φ, µ formulas (all possibly subscripted or primed). Then, ∆ is an IC merging operator if it satisfies the following postulates.\n(IC0). ∆µ(Ψ) ⊢ µ.\n(IC1). If µ 6⊢ ⊥ then ∆µ(Ψ) 6⊢ ⊥. (IC2). If ∧ Ψ 6⊢ ¬µ then ∆µ(Ψ) ≡ ∧ Ψ ∧ µ.\n(IC3). If Ψ1 ≡ Ψ2 and µ1 ≡ µ2 then ∆µ1(Ψ1) ≡ ∆µ2 (Ψ2). (IC4). If φ ⊢ µ and φ′ ⊢ µ then ∆µ(φ ∪ φ′) ∧ φ 6⊢ ⊥ implies ∆µ(φ ∪ φ′) ∧ φ′ 6⊢ ⊥.\n(IC5). ∆µ(Ψ1) ∧∆µ(Ψ2) ⊢ ∆µ(Ψ1 ∪Ψ2). (IC6). If ∆µ(Ψ1) ∧∆µ(Ψ2) 6⊢ ⊥ then ∆µ(Ψ1 ∪Ψ2) ⊢ ∆µ(Ψ1) ∧∆µ(Ψ2). (IC7). ∆µ1(Ψ) ∧ µ2 ⊢ ∆µ1∧µ2(Ψ). (IC8). If ∆µ1(Ψ) ∧ µ2 6⊢ ⊥ then ∆µ1∧µ2(Ψ) ⊢ ∆µ1 (Ψ) ∧ µ2.\n(IC2) states that, when consistent, the result of merging is simply the conjunction of the belief bases and integrity constraints. (IC4) asserts that when two belief bases disagree, merging does not give preference to one of them. (IC5) states that a model of two mergings is in the union of their merging. With (IC5) we get that if two mergings are consistent\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nthen their merging is implied by their conjunction. Note that merging operators are trivially commutative. (IC7) and (IC8) correspond to the extended AGM postulates (K ∗ 7) and (K ∗ 8) for revision (cf. [Alchourrón et al. 1985; Gärdenfors 1988]), but with respect to the integrity constraints."
    }, {
      "heading" : "2.3 Belief Change in Logic Programming",
      "text" : "Most previous work on belief change for logic programs goes under the title of update [Foo and Zhang 1997; Przymusinski and Turner 1997; Zhang and Foo 1998; Alferes et al. 1998; 2000; Leite 2003; Inoue and Sakama 1999; Eiter et al. 2002; Zacarı́as et al. 2005; Delgrande et al. 2007]. Strictly speaking, however, such approaches generally do not address “update,” at least insofar as the term is understood in the belief revision community. There, update refers to a belief change in response to a change in the world being modelled [Katsuno and Mendelzon 1992]; this notion of change is not taken into account in the abovecited work. A common feature of most update approaches is to consider a sequence P1, P2, . . . , Pn of programs where each Pi is a logic program. For Pi, Pj , and i > j, the intuition is that Pi has higher priority or precedence. Given such a sequence, a set of answer sets is determined that in some sense respects the ordering. This may be done by translating the sequence into a single logic program that contains an encoding of the priorities, or by treating the sequence as a prioritised logic program, or by some other appropriate method. The net result, one way or another, is to obtain a set of answer sets from such a program sequence, and not a single new program expressed in the language of the original logic programs. Hence, these approaches fall outside the general AGM belief revision paradigm.\nHowever, various principles have been proposed for such approaches to logic program update. In particular, Eiter et al. [2002] consider the question of what principles the update of logic programs should satisfy. This is done by re-interpreting different AGM-style postulates for revising or updating classic knowledge bases, as well as introducing new principles. Among the latter, let us note the following:"
    }, {
      "heading" : "Initialisation. ∅ ∗ P ≡ P .",
      "text" : ""
    }, {
      "heading" : "Idempotency. (P ∗ P ) ≡ P .",
      "text" : "Tautology. If Q is tautologous, then P ∗Q ≡ P .\nAbsorption. If Q = R, then ((P ∗Q) ∗R) ≡ (P ∗Q).\nAugmentation. If Q ⊆ R, then ((P ∗Q) ∗R) ≡ (P ∗R).\nIn view of the failure of several of the discussed postulates in the approach of Eiter et al. [2002] (as well as in others), Osorio and Cuevas [2007] noted that for re-interpreting the standard AGM postulates in the context of logic programs, the logic underlying strong equivalence should be adopted. Since Osorio and Cuevas [2007] studied programs with strong negation, this led them to consider the logic N2, an extension of HT by allowing strong negation.3 They also introduced a new principle, which they called weak independence of syntax (WIS), which they proposed any update operator should satisfy:\nWIS. If Q ≡s R, then (P ∗Q) ≡ (P ∗R).\n3 N2 itself traces back to an extension of intuitionistic logic with strong negation, first studied by Nelson [1949].\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nIndeed, following this spirit, the above absorption and augmentation principles can be accordingly changed by replacing their antecedents by “Q ≡s R” and “Q |=s R”, respectively. We note that the WIS principle was also discussed in an update approach based on abductive programs [Zacarı́as et al. 2005].\nTurning our attention to the few works on revision of logic programs, early work in this direction includes a series of investigations dealing with restoring consistency for programs possessing no answer sets (cf., e.g., Witteveen et al. [1994]). Other work uses logic programs under a variant of the stable semantics to specify database revision, i.e., the revision of knowledge bases given as sets of atomic facts [Marek and Truszczyński 1998]. Finally, an approach following the spirit of AGM revision is discussed by Kudo and Murai [2004]. In their work, they deal with the question of constructing revisions of form P ∗ A, where P is an extended logic program and A is a conjunction of literals. They give a procedural algorithm to construct the revised programs; however no properties are analysed.\nWith respect to merging logic programs, we have already mentioned updating logic programs, which can also be considered as prioritised logic program merging. With respect to combining logic programs, Baral et al. [1991] describe an algorithm for combining a set of normal, stratified logic programs in which the union of the programs is also stratified. In their approach the combination is carried out so that a set of global integrity constraints, which is satisfied by individual programs, is also satisfied by the combination. Buccafurri and Gottlob [2002] present an interesting approach whereby rules in a given program encode desires for a corresponding agent. A predicate okay indicates that an atom is acceptable to an agent. Answer sets of these compromise logic programs represent acceptable compromises between agents. While it is shown that the joint fixpoints of such logic programs can be computed as answer sets, and complexity results are presented, the approach is not analysed from the standpoint of properties of merging. Sakama and Inoue [2008] address what they call the generous and rigorous coordination of logic programs in which, given a pair of programs P1 and P2, a program Q is found whose answer sets are equal to the union of the answer sets of P1 and P2 in the first case, and their intersection in the second. As the authors note, this approach and its goals are distinct from program merging."
    }, {
      "heading" : "3. BELIEF CHANGE IN ASP BASED ON SE MODELS",
      "text" : "In AGM belief change, an agent’s beliefs may be abstractly characterised in various different ways. In the classical AGM approach an agent’s beliefs are given by a belief set, i.e., a deductively-closed set of sentences. As well, an agent’s beliefs may also be characterised abstractly by a set of interpretations or possible worlds; these would correspond to models of the agent’s beliefs. Last, as proposed in the Katsuno-Mendelzon formulation, and given the assumption of a finite language, an agent’s beliefs can be specified by a formula. Given a finite language, it is straightforward to translate between these representations.\nIn ASP, there are notions analogous to the above for specifying an agent’s beliefs. Though we do not get into it here, the notion of strong equivalence of logic programs can be employed to define a (logic program) belief set. Indeed, a set of well-defined SE models characterises a class of equivalent logic programs. Hence, the set of SE models of a program can be considered as the proposition expressed by the program. Continuing this analogy, a specific logic program can be considered to correspond to a formula or set of formulas in classical logic.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY."
    }, {
      "heading" : "3.1 Expanding Logic Programs",
      "text" : "Belief expansion is a belief change operator that is much more basic than revision or contraction, and in a certain sense is prior to revision and contraction (since in the AGM approach revision and contraction postulates make reference to expansion). Hence, it is of interest to examine expansion from the point of view of logic programs. As well, it proves to be the case that expansion in logic programs is of interest in its own right.\nThe next definition corresponds model-theoretically with the usual definition of expansion in AGM belief change.\nDEFINITION 6. For logic programs P andQ, define the expansion of P andQ, P +Q, to be a logic program R such that SE (R) = SE (P ) ∩ SE (Q).\nFor illustration, consider the following examples:4\n(1) {p←}+ {⊥ ← p} has no SE models.\n(2) {p← q}+ {⊥ ← p} has SE model (∅, ∅).\n(3) {p←}+ {q ← p} ≡s {p←}+ {q ←} ≡s {p←, q ←}.\n(4) {p← ∼q}+ {q ← ∼p} ≡s\n{\np← ∼q q ← ∼p\n}\n.\n(5)\n{\np← ∼q q ← ∼p\n}\n+ {p← q} ≡s\n{\np← q p← ∼q\n}\n.\n(6)\n{\np← ∼q q ← ∼p\n}\n+ {p; q ←} ≡s {p; q ←}.\n(7) {p; q ←}+ {⊥ ← q} ≡s\n{\np← ⊥← q\n}\n.\n(8) {p; q ←}+ {⊥ ← p, q} ≡s\n{\np; q← ⊥← p, q\n}\n.\nBelief expansion has desirable properties. The following all follow straightforwardly from the definition of expansion with respect to SE models.\nTHEOREM 1. Let P and Q be logic programs. Then:\n(1) P +Q is a logic program.\n(2) P +Q |=s P . (3) If P |=s Q, then P +Q ≡s P . (4) If P |=s Q, then P +R |=s Q+R. (5) If SE (P ) and SE(Q) are well-defined, then so is SE(P +Q). (6) If SE (P ) and SE(Q) are complete, then so is SE (P +Q).\n(7) If Q ≡s ∅, then P +Q ≡s P .\nWhile these results are indeed elementary, following as they do from the monotonicity of the SE interpretations framework, they are still of interest. Notably, virtually every previous approach to updating logic programs has trouble with the last property, expressing a tautology postulate. Here, expansion by a tautologous program presents no problem,\n4Unless otherwise noted, we assume that the language of discourse in each example consists of just the atoms mentioned.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nas it corresponds to an intersection with the set of all SE interpretations. We note also that the other principles mentioned earlier—initialisation, idempotency, absorption, and augmentation—are trivially satisfied by expansion.\nIn classical logic, the expansion of two formulas can be given in terms of the intersection of their models. It should be clear from the preceding that the appropriate notion of the set of “models” of a logic program is given by a set of SE models, and not by a set of answer sets. Hence, there is no natural notion of expansion that is given in terms of answer sets. For instance, in Example 3, we have AS({p ←}) = {{p}} and AS({q ← p}) = {∅} while AS({p ←, q ← p}) = {{p, q}}. Likewise, in Example 4, the intersection of AS ({{p ← ∼q}}) = {{p}} and AS ({{q ← ∼p}}) = {{q}} is empty, whereas AS({p← ∼q, q ← ∼p}) = {{p}, {q}}."
    }, {
      "heading" : "3.2 Revising Logic Programs",
      "text" : "We next turn to specific operators for belief revision. As discussed earlier, for a revision P ∗Q, we suggest that the most natural distance-based notion of revision for logic programs uses set containment as the appropriate means of relating SE interpretations. Hence, we begin by considering set-containment based revision. Thus, P ∗Q will be a logic program whose SE models are a subset of the SE models of Q, comprising just those models of Q that are closest to those of P . Following the development of this operator we also consider cardinality-based revision, as a point of contrast. While these two approaches correspond to the two best-known ways of incorporating distance based revision, they are not exhaustive and any other reasonable notion of distance could also be employed.\n3.2.1 Set-Containment Based Revision. The following definition gives, for sets of interpretations E1, E2, the subset of E1 that is closest to E2, where the notion of “closest” is given in terms of symmetric difference.\nDEFINITION 7. Let E1, E2 be two sets of either classical or SE interpretations. Then:\nσ(E1, E2) = {A ∈ E1 | ∃B ∈ E2 such that\n∀A′ ∈ E1, ∀B′ ∈ E2, A′ ⊖B′ 6⊂ A⊖B}.\nIt might seem that we could now define the SE models of P ∗ Q to be given by σ(SE (Q),SE (P )). However, for our revision operator to be meaningful, it must also produce a well-defined set of SE models. Unfortunately, Definition 7 does not preserve well-definedness. For an example, consider P = {⊥ ← p} and Q = {p ← ∼p}. Then, SE (P ) = {(∅, ∅)} and SE (Q) = {(∅, p), (p, p)}, and so σ(SE (Q),SE (P )) = {(∅, p)}. However {(∅, p)} is not well-defined.\nThe problem is that for programs P and Q, there may be an SE model (X,Y ) of Q with X ⊂ Y such that (X,Y ) ∈ σ(SE (Q),SE (P )) but (Y, Y ) 6∈ σ(SE (Q),SE (P )). Hence, in defining P ∗ Q in terms of σ(SE (Q),SE (P )), we must elaborate the set σ(SE (Q),SE (P )) in some fashion to obtain a well-defined set of SE models.\nIn view of this, our approach is based on the following idea to obtain a well-defined set of models of P ∗Q based on the notion of distance given in σ:\n(1) Determine the “closest” models of Q to P of form (Y, Y ).\n(2) Determine the “closest” models ofQ to P limited to models (X,Y ) ofQwhere (Y, Y ) was found in the first step.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nThus, we give preference to potential answer sets, in the form of models (Y, Y ), and then to general models.\nDEFINITION 8. For logic programs P and Q, define the revision of P by Q, P ∗Q, to be a logic program such that:\nif SE (P ) = ∅, then SE (P ∗Q) = SE (Q);\notherwise\nSE (P ∗Q) = {(X,Y ) | Y ∈ σ(Mod (Q),Mod(P )), X ⊆ Y,\nand if X ⊂ Y then (X,Y ) ∈ σ(SE (Q),SE (P ))}.\nAs is apparent, SE (P ∗ Q) is well-defined, and thus is representable through a canonical logic program. Furthermore, over classical models, the definition of revision reduces to that of containment-based revision in propositional logic [Satoh 1988]. As we show below, the result of revising P by Q is identical to that of expanding P by Q whenever P and Q possess common SE models. Hence, all previous examples of non-empty expansions are also valid program revisions. We have the following examples of revision that do not reduce to expansion.5\n(1) {p← ∼p} ∗ {⊥ ← p} ≡s {⊥ ← p}. Over the language {p, q}, ⊥ ← p has SE models (∅, ∅), (∅, q), and (q, q).\n(2)\n{\np← q←\n}\n∗ {⊥ ← q} ≡s\n{\np← ⊥← q\n}\n.\nThe first program has a single SE model, (pq, pq), while the second has three, (∅, ∅), (∅, p), and (p, p). Among the latter, (p, p) has the least pairwise symmetric difference to (pq, pq). The program induced by the singleton set {(p, p)} of SE models is\n{p←, ⊥ ← q}.\n(3)\n{\np← q←\n}\n∗ {⊥ ← p, q} ≡s\n{\np; q← ⊥← p, q\n}\n.\nThus, if one originally believes that p and q are true, and revises by the fact that one is false, then the result is that precisely one of p, q is true.\n(4)\n{\n⊥← ∼p ⊥← ∼q\n}\n∗ {⊥ ← p, q} ≡s\n{\n⊥←∼p,∼q ⊥← p, q\n}\n.\nObserve that the classical models in the programs here are exactly the same as above. This example shows that the use of SE models provides finer “granularity” compared to using classical models of programs together with known revision techniques.\n(5)\n{\n⊥← p ⊥← q\n}\n∗ {p; q ←} ≡s\n{\np; q← ⊥← p, q\n}\n.\nWe next rephrase the Katsuno-Mendelzon postulates for belief revision. Here, ∗ is a function from ordered pairs of logic programs to logic programs.\n(RA1). P ∗Q |=s Q. (RA2). If P +Q is satisfiable, then P ∗Q ≡s P +Q.\n(RA3). If Q is satisfiable, then P ∗Q is satisfiable.\n5Note that {p ← ∼p} has SE models but no answer sets.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\n(RA4). If P1 ≡s P2 and Q1 ≡s Q2, then P1 ∗Q1 ≡s P2 ∗Q2. (RA5). (P ∗Q) +R |=s P ∗ (Q+R). (RA6). If (P ∗Q) +R is satisfiable, then P ∗ (Q+R) |=s (P ∗Q) +R.\nWe obtain that logic program revision as given in Definition 8 satisfies the first five of the revision postulates. Unsurprisingly, this is analogous to set-containment based revision in propositional logic.\nTHEOREM 2. The logic program revision operator ∗ from Definition 8 satisfies postulates (RA1)-(RA5).\nThe fact that our revision operator does not satisfy (RA6) can be seen by the following example: Consider\nP = {p;∼p, q ← p, r ← p, s← p, ⊥ ← ∼p, q,\n⊥ ← ∼p, r, ⊥ ← ∼p, s},\nQ = {p; r, ⊥ ← q, ⊥ ← p, r, ⊥ ← p, s, s;∼s← r},\nR = {p; r, ⊥ ← q, ⊥ ← p, r, ⊥ ← p, s, s← r}.\nStraightforward computations show that\nSE (P ∗ (Q+R)) = {(rs, rs), (p, p)} while\nSE ((P ∗Q) +R) = {(p, p)}.\nSo, P ∗ (Q+R) 6|=s (P ∗Q) + R. Since SE ((P ∗Q) +R) 6= ∅, this shows that (RA6) indeed fails.\nLast, we have the following result concerning other principles for updating logic programs listed earlier:\nTHEOREM 3. Let P and Q be logic programs. Then, P ∗ Q satisfies initialisation, idempotency, tautology, and absorption with respect to strong equivalence.\nAugmentation, however, does not hold, nor would one expect it to hold in a distancebased approach. For example, consider the case where P , Q, and R are characterised by models SE (P ) = {(a, a), (ab, ab)}, SE (Q) = {(ab, ab), (ac, ac), (b, b)}, and SE (R) = {(ac, ac), (b, b)}. Thus SE (R) ⊆ SE (Q). We obtain that SE (P ∗ Q) = SE (P + Q) = {(ab, ab)}, and thus SE ((P ∗Q)∗R) = {(b, b)}. However, SE (P ∗R) = {(ac, ac), (b, b)}, contradicting augmentation.\nDefinition 8 seems to be the most natural possibility for constructing a set-containment based revision operator. However, it is not the only such possibility. We next briefly discuss an alternative definition for revision. The idea here is that for the revision of P by Q, we select the closest models of Q to P , and then add interpretations to make the result well-defined.\nDEFINITION 9. For logic programs P andQ, define the weak revision of P by Q to be a logic program P ∗w Q such that:\nif SE (P ) = ∅, then SE (P ∗w Q) = SE (Q);\notherwise\nSE(P ∗w Q) = σ(SE (Q),SE (P )) ∪\n{(Y, Y ) | (X,Y ) ∈ σ(SE (Q),SE (P )) for some X}.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nThe drawback to this approach is that it introduces possibly irrelevant interpretations in order to obtain well-definedness. As well, Definition 8 appears to be the more natural. Consider the following example, which also serves to distinguish Definition 8 from Definition 9. Let\nP = {⊥ ← p, ⊥ ← q, ⊥ ← r},\nQ = { r, p← q, p← ∼q }.\nThen, we get the following SE models:\nSE (P ) = {(∅, ∅)},\nSE (Q) = {(r, pqr), (pr, pr), (pr, pqr), (pqr, pqr)},\nand\nSE (P ∗Q) = {(pr, pr)},\nSE (P ∗w Q) = SE (Q) \\ {(pr, pqr)}.\nConsequently, P ∗Q is given by the program {p, ⊥ ← q, r}. Thus, in this example, P ∗Q gives the desired result, preserving the falsity of q from P , while incorporating the truth of r and p fromQ. This then reflects the assumption of minimal change to the program being revised, in this case P . P ∗w Q on the other hand represents a very cautious approach to program revision.\nFinally, we have that our definition of revision is strictly stronger than the alternative given by ∗w:\nTHEOREM 4. Let P and Q be programs. Then, P ∗Q |=s P ∗w Q.\nFor completeness, let us mention that enforcing well-definedness by simply determining the “closest” models of Q to P of form (Y, Y ) is inadequate. For our motivating example, we would obtain SE ({p← ∼p} ∗ {⊥ ← p}) = ∅, violating the key postulate (RA3), that the result of revising by a satisfiable program results in a satisfiable revision.\n3.2.2 Cardinality-Based Revision. We next briefly recapitulate the previous development but in terms of cardinality-based revision. Define, for two sets E1, E2 of interpretations, the subset of E1 that is closest to E2, where the notion of “closest” is now given in terms of cardinality:\nDEFINITION 10. LetE1,E2 be two sets of either classical or SE interpretations. Then:\nσ||(E1, E2) = {A ∈ E1 | ∃B ∈ E2 such that\n∀A′ ∈ E1, ∀B′ ∈ E2, |A′ ⊖B′| 6< |A⊖B|}.\nAs with set containment-based revision, we must ensure that our operator results in a well-defined set of SE models. Again, we first give preference to potential answer sets, in the form of models (Y, Y ), and then to general models.\nDEFINITION 11. For logic programs P and Q, define the (cardinality-based) revision of P by Q, P ∗c Q, to be a logic program such that:\nif SE (P ) = ∅, then SE (P ∗c Q) = SE (Q);\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\notherwise\nSE (P ∗c Q) = {(X,Y ) | Y ∈ σ||(Mod(Q),Mod(P )), X ⊆ Y,\nand if X ⊂ Y then (X,Y ) ∈ σ||(SE (Q),SE (P ))}.\nP ∗cQ can be seen to be well-defined, and so can be represented through a canonical logic program. As well, over classical, propositional models the definition reduces to cardinalitybased revision in propositional logic [Dalal 1988].\nWe observe from the respective definitions that\nSE (P ∗c Q) ⊆ SE (P ∗Q).\nThat the two revision operators differ is easily shown: For example, if\nP =\n\n\n p ← q ← r ←\n\n\n\nand Q =\n\n\n p ; q ← r ← q ← p, r\n\n\n\nwe get SE (P ) = {(pqr, pqr)} and SE (Q) = {(p, p), (qr, qr)}. This yields SE (P ∗Q) = {(p, p), (qr, qr)} while SE (P ∗c Q) = {(qr, qr)}.\nIt can be observed that P ∗c Q yields the same results as P ∗ Q for the five examples given in the previous subsection. However, cardinality-based revision fully aligns with the AGM postulates:\nTHEOREM 5. Let P andQ be logic programs. Then, P ∗cQ satisfies postulates (RA1) – (RA6).\nAs well, the following result is straightforward:\nTHEOREM 6. Let P and Q be logic programs. Then, P ∗c Q satisfies initialisation, idempotency, tautology, and absorption with respect to strong equivalence.\n3.2.3 Remarks. Both of our proposed approaches to revising logic programs are based on a notion of distance between SE models. In the first, a partial preorder was induced between SE models, while in the second a total preorder resulted. We note that any definition of distance that results in a partial (resp., total) preorder among SE models could have been used, with the same technical results obtaining (but not, of course, the same examples). Hence, these approaches are exemplars of the two most common types of revision, expressed in terms of differences among truth values of atoms in models. As such, our specific approaches can be seen as natural generalisations of the approaches of Satoh [1988] and Dalal [1988].\nWe have suggested earlier that the approach based on set containment is the more natural or plausible approach, even though it does not satisfy all of the AGM postulates. This is because the cardinality-based approach may make somewhat arbitrary distinctions in arriving at a total preorder over SE interpretations. Recall the example we used to illustrate the difference between the approaches:\nSE (P ) = {(pqr, pqr)} and SE (Q) = {(p, p), (qr, qr)},\nyielding\nSE (P ∗Q) = {(p, p), (qr, qr)} and SE (P ∗c Q) = {(qr, qr)}.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nGiven that we have no information concerning the ontological import of the atoms involved, it seems somewhat arbitrary to decide (in the case of ∗c) that qr should take priority over p. As an alternative argument, consider where for some large n we have\nSE (P ) = {(p1 . . . p2n, p1 . . . p2n)} and SE (Q) = {(p1 . . . pn+1, p1 . . . pn+1), (p1 . . . pn, p1 . . . pn)}.\nSo, in this example it is quite arbitrary to select (as the cardinality-based approach does) (p1 . . . pn+1, p1 . . . pn+1) over (p1 . . . pn, p1 . . . pn).\nLet us finally remark that another plausible definition of an ordering underlying cardinality-based revision would be the following:\n|(X1, X2)| ≤′ |(Y1, Y2)| iff |X1| ≤ |Y1| and |X2| ≤ |Y2|.\nHowever, this ordering yields a partial preorder, and a revision operator based on this notion of distance would be very similar to P ∗Q; in particular the postulate (RA6) would not be satisfied. Since this operator is of at best marginal interest, we do not explore it further."
    }, {
      "heading" : "3.3 Complexity of Revision",
      "text" : "We now turn to the complexity of our approach to revision. First, we recapitulate the complexity classes relevant in what follows. As usual, for any complexity class C, by co-C we understand the class of all problems which are complementary to the problems in C. Furthermore, for C as before and complexity class A, the notation CA stands for the relativised version of C, consisting of all problems which can be decided by Turing machines of the same sort and time bound as in C, only that the machines have access to an oracle for problems in A.\nFour complexity classes are relevant here, viz. NP, ΣP2 , Π P 2 , and Θ P 2 , which are defined\nthus:\n—NP consists of all decision problems which can be solved with a nondeterministic Turing machine working in polynomial time; —ΣP2 = NP NP; —ΠP2 = co-Σ P 2 ; and —ΘP2 is the class of all problems solvable on a deterministic Turing machine in polynomial time asking on input x a total of O(log |x|) many oracle calls to NP (thus, ΘP2 is also denoted by PNP[logn]).\nObserve that NP, ΣP2 , and Π P 2 are part of the polynomial hierarchy, which is given by\nthe following sequence of objects: the initial elements are\n∆P0 = Σ P 0 = Π P 0 = P;\nand, for i > 0,\n∆Pi = P ΣP i−1 ; ΣPi = NP ΣP i−1 ; ΠPi = co-NP ΣP i−1 .\nHere, P is the class of all problems solvable on a deterministic Turing machine in polynomial time. It holds that ΣP1 = NP, Σ P 2 = NP NP, and ΠP2 = co-NP NP. A problem is said to be at the k-th level of the polynomial hierarchy iff it is in ∆Pk+1 and either Σ P k -hard or ΠPk -hard.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nWe first consider the worst-case complexity of our approach to set-containment based revision. The standard decision problem for revision in classical logic is:\nGiven formulas P , Q, and R, does P ∗Q entail R?\nEiter and Gottlob [1992] showed that approaches to classical propositional revision are ΠP2 -complete. The next result shows that this property carries over to our approach for program revision.\nTHEOREM 7. Deciding whether P ∗ Q |=s R holds, for given GLPs P , Q, and R, is ΠP2 -complete. Moreover, hardness holds already for P being a set of facts, Q being positive or normal, and R being a single fact.\nAlthough we do not show it here, we mention that the same results holds for the cautious revision operator ∗w as well.\nFor cardinality-based revision, we obtain the following result, again mirroring a similar behaviour for the classical case and being a consequence of the construction given in Section 5:\nTHEOREM 8. Deciding whether P ∗c Q |=s R holds, for given GLPs P , Q, and R, is in ΘP2 ."
    }, {
      "heading" : "4. MERGING LOGIC PROGRAMS",
      "text" : "We denote (generalised) logic programs by P1, P2, . . . , reserving P0 for a program representing global constraints, as described later. For logic programs P1, P2, we define P1 ⊓ P2 to be a program with SE models equal to SE (P1) ∩ SE (P2) and P1 ⊔ P2 to be a program with SE models equal to SE (P1) ∪ SE (P2). By a belief profile, Ψ, we understand a sequence6 〈P1, . . . , Pn〉 of (generalised) logic programs. For Ψ = 〈P1, . . . , Pn〉 we write ⊓Ψ for P1 ⊓ · · · ⊓ Pn. We write Ψ1 ◦ Ψ2 for the (sequence) concatenation of belief profiles Ψ1, Ψ2; and for logic program P0 and Ψ = 〈P1, . . . , Pn〉 we abuse notation by writing 〈P0,Ψ〉 for 〈P0, P1, . . . , Pn〉. A belief profile Ψ is satisfiable just if each component logic program is satisfiable. The set of SE models of Ψ is given by SE (Ψ) = SE (P1)× · · · × SE (Pn). For S ∈ SE (Ψ) such that S = 〈S1, . . . , Sn〉, we use Si to denote the ith component of S. Thus, Si ∈ SE (Pi). Analogously, the set of classical propositional models of Ψ is given by Mod(Ψ) = Mod(P1) × · · · × Mod(Pn); also we use Xi to denote the ith component of X ∈ Mod(Ψ)."
    }, {
      "heading" : "4.1 Arbitration Merging",
      "text" : "For the first approach to merging, called arbitration, we consider models of Ψ and select those models in which, in a global sense, the constituent models vary minimally. The result of arbitration is a logic program made up of SE models from each of these minimallyvarying tuples. Note that, in particular, if a set of programs is jointly consistent, then there are models of Ψ in which all constituent SE models are the same. That is, the models that vary minimally are those S ∈ SE (Ψ) in which Si = Sj for every 1 ≤ i, j ≤ n; and merging is the same as simply taking the union of the programs.\nThe first definition provides a notion of distance between models of Ψ, while the second then defines merging in terms of this distance.\n6This departs from usual practise, where a belief profile is usually taken to be a multiset.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nDEFINITION 12. Let Ψ = 〈P1, . . . , Pn〉 be a satisfiable belief profile and let S, T be two SE models of Ψ (or two classical models of Ψ).\nThen, define S ≤a T , if Si ⊖ Sj ⊆ Ti ⊖ Tj for every 1 ≤ i < j ≤ n.\nClearly, ≤a is a partial preorder. In what follows, let Mina(N) denote the set of all minimal elements of a set N of tuples relative to ≤a, i.e.,\nMina(N) = {S ∈ N | T ≤a S implies S ≤a T for all T ∈ N} .\nPreparatory for our central definition to arbitration merging, we furthermore define, for a set N of n-tuples,\n∪N = {Si | for S ∈ N,S = 〈S1, . . . , Sn〉 and i ∈ {1, . . . , n}}.\nDEFINITION 13. Let Ψ = 〈P1, . . . , Pn〉 be a belief profile. Then, the arbitration merging, or simply arbitration, of Ψ, is a logic program ∇(Ψ) such that\nSE (∇(Ψ)) = {(X,Y ) | Y ∈ ∪Mina(Mod(Ψ)), X ⊆ Y,\nand if X ⊂ Y then (X,Y ) ∈ ∪Mina(SE (Ψ))} ,\nproviding Ψ is satisfiable, otherwise, if Pi is unsatisfiable for some 1 ≤ i ≤ n, define ∇(Ψ) = ∇(〈P1, . . . , Pi−1, Pi+1, . . . , Pn〉).\nFor illustration, consider the belief profile\n〈P1, P2〉 = 〈{p← , u←}, {← p , v ←}〉 . (2)\nSince SE (P1) = {(pu, pu), (pu, puv), (puv, puv)} and SE (P2) = {(v, v), (v, uv), (uv, uv)}, we obtain nine SE models for SE (〈P1, P2〉). Among them, we find a unique ≤a-minimal one, yielding Mina(SE (〈P1, P2〉)) = {〈(puv, puv), (uv, uv)〉}. Similarly, 〈P1, P2〉 has a single ≤a-minimal collection of pairs of classical models, viz. Mina(Mod(〈P1, P2〉)) = {〈puv, uv〉}. Accordingly, we get\n∪Mina(Mod(〈P1, P2〉)) = {puv, uv},\n∪Mina(SE (〈P1, P2〉)) = {(puv, puv), (uv, uv)}, and\nSE (∇((P1, P2))) = ∪Mina(SE (〈P1, P2〉)) .\nWe thus obtain the program ∇(〈P1, P2〉) = {p;∼p ← , u ← , v ←} as the resultant arbitration of P1 and P2.\nFor further illustration, consider the technical examples given in Table I. We note that merging normal programs often leads to disjunctive or generalised programs. Although plausible, this is also unavoidable because merging does not preserve the model intersection property of the reduced program satisfied by normal programs.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nMoreover, we have the following general result.\nTHEOREM 9. Let Ψ = 〈P1, P2〉 be a belief profile, and define P1 ⋄ P2 = ∇(Ψ). Then, ⋄ satisfies the following versions of the postulates of Definition 4.\n(LS1′). P1 ⋄ P2 ≡s P2 ⋄ P1. (LS2′). P1 ⊓ P2 |=s P1 ⋄ P2. (LS3′). If P1 ⊓ P2 is satisfiable then P1 ⋄ P2 |=s P1 ⊓ P2. (LS4′). P1 ⋄ P2 is satisfiable iff P1 is satisfiable and P2 is satisfiable. (LS5′). If P1 ≡s P2 and P ′1 ≡s P ′ 2 then P1 ⋄ P2 ≡s P ′ 1 ⋄ P ′ 2. (LS7′). P1 ⋄ P2 |=s P1 ⊔ P2. (LS8′). If P1 and P2 are satisfiable then P1 ⊓ (P1 ⋄ P2) is satisfiable."
    }, {
      "heading" : "4.2 Basic Merging",
      "text" : "For the second approach to merging, programs P1, . . . , Pn are merged with a target logic program P0 so that the SE models in the merging will be drawn from models of P0. This operator will be referred to as the (basic) merging of P1, . . . , Pn with respect to P0. The information in P0 must hold in the merging, and so can be taken as necessarily holding. Konieczny and Pino Pérez [2002] call P0 a set of integrity constraints, though this usage of the term differs from its usage in logic programs. Note that in the case where SE (P0) is the set of all SE models, the two approaches (of this section and the previous section) do not coincide, and that merging is generally a weaker operator than arbitration.\nDEFINITION 14. Let Ψ = 〈P0, . . . , Pn〉 be a belief profile and let S, T be two SE models of Ψ (or two classical models of Ψ)."
    }, {
      "heading" : "Then, define S ≤b T , if S0 ⊖ Sj ⊆ T0 ⊖ Tj for every 1 ≤ j ≤ n.",
      "text" : "As in the case of arbitration merging,≤b is a partial preorder. Accordingly, let Minb(N) be the set of all minimal elements of a setN of tuples relative to ≤b. In extending our notation for referring to components of tuples, we furthermore define N0 = {S0 | S ∈ N}. We thus can state our definition for basic merging as follows:\nDEFINITION 15. Let Ψ = 〈P1, . . . , Pn〉 be a belief profile. Then, the basic merging, or simply merging, of Ψ, is a logic program ∆(Ψ) such that\nSE (∆(Ψ)) = {(X,Y ) | Y ∈ Minb(Mod(Ψ))0, X ⊆ Y, and if X ⊂ Y then (X,Y ) ∈ Minb(SE (Ψ))0} ,\nproviding Ψ is satisfiable, otherwise, if Pi is unsatisfiable for some 1 ≤ i ≤ n, define ∆(Ψ) = ∆(〈P0, . . . , Pi−1, Pi+1, . . . , Pn〉).\nLet us reconsider Programs P1 and P2 from (2) in the context of basic merging. To this end, we consider the belief profile 〈∅, {p ← , u ←}, {← p , v ←}〉. We are now faced with 27 SE models for SE (〈∅, P1, P2〉). Among them, we get the following ≤b-minimal SE models\nMinb(SE (〈∅, P1, P2〉)) = {〈(uv, uv), (puv, puv), (uv, uv)〉,\n〈(uv, puv), (puv, puv), (uv, uv)〉, 〈(puv, puv), (puv, puv), (uv, uv)〉}\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nalong with Minb(Mod(〈∅, P1, P2〉)) = {〈uv, puv, uv〉, 〈puv, puv, uv〉}. We get:\nMinb(Mod(〈∅, P1, P2〉))0 = {puv, uv},\nMinb(SE (〈∅, P1, P2〉))0 = {(uv, uv), (uv, puv), (puv, puv)}, and\nSE (∆(〈∅, P1, P2〉)) = Minb(SE (〈∅, P1, P2〉))0 .\nWhile arbitration resulted in ∇(〈P1, P2〉) = {p;∼p ← , u ← , v ←}, the more conservative approach of basic merging yields ∆(〈∅, P1, P2〉) = {u← , v ←}.\nWe have just seen that basic merging adds “intermediate” SE models, viz. (uv, puv), to the ones obtained in arbitration merging. This can also be observed on the examples given in Table I, where every second merging is weakened by the addition of such intermediate SE models. This is made precise in Theorem 11 below. We summarise the results in Table II but omit the programs ∆(〈∅, P1, P2〉) because they are obtained from ∇(〈P1, P2〉) in Table I by simply dropping all rules of form p;∼p← and q;∼q ←, respectively.\nThe next example further illustrates the difference between arbitration and basic merging. Take P1 = {p ← , q ←} and P2 = {∼p ← ,∼q ←}. Then, we have that SE (∇(〈P1, P2〉)) = {(pq, pq), (∅, ∅)} and SE (∆(〈∅, P1, P2〉)) = SE (∅). That is, in terms of programs, we obtain\n∇(〈P1, P2〉) = {p;∼p←, q;∼q ←, ← p,∼q, ← ∼p, q} and ∆(〈∅, P1, P2〉) = ∅ .\nTHEOREM 10. Let Ψ be a belief profile, P0 a program representing global constraints, and ∆ as given in Definition 15. Then, ∆ satisfies the following versions of the postulates of Definition 5:\n(IC0′). ∆(〈P0,Ψ〉) |=s P0. (IC1′). If P0 and Ψ are satisfiable then ∆(〈P0,Ψ〉) is satisfiable. (IC2′). If ⊓(P0,Ψ) is satisfiable then ∆(〈P0,Ψ〉) ≡s P0 ⊓ (⊓(Ψ)). (IC3′). If P0 ≡s P ′0 and Ψ ≡s Ψ ′ then ∆(〈P0,Ψ〉) ≡s ∆(〈P ′0,Ψ ′〉). (IC4′). If P1 |=s P0 and P2 |=s P0 then: if ∆(〈P0, P1, P2〉) ⊓ P1 is satisfiable, then ∆(〈P0, P1, P2〉) ⊓ P2 is satisfiable. (IC5′). ∆(〈P0,Ψ〉) ⊓∆(〈P0,Ψ′〉) |=s ∆(〈P0,Ψ ◦Ψ′〉). (IC7′). ∆(〈P0,Ψ〉) ⊓ P1 |=s ∆(〈P0 ⊓ P1,Ψ〉). (IC9′). Let Ψ′ be a permutation of Ψ. Then, ∆(〈P0,Ψ〉) ≡s ∆(〈P0,Ψ′〉).\nWe also obtain that arbitration merging is stronger than (basic) merging in the case of tautologous constraints in P0.\nTHEOREM 11. Let Ψ be a belief profile. Then ∇(Ψ) |=s ∆(〈∅,Ψ〉).\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nAs well, for belief profile Ψ = 〈P1, P2〉, we can express our merging operators in terms of the revision operator defined in Section 3.2.\nTHEOREM 12. Let 〈P1, P2〉 be a belief profile.\n(1) ∇(〈P1, P2〉) = (P1 ∗ P2) ⊔ (P2 ∗ P1).\n(2) ∆(〈P1, P2〉) = P2 ∗ P1.\nNote that in the second part of the preceding result, P1 is regarded as a set of constraints (usually with name P0) according to our convention for basic merging."
    }, {
      "heading" : "4.3 Complexity Analysis",
      "text" : "In the previous section, the following decision problem was studied with respect to the revision operator ∗: Given GLPs P , Q, R, does P ∗ Q |=s R hold? This problem was shown to be ΠP2 -complete. Accordingly, we give here results for the following problems:\n(1) Given a belief profile Ψ and a programR, does ∇(Ψ) |=s R hold?\n(2) Given a belief profile Ψ and a programR, does ∆(Ψ) |=s R hold?\nBy Theorem 12, it can be shown that the hardness result for the revision problem also applies to the respective problems in terms of merging. On the other hand,ΠP2 -membership can be obtained by a slight extension of the encodings given in the next section such that these extensions possess an answer set iff the respective problem (1) or (2) does not hold. Since checking whether a program has at least one answer set is a problem on the second of layer of the polynomial hierarchy, and our (extended) encodings are polynomial in the size of the encoded problems, the desired membership results follow.\nTHEOREM 13. Given a belief profile Ψ and a programR, deciding∇(Ψ) |=s R (resp., ∆(Ψ) |=s R) is ΠP2 -complete."
    }, {
      "heading" : "5. COMPUTING BELIEF CHANGE VIA ANSWER SET PROGRAMMING",
      "text" : "In this section, we provide encodings for our belief change operators in terms of fixed nonground ASP programs. We recall that non-ground programs are defined over predicates of arbitrary arity which have either variables or constants as arguments. Such non-ground programs can be seen as a compact representation of large programs without variables (and thus as propositional programs), by considering the grounding of a program (recall that the grounding of a program P is given by the union of the groundings of its rules, and the grounding of a rule r ∈ P is the set obtained by all possible substitutions of variables in r by constants occurring in P ; cf. Dantsin et al. [2001] for a more thorough exposition). The non-ground programs we define in this section can be seen as queries which take the (propositional) programs subject to revision or merging as an input database. Thus, we follow here the tradition of meta-programming (see, e.g., the works of Delgrande et al. [2003], Eiter et al. [2003], and Gebser et al. [2008]).\nOur encodings are given via certain language fragments of non-ground ASP such that their respective data complexity matches the complexity of the encoded task. Recall that data complexity addresses problems over programsP ∪D where a non-ground program P is fixed, while the input databaseD (a set of ground atoms) is the input of the decision problem. As is well known, the data complexity of the problem whether a is contained in all answer sets of P ∪D is ΠP2 -complete for disjunctive programs (without weak constraints)\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\n[Dantsin et al. 2001] and ΘP2 -complete for normal programs with certain optimisation constructs (for instance, weak constraints over a single level; we introduce weak constraints later) [Buccafurri et al. 2000]. We use weak constraints for the encoding of the cardinalitybased revision operator (although similar optimisation constructs could be used likewise) while for the set-based revision operator and the merging operators we require disjunctive programs. However, instead of coming up with encodings for the decisions problems discussed in the previous section, our ultimate goal here is to provide programs such that their answer sets characterise the SE models of the result of the encoded revision or merging problem.\nBefore we start with the ASP encodings, we have to fix how the programs subject to revision and merging are represented in our approach. To have a uniform setting in what follows, we use belief profiles Ψ = 〈Pα, . . . , Pn〉 where, for revision problems we have α = 1 and n = 2 (and so 〈P1, P2〉 here represents revision problemP1∗P2), for arbitration problems α = 1 and n ≥ 2, and for basic merging, we use α = 0 and n ≥ 2.\nGiven such a belief profile Ψ = 〈Pα, . . . , Pn〉, we use four ternary predicates, phead , nhead , pbody , and nbody to represent Ψ. For each predicate, the first argument i indices the program (i.e., i is a number between α and n), the second argument contains the rule identifier #r of a rule r ∈ Pi, and the third argument is an atom, indicating that this atom occurs in the positive or negative head or the positive or negative body of rule r ∈ Pi, respectively. For example, let Ψ = 〈P1, P2〉 with P1 = {← ∼p, ← ∼q} and P2 = {p; q ←, ← p, q}. We obtain the relational representation of Ψ by7\n[Ψ] = {nbody(1, 1, p), nbody(1, 2, q),\nphead(2, 1, p), phead(2, 1, q), pbody(2, 2, p), pbody(2, 2, q)}.\nHere, we just use numbers as rule identifiers, i.e. #(← ∼p) = #(p; q ←) = 1 and #(← ∼q) = #(← p, q) = 2. The only necessary requirement is that different rules are assigned to different identifiers, i.e., r 6= r′ implies #r 6= #r′.\nIn general, we define the relational representation of a belief profile as follows.\nDEFINITION 16. Let Ψ = 〈Pα, . . . , Pn〉 be a belief profile. Then, the relational representation of Ψ is given by\n[Ψ] = n ⋃\ni=α\n⋃\nr∈Pi\n(\n{phead(i,#r, a) | a ∈ H(r)+} ∪ {nhead(i,#r, a) | a ∈ H(r)−} ∪\n{pbody(i,#r, a) | a ∈ B(r)+} ∪ {nbody(i,#r, a) | a ∈ B(r)−} ) .\nWe assume here that all i and #r are given as numbers. Note that some ASP solvers then require to define the domain of integers (for instance, via #maxint in the solver DLV [Leone et al. 2006]). Following datalog notation, we write, for a program Π and a belief profile Ψ, Π[Ψ] instead of Π ∪ [Ψ].\nWe provide our encodings in a modular way. That is, we introduce various sets of rules which implement different aspects required to solve the respective problem. We start with some basic modules, which are used in most of the encodings. Then, we provide our results for revision and conclude with the encodings for merging.\n7Since we have here rules which are all simple facts, we omit the “←”-symbol for rules.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY."
    }, {
      "heading" : "5.1 Basic Modules",
      "text" : "We start with a simple fragment which contains some domain predicates and fixes some designated identifiers.\nDEFINITION 17.\nπdomain = {prog rule(P,R) ← α(P,R,A), dom(A) ← α(P,R,A) |\nα ∈ {phead , pbody ,nhead ,nbody} } ∪\n{prog(P ) ← prog rule(P,R),\nmodel(c) ←, model (t) ←, model (h) ←,\nprog model(c) ←, prog model (t) ←, prog model(h) ←}.\nPredicates prog rule(·, ·), dom(·), and prog(·) are just used to gather some information from a conjoined input [Ψ]; the designated constants c, t, h are used later on to distinguish between different guesses for models. In fact, c refers to classical models while h and t refer to the first and second part of SE models, respectively.\nThe following code guesses such models for each programP in the belief profile Ψ. The guess is accomplished in Rules (3) and (4) below which assign each atom A in the domain to be in(·) or out(·).\nDEFINITION 18.\nπmodels = {in(P,A,M) ← ∼out(P,A,M), prog(P ), dom(A),model (M), (3)\nout(P,A,M) ← ∼in(P,A,M), prog(P ), dom(A),model (M), (4)\n← in(P,A, h), out(P,A, t), (5)\ndiff (P,Q,A,M) ← in(P,A,M), out(Q,A,M), (6)\ndiff (P,Q,A,M) ← out(P,A,M), in(Q,A,M), (7)\nsame(P,Q,A,M) ← in(P,A,M), in(Q,A,M), (8)\nsame(P,Q,A,M) ← out(P,A,M), out(Q,A,M), (9)\nok(P,R,M) ← in(P,A,M), phead (P,R,A),model (M), (10)\nok(P,R,M) ← out(P,A,M), pbody(P,R,A),model (M), (11)\nok(P,R,M) ← in(P,A,M),nbody(P,R,A), prog model (M), (12)\nok(P,R,M) ← out(P,A,M),nhead(P,R,A), prog model(M), (13)\nok(P,R, h) ← in(P,A, t),nbody(P,R,A), (14)\nok(P,R, h) ← out(P,A, t),nhead (P,R,A), (15)\n← ∼ok (P,R,M), prog rule(P,R),model (M)}. (16)\nThis allows us to draw a one-to-one correspondence between answer sets S and models (resp., SE models) of the programs Pi in the belief profile. Note that Rule (5) excludes such guesses where the corresponding SE model (X,Y ) would not satisfy X ⊆ Y . To make this intuition a bit more precise, let us define the following operator for a set S of ground atoms and a number i:\nΠiMod(S) = {a | in(i, a, c) ∈ S};\nΠiSE (S) = ( {a | in(i, a, h) ∈ S}, {b | in(i, b, t) ∈ S} ) .\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nThe next Rules (6) – (9) indicate whether atom A is assigned differently (via predicate diff (·, ·, ·, ·)) or equally (via predicate same(·, ·, ·, ·)) for two programs. These predicates are useful later.\nThe remaining Rules (10) – (15) tell us which rules (in which programs) are satisfied by the respective guess. Observe that (10) and (11) are applied to any forms of models (i.e., h, t, and c) while (12) and (13) are only applied to t and c. Rules (14) and (15) finally take care of the fact that the first argument of an SE model has to be a model of the reduct. Therefore, we check whether the model given by the t-guess already eliminates rules. Note that such rules are satisfied by the h-guess in a trivial way. The last Rule (16) finally ensures that all rules of all programs are satisfied by our guesses.\nWe observe that the answer sets of the program P [Ψ] where P = πdomain ∪πmodels are in a one-to-one correspondence to the models and SE models of belief profile Ψ. Formally we have that, given Ψ = 〈Pα, . . . , Pn〉,\n{(M,N) |M ∈ Mod(Ψ), N ∈ SE (Ψ)} =\n{(〈ΠαMod(S), . . . ,Π n Mod(S)〉, 〈Π α SE (S), . . . ,Π n SE (S)〉) | S ∈ AS (P [Ψ])}.\nWe define one further module, which just orders the domain elements (i.e., the atoms in the given belief profile) using the standard ordering < provided by the employed ASP solver. In particular, we define infimum, supremum, and successor with respect to this order. This is a standard technique used quite frequently in ASP; we require this later in order to “loop” over the domain elements. We also note that we could add such rules also for the program indices, as well as for the rule identifiers. However, since we assume them to be given by successive numbers, we omit such rules here. In fact, we use N = M + 1 instead of a designated successor predicate for program indices and rule identifiers. We add only rules which provide the minimal number α and resp. the maximal number n of programs in the given profile Ψ = 〈Pα, . . . , Pn〉. The module thus looks as follows:\nDEFINITION 19.\nπorder = {lt(X,Y ) ← dom(X), dom(Y ), X < Y,\nnsucc(X,Z) ← lt(X,Y ), lt(Y, Z),\nsucc(X,Y ) ← lt(X,Y ),∼nsucc(X,Y ),\nninf (X) ← lt(Y,X),\nnsup(X) ← lt(X,Y ),\ninf (X) ← ∼ninf (X), dom(X),\nsup(X) ← ∼nsup(X), dom(X),\nminprog(P ) ← prog(P ), P = Q+ 1,∼prog(Q),\nmaxprog(P ) ← prog(P ), Q = P + 1,∼prog(Q)}."
    }, {
      "heading" : "5.2 Encodings for Revision",
      "text" : "5.2.1 Cardinality-based Revision. We are now prepared to encode the cardinalitybased revision, following Definition 11. For our forthcoming encoding, we require optimisation constructs which are available in most ASP solvers. We shall use here the concept of weak constraints [Buccafurri et al. 2000] as used by DLV. A weak constraint (without\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nweights and levels) is a rule of the form\n⇐ c1, . . . , cm,∼dm+1, . . . ,∼dp. (17)\nThe semantics of a program P with such weak constraints is as follows: First, compute the answer sets of the program P ′ given as P without the weak constraints. Then, count for each answer set S of P the number of the grounded weak constraints which apply to S. By “apply to S”, we mean that given a ground weak constraint of the form (17) {c1, . . . , cm} ⊆ S and {dm+1, . . . , dp} ∩ S jointly hold. The answer sets of P are then given by those answer sets P ′ which have a minimal number of applied weak constraints.\nRecall that for representing revision problems, we use belief profiles of the form 〈P1, P2〉. We already have computed all models and SE models of both programs. We now have to (i) find those pairs (M1,M2) of models M1 ∈ Mod(P1), M2 ∈ Mod(P2) which have a minimum number of differences, and (ii) find those pairs (S1, S2) of SE models S1 ∈ Mod(S1), S2 ∈ Mod(P2) which are minimal with respect to the order < defined in Definition 3. After isolating the respective answer sets we then can find the SE models of P1 ∗c P2 (following Definition 11) quite straightforwardly. Indeed, Task (i) can easily be achieved by making use of weak constraints which penalise each mismatch, and a similar method is possible for Task (ii). However, Definition 3 requires a certain two-phased comparison of SE models. We thus count a mismatch in the h-models as many times as we have differences in the t and c-models, respectively. Finally, if there was no difference in the t- or c-models, we still have to count the number of mismatches in the h-models. This is done by the third rule in the following program.\nDEFINITION 20.\nπcard = {⇐ diff (1, 2, A,M), prog model(M),\n⇐ diff (1, 2, A, h), diff (1, 2, B,M),\n⇐ diff (1, 2, A, h),∼diff (1, 2, B,M), dom(B), prog model(M),\nselector (2) ←}.\nWe finally put things together. To this end, we first define a module which takes the models and SE models, respectively, of some selected program (in the case of revision, it is program P2, thus selector (2) is specified in πcard ) and copies them into a designated predicate.\nDEFINITION 21.\nπresult = {total ← ∼nontotal ,\nnontotal ← ∼total ,\n← nontotal , selector(S), in(S,A, t), out(S,A, c),\n← nontotal , selector(S), out(S,A, t), in(S,A, c),\nresultH (A) ← selector (S), in(S,A, h),nontotal ,\nresultH (A) ← selector (S), in(S,A, c), total ,\nresultT (A) ← selector(S), in(S,A, c)}.\nThe intuition for the module is as follows: we either generate a total SE model (Y, Y ) or a non-total SE model (X,Y ) with X ⊆ Y . Thus, the guess between predicates total and nontotal . In case we want to derive a non-total SE model (X,Y ), we have to make sure\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nthat Y coincides with the classical model we guessed.8 This is done by the two constraints. The remaining lines fill the predicates resultH and resultT accordingly, where atoms in resultH yield the X of the SE model and atoms in resultT yield the Y of the SE model.\nWe formulate our first main result.\nTHEOREM 14. For any set S of non-ground atoms, let\nρ(S) = ({a | resultH (a) ∈ S}, {b | resultT (b) ∈ S})."
    }, {
      "heading" : "Moreover, let",
      "text" : "Pcard = πdomain ∪ πmodels ∪ πresult ∪ πcard\nand Ψ = 〈P1, P2〉 a belief profile. Then,\nSE (P1 ∗c P2) = {ρ(S) | S ∈ AS (Pcard [Ψ])}.\n5.2.2 Set-based Revision. We continue with set-based revision. Unfortunately, the encodings now become more cumbersome, since we cannot make use of weak constraints anymore (which implicitly compared different models and SE models). Instead, we have to use a certain saturation technique (also called spoiling), which is quite common to encode problems from the second level of the polynomial hierarchy [Eiter and Gottlob 1995; Eiter and Polleres 2006]. Let us first look at the two main modules for revision πwitness and πincl : πwitness guesses a witness and contains the so-called “spoiling rules” (explained below); this module is also used later in the encodings for merging. πincl contains the specific conditions for spoiling in terms the revision operator. Two predicates used in πincl , violated and samediff all , will be explained in detail later.\nIntuitively, the module πwitness works as follows. For each interpretation guessed in πmodels we now guess possible witnesses via predicates win and wout . Note that this guess (see Rule (18) below) is done via disjunction. This allows us to treat wrong guesses for witnesses via saturation (rather than via constraints as we did in πmodels). In fact, such wrong guesses will be indicated via the predicate spoil (πincl will provide us with rules which derive spoil ). Finally, if all such guesses for witnesses are violating some properties, we know that our initial guess (via in and out ) meets the expected criteria, and the constraint ← ∼spoil guarantees that only those initial guesses are contained in the answer sets of our encodings. Let us look at this concept in more detail.\nDEFINITION 22.\nπwitness = {win(P,A,M) ; wout(P,A,M) ← prog(P ), dom(A),model (M), (18)\nwdiff (P,Q,A,M) ← win(P,A,M),wout(Q,A,M), (19)\nwdiff (P,Q,A,M) ← wout(P,A,M),win(Q,A,M), (20)\nwsame(P,Q,A,M) ← win(P,A,M),win(Q,A,M), (21)\nwsame(P,Q,A,M) ← wout(P,A,M),wout(Q,A,M), (22)\nnotsubseteq(M, I, J) ← same(P,Q,A,M),wdiff (P,Q,A,M), (23)\nwin(P,A,M) ← spoil , prog(P ), dom(A),model (M), (24)\n8One might ask why we use the different concepts of t- and c-models. The reason is that there might be a minimal difference between (X1, Y1) and (X2, Y2) although there is no minimal difference between Y1 and Y2. But then we still need those interpretations Y in order to compute the corresponding interpretations X. On the other hand, there might be a minimal distance between Y1 and Y2 but not between any (X1, Y1) and (X2, Y2). Still, we then want (Y2, Y2) in the result.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nwout(P,A,M) ← spoil , prog(P ), dom(A),model (M), (25)\n← ∼spoil}. (26)\nAs mentioned before, Rule (18) formulates the disjunctive guess for witnesses (referred to as “wguess” in the following) and Rules (19)–(22) provide us with some auxiliary predicates in exactly the same spirit as Rules (6)–(9) from πmodels . Rule (23) indicates that the wguess cannot be in a certain subset relation to the initial guess.\nLet us illustrate this for the case of revision and suppose the initial guess (via in and out) talks about models M1 of P1 and M2 of P2 and the wguess (via win and wout ) talks about models N1 of P1 and N2 of P2. In case N1 ⊖ N2 6⊆ M1 ⊖M2, we derive here notsubseteq(1, 2, c).\nBefore discussing Rules (24)–(26), let us now turn to the specific conditions under which predicate spoil is derived:\nDEFINITION 23.\nπincl = {spoil ← win(P,A, h),wout(P,A, t), (27)\nspoil ← violated(P,R,M), (28)\nspoilcond(M) ← notsubseteq(M, 1, 2), prog model(M), (29)\nspoilcond(c) ← samediff all (c), (30)\nspoilcond(t) ← notsubseteq(h, 1, 2), samediff all (t), (31)\nspoilcond(t) ← samediff all (h), samediff all(t), (32)\nspoil ← spoilcond(c), spoilcond (t), (33)\nselector(2) ←}. (34)\nRule (27) mirrors Rule (5) from πmodels in order to obtain valid SE interpretations. Rule (28) checks whether some wguess does not satisfy some rule (predicate violated is defined in program πviolation below). Both rules derive predicate spoil .\nLet us for the moment return to Rules (24) and (25), which derive all possible win and wout predicates in case spoil was derived. Thus, in other words, a wguess which violates some property has to carry to predicate spoil , but in case spoil is derived all possible win and wout predicates have to be derived, hence all these wguesses lead to a single answer-set candidate I containing all win and wout predicates (the in and out predicates remain unchanged, however, and thus still characterise an initial guess G). In the end, we want that to check whether each wguess violates some property (i.e., carries the spoil predicate). To guarantee that this is the case, Rule (26) finally kills such interpretations, where a wguess would have been valid. Now, due to the minimality of the answer set semantics, if such a wguess existed (for an initial guess G), then the set I (containing the same initial guess) cannot become an answer set, and this initial guess has to be withdrawn. In turn, if no wguess without the spoil predicate is left (for an initial guess G), then the saturated interpretation I for this initial guess becomes an answer set.\nSo far, we just have eliminated wguesses which violate the concept of being models and SE models of the given belief profile, respectively. We now have to take the conditions of Definition 8 into account. To this end, we derive spoil for wguesses which are not in the desired relation to the initial guess. Let us first look into the classical models and suppose the initial guess (via in and out) makes reference about models M1 of P1 and M2 of P2 and the wguess (via win and wout ) refers to models N1 of P1 and N2 of P2. In case\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nN1⊖N2 6⊆M1⊖M2, we already observed that we obtain notsubseteq(1, 2, c) and we have one reason to spoil this wguess (cf. Rule (29)). The same holds for N1 ⊖N2 =M1 ⊖M2 (this is done by Rule (30); for the definition of predicate samediff all , see below). A second reason to spoil is if also the initial guess for the SE models S1 = (X1, Y1) of P1 and S2 = (X2, Y2) of P2 is in a certain relation to the SE model S′1 = (X ′ 1, Y ′ 1) of P1 and S′2 = (X ′ 2, Y ′ 2) of P2 which are given by the wguess. In accordance to Definition 2, we first have to compare the there-parts. Thus, if Y ′1 ⊖Y ′ 2 6⊆ Y1⊖Y2, we already have a reason to spoil (again, taken care of by Rule (29)). If Y ′1 ⊖ Y ′ 2 = Y1 ⊖ Y2, we are not allowed to spoil yet, but have to look into the here-parts. Now, we spoil if X ′1 ⊖X ′ 2 6⊆ X1 ⊖X2 (Rule (31)) or if X ′1 ⊖X ′ 2 = X1 ⊖X2 (Rule (32)). If both reasons for spoil are fulfilled, we finally derive spoil by Rule (33). Finally, rule selector(2) ← plays the same role as in πcard and triggers the πresult module.\nIt remains to define the predicates violated and samediff all . One particular problem is that the employed saturation technique allows only for a restricted use of negation. Therefore, we have to re-implement concepts in a different way. In fact, predicates samediff all and violated are obtained via additional predicates which loop over all atoms (we now require the concepts defined in module πorder ).\nLet us have a closer look on the definition of the violated predicate, which derives violated(P,R,M) if the rule R of program P is violated by the current wguess (either in terms of c-, t-, or h-models, as explained earlier). The main idea is to loop over all domain elements. To this end, we first check whether the current guess potentially violates the rule R if we just look at an atom A. For instance, if we consider a rule a ← b, and a is in the guess, then this guess cannot violate the rule; the same holds if b is not in the guess. In general, these conditions are formulated by the unsat predicate defined below. Next, we loop over all atoms, and in case we can violate the rule if we take all domain elements B into account (violupto(P,R,B,M)), and A is the next element and also allows for violation, we derive violupto(P,R,A,M). rule R is violated by the wguess.\nDEFINITION 24.\nπviolation = {unsat(P,R,A,M) ← win(P,A,M),∼phead (P,R,A),\n∼nbody(P,R,A), prog rule(P,R),\nprog model(M),\nunsat(P,R,A,M) ← wout(P,A,M),∼pbody(P,R,A),\n∼nhead(P,R,A), prog rule(P,R),\nprog model(M),\nunsat(P,R,A, h) ← wout(P,A, h),win(P,A, t),∼pbody(P,R,A),\n∼nbody(P,R,A), prog rule(P,R),\nunsat(P,R,A, h) ← wout(P,A, h),wout(P,A, t),∼pbody(P,R,A),\n∼nhead(P,R,A), prog rule(P,R),\nviolupto(P,R,A,M) ← inf (A), unsat(P,R,A,M),\nviolupto(P,R,A,M) ← succ(B,A), violupto(P,R,B,M),\nunsat(P,R,A,M),\nviolated(P,R,M) ← sup(A), violupto(P,R,A,M)}.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nThe test for equality follows a similar idea. In fact, what we want to do here is, given two sequences of models, 〈Mα, . . . ,Mn〉 and 〈Nα, . . . , Nn〉, to check whether Mi ⊖Mj = Ni ⊖ Nj for all α ≤ i < j ≤ n. The first five rules in the module below do this for any pair of indices i, j. By transitivity of =, it is then sufficient to simply loop over all indices and check whether the above test holds for all i, j such that α ≤ i < n and j = i+ 1.\nDEFINITION 25.\nπeq = {samediff atom(I, J, A,M) ← same(I, J, A,M),wsame(I, J, A,M),\nsamediff atom(I, J, A,M) ← diff (I, J, A,M),wdiff (I, J, A,M),\nsamediff upto atom(I, J, A,M) ← inf (A), samediff atom(I, J, A,M),\nsamediff upto atom(I, J, A,M) ← succ(B,A), samediff atom(I, J, A,M),\nsamediff upto atom(I, J,B,M),\nsamediff (I, J,M) ← sup(A), samediff upto atom(I, J, A,M),\nsamediff upto prog(I,M) ← minprog(I),\nsamediff upto prog(I,M) ← I = J + 1, samediff (I, J,M),\nsamediff upto prog(J,M),\nsamediff all (M) ← samediff upto prog(I,M),maxprog(I)}.\nWe have the following result.\nTHEOREM 15. Let Ψ = 〈P1, P2〉 a belief profile and define\nPincl = πdomain ∪ πmodels ∪ πorder ∪ πresult ∪ πwitness ∪ πincl ∪ πviolation ∪ πeq .\nThen,\nSE (P1 ∗ P2) = {ρ(S) | S ∈ AS(Pincl [Ψ])},\nwhere ρ is defined as in Theorem 14."
    }, {
      "heading" : "5.3 Encodings for Merging",
      "text" : "5.3.1 Basic Merging. We continue with the problem of basic merging. We now suppose that belief profiles Ψ = 〈P0, . . . , Pn〉 with an arbitrary number of programs are given. Also recall that P0 plays a special role in basic merging. In particular, the SE models of the result of the merging are taken from the SE models of P0.\nIn view of the general definition of the previous modules, we do not need to add any further concepts and just define the spoiling conditions:\nDEFINITION 26.\nπbasic = {spoil ← win(P,A, h),wout(P,A, t),\nspoil ← violated(P,R,M),\nspoilcond(M) ← notsubseteq(M, 0, J), prog model(M),\nspoilcond(c) ← samediff all (c),\nspoilcond(t) ← notsubseteq(h, 0, J), samediff all (t),\nspoilcond(t) ← samediff all (h), samediff all(t),\nspoil ← spoilcond(c), spoilcond (t),\nselector(0) ←, prog(0) ←}.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nNote that we specified selector(0) to select the program from which πresult takes the models and SE models to define the results, respectively. Also note the fact prog(0) which is necessary in case P0 is the empty program.\nWe have the following result:\nTHEOREM 16. Let Ψ = 〈P0, . . . , Pn〉 a belief profile and define\nPbasic = πdomain ∪ πmodels ∪ πorder ∪ πresult ∪ πwitness ∪ πviolation ∪ πeq ∪ πbasic .\nThen,\nSE (∆(Ψ)) = {ρ(S) | S ∈ AS(Pbasic [Ψ])},\nwhere ρ is defined as in Theorem 14.\n5.3.2 Arbitration Merging. Our final encoding is the one for arbitration merging. The spoiling module πarbitration given next is very much in the style of πbasic and πincl . However, we need a somewhat more complicated module to prepare the resultH and resultT predicates, since arbitration merging collects SE models from all programs of the belief profile rather than from a single program (which was the case in the approaches we encoded so far). We thus do not use a selector predicate here but instead provide a new result module below. Also recall that belief profiles for arbitration merging are of the form 〈P1, . . . , Pn〉. In fact, the only main difference between πbasic and πarbitration is to check that our guess is minimal in a global sense (i.e., the models vary in a minimal way among each other, cf. Definition 12) while in the case of basic merging the minimality has been guaranteed between the designated program P0 and the other programs (cf. Definition 14). This particular difference is reflected by the usage of predicate notsubseteq(·, I, J) compared to notsubseteq(·, 0, J) as used in πbasic .\nDEFINITION 27.\nπarbitration = {spoil ← win(P,A, h),wout(P,A, t),\nspoil ← violated (P,R,A,M),\nspoilcond (M) ← notsubseteq(M, I, J), prog model(M),\nspoilcond (c) ← samediff all(c),\nspoilcond (t) ← notsubseteq(h, I, J), samediff all(t),\nspoilcond (t) ← samediff all(h), samediff all (t),\nspoil ← spoilcond (c), spoilcond(t),\nwin(P,A,M) ← spoil , prog(P ), dom(A),model (M),\nwout(P,A,M) ← spoil , prog(P ), dom(A),model (M),\n← ∼spoil}.\nHere is the new result module:\nDEFINITION 28.\nπ′result = {tout(I); tout(J) ← prog(I), prog(J), I 6= J,\ntselect(I) ← ∼tout(I), prog(I),\ntotal ← ∼nontotal ,\nnontotal ← ∼total ,\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nresultT (A) ← in(M,A, c), tselect(M),\nresultH (A) ← in(M,A, c), total , tselect(M),\nhout(I); hout(J) ← prog(I), prog(J), I 6= J,nontotal ,\nhselect(I) ← ∼hout(I), prog(I),nontotal ,\n← nontotal , in(I, A, t), out(J,A, c), tselect(J), hselect(I),nontotal ,\n← nontotal , out(I, A, t), in(J,A, c), tselect(J), hselect(I),nontotal ,\nresultH (A) ← in(I, A, h), hselect(I),nontotal}.\nRoughly speaking, the first two rules select exactly one program Pi from the belief profile. We then guess whether we build a total or a non-total SE model (as we did in πresult ). Then, we copy the model from the guessed program into the there-part of the result, and in case we are constructing a total SE model, also in the here-part. If we construct a non-total SE model, we guess a second program Pj from the belief profile and check whether the there-part of the current SE model of Pj coincides with the classical model of Pi (this is done by the two constraints). If this check is passed, we copy the here-part of the SE model of Pj into the here-part of the resulting SE model.\nWe arrive at our final result:\nTHEOREM 17. Let Ψ = 〈P1, . . . , Pn〉 a belief profile and define\nParbitration = πdomain ∪ πmodels ∪ πorder ∪ π ′ result ∪\nπwitness ∪ πviolation ∪ πeq ∪ πarbitration .\nThen,\nSE (∇(Ψ)) = {ρ(S) | S ∈ AS(Pincl [Ψ])},\nwhere ρ is defined as in Theorem 14.\nAll encodings presented here can be downloaded under the following URL:\nhttp://www.cs.uni-potsdam.de/˜torsten/"
    }, {
      "heading" : "6. DISCUSSION",
      "text" : "We have addressed the problem of belief change in logic programming under the answer set semantics. Our overall approach is based on a monotonic characterisation of logic programs, given in terms of the set of SE models of a program. Based on the latter, we first defined and examined operators for logic program expansion and revision. Both subsetbased revision and cardinality-based revision were considered. As well as giving properties of these operators, we also considered their complexity. This work is novel, in that it addresses belief change in terms familiar to researchers in belief revision: expansion is characterised in terms of intersections of models, and revision is characterised in terms of minimal distance between models.\nWe also addressed the problem of merging logic programs under the answer set semantics. Again, the approaches are based on a monotonic characterisation of logic programs, given in terms of the set of SE models of a sequence of programs. We defined and examined two operators for logic program merging, the first following intuitions from arbitration [Liberatore and Schaerf 1998], the second being closer to IC merging [Konieczny and Pino Pérez 2002]. Notably, since these merging operators are defined via a semantic\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\ncharacterisation, the results of merging are independent of the particular syntactic expression of a logic program. As well as giving properties of these operators, we also considered complexity questions. Last, we provided encodings for both program revision and program merging.\nWe note that previous work on logic program belief change was formulated at the level of the individual program, and not in terms of an abstract characterisation (via strong equivalence or sets of SE interpretations). The net result is that such previous work is generally difficult to work with: properties are difficult to come by, and often desirable properties (such as the tautology property) are lacking. The main point of departure for the current approach then is to lift the problem of logic program revision or merging from the program (or syntactic) level to an abstract (or semantic) level."
    }, {
      "heading" : "A. APPENDIX",
      "text" : ""
    }, {
      "heading" : "A.1 Proof of Theorem 1",
      "text" : "Most of the parts follow immediately from the fact that SE (P +Q) = SE (P ) ∩ SE (Q).\n(1) We need to show that Definition 6 results in a well-defined set of SE models. For SE (P ) ∩ SE (Q) = ∅ we have that ∅ is trivially well-defined (and R can be given by ⊥ ←). Otherwise, for SE (P ) ∩ SE (Q) 6= ∅, we have the following: If (X,Y ) ∈ SE (P ) ∩ SE (Q), then (X,Y ) ∈ SE (P ) and (X,Y ) ∈ SE (Q); whence (Y, Y ) ∈ SE (P ) and (Y, Y ) ∈ SE (Q) since SE (P ) and SE (Q) are well-defined by virtue of P and Q being logic programs. Hence, (Y, Y ) ∈ SE (P ) ∩ SE (Q). Since this holds for arbitrary (X,Y ) ∈ SE (P ) ∩ SE (Q), we have that SE (P ) ∩ SE (Q) is well-defined.\n(2) Immediate from the definition of +. (3) If P |=s Q, then SE (P ) ⊆ SE (Q). Hence, SE (P )∩SE (Q) = SE (P ), or P +Q ≡s\nP . (4) Similar to the previous part. (5) This was established in the first part. (6) To show completeness, we need to show that for any (X,Y ) ∈ SE (P + Q) and\n(Y ∪ Y ′, Y ∪ Y ′) ∈ SE (P +Q) that (X,Y ∪ Y ′) ∈ SE (P +Q). If (X,Y ) ∈ SE (P + Q) and (Y ∪ Y ′, Y ∪ Y ′) ∈ SE (P + Q), then (X,Y ) ∈ SE (P )∩SE (Q) and (Y ∪Y ′, Y ∪Y ′) ∈ SE (P )∩SE (Q). Hence, (X,Y ) ∈ SE (P ) and (Y ∪ Y ′, Y ∪ Y ′) ∈ SE (P ), and so, since SE (P ) is complete by assumption, we have (X,Y ∪ Y ′) ∈ SE (P ). The same argument gives that (X,Y ∪Y ′) ∈ SE (Q), whence (X,Y ∪Y ′) ∈ SE (P )∩ SE (Q) and (X,Y ∪ Y ′) ∈ SE (P +Q).\n(7) If Q ≡s ∅, then SE (Q) = {(X,Y ) | X ⊆ Y ⊆ A} from which the result follows immediately. 2"
    }, {
      "heading" : "A.2 Proof of Theorem 2",
      "text" : "(RA1). This postulate follows immediately from Definition 8. Note that (X,Y ) ∈ SE (P ∗Q) only if Y ∈ σ(Mod(Q),Mod(P )), and therefore (Y, Y ) ∈ σ(SE (Q),SE (P )). So, SE (P ∗Q) is well-defined. (RA2). If P + Q is satisfiable, then we have that both σ(Mod(Q),Mod(P )) 6= ∅ and σ(SE (Q),SE (P )) 6= ∅. Further, for Y ∈ Mod(Q) (or (X,Y ) ∈ SE (Q)), there is\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nsome Y ′ ∈ Mod(P ) (resp., (X ′, Y ′) ∈ SE (P )) such that Y ⊖ Y ′ = ∅ (resp., (X,Y ) ⊖ (X ′, Y ′) = ∅), from which our result follows.\n(RA3). From Definition 8 we have that, if P is unsatisfiable, then Q is satisfiable iff P ∗Q is satisfiable.\nOtherwise, if P is satisfiable and Q is satisfiable, then there is some (Y, Y ) ∈ σ(Mod(Q),Mod(P )) (since SE (Q) is well-defined and given Definition 7). Hence, SE (P ∗Q) 6= ∅.\n(RA4). Immediate from Definition 8.\n(RA5). If SE (P ) = ∅, then the result follows immediately from the first part of Definition 8.\nOtherwise, we show that, if (X,Y ) is an SE model of (P ∗ Q) + R, then (X,Y ) is an SE model of P ∗ (Q+R).\nLet (X,Y ) ∈ SE ((P ∗ Q) + R). Then, (X,Y ) ∈ SE (P ∗ Q) and (X,Y ) ∈ SE (R). Since (X,Y ) ∈ SE (P ∗ Q), by (RA1) we have that (X,Y ) ∈ SE (Q), and so (X,Y ) ∈ SE (Q) ∩ SE (R), or (X,Y ) ∈ SE (Q+R).\nThere are two cases to consider: X = Y : Since then (X,Y ) = (Y, Y ), and (Y, Y ) ∈ SE (P ∗ Q), we have that Y ∈ σ(Mod(Q),Mod(P )). Hence, from Definition 7, Y ∈ Mod(Q) and there is some Y ′ ∈ Mod(P ) such that there is no Y1 ∈ Mod(Q) and no Y2 ∈ Mod(P ) such that Y1 ⊖ Y2 ⊂ Y ⊖ Y ′. We established at the outset that (X,Y ) ∈ SE (Q+R). Hence, Y ∈ Mod(Q+R). This gives us that Y ∈ Mod(Q + R) and there is some Y ′ ∈ Mod(P ) such that no Y1, Y2 exist with Y1 ∈ Mod(Q), Y2 ∈ Mod(P ), and Y1 ⊖ Y2 ⊂ Y ⊖ Y ′. Clearly, in the above, if there is no Y1 ∈ Mod(Q) such that the above condition holds, then there is no Y1 ∈ Mod(Q+R) such that the above condition holds. Thus, we have Y ∈ Mod(Q + R) and there is some Y ′ ∈ Mod(P ) for which no Y1 ∈ Mod(Q+R) and no Y2 ∈ Mod(P ) exists such that Y1 ⊖ Y2 ⊂ Y ⊖ Y ′. Thus, from Definition 7, we get Y ∈ σ(Mod(Q+R),Mod(P )), hence (Y, Y ) ∈ SE (P ∗ (Q+R)). X ⊂ Y : We have Y ∈ σ(Mod(Q),Mod(P )) by virtue of (X,Y ) ∈ SE (P ∗ Q). In the previous part we established that Y ∈ σ(Mod(Q+R),Mod(P )). As well, (X,Y ) ∈ σ(SE (Q),SE (P )) since (X,Y ) ∈ SE(P ∗Q). Thus, from Definition 7, we have that there is some (X ′, Y ′) ∈ SE (P ) such that noU, V, U ′, V ′ exist such that (U, V ) ∈ SE (Q), (U ′, V ′) ∈ SE (P ), and (U, V )⊖ (U ′, V ′) ⊂ (X,Y )⊖ (X ′, Y ′). Therefore, there is no (U, V ) ∈ SE (Q+R) and no (U ′, V ′) ∈ SE (P ) such that (U, V )⊖ (U ′, V ′) ⊂ (X,Y )⊖ (X ′, Y ′). We previously showed that (X,Y ) ∈ SE (Q+R). Consequently, from Definition 8, we obtain that (X,Y ) ∈ σ(SE (Q+R),SE (P )). Hence, (X,Y ) ∈ SE (P ∗ (Q+R)). Thus, in either case, we get (X,Y ) ∈ SE (P ∗ (Q+R)), which was to be shown. 2"
    }, {
      "heading" : "A.3 Proof of Theorem 3",
      "text" : "For initialisation, idempotency, and tautology, in the left-hand side of the given equivalence, revision corresponds with expansion via (RA2), from which the result is immediate.\nFor absorption, we have Q = R, and so ((P ∗ Q) ∗ R) = ((P ∗ Q) ∗ Q). Since SE (P ∗Q) ⊆ SE (Q), then from Theorem 1, Part 3, we have that (P ∗Q) +Q ≡s P ∗Q. As well, ((P ∗Q) ∗Q) = ((P ∗Q) +Q), from which our result follows. 2\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY."
    }, {
      "heading" : "A.4 Proof of Theorem 4",
      "text" : "We need to show that SE (P ∗ Q) ⊆ SE (P ∗w Q). If SE (P ) = ∅, then SE (P ∗ Q) = SE (Q) = SE (P ∗w Q).\nOtherwise, there are two cases to consider:\n(1) (X,Y ) ∈ SE (P ∗Q) where X ⊂ Y . Then, (X,Y ) ∈ σ(SE (P ),SE (Q)) by Definition 8, and (X,Y ) ∈ SE (P ∗w Q) by Definition 9. (2) (Y, Y ) ∈ SE (P ∗ Q). From Definition 8, we have that Y ∈ σ(Mod (Q),Mod(P )). Y ∈ σ(Mod(Q),Mod(P )) implies that (Y, Y ) ∈ σ(SE (Q),SE (P )). Hence, according to Definition 9, (Y, Y ) ∈ SE (P ∗w Q).\nTherefore, (X,Y ) ∈ SE (P ∗Q) implies that (X,Y ) ∈ SE (P ∗w Q), whence SE (P ∗ Q) ⊆ SE (P ∗w Q). 2"
    }, {
      "heading" : "A.5 Proof of Theorem 5",
      "text" : "Before giving the proof, we first present a lemma that is key for postulates (RA5) and (RA6).\nLEMMA 1. Let E1, E2, and E3 be SE interpretations. If σ||(E1, E2) ∩ E3 6= ∅, then σ||(E1, E2) ∩ E3 = σ||(E1 ∩ E3, E2).\nPROOF. Assume that σ||(E1, E2) ∩ E3 6= ∅. For showing ⊆ in the equality, let (X,Y ) ∈ σ||(E1, E2) ∩ E3 and, toward a contradiction, assume that (X,Y ) 6∈ σ||(E1 ∩ E3, E2). Since (X,Y ) ∈ σ||(E1, E2), so (X,Y ) ∈ E1; as well, (X,Y ) ∈ E3, so (X,Y ) ∈ E1 ∩ E3. Since (X,Y ) 6∈ σ||(E1 ∩ E3, E2) we have that there is some (X ′, Y ′) ∈ E1∩E3 and some (U ′, V ′) ∈ E2 such that for every (U, V ) ∈ E2, |(X ′, Y ′)⊖(U ′, V ′)| < |(X,Y )⊖ (U, V )|. But this contradicts the assumption that (X,Y ) ∈ σ||(E1, E2). Hence, the assumption that (X,Y ) 6∈ σ||(E1 ∩ E3, E2) cannot hold, i.e., (X,Y ) ∈ σ||(E1 ∩ E3, E2), establishing that σ||(E1, E2) ∩ E3 ⊆ σ||(E1 ∩ E3, E2).\nTo show ⊇ in the equality, let (X,Y ) ∈ σ||(E1 ∩ E3, E2) and, toward a contradiction, assume that (X,Y ) 6∈ σ||(E1, E2) ∩ E3.\nSince (X,Y ) ∈ σ||(E1 ∩ E3, E2), we get that (X,Y ) ∈ E3. Hence, (X,Y ) 6∈ σ||(E1, E2) (via the assumption that (X,Y ) 6∈ σ||(E1, E2) ∩ E3).\nWe also have by assumption that σ||(E1, E2) ∩ E3 6= ∅, and so let (X ′, Y ′) ∈ σ||(E1, E2)∩E3. Then, from the first part above, we have that (X,Y ) ∈ σ||(E1∩E3, E2). Thus, we have both that (X,Y ) ∈ σ||(E1 ∩ E3, E2) and (X ′, Y ′) ∈ σ||(E1 ∩ E3, E2). Consequently, we obtain that\nmin({|(X,Y )⊖ (U, V )| | (U, V ) ∈ E2}) = min({|(X ′, Y ′)⊖ (U, V )|(U, V ) ∈ E2}).\nTherefore, since (X ′, Y ′) ∈ σ||(E1, E2), so also (X,Y ) ∈ σ||(E1, E2). But this together with (X,Y ) ∈ E3 contradicts our assumption that (X,Y ) 6∈ σ||(E1, E2)∩E3; i.e., we have (X,Y ) ∈ σ||(E1, E2) ∩ E3, establishing that σ||(E1, E2) ∩ E3 ⊇ σ||(E1 ∩ E3, E2).\nWe now move on to the proof of Theorem 5:\n(RA1). This follows immediately from Definition 11. Note that (X,Y ) ∈ SE (P ∗cQ) only if Y ∈ σ||(Mod(Q),Mod(P )), and therefore (Y, Y ) ∈ σ||(SE (Q),SE (P )). So, SE (P ∗c Q) is well-defined.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\n(RA2). If P + Q is satisfiable, then we have that both σ||(Mod(Q),Mod(P )) 6= ∅ and σ||(SE (Q),SE (P )) 6= ∅. Further, for Y ∈ Mod(Q) (or (X,Y ) ∈ SE (Q)) we have that there is some Y ′ ∈ Mod(P ) (resp., (X ′, Y ′) ∈ SE (P )) such that Y ⊖ Y ′ = ∅ ((X,Y )⊖ (X ′, Y ′) = ∅), from which our result follows.\n(RA3). From Definition 11 we have that, if P is unsatisfiable, then Q is satisfiable iff P ∗ Q is satisfiable. Otherwise, if P is satisfiable and Q is satisfiable, then there is some (Y, Y ) ∈ σ||(Mod(Q),Mod(P )) (since SE (Q) is well-defined and given Definition 10). Hence, SE (P ∗Q) 6= ∅.\n(RA4). This is immediate from Definition 11.\n(RA5), (RA6). For P ∗c Q, if SE (P ) = ∅, we have that (P ∗c Q) + R = Q + R = (P ∗c (Q+R)).\nSo, assume that SE (P ) 6= ∅. We show that SE (P ∗cQ)+SE (R) = SE (P ∗c (Q+R)), thus establishing both postulates.\nFor ⊆, assume that (X,Y ) ∈ SE (P ∗c Q) + R. Thus, (X,Y ) ∈ SE (P ∗c Q) and (X,Y ) ∈ R.\nFor X ⊆ Y , we have that Y ∈ σ||(Mod(Q),Mod(P )) and as well Y ∈ Mod(R). We get that Y ∈ σ||(Mod(Q+R),Mod(P )) by the analogous proof in propositional logic for cardinality-based revision.\nFor X ⊂ Y , we have that (X,Y ) ∈ σ||(SE (Q),SE (P )) and as well (X,Y ) ∈ SE (R). By Lemma 1 we get that (X,Y ) ∈ σ||(SE (Q+R),SE (P )).\nThis establishes one direction of the set equality. For ⊇, the argument is essentially the same, though in the reverse direction, and again appealing to Lemma 1."
    }, {
      "heading" : "A.6 Proof of Theorem 6",
      "text" : "The proof is the same as for Theorem 3."
    }, {
      "heading" : "A.7 Proof of Theorem 7",
      "text" : "Since we deal with a globally fixed language, we first need a few lemmata.\nLEMMA 2. Let P,Q be programs, Y an interpretation, and x ∈ Y \\var(P ∪Q). Then, Y ∈ σ(Mod(Q),Mod(P )) implies Y \\ {x} ∈ σ(Mod (Q),Mod(P )).\nPROOF. Since Y ∈ σ(Mod(Q),Mod(P )), so Y ∈ Mod(Q) and there exists some Z ∈ Mod(P ) such that for each Y ′ ∈ Mod(Q) and Z ′ ∈ Mod(P ), Y ′ ⊖ Z ′ 6⊂ Y ⊖ Z . We show that x ∈ Z holds. Suppose this is not the case: Then, we have x ∈ Y ⊖ Z , since x ∈ Y . Now, since x /∈ var (P ), also Z ∪ {x} ∈ Mod(P ). But then x /∈ Y ⊖ (Z ∪ {x}) which yields Y ⊖ (Z ∪ {x}) ⊂ Y ⊖ Z , a contradiction to our assumption. Hence, we can suppose x ∈ Z . Now, since Y ∈ Mod(Q), obviously Y \\ {x} ∈ Mod(Q) as well. We obtain Y ⊖Z = (Y \\ {x})⊖ (Z \\ {x}), thus Y \\ {x} ∈ σ(Mod (Q),Mod(P )) holds.\nLEMMA 3. Let P,Q be programs, (X,Y ) an SE interpretation, and x ∈ Y \\ var (P ∪ Q). Then, (X,Y ) ∈ σ(SE (Q),SE (P )) implies (X \\{x}, Y \\{x}) ∈ σ(SE (Q),SE (P )).\nPROOF. Since (X,Y ) ∈ σ(SE (Q),SE (P )), (X,Y ) ∈ SE (Q) and there exists a (U,Z) ∈ SE (P ) such that for each (X ′, Y ′) ∈ SE (Q) and each (U ′, Z ′) ∈ SE (P ), (X ′, Y ′) ⊖ (U ′, Z ′) 6⊂ (X,Y ) ⊖ (U,Z). We show that the following relations hold: (i) x ∈ Z; and (ii) x ∈ U iff x ∈ X . Towards a contradiction, first suppose x /∈ Z . Then, we have x ∈ Y ⊖ Z , since x ∈ Y . Now, since x /∈ var (P ), also (U,Z ∪ {x}) ∈ SE (P )\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nand (U ∪ {x}, Z ∪ {x}) ∈ SE (P ). We have x /∈ Y ⊖ (Z ∪ {x}) which yields Y ⊖(Z∪{x}) ⊂ Y ⊖Z . Thus, (X,Y )⊖(U,Z∪{x}) ⊂ (X,Y )⊖(U,Z), which is a contradiction to the assumption. Hence, x ∈ Z holds. If (ii) does not hold, we get x ∈ X⊖U . Now, in case x ∈ X and x /∈ U , we have (X,Y ) ⊖ (U ∪ {x}, Z) ⊂ (X,Y ) ⊖ (U,Z). In case x ∈ U and x /∈ X , we have (X,Y ) ⊖ (U \\ {x}, Z) ⊂ (X,Y ) ⊖ (U,Z). Again, both cases yield a contradiction. Clearly, (X,Y ) ∈ SE (Q) implies (X \\ {x}, Y \\ {x}) ∈ SE (Q) and we obtain (X,Y ) ⊖ (U,Z) = (X \\ {x}, Y \\ {x}) ⊖ (U \\ {x}, Z \\ {x}). (X \\ {x}, Y \\ {x}) ∈ σ(SE (Q),SE (P )) thus follows.\nLEMMA 4. For any programs P , Q, and R, P ∗ Q 6|=s R iff there exist X ⊆ Y ⊆ var (P ∪Q ∪R) such that (X,Y ) ∈ SE (P ∗Q) and (X,Y ) /∈ SE (R).\nPROOF. The if-direction is by definition. As for the only-if direction, assume P ∗ Q 6|=s R. Then, there exists a pair (X,Y ) such that (X,Y ) ∈ SE (P ∗ Q) and (X,Y ) /∈ SE (R). Let V = var (P ∪ Q ∪ R). We first show that (X ∩ V, Y ∩ Y ) ∈ SE (P ∗ Q). By definition, (X,Y ) ∈ SE (Q). If SE (P ) = ∅, SE (P ∗ Q) = SE (Q), and since (X,Y ) ∈ SE (Q) obviously implies (X∩V, Y ∩Y ) ∈ SE (Q), (X∩V, Y ∩Y ) ∈ SE (P∗Q) thus follows in this case. So suppose SE (P ) 6= ∅. Then, Y ∈ σ(Mod (Q),Mod(P )). By iteratively applying Lemma 2, we obtain that also Y ∩ V ∈ σ(Mod(Q),Mod(P )). Analogously using Lemma 3, (X,Y ) ∈ σ(SE (Q),SE (P )) yields (X ∩ V, Y ∩ V ) ∈ σ(SE (Q),SE (P )). By Definition 8, we get (X ∩ V, Y ∩ V ) ∈ SE (P ∗ Q). Finally, it is clear that (X,Y ) /∈ SE (R), implies that (X ∩ V, Y ∩ V ) /∈ SE (R).\nWe now proceed with the proof of Theorem 7. We first show membership in ΣP2 for the complementary problem. From Lemma 4, the complementary problem holds iff there exist X,Y ⊆ var (P ∪Q∪R) such that (X,Y ) ∈ SE (P ∗ Q) and (X,Y ) /∈ SE (R). In what follows, let V = var(P ∪ Q ∪ R). We first state the following observation: Recall that Y ∈ σ(Mod(Q),Mod(P )) iff Y ∈ Mod(Q) and there exists a W ∈ Mod(P ) such that W ⊆ V and for each Y ′ ∈ Mod(Q) and W ′ ∈ Mod(P ), Y ′ ⊖ W ′ 6⊂ Y ⊖ W . Now, if Y ⊆ V , then there is also a W ⊆ V satisfying above test (this is seen by the arguments used in the proof of Lemma 2). A similar observation holds for (X,Y ) ∈ σ(SE (Q),SE (P )).\nThus an algorithm to decide P ∗ Q 6|=s R is as follows. We guess interpretations X,Y,W,U, Z ⊆ V and start with checking (X,Y ) ∈ SE (Q) and (X,Y ) /∈ SE (R). Then, we check whether SE (P ) = ∅ which can be done via a single call to an NPoracle. If the answer is yes, we already have found an SE interpretation (X,Y ) such that (X,Y ) ∈ SE (P ∗Q) and (X,Y ) /∈ SE (R) and thus the complementary problem holds. If the answer is no, we next check whether (U,Z) ∈ SE (P ) and W ∈ Mod(P ). Then, (i) given Y and W , we check whether for each Y ′ ⊆ V and each W ′ ⊆ V such that Y ′ ∈ Mod(Q) and W ′ ∈ Mod(P ), Y ′ ⊖ W ′ 6⊂ Y ⊖ W holds. It is easy to see that then the same relation holds for arbitrary models Y ′ and W ′. From that we can conclude that Y ∈ σ(Mod (Q),Mod(P )). Next, (ii) given (X,Y ) and (U,Z), we check whether for each X ′ ⊆ Y ′ ⊆ V and each U ′ ⊆ Z ′ ⊆ V such that (X ′, Y ′) ∈ SE (Q) and (U ′,W ′) ∈ SE (P ), (X ′, Y ′)⊖ (U ′,W ′) 6⊂ (X,Y )⊖ (U,W ). Again, it is easy to see that in this case (X,Y ) ∈ σ(SE (Q),SE (P )) follows. But then we obtain (X,Y ) ∈ SE (P ∗Q) by Definition 8 which together with (X,Y ) /∈ SE (R) solves the complementary problem in view of Lemma 4.\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nWe recall that model checking as well as SE model checking are in P. So most of the checks used above are in P (expect the already mentioned call to an NP-oracle) and it remains to settle the complexity of the checks (i) and (ii). As well, they can be done by an NP-oracle. This can be seen by considering the respective complementary problems, where one guesses the sets Y ′,W ′ (resp., X ′, Y ′, U ′, Z ′) and then performs model checking or SE model checking together with some other simple tests which are all in P. Thus, the overall algorithm runs in nondeterministic polynomial time with access to an NP-oracle. This shows the ΣP2 -membership as desired.\nAs for the hardness-part, we use a reduction from the problem of checking whether a given quantified Boolean formula of form Φ = ∀Y ∃Xϕ, where ϕ is a propositional formula in conjunctive normal form over atoms X ∪ Y , evaluates to true, which is ΠP2 - complete. For Φ as described, let, for each z ∈ X ∪ Y , z′ be a new atom. Additionally, for each clause c = z1 ∨ · · · ∨ zk ∨ ¬zk+1 ∨ · · · ∨ ¬zm in ϕ, let ĉ be the sequence z′1, . . . , z ′ k, zk+1, . . . , zm. Finally, let w be a further new atom and V = X ∪Y ∪{z\n′ | z ∈ X ∪ Y } ∪ {w}. We define the following programs: PΦ = {v ←| v ∈ V }, RΦ = {w ←}, and\nQΦ = {y ← ∼y ′; y′ ← ∼y; ⊥ ← y, y′ | y ∈ Y } ∪\n{x← ∼x′, w; x′ ← ∼x,w; w ← x; w ← x′;\n⊥ ← x, x′ | x ∈ X} ∪\n{⊥ ← ĉ, w | c a clause in ϕ}.\nThe SE models over V of these programs are as follows (for a set Z of atoms, Z ′ stands for {z′ | z ∈ Z}):\nSE (PΦ) = {(V, V )}; SE (QΦ) = {(S, S) | S = I ∪ (Y \\ I) ′, I ⊆ Y } ∪\n{(S, T ), (T, T ) | S = I ∪ (Y \\ I)′,\nT = {w} ∪ S ∪ J ∪ (X \\ J)′,\nI ⊆ Y, J ⊆ X, I ∪ J |= ϕ};\nSE (RΦ) = {(W1,W2) | {w} ⊆W1 ⊆W2 ⊆ V }.\nWe show that Φ is true iff PΦ ∗QΦ |=s RΦ holds.\nOnly-if direction: Suppose PΦ∗QΦ |=s RΦ does not hold. By Lemma 4, there exist S ⊆ T ⊆ var (PΦ ∪QΦ ∪RΦ) = V such that (S, T ) ∈ SE (PΦ ∗QΦ) and (S, T ) /∈ SE (RΦ). Inspecting the SE models of RΦ, we obtain that w /∈ S. From (S, T ) ∈ SE (PΦ ∗ QΦ), (S, T ) ∈ SE(QΦ), and thus S has to be of the form I ∪ (Y \\ I)′ for some I ⊆ Y . Recall that (V, V ) is the only SE model of PΦ over V . Hence, S = T holds, since otherwise (T, T )⊖ (V, V ) ⊂ (S, T )⊖ (V, V ), which is in contradiction to (S, T ) ∈ SE (PΦ ∗QΦ). Now we observe that for each U with S = T ⊂ U ⊆ V , (U,U) /∈ SE (QΦ) has to hold, (otherwise (U,U) ⊖ (V, V ) ⊂ (S, S) ⊖ (V, V )). Inspecting the SE models of SE (QΦ), this only holds if, for each J ⊆ X , I ∪ J 6|= ϕ. But then Φ is false.\nIf direction: Suppose Φ is false. Then, there exists an I ⊆ Y such that for all J ⊆ X , I ∪ J 6|= ϕ. We know that (S, S) = (I ∪ (Y \\ I)′, I ∪ (Y \\ I)′) ∈ SE (QΦ) and (V, V ) ∈ SE (PΦ). Next, to obtain (S, S) ∈ SE (PΦ ∗QΦ), we show S ∈ σ(Mod(QΦ),Mod(PΦ)). Suppose this is not the case. Since S ⊂ V and V is the minimal model of PΦ, there has\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nto exist an U with S ⊂ U ⊆ V such that U ∈ Mod(QΦ). Recall that S = I ∪ (Y \\ I)′ and, by assumption, for all J ⊆ X , I ∪ J 6|= ϕ. By inspecting the SE models of QΦ, it is clear that no such U ∈ Mod(QΦ) exists. By essentially the same arguments, (S, S) ∈ σ(SE (QΦ),SE (PΦ)) can be shown. Therefore, (S, S) ∈ SE (PΦ ∗QΦ) and since w /∈ S, PΦ ∗QΦ |=s RΦ does not hold.\nThis shows ΠP2 -hardness for normal programs Q. The result for positive programs Q is obtained by replacing in QΦ rules y ← ∼y′, y′ ← ∼y by y; y′ ←, and likewise rules x ← ∼x′, w and x′ ← ∼x,w by x;x′ ← w. Due to the presence of the constraints ⊥ ← y, y′ and ⊥ ← x, x′, this modification does not change the SE models of these programs."
    }, {
      "heading" : "A.8 Proof of Theorem 9",
      "text" : "The definitions for arbitration and basic merging (Definitions 13 and 15) are essentially composed of two parts (as are the definitions for revision): there is a phrase to deal with classical propositional models (or SE models of form (Y, Y )) and then general SE models. For brevity, and because the case for propositional models follows immediately from the case of general SE models, we consider general SE models in the proofs here.\n(LS1′) – (LS7′). These all follow trivially or straightforwardly from the definition of P1 ⋄ P2. (LS8′). Assume that P1 and P2 are satisfiable. It follows that SE (〈P1, P2〉) 6= ∅ and so Mina(SE (〈P1, P2〉)) 6= ∅. Let 〈S1, S2〉 ∈ Mina(SE (〈P1, P2〉)), and so S1, S2 ∈ SE (P1 ⋄ P2). Since S1 ∈ SE (P1) we get that S1 ∈ SE (P1) ∩ SE (P1 ⋄ P2) and so S1 ∈ SE (P1 ⊓ (P1 ⋄ P2)). Thus, P1 ⊓ (P1 ⋄ P2) is satisfiable."
    }, {
      "heading" : "A.9 Proof of Theorem 10",
      "text" : "Let Ψ be a belief profile, P0 a program representing global constraints, and ∆ as given in Definition 15. Then, ∆ satisfies the following versions of the postulates of Definition 5:\n(IC0′) – (IC3′), (IC9′). These follow trivially or straightforwardly from the definition of ∆(〈P0,Ψ〉). (IC4′). Assume that P1 |=s P0 and P2 |=s P0. If SE (P1) ∩ SE (P2) 6= ∅ then by (IC2′) we have that ∆(〈P0, P1, P2〉) = P0 ⊓ P1 ⊓ P2 from which our result follows immediately.\nConsequently, assume that SE (P1) ∩ SE (P2) = ∅. As well, assume the antecedent condition of the postulate that ∆(〈P0, P1, P2〉) ⊓ P1 is satisfiable. Let Ψ = 〈P0, P1, P2〉. Thus, we have for some (X,Y ) that (X,Y ) ∈ SE (∆(Ψ)⊓P1), and so (X,Y ) ∈ SE (P0)∩ SE (P1), where (X,Y ) ∈ Minb(SE (Ψ))0. (X,Y ) ∈ Minb(SE (Ψ))0 implies that there is some (X ′, Y ′) ∈ SE (P2) such that S = 〈(X,Y ), (X,Y ), (X ′, Y ′)〉 ∈ Minb(SE (Ψ)).\nWe claim that S ′ = 〈(X ′, Y ′), (X,Y ), (X ′, Y ′)〉 ∈ Minb(SE (Ψ)). This is sufficient to prove our result, since S ′ ∈ Minb(SE (Ψ)) yields that (X ′, Y ′) ∈ ∆(Ψ) and (X ′, Y ′) ∈ SE (P2), that is to say, ∆(Ψ) ⊓ P2 is satisfiable. Proof of claim: Since S ∈ Minb(SE (Ψ)), this means that for every T ∈ SE (Ψ) we have that T ≤b S implies that S ≤b T . Consider T = 〈(U0, V0), (U1, V1), (U2, V2)〉. If T ≤b S then we have that (U0, V0) ⊖ (U1, V1) ⊆ (X,Y ) ⊖ (X,Y ) = (∅, ∅). That is, U0 = U1 and V0 = V1, and so T =\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\n〈(U0, V0), (U0, V0), (U2, V2)〉. As well, from T ≤b S, we get that (U0, V0) ⊖ (U2, V2) ⊆ (X,Y )⊖ (X ′, Y ′). Since T ≤b S implies S ≤b T , this means that (X,Y )⊖ (X ′, Y ′) ⊆ (U0, V0)⊖ (U2, V2).\nWe will use this later, and so summarise the result here: (α) (X,Y ) and (X ′, Y ′) are such that for every (U0, V0) ∈ SE (P1) and (U2, V2) ∈\nSE (P2) if (U0, V0) ⊖ (U2, V2) ⊆ (X,Y ) ⊖ (X ′, Y ′) then (X,Y ) ⊖ (X ′, Y ′) ⊆ (U0, V0)⊖ (U2, V2).\nWe must show for S ′ = 〈(X ′, Y ′), (X,Y ), (X ′, Y ′)〉, that T ≤b S ′ implies S ′ ≤b T . Let T = 〈(U ′0, V ′ 0), (U ′ 1, V ′ 1), (U ′ 2, V ′ 2)〉 and assume that T ≤b S ′ . Then, by definition of ≤b, we have that (U ′0, V ′ 0) ⊖ (U ′ 1, V ′ 1) ⊆ (X\n′, Y ′) ⊖ (X,Y ). As well, we have that (U ′0, V ′ 0) ⊖ (U ′ 2, V ′ 2) ⊆ (X ′, Y ′) ⊖ (X ′, Y ′) = (∅, ∅). Hence, we must have that U ′0 = U ′ 2 and V ′0 = V ′ 2 . Thus, we can write T = 〈(U ′ 0, V ′ 0), (U ′ 1, V ′ 1), (U ′ 0, V ′ 0)〉.\nNow, we will have S ′ ≤b T just if (X ′, Y ′) ⊖ (X,Y ) ⊆ (U ′0, V ′ 0) ⊖ (U ′ 1, V ′ 1) and\n(X ′, Y ′) ⊖ (X ′, Y ′) ⊆ (U ′0, V ′ 0) ⊖ (U ′ 2, V ′ 2). The second condition is vacuously true. As for the first condition, we have that (U ′0, V ′ 0) ∈ SE (P2) and (U ′ 1, V ′ 1) ∈ SE (P1). Thus, via (α), we obtain that (X ′, Y ′)⊖ (X,Y ) ⊆ (U ′1, V ′ 1)⊖ (U ′ 0, V ′ 0). We conclude that S ′ ≤b T .\nThis shows that S ′ ∈ Minb(SE (Ψ)), where (X ′, Y ′) ∈ SE (P0) and (X ′, Y ′) ∈\nSE (P2). Consequently, SE (∆(〈P0, P1, P2〉) ⊓ P2) is satisfiable.\n(IC5′). Consider (X,Y ) ∈ SE (∆(〈P0,Ψ〉) ⊓ ∆(〈P0,Ψ′〉)), and so (X,Y ) ∈ SE (∆(〈P0,Ψ〉)) and (X,Y ) ∈ SE (∆(〈P0,Ψ′〉)). Thus, (X,Y ) ∈ Minb(SE (〈P0,Ψ〉)) and (X,Y ) ∈ Minb(SE (〈P0,Ψ′〉)). Hence, there is some 〈(X,Y ), S〉 ∈ SE (〈P0,Ψ〉) and some 〈(X,Y ), S ′ 〉 ∈ SE (〈P0,Ψ′〉) such that 〈(X,Y ), S〉 ≤b T for every T ∈ SE (〈P0,Ψ〉) and 〈(X,Y ), S ′ 〉 ≤b T ′ for every T ′ ∈ SE (〈P0,Ψ′〉). But this implies that 〈(X,Y ), S, S ′ 〉 ≤b 〈(X,Y ), T ′′ 〉 for every T ′′ ∈ SE (〈P0,Ψ,Ψ′〉). Consequently, (X,Y ) ∈ SE (∆(〈P0,Ψ ◦Ψ′〉)).\n(IC7′). If ∆(〈P0,Ψ〉) ⊓ P1 is unsatisfiable then the result is immediate. So, assume that ∆(〈P0,Ψ〉)⊓P1 is satisfiable, and let (X,Y ) ∈ SE (∆(〈P0,Ψ〉)⊓P1). That is, (X,Y ) ∈ SE (∆(〈P0,Ψ〉)) and (X,Y ) ∈ SE (P1). By definition we have that (X,Y ) ∈ Minb(SE (〈P0,Ψ〉))0. Clearly, since (X,Y ) ∈ SE (P1) we also obtain that (X,Y ) ∈ Minb(SE (〈P0∩P1,Ψ〉))0, from which we get (X,Y ) ∈ SE (∆(〈P0⊓P1,Ψ〉))."
    }, {
      "heading" : "A.10 Proof of Theorem 11",
      "text" : "We first prove a helpful lemma.\nLEMMA 5. Let Ψ be a belief profile. If X ∈ Mina(SE (Ψ)) then for Xi ∈ X we have 〈Xi, X〉 ∈ Minb(SE (〈∅,Ψ〉)).\nPROOF. Let Ψ be a belief profile, and let X ∈ Mina(SE (Ψ)). Hence, for every Y ∈ SE (Ψ) we have that Y ≤a X implies X ≤a Y . Now, Y ≤a X means that Yi ⊖ Yj ⊆ Xi ⊖Xj for every 1 ≤ i, j ≤ |Ψ|.\nSo, for fixed i we have that Yi ⊖ Yj ⊆ Xi ⊖ Xj implies that Xi ⊖ Xj ⊆ Yi ⊖ Yj . Let X0 = Xi for that i. Thus, substituting we get that Yi ⊖ Yj ⊆ X0 ⊖ Xj implies that X0 ⊖Xj ⊆ Yi ⊖ Yj .\nBut this means that 〈X0, X〉 ∈ Minb(SE (〈∅,Ψ〉)).\nFor the proof of the theorem, we have:\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nLet X ∈ SE (∇(Ψ)). Then, X ∈ ⋃\nMina(SE (Ψ)); that is, there is some X such that X ∈ X and X ∈ Mina(SE (Ψ)). But by Lemma 5 we then have that 〈X,X〉 ∈ Minb(SE (〈∅,Ψ〉)). Hence, X ∈ Minb(SE (〈∅,Ψ〉)0) and so X ∈ SE (∆(〈∅,Ψ〉))."
    }, {
      "heading" : "A.11 Proof of Theorem 12",
      "text" : "These results follow directly from the appropriate definitions."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2009,
    "abstractText" : "We address the problem of belief change in (nonmonotonic) logic programming under answer set semantics. Unlike previous approaches to belief change in logic programming, our formal techniques are analogous to those of distance-based belief revision in propositional logic. In developing our results, we build upon the model theory of logic programs furnished by SE models. Since SE models provide a formal, monotonic characterisation of logic programs, we can adapt techniques from the area of belief revision to belief change in logic programs. We first consider belief revision: given logic programs P and Q, the goal is to determine a program R that corresponds to the revision of P by Q, denoted P ∗ Q. We investigate several specific operators, including (logic program) expansion and two revision operators based on the distance between the SE models of logic programs. It proves to be the case that expansion is an interesting operator in its own right, unlike in classical AGM-style belief revision where it is relatively uninteresting. Expansion and revision are shown to satisfy a suite of interesting properties; in particular, our revision operators satisfy the majority of the AGM postulates for revision. Second, we consider approaches for merging logic programs. Given logic programs P1, . . . , Pn, the goal is to provide characterisations of the merging of these programs. Again, our formal techniques are based on notions of relative distance between the underlying SE models of the logic programs. Two approaches are examined. The first informally selects those models of the programs that vary the least from the models of the other programs. The second approach informally selects those models of a program P0 that are closest to the models of programs P1, . . . , Pn. In this case, P0 can be thought of as analogous to a set of database integrity constraints. We examine properties of these operators with regards to how they satisfy relevant postulate sets. We also present encodings for computing the revision as well as the merging of logic programs within the same logic programming framework, giving rise to a direct implementation of our approach in terms of off-the-shelf answer set solvers. These encodings reflect in turn the fact that our change operators do not increase the complexity of the base formalism.",
    "creator" : "dvips(k) 5.95a Copyright 2005 Radical Eye Software"
  }
}