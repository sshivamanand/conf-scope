{
  "name" : "1103.4558.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Representing First-Order Causal Theories by Logic Programs",
    "authors" : [ "Paolo Ferraris", "Joohyung Lee", "Yuliya Lierler", "Fangkai Yang" ],
    "emails" : [ "otto@cs.utexas.edu)", "joolee@asu.edu)", "yuliya@cs.utexas.edu)", "vl@cs.utexas.edu)", "fkyang@cs.utexas.edu)" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\na basis for the semantics of several expressive action languages. McCain’s embedding of definite propositional causal theories into logic programming paved the way to the use of answer set solvers for answering queries about actions described in such languages. In this paper we extend this embedding to nondefinite theories and to first-order causal logic.\nKEYWORDS: reasoning about actions, nonmonotonic causal logic, answer set programming"
    }, {
      "heading" : "1 Introduction",
      "text" : "Propositional nonmonotonic causal logic (McCain and Turner 1997) and its generalizations became a basis for the semantics of several expressive action languages (Giunchiglia and Lifschitz 1998; Giunchiglia et al. 2004; Lifschitz and Ren 2006; Lifschitz and Ren 2007; Ren 2009). The Causal Calculator (CCalc)1 is a partial\n1 http://www.cs.utexas.edu/users/tag/ccalc/\nimplementation of this logic that allows us to automate some kinds of reasoning and planning in action domains described in such languages. It has been used to solve several challenging commonsense reasoning problems, including problems of nontrivial size (Akman et al. 2004), to provide a group of robots with high-level reasoning (Caldiran et al. 2009), to give executable specifications of norm-governed computational societies (Artikis et al. 2009), and to automate the analysis of business processes under authorization constraints (Armando et al. 2009).\nAn important theorem due to Norman McCain (McCain 1997, Proposition 6.7) shows how to embed a fragment of propositional causal logic into the language of logic programming under the answer set semantics (Gelfond and Lifschitz 1991). This result, reviewed below, paved the way to the development of an attractive alternative to CCalc—the software system coala (Gebser et al. 2010) that uses answer set programming (Marek and Truszczyński 1999; Niemelä 1999; Lifschitz 2008) for answering queries about actions described in causal logic.\nA causal theory in the sense of (McCain and Turner 1997) is a set of “causal rules” of the form F ⇐ G, where F and G are propositional formulas (the head and the body of the rule). The rule reads “F is caused if G is true.” Distinguishing between being true and having a cause turned out to be essential for the study of commonsense reasoning. The assertion “if the light is on at time 0 and you toggle the switch then the light will be off at time 1” can be written as an implication:\non0 ∧ toggle → ¬on1·\nIn causal logic, on the other hand, we can express that under the same assumption there is a cause for the light to be off at time 1:\n¬on1 ⇐ on0 ∧ toggle·\n(Performing the toggle action is the cause.) McCain and Turner showed that distinctions like this help us solve the frame problem (see Example 5 in Section 5.2) and overcome other difficulties arising in the theory of reasoning about actions.\nThe semantics of theories of this kind defines when a propositional interpretation (truth assignment) is a model of the given theory (is “causally explained” by the theory, in the terminology of McCain and Turner). We do not reproduce the definition here, because a more general semantics is described below in Section 3. But here is an example: the causal theory\np ⇐ ¬q\n¬q ⇐ p (1)\nhas one model, according to the semantics from (McCain and Turner 1997). In this model, p is true and q is false. (Since the bodies of both rules are true in this model, both rules “fire”; consequently the heads of the rules are “caused”; consequently the truth values of both atoms are “causally explained.” This will be discussed formally in Section 3.)\nMcCain’s translation is applicable to a propositional causal theory T if the head\nof each rule of T is a literal, and the body is a conjunction of literals:\nL ⇐ A1 ∧ · · · ∧ Am ∧ ¬Am+1 ∧ · · · ¬An · (2)\nThe corresponding logic program consists of the logic programming rules\nL ← not ¬A1, . . . , not ¬Am , not Am+1, . . . , not An (3)\nfor all rules (2) of T . This program involves two kinds of negation: negation as failure (not) and strong, or classical, negation (¬). According to Proposition 6.7 from (McCain 1997), complete answer sets of this logic program are identical to the models of T . (A set of literals is complete if it contains exactly one member of each complementary pair of literals A,¬A. We identify a complete set of literals with the corresponding truth assignment.)\nFor instance, McCain’s translation turns causal theory (1) into\np ← not q\n¬q ← not ¬p· (4)\nThe only answer set of this program is {p,¬q}. It is complete, and it corresponds to the model of causal theory (1).\nIn this paper we generalize McCain’s translation in several ways. First, we discard the requirement that the bodies of the given causal rules be conjunctions of literals. Second, instead of requiring that the head of each causal rule be a literal, we allow the heads to be disjunctions of literals. In this more general setting, the logic program corresponding to the given causal theory becomes disjunctive as well.\nThird, we study causal rules with heads of the form L1 ↔ L2, where L1 and L2 are literals. Such a rule says that there is a cause for L1 and L2 to be equivalent (“synonymous”) under some condition, expressed by the body of the rule. Synonymity rules play an important role in the theory of commonsense reasoning in view of the fact that humans often explain the meaning of words by referring to their synonyms. A synonymity rule\nL1 ↔ L2 ⇐ G (5)\ncan be translated into logic programming by rewriting it as the pair of rules\nL1 ∨ L2 ⇐ G L1 ∨ L2 ⇐ G\n(L stands for the literal complementary to L) and then using our extension of McCain’s translation to rules with disjunctive heads. It turns out, however, that there is no need to use disjunctive logic programs in the case of synonymity rules. If, for instance, G in (5) is a literal then the following group of nondisjunctive rules will do:\nL1 ← L2, not G L2 ← L1, not G L1 ← L2, not G L2 ← L1, not G ·\nFinally, we extend the translation from propositional causal rules to first-order causal rules in the sense of (Lifschitz 1997). This version of causal logic is useful for defining the semantics of variables in action descriptions (Lifschitz and Ren 2007).\nAs part of motivation for our approach to transforming causal theories into logic\nprograms, we start with a few additional comments on McCain’s translation (Section 2). After reviewing the semantics of causal theories and logic programs in Sections 3 and 4, we describe four kinds of causal rules that we are interested in and show how to turn a theory consisting of such rules into a logic program (Section 5). This translation is related to answer set programming in Section 6, and its soundness is proved in Section 7.\nPreliminary reports on this work are published in (Ferraris 2006; Ferraris 2007; Lee et al. 2010; Lifschitz and Yang 2010). Some results appear here for the first time, including the soundness of a representation of a synonymity rule with variables by a nondisjunctive logic program."
    }, {
      "heading" : "2 McCain’s Translation Revisited",
      "text" : ""
    }, {
      "heading" : "2.1 Incorporating Constraints",
      "text" : "In causal logic, a constraint is a rule with the head ⊥ (falsity). McCain’s translation can be easily extended to constraints with a conjunction of literals in the body— causal rules of the form\n⊥ ⇐ A1 ∧ · · · ∧ Am ∧ ¬Am+1 ∧ · · · ∧ ¬An · (6)\nIn the language of logic programming, (6) can be represented by a rule similar to (3):\n⊥ ← not ¬A1, . . . , not ¬Am , not Am+1, . . . , not An · (7)\nFurthermore, each of the combinations not ¬ in (7) can be dropped without destroying the validity of the translation; that is to say, the rule\n⊥ ← A1, . . . ,Am , not Am+1, . . . , not An (8)\ncan be used instead of (7)."
    }, {
      "heading" : "2.2 Eliminating Strong Negation",
      "text" : "As observed in (Gelfond and Lifschitz 1991), strong negation can be eliminated from a logic program in favor of additional atoms. Denote the new atom representing a negative literal ¬A by Â. Then (3) will become\nA0 ← not Â1, . . . , not Âm , not Am+1, . . . , not An (9)\nif L is a positive literal A0, and\nÂ0 ← not Â1, . . . , not Âm , not Am+1, . . . , not An (10)\nif L is a negative literal ¬A0. The modified McCain translation of a causal theory T consisting of rules of the forms (2) and (6) includes\n• rules (8) corresponding to the constraints (6) of T , • rules (9), (10) corresponding to the other rules of T , and\n• the completeness constraints\n← A, Â ← not A, not Â (11)\nfor all atoms A.\nFor instance, the modified McCain translation of (1) is\np ← not q q̂ ← not p̂\n← p, p̂ ← not p, not p̂ ← q, q̂ ← not q, not q̂ ·\n(12)\nThe only answer set (stable model2) of this program is {p, q̂}.\nThis modification is useful to us in view of the fact that eliminating strong negation in favor of aditional atoms is part of the definition of a stable model proposed in (Ferraris et al. 2011, Section 8)."
    }, {
      "heading" : "2.3 Rules as Formulas",
      "text" : "The definition of a stable model for propositional formulas given in (Ferraris 2005) and the definition of a stable model for first-order sentences proposed in (Ferraris et al. 2011) become generalizations of the original definition (Gelfond and Lifschitz 1988) when we rewrite rules as logical formulas. For instance, rules (9) and (10), rewritten as propositional formulas, become\n¬Â1 ∧ · · · ∧ ¬Âm ∧ ¬Am+1 ∧ · · · ∧ ¬An → A0 (13)\nand\n¬Â1 ∧ · · · ∧ ¬Âm ∧ ¬Am+1 ∧ · · · ∧ ¬An → Â0· (14)\nRule (8) can be identified with the formula\nA1 ∧ · · · ∧Am ∧ ¬Am+1 ∧ . . . ∧ ¬An → ⊥ (15)\nor, alternatively, with\n¬(A1 ∧ · · · ∧ Am ∧ ¬Am+1 ∧ . . . ∧ ¬An)· (16)\nThe completeness constraints for an atom A turn into the formulas\n¬(A ∧ Â) ¬(¬A ∧ ¬Â)· (17)\n2 The term “stable model” was introduced in (Gelfond and Lifschitz 1988) to describe the meaning of logic programs with negation as failure but without strong negation. When the stable model semantics was extended to programs with strong negation in (Gelfond and Lifschitz 1991), the term “answer set” was proposed as a replacement.\nHere is program (12) rewritten in the syntax of propositional logic:\n¬q → p ¬p̂ → q̂ ¬(p ∧ p̂) ¬(¬p ∧ ¬p̂) ¬(q ∧ q̂) ¬(¬q ∧ ¬q̂)·\n(18)\nNote that the process of rewriting a rule as a formula is applicable only when the rule does not contain strong negation; the symbol ¬ in the resulting formula corresponds to the negation as failure symbol (not) in the rule.\nOne of the advantages of writing rules as formulas is that it allows us to relate properties of stable models to subsystems of classical logic. We know, for instance, that if the equivalence of two sentences can be proved in intuitionistic logic (or even in the stronger logic of here-and-there) then these sentences have the same stable models (Ferraris et al. 2011, Theorem 5). This fact will be used here many times."
    }, {
      "heading" : "2.4 Translating Arbitrary Definite Theories",
      "text" : "The requirement, in the definition of McCain’s translation, that the bodies of all causal rules should be conjunctions of literals can be lifted by slightly modifying the translation process. Take any set T of causal rules of the forms\nA ⇐ G, (19)\n¬A ⇐ G, (20)\n⊥ ⇐ G, (21)\nwhere A is an atom and G is an arbitrary propositional formula (rules of these forms are called definite). For each rule (19), take the formula ¬¬G → A; for each rule (20), the formula ¬¬G → Â; for each rule (21), the formula ¬G. Then add completeness constraints (17) for all atoms A. Answer sets of this collection of propositional formulas correspond to the models of T .\nIn application to example (1), this modification of McCain’s translation gives\n¬¬¬q → p ¬¬p → q̂ ¬(p ∧ p̂) ¬(¬p ∧ ¬p̂) ¬(q ∧ q̂) ¬(¬q ∧ ¬q̂)·\n(22)\nIt is not surprising that (22) has the same answer set as (18): the two collections of formulas are intuitionistically equivalent to each other.3\n3 Indeed, ¬¬¬q is intuitionistically equivalent to ¬q ; the equivalence between ¬¬p and ¬p̂ is intuitionistically entailed by the formulas ¬(p ∧ p̂) and ¬(¬p ∧ ¬p̂), which belong both to (18) and to (22)."
    }, {
      "heading" : "3 Review: First-Order Causal Theories",
      "text" : "According to (Lifschitz 1997), a first-order causal theory T is defined by\n• a list p of distinct predicate constants,4 called the explainable symbols of T ,5\nand\n• a finite set of causal rules of the form F ⇐ G, where F and G are first-order\nformulas.\nThe semantics of first-order causal theories can be described as follows. For each p ∈ p, choose a new predicate variable υp of the same arity, and let υp stand for the list of all these variables. By T †(υp) we denote the conjunction of the formulas\n∀x(G → Fp υp ) (23)\nfor all rules F ⇐ G of T , where x is the list of all free variables of F , G. (The expression Fp υp denotes the result of substituting the variables υp for the corresponding constants p in F .)\nWe view T as shorthand for the sentence\n∀υp(T †(υp) ↔ (υp = p))· (24)\n(By υp = p we denote the conjunction of the formulas ∀x(υp(x) ↔ p(x)) for all p ∈ p, where x is a tuple of distinct object variables.) Accordingly, by a model of T we understand a model of (24) in the sense of classical logic. The models of T are characterized, informally speaking, by the fact that the interpretation of the explainable symbols p in the model is the only interpretation of these symbols that is “causally explained” by the rules of T .\nIn the definite case (see Section 2.4) second-order formula (24) can be replaced by an equivalent first-order formula using a process similar to Clark’s completion (Clark 1978), called literal completion (McCain and Turner 1997), (Lifschitz 1997, Section 5). This process is used in the operation of CCalc.\nExample 1. Let T be causal theory (1) with both p and q explainable. Then T †(υp, υq) is\n(¬q → υp) ∧ (p → ¬υq)\n(υp, υq are propositional variables), so that T is understood as shorthand for the second-order propositional formula (“QBF”)\n∀(υp)(υq)((¬q → υp) ∧ (p → ¬υq) ↔ (υp ↔ p) ∧ (υq ↔ q))· (25)\nThis formula is equivalent to p ∧ ¬q.6\n4 We view propositional symbols as predicate constants of arity 0, so that they are allowed in p. Equality, on the other hand, may not be declared explainable. 5 To be precise, the definition in (Lifschitz 1997) is more general: object and function constants can be treated as explainable as well. 6 This fact can be verified by replacing the universal quantifier in (25) with the conjunction of the four propositional formulas obtained by substituting all possible combinations of values for the variables υp, υq , and simplifying the result. Alternatively, one can apply literal completion to rules (1) and simplify the result.\nExample 2. Let T be the causal theory consisting of two rules:\np(a) ⇐ ⊤\n(here ⊤ is the logical constant true) and\n¬p(x ) ⇐ ¬p(x ),\nwith the explainable symbol p. The first rule says that there is a cause for a to have property p. The second rule says that if an object does not have property p then there is a cause for that; including this rule in a causal theory has, informally speaking, the same effect as saying that p is false by default (Lifschitz 1997, Section 3). In this case, T †(υp) is\nυp(a) ∧ ∀x (¬p(x ) → ¬υp(x )),\nso that T is understood as shorthand for the sentence\n∀υp(υp(a) ∧ ∀x (¬p(x ) → ¬υp(x )) ↔ ∀x (υp(x ) ↔ p(x )))·\nThis sentence is equivalent to the first-order formula\n∀x (p(x ) ↔ x = a), (26)\nas can be verified by applying literal completion to the rules of T ."
    }, {
      "heading" : "4 Review: Stable Models",
      "text" : "Some details of the definition of a stable model proposed in (Ferraris et al. 2011) depend on which propositional connectives are treated as primitives, and which are viewed as abbreviations. The convention there is to take the 0-place connective ⊥ and the binary connectives ∧, ∨, → as primitives; ¬F is shorthand for F → ⊥.\nIn this paper we adopt the view that first-order formulas are formed using a\nslightly larger set of propositional connectives:\n⊤, ⊥, ¬, ∧, ∨, →\n(as well as the quantifiers ∀, ∃). On the other hand, stable models are only defined here for sentences of a special syntactic form. A first-order sentence is a rule7 if it has the form ∀̃(F → G) and has no occurrences of → other than the one explicitly shown.8 If a sentence F does not contain implication then we will identify it with the rule ⊤ → F . For instance, propositional formulas (13)–(18) are rules. A logic program is a conjunction of rules. The definition of a stable model below is more limited than the definition from (Ferraris et al. 2011) because it is only applicable to programs, not to arbitrary sentences. For instance, it does not cover the formulas (p → q) → r and (p → q) ∨ r . On the other hand, it is simpler than the general definition, and it is sufficient for our present purposes.\n7 Or program rule, to distinguish it from causal rules in the sense of Section 3. 8 ∀̃F stands for the universal closure of F .\nWe need the following notation from (Lifschitz 1994). If p and q are predicate\nconstants of the same arity then p ≤ q stands for the formula\n∀x(p(x) → q(x)),\nwhere x is a tuple of distinct object variables. If p and q are tuples p1, . . . , pn and q1, . . . , qn of predicate constants then p ≤ q stands for the conjunction\n(p1 ≤ q1) ∧ · · · ∧ (pn ≤ qn),\nand p < q stands for (p ≤ q)∧¬(q ≤ p). In second-order logic, we apply the same notation to tuples of predicate variables.\nLet p be a list of distinct predicate constants; members of p will be called intensional predicates.9 For each p ∈ p, choose a predicate variable υp of the same arity, and let υp stand for the list of all these variables. For any logic program F , by SMp[F ] we denote the second-order sentence\nF ∧ ¬∃υp((υp < p) ∧ F ⋄(υp)), (27)\nwhere F ⋄(υp) is the formula obtained from F by replacing, for every p ∈ p, each occurrence of p that is not in the scope of negation with υp. A model of F is stable (relative to the set p of intensional predicates) if it satisfies SMp[F ]. 10\nExample 3. Let F be the propositional formula ¬p → q (the one-rule program q ← not p, in traditional notation). If both p and q are intensional then F ⋄(υp, υq) is\n¬p → υq,\nso that SMpq [F ] is\n(¬p → q) ∧ ¬∃(υp)(υq)(((υp, υq) < (p, q)) ∧ (¬p → υq))·\nThis formula is equivalent to ¬p ∧ q.11 Consequently F has one stable model: p is false and q is true.\nExample 4. Let F be the formula\n∀x (¬p(x ) → (q(x ) ∨ ¬q(x ))) (28)\n(it can be thought of as a formula representation of the lparse choice rule\n9 This list usually consists of all predicate symbols occurring in the heads of rules; those are the predicates that we “intend to characterize” by the rules of the program. The original definition of a stable model (Gelfond and Lifschitz 1988) treats all predicates as intensional. 10 We can make two comments about the relation of this treatment of stable models to earlier work. First, if we drop from the definition of SM the words “that is not in the scope of negation” then it will turn into the definition of parallel circumscription (McCarthy 1986; Lifschitz 1985). It follows that if a logic program does not contain negation then the class of its stable models is identical to the class of its minimal models. The stipulation in the description of F⋄(υp) that intensional predicates in the scope of negation are not replaced by variables is a reflection of the idea of negation as failure. Second, the operator of SM as defined in (Ferraris et al. 2011) produces, in application to a logic program, a second-order formula that is usually more complex than (27) but is equivalent to it. 11 Methods for simplifying the result of applying the operator SM are discussed in (Ferraris et al. 2011).\n{q(X)} :- not p(X)).12 If we take q to be the only intensional predicate then F ⋄(υq) is\n∀x (¬p(x ) → (υq(x ) ∨ ¬q(x )))·\nConsequently SMq [F ] is\n∀x (¬p(x ) → (q(x ) ∨ ¬q(x ))) ∧ ¬∃υq((υq < q) ∧ ∀x (¬p(x ) → (υq(x ) ∨ ¬q(x ))))·\nThe first conjunctive term here is logically valid and can be dropped. The second is equivalent to the first-order formula ¬∃x (p(x ) ∧ q(x )), which reflects the intuitive meaning of the choice rule above: q is an arbitrary set disjoint from p.\nThe relationship between the definition of a stable model given above and the\noperation of answer set solvers is discussed in Section 6.\nIf programs F and G are intuitionistically equivalent then SMp[F ] is equivalent to SMp[G], that is to say, F and G have the same stable models. Moreover, for establishing that F and G have the same stable models we only need to derive F ↔ G intuitionistically from the excluded middle formulas ∀̃(H ∨ ¬H ) for some formulas H that do not contain intensional predicates. This fact follows from (Ferraris et al. 2011, Theorem 5)."
    }, {
      "heading" : "5 Turning a Causal Theory into a Logic Program",
      "text" : ""
    }, {
      "heading" : "5.1 Four Types of Causal Rules",
      "text" : "In the rest of the paper, we assume that the bodies of causal rules do not contain implication. This is not an essential limitation, because in classical logic → can be expressed in terms of other connectives, and the meaning of a causal rule does not change if we replace its body (or head) by a classically equivalent formula.\nHere are four types of rules that we are going to consider, in the order of increasing\ncomplexity of their heads:\n• The head is ⊥, that is, the rule is a constraint. Such causal rules will be also\ncalled C-rules.\n• The head is a literal containing an explainable predicate symbol. These are\nL-rules.\n• The head has the form L1 ↔ L2, where each Li is a literal containing an\nexplainable predicate symbol. These are synonymity rules, or S-rules.\n• The head has the form L1 ∨ · · · ∨ Ln (n ≥ 0), where each Li is a literal\ncontaining an explainable predicate symbol. These are D-rules.\nAll C-rules and L-rules can be viewed also as D-rules, and any S-rule can be replaced with an equivalent pair of D-rules (see Lemma 11 in Section 7.2). Nevertheless, we give special attention here to rules of the first three types, and the reason is that our translation handles such rules in special ways. It appears that\n12 This rule would not be accepted by lparse, however, because it is “nonrestricted.” For a description of the language of lparse see http://www.tcs.hut.fi/Software/ smodels/lparse.ps.\ncausal rules of types C, L, and S will be more important than general D-rules in applications of this work to the automation of reasoning about actions.\nOn the other hand, the possibility of reducing types C, L, and S to type D plays an important role in the proof of the soundness of our translation (Section 7). This is one of the reasons why we are interested in general D-rules.\nThe requirement, in the definitions of types L, S and D, that the literals in the head of the rule contain explainable predicate symbols is not an essential limitation. If, for instance, the predicate symbol in the head of L ⇐ G is not explainable then this rule can be equivalently replaced by the C-rule ⊥ ⇐ G ∧ L. If a rule has the form\nL1 ↔ L2 ⇐ G\nand the predicate symbol in L1 is not explainable then the rule can be replaced by\nL2 ⇐ G ∧ L1, L2 ⇐ G ∧ L1·\nIf a rule has the form\nL1 ∨ · · · ∨ Ln ⇐ G\nand the predicate symbol in L1 is not explainable then the rule can be replaced by\nL2 ∨ · · · ∨ Ln ⇐ G ∧ L1·"
    }, {
      "heading" : "5.2 Translating C-Rules and L-Rules",
      "text" : "The transformation described in this section generalizes McCain’s translation, in the form described in Section 2.4, to first-order causal theories.\nThe operator Trc , which transforms any C-rule into a program rule, is defined\nby the formula\nTrc [⊥ ⇐ G] = ∀̃¬G·\nThe operator Trl , which transforms any L-rule into a program rule, is defined by\nthe formulas\nTrl [p(t) ⇐ G] = ∀̃(¬¬G → p(t)),\nTrl [¬p(t) ⇐ G] = ∀̃(¬¬G → p̂(t))\n(t is a tuple of terms).\nIf T is a causal theory consisting of C-rules and L-rules then its translation Tr[T ]\nis the logic program obtained by conjoining\n• the rules obtained by applying Trc to the C-rules of T , • the rules obtained by applying Trl to the L-rules of T , and • the completeness constraints\n∀x¬(p(x) ∧ p̂(x)), ∀x¬(¬p(x) ∧ ¬p̂(x)) (29)\n(x is a tuple of distinct object variables) for all explainable predicate symbols p of T .\nLet p be the list of explainable predicate symbols p of T , and let p̂ be the list of the corresponding predicate symbols p̂. Take the union of p and p̂ to be the set of intensional predicates. Then the stable models of the logic program Tr[T ] are “almost identical” to the models of T ; the difference is due to the fact that the language of T does not contain the symbols p̂. Let CC be the conjunction of all completeness constraints (29). Then the relationship between T and Tr[T ] can be described as follows:\nSMpp̂[Tr[T ]] is equivalent to T ∧CC · (30)\nThis claim, expressing the soundness of our translation, is extended in Sections 5.3 and 5.4 to causal theories containing S-rules and D-rules, and its proof is given in Section 7.\nSince the conjunction of formulas (29) is classically equivalent to\n∀x(p̂(x) ↔ ¬p(x)), (31)\nsentence CC can be viewed as the conjunction of explicit definitions of the predicates p̂ in terms of the predicates p. Consequently the relationship (30) shows that SMpp̂[Tr[T ]] is a definitional extension of T . The models of Tr[T ] that are stable relative to pp̂ can be characterized as the models of T extended by the interpretations of the predicates p̂ that are provided by definitions (31).\nExample 1, continued. If T is causal theory (1) with both p and q explainable then Tr[T ] is the conjunction of formulas (22). The result of applying the operator SMpqp̂q̂ to this conjunction is equivalent to\np ∧ ¬q ∧ ¬p̂ ∧ q̂·\nRecall that T is equivalent to the first half of this conjunction (Section 3). The second half tells us that the truth values of p̂, q̂ are opposite to the truth values of p, q. In the only stable model of (22), p and q̂ are true, and p̂ and q are false; if we “forget” the truth values of p̂ and q̂ then we will arrive at the model of (1).\nExample 2, continued. Our translation turns the causal theory from Example 2 into the conjunction of the rules\n¬¬⊤ → p(a), ∀x (¬¬¬p(x ) → p̂(x )), ∀x¬(p(x ) ∧ p̂(x )), ∀x¬(¬p(x ) ∧ ¬p̂(x )),\nor, after intuitionistically equivalent transformations,\np(a), ∀x (¬p(x ) → p̂(x )), ∀x¬(p(x ) ∧ p̂(x )), ∀x¬(¬p(x ) ∧ ¬p̂(x ))·\nThe result of applying SMpp̂ to the conjunction of these formulas is equivalent to the conjunction of (26) with the formula ∀x (p̂(x ) ↔ ¬p(x )), which says that p̂ is the complement of p.\nExample 5. Consider the following causal rules:\non1(x ) ⇐ toggle(x ) ∧ ¬on0(x ),\n¬on1(x ) ⇐ toggle(x ) ∧ on0(x ),\non1(x ) ⇐ on0(x ) ∧ on1(x ),\n¬on1(x ) ⇐ ¬on0(x ) ∧ ¬on1(x )·\n(32)\nThe first pair of rules describes the effect of toggling a switch x : this action causes the fluent on(x ) at time 1 to take the value opposite to its value at time 0. The second pair solves the frame problem (Shanahan 1997) for the fluent on(x ) by postulating that if the value of that fluent at time 1 is equal to its previous value then there is a cause for this. (Inertia, in the sense of commonsense reasoning, is the cause.) Let T be the causal theory with rules (32) and with on1 as the only explainable symbol. Using literal completion, we can check that T is equivalent to\n∀x (on1(x ) ↔ ((on0(x ) ∧ ¬toggle(x )) ∨ (¬on0(x ) ∧ toggle(x ))))· (33)\nOur translation turns T into the conjunction of the rules\n∀x (¬¬(toggle(x ) ∧ ¬on0(x )) → on1(x )), ∀x (¬¬(toggle(x ) ∧ on0(x )) → ôn1(x )), ∀x (¬¬(on0(x ) ∧ on1(x )) → on1(x )), ∀x (¬¬(¬on0(x ) ∧ ¬on1(x )) → ôn1(x )), ∀x¬(on1(x ) ∧ ôn1(x )), ∀x¬(¬on1(x ) ∧ ¬ôn1(x )),\n(34)\nor, equivalently,13\n∀x (toggle(x ) ∧ ¬on0(x ) → on1(x )), ∀x (toggle(x ) ∧ on0(x ) → ôn1(x )), ∀x (on0(x ) ∧ ¬ôn1(x ) → on1(x )), ∀x (¬on0(x ) ∧ ¬on1(x ) → ôn1(x )), ∀x¬(on1(x ) ∧ ôn1(x )), ∀x¬(¬on1(x ) ∧ ¬ôn1(x ))·\n(35)\nThe result of applying SMon1ôn1 to this program is equivalent to the conjunction of (33) with the formula ∀x (ôn1(x ) ↔ ¬on1(x )), which says that ôn1 is the complement of on1.\nExample 6. The constraint\n⊥ ⇐ toggle(badswitch)\nexpresses that badswitch is stuck: the action of toggling it is not executable. If we add this constraint to the causal theory from Example 5 then the rule\n¬toggle(badswitch)\n13 Removing the double negations in the first two lines of (34) is possible because neither toggle nor on0 is intensional (see the comment on equivalent transformations of logic programs at the end of Section 4). In a similar way, the antecedent of the third impication in (34) can be replaced by on0(x) ∧ ¬¬on1(x); the equivalence between ¬¬on1(x) and ¬ôn1(x) is intuitionistically entailed by the last two lines of (34). The fourth line of (34) is simplified in a similar way.\nwill be added to its translation (35).\nThe bodies of causal rules in Examples 5 and 6 are syntactically simple: they are conjunctions of literals. The general definitions of a C-rule and an L-rule do not impose any restrictions on the form of the body, and in applications of causal logic to formalizing commonsense knowledge this generality is often essential. For instance, the statement “each position must have at least one neighbor” in the landscape structure of the Zoo World14 would be represented in causal logic by a C-rule with a quantifier in the body."
    }, {
      "heading" : "5.3 Translating S-Rules",
      "text" : "We will turn now to translating synonymity rules (Section 5.1). The operator Trs , transforming any such rule into a logic program, is defined by the formulas\nTrs [p1(t 1) ↔ p2(t2) ⇐ G] = Trs [¬p1(t1) ↔ ¬p2(t2) ⇐ G]\n= ∀̃(¬¬G ∧ p1(t1) → p2(t2)) ∧ ∀̃(¬¬G ∧ p2(t2) → p1(t1))∧\n∀̃(¬¬G ∧ p̂1(t1) → p̂2(t2)) ∧ ∀̃(¬¬G ∧ p̂2(t2) → p̂1(t1)),\nTrs [¬p1(t1) ↔ p2(t2) ⇐ G] = Trs [p1(t1) ↔ ¬p2(t2) ⇐ G]\n= ∀̃(¬¬G ∧ p̂1(t1) → p2(t2)) ∧ ∀̃(¬¬G ∧ p2(t2) → p̂1(t1))∧\n∀̃(¬¬G ∧ p1(t1) → p̂2(t2)) ∧ ∀̃(¬¬G ∧ p̂2(t2) → p1(t1))\n(t1, t2 are tuples of terms). The definition of program Tr[T ] from Section 5.2 is extended to causal theories that may contain S-rules, besides C-rules and L-rules, by adding that Tr[T ] includes also\n• the rules obtained by applying Trs to the S-rules of T .\nExample 7. Extend the theory from Example 5 by the rule\ndark ↔ ¬on1(myswitch) ⇐ ⊤, (36)\nwhere dark is explainable. The corresponding logic program is obtained from (35) by adding the rules\nd̂ark → on1(myswitch), on1(myswitch) → d̂ark , dark → ôn1(myswitch), ôn1(myswitch) → dark , ¬(dark ∧ d̂ark ),\n¬(¬dark ∧ ¬d̂ark )·\n(37)\nWe will see that the soundness property (30) holds for arbitary causal theories\nconsisting of rules of types C, L, and S.\n14 The challenge of formalizing the Zoo World was proposed as part of the Logic Modelling Workshop (http:/www/ida.liu.se/ext/etai/lmw/). The possibility of addressing this challenge using CCalc is discussed in (Akman et al. 2004, Section 4)."
    }, {
      "heading" : "5.4 Translating D-Rules",
      "text" : "A D-rule (Section 5.1) has the form\n∨\nA∈Pos\nA ∨ ∨\nA∈Neg\n¬A ⇐ G (38)\nfor some sets Pos, Neg of atomic formulas.\nIf A is an atomic formula p(t), where p ∈ p and t is a tuple of terms, then by Â we will denote the formula p̂(t). The operator Trd transforms D-rule (38) into the program rule\n∀̃  ¬¬G ∧ ∧\nA∈Pos\n(Â ∨ ¬Â) ∧ ∧\nA∈Neg\n(A ∨ ¬A) → ∨\nA∈Pos\nA ∨ ∨\nA∈Neg\nÂ   · (39)\nExample 8. The result of applying Trd to the D-rule\np ∨ ¬q ∨ ¬r ⇐ s\nis\n¬¬s ∧ (p̂ ∨ ¬p̂) ∧ (q ∨ ¬q) ∧ (r ∨ ¬r) → p ∨ q̂ ∨ r̂ ·\nThe number of “excluded middle formulas” conjoined with ¬¬G in (39) equals the number of disjunctive terms in the head of D-rule (38). In particular, if (38) is an L-rule then the antecedent of (39) contains one such formula. For instance, in application to the first rule of (1) Trd produces the program rule\n¬¬¬q ∧ (p̂ ∨ ¬p̂) → p,\nwhich is more complex than the first rule of (22).\nFor a fixed collection p of explainable symbols, let C , L, S , and D be finite sets of causal rules of types C, L, S, and D respectively. By Tr[C ,L, S ,D ] we denote the logic program obtained by conjoining\n• the rules obtained by applying Trc to all rules from C , • the rules obtained by applying Trl to all rules from L, • the programs obtained by applying Trs to all rules from S , • the rules obtained by applying Trd to all rules from D , • the completeness constraints (29) for all explainable symbols p.\nOur most general form of the soundness theorem, proved in Section 7, asserts that\nSMpp̂[Tr[C ,L, S ,D ]] is equivalent to T ∧ CC (40)\nfor the causal theory T with the set of rules C∪L∪S∪D . In the special case when D is empty this theorem turns into the assertion stated at the end of Section 5.3."
    }, {
      "heading" : "6 Using Answer Set Solvers to Generate Models of a Causal Theory",
      "text" : "The discussion of answer set solvers in this section, as almost any discussion of software, is somewhat informal. We assume here that the first-order language under consideration does not contain function constants of nonzero arity.\nAn answer set solver can be viewed as a system for generating stable models in the sense of Section 4, with three caveats. First, currently available solvers require that the input program have a syntactic form that is much more restrictive than the syntax of first-order logic.15 Preprocessing based on intuitionistically equivalent transformations often helps us alleviate this difficulty. There exists a tool, called f2lp (Lee and Palla 2009), that converts first-order formulas of a rather general kind into logic programs accepted by lparse. The rules produced by the process described in the previous section have no existential quantifiers in their heads, and all quantifiers in their bodies are in the scope of negation. Consequently, these rules satisfy a syntactic condition that guarantees the correctness of the translation implemented in f2lp.\nSecond, answer set solvers represent stable models by sets of ground atoms. To introduce such a representation, we usually choose a finite set of object constants that includes all object constants occurring in the program, and restrict attention to Herbrand interpretations of the extended language. The #domain construct of lparse16 can be used to specify the object constants constituting the domain of the variables in the program.\nThird, most existing answer set solvers are unaware of the possibility of nonintensional (or extensional) predicates. Treating a predicate constant as extensional can be simulated using a choice rule (Ferraris et al. 2011, Theorem 2). There is also another approach to overcoming this limitation. Take a conjunction E of some ground atoms containing extensional predicates, and assume that we are interested in the Herbrand stable models of a program F that interpret the extensional predicates in accordance with E (every atom from E is true; all other atoms containing extensional predicates are false). Under some syntactic conditions,17 these stable models are identical to the Herbrand stable models of F ∧ E with all predicate constants treated as intensional. This can be proved using the splitting theorem from (Ferraris et al. 2009).\nExample 4, continued. We would like to find the stable models of (28), with q intensional, that have the universe {a, b, c, d} and make p true on a, b and false on c, d . This is the same as to look for the Herbrand stable models of the formula\n∀x (¬p(x ) → (q(x ) ∨ ¬q(x ))) ∧ p(a) ∧ p(b),\nwith c and d viewed as object constants of the language along with a and b, and with both p and q taken to be intensional.\n15 They also require that the input satisfy some safety conditions. See, for instance, Chapter 3 of the dlv manual, http://www.dbai.tuwien.ac.at/proj/dlv/man/. 16 See Footnote (12). 17 Specifically, under the assumption that every occurrence of every extensional predicate in F is\nin the scope of negation or in the antecedent of an implication.\nA representation of this example in the language of lparse is shown in Figure 1. The auxiliary predicate u describes the universe of the interpretations that we are interested in. The first line is shorthand for\nu(a). u(b). u(c). u(d).\nand the last line is understood by lparse in a similar way.\nGiven this input, the answer set solver smodels generates 4 stable models, rep-\nresenting the subsets of {a, b, c, d} that are disjoint from {a, b}:\nAnswer: 1 Stable Model: p(b) p(a) u(d) u(c) u(b) u(a) Answer: 2 Stable Model: p(b) p(a) q(d) u(d) u(c) u(b) u(a) Answer: 3 Stable Model: p(b) p(a) q(c) u(d) u(c) u(b) u(a) Answer: 4 Stable Model: p(b) p(a) q(d) q(c) u(d) u(c) u(b) u(a)\nIn application to the logic program obtained from a causal theory T as described in Section 5, this process often allows us to find the models of T with a given universe and given extents of extensional predicates.\nExample 7, continued. There are two switches, myswitch and hisswitch . It is dark in my room at time 1 if and only if myswitch is not on at time 1. At time 0, both switches are on; then hisswitch is toggled, and myswitch is not. Is it dark in my room at time 1? We would like to answer this question using answer set programming.\nThis example of commonsense reasoning involves inertia (the value of the fluent on(myswitch) does not change because this fluent is not affected by the action that is executed) and indirect effects of actions: whether or not it is dark in the room at time 1 after performing some actions is determined by the effect of these actions on the fluent on(myswitch).\nMathematically, we are talking here about the causal theory T with rules (32) and (36), with the object constant hisswitch added to the language, and with the explainable symbols on1 and dark . We are interested in the Herbrand models of T in which the extents of the extensional predicates are described by the atoms\non0(myswitch), on0(hisswitch), toggle(hisswitch)·\nAs we have seen, the logic program Tr[T ] is equivalent to the conjunction of\nrules (35) and (37). The corresponding lparse input file is shown in Figure 2. In this file, the “true negation” symbol - is used in the ASCII representations of the symbols ôn1 and d̂ark ; the lparse counterparts of the rules\n∀x¬(on1(x ) ∧ ôn1(x )), ¬(dark ∧ d̂ark )\nare dropped, because such “coherence” conditions are verified by the system automatically.\nGiven this input, smodels generates the only model of T satisfying the given\nconditions:\nAnswer: 1 Stable Model: -on1(hisswitch) on1(myswitch) -dark toggle(hisswitch) on0(hisswitch) on0(myswitch) u(hisswitch) u(myswitch)\nThe presence of -dark in this model tells us that it is not dark in the room at time 1.\nThe example above is an example of “one-step temporal projection”—predicting the value of a fluent after performing a single action in a given state. Some other kinds of temporal reasoning and planning can be performed by generating models of simple modifications of the given causal theory (Giunchiglia et al. 2004, Section 3.3); this is one of the ideas behind the design of CCalc and coala. McCain’s translation reviewed in the introduction and its generalization presented in Section 5 allow us to solve such problems automatically using an answer set solver."
    }, {
      "heading" : "7 Proof of Soundness",
      "text" : "To prove claim (40), which expresses the soundness of our translation, we will first establish it for the case when C = L = S = ∅ (Section 7.1). In this “leading special case” all rules of the given causal theory are D-rules, and they are converted to program rules using the translation Trd . Then we will derive the soundness theorem in full generality (Section 7.2)."
    }, {
      "heading" : "7.1 Leading Special Case",
      "text" : "Let T be a finite set of causal rules of the form (38). Let Π be the conjunction of the corresponding program rules (39), and let CC , as before, stand for the conjunction of the completeness constraints (29) for all explainable symbols p of T . We want to show that\nSMpp̂[Π ∧ CC ] is equivalent to T ∧ CC · (41)\nThe key steps in the proof below are Lemma 5 (one half of the equivalence) and\nLemma 8 (the other half).\nIn the statement of the following lemma, ¬p stands for the list of predicate expressions18 λx¬p(x), where x is a list of distinct object variables, for all p from p. By υp, υp̂ we denote the lists of predicate variables used in the second-order formula SMpp̂[Π ∧ CC ] (see Section 4).\nLemma 1 Formula (υp, υp̂) < (p,¬p) is equivalent to ∨\np∈p\n(((υp, υp̂) ≤ (p,¬p)) ∧ ∃x(¬υp(x) ∧ ¬υp̂(x)))·"
    }, {
      "heading" : "Proof",
      "text" : "Note first that\n(υp, υp̂) < (p,¬p)\n⇔ ((υp, υp̂) ≤ (p,¬p)) ∧ ¬ ((p,¬p) ≤ (υp, υp̂)) ⇔ ((υp, υp̂) ≤ (p,¬p)) ∧ ∨\np∈p ∃x((p(x) ∧ ¬υp(x)) ∨ (¬p(x) ∧ ¬υp̂(x)))\n⇔ ∨\np∈p(((υp, υp̂) ≤ (p,¬p)) ∧ ∃x((p(x) ∧ ¬υp(x)) ∨ (¬p(x) ∧ ¬υp̂(x))))·\nThe disjunction after ∃x is equivalent to\n(p(x) ∨ ¬υp̂(x)) ∧ (¬υp(x) ∨ ¬p(x)) ∧ (¬υp(x) ∨ ¬υp̂(x))· (42)\nSince (υp, υp̂) ≤ (p,¬p) entails\nυp(x) → p(x) and υp̂(x) → ¬p(x),\nthe first conjunctive term of (42) can be rewritten as ¬υp̂(x), and the second term as ¬υp(x), so that (42) will turn into ¬υp(x) ∧ ¬υp̂(x).\n18 See (Lifschitz 1994, Section 3.1).\nFor any formula F , by FΣ1 we denote the formula\nF (υp)(υp̂) (υp∧p)(¬υp∧¬p)\nwhere υp ∧ p is understood as the list of predicate expressions\nλx(υp(x) ∧ p(x))\nfor all p ∈ p, and ¬υp ∧ ¬p is understood in a similar way.19\nLemma 2 Formula\n((υp, υp̂) < (p,¬p))Σ1\nis equivalent to υp 6= p."
    }, {
      "heading" : "Proof",
      "text" : "In view of Lemma 1, ((υp, υp̂) < (p,¬p))Σ1 is equivalent to the disjunction of the formulas(∧ p∈p ∀x(υp(x) → p(x))Σ1 ) ∧ (∧ p∈p ∀x(υp̂(x) → ¬p(x))Σ1 )\n∧ ∃x(¬υp(x) ∧ ¬υp̂(x))Σ1 (43)\nfor all p ∈ p. It is easy to verify that\n(υp(x) → p(x))Σ1 = (υp(x) ∧ p(x) → p(x)) ⇔ ⊤ ,\n(υp̂(x) → ¬p(x))Σ1 = (¬υp(x) ∧ ¬p(x) → ¬p(x)) ⇔ ⊤,\n(¬υp(x) ∧ ¬υp̂(x))Σ1 ⇔ ((¬υp(x) ∨ ¬p(x)) ∧ ¬(¬υp(x) ∧ ¬p(x)))\n⇔ (υp(x) ↔ ¬p(x)) ⇔ ¬(υp(x) ↔ p(x))·\nTherefore (43) is equivalent to ∃x¬(υp(x) ↔ p(x)), so that the disjunction of all formulas (43) is equivalent to υp 6= p.\nIf A is an atomic formula p(t), where p ∈ p and t is a tuple of terms, then we will write υA for υp(t), and Â for υp̂(t). By ∀̃objF we denote the formula ∀xF , where x is list of all free object variables of F (“object-level universal closure”).\nDefine H (υp, υp̂) to be the conjunction of the implications\n∀̃obj\n G → ∨\nA∈Pos\n((υÂ ∨ A) → υA) ∨ ∨\nA∈Neg\n((υA ∨ ¬A) → υÂ)   (44)\nfor all rules (38) in T .\nLemma 3 Formula SMpp̂[Π ∧ CC ] is equivalent to\nΠ ∧ CC ∧ ∀(υp)(υp̂)(((υp, υp̂) < (p,¬p)) → ¬H (υp, υp̂))· (45)\n19 For the definition of F p\nυp see Section 3."
    }, {
      "heading" : "Proof",
      "text" : "Every occurrence of every intensional predicate in CC is in the scope of a negation. Consequently SMpp̂[Π ∧ CC ] is\nΠ ∧ CC ∧ ¬∃(υp)(υp̂)(((υp, υp̂) < (p, p̂)) ∧ Π⋄(υp, υp̂) ∧ CC ),\nwhich is equivalent to\nΠ ∧ CC ∧ ∀(υp)(υp̂)(((υp, υp̂) < (p,¬p)) → ¬Π⋄(υp, υp̂))·\nWe will conclude the proof by showing that CC entails\nΠ⋄(υp, υp̂) ↔ H (υp, υp̂)·\nThe left-hand side of this equivalence is the conjunction of the formulas\n∀̃obj\n ¬¬G ∧ ∧\nA∈Pos\n(υÂ ∨ ¬Â) ∧ ∧\nA∈Neg\n(υA ∨ ¬A) → ∨\nA∈Pos\nυA ∨ ∨\nA∈Neg\nυÂ\n \nfor all rules (38) in T . Under the assumption CC this formula can be rewritten as\n∀̃obj\n G → ∨\nA∈Pos\n¬(υÂ ∨A) ∨ ∨\nA∈Neg\n¬(υA ∨ ¬A) ∨ ∨\nA∈Pos\nυA ∨ ∨\nA∈Neg\nυÂ   ·\nThe last formula is equivalent to\n∀̃obj\n G → ∨\nA∈Pos\n(¬(υÂ ∨ A) ∨ υA) ∨ ∨\nA∈Neg\n(¬(υA ∨ ¬A) ∨ υÂ)   ·\nand consequently to (44).\nLemma 4 T †(υp) is equivalent to H (υp, υp̂)Σ1."
    }, {
      "heading" : "Proof",
      "text" : "Formula T †(υp) is the conjunction of the formulas\n∀̃obj\n G → ∨\nA∈Pos\nυA ∨ ∨\nA∈Neg\n¬υA   (46)\nfor all rules (38) in T . On the other hand, H (υp, υp̂)Σ1 is the conjunction of the formulas\n∀̃obj\n G → ∨\nA∈Pos\n((υÂ ∨ A) → υA)Σ1 ∨ ∨\nA∈Neg\n((υA ∨ ¬A) → υÂ)Σ1\n  (47)\nfor all rules (38) in T . It remains to observe that\n((υÂ ∨ A) → υA)Σ1 = (¬υA ∧ ¬A) ∨ A → υA ∧A\n⇔ ¬υA ∨ A → υA ∧ A ⇔ (υA ∧ ¬A) ∨ (υA ∧ A) ⇔ υA,\nand that, similarly, ((υA ∨ ¬A) → υÂ)Σ1 is equivalent to ¬υA.\nLemma 5 SMpp̂[Π ∧ CC ] |= T ∧ CC ."
    }, {
      "heading" : "Proof",
      "text" : "Recall that, according to Lemma 3, SMpp̂[Π∧CC ] is equivalent to (45). The second conjunctive term of (45) is CC . The first conjunctive term is equivalent to T †(p). From the other two terms we conclude:\n∀υp(((υp, υp̂) < (p, p̂))Σ1 → ¬H (υp, υp̂)Σ1)·\nBy Lemma 2 and Lemma 4, this formula is equivalent to\n∀υp((υp 6= p) → ¬T †(υp)),\nand consequently to\n∀υp(T †(υp) → (υp = p))·\nThe conjunction of the last formula with T †(p) is equivalent to (24).\nFor any formula F , by FΣ2 we denote the formula\nFυp(((υp,υp̂)≤(p,¬p))∧¬υp∧¬υp̂)↔¬p\nwhere the subscript\n(((υp, υp̂) ≤ (p,¬p)) ∧ ¬υp ∧ ¬υp̂) ↔ ¬p\nis understood as the list of predicate expressions\nλx((((υp, υp̂) ≤ (p,¬p)) ∧ ¬υp(x) ∧ ¬υp̂(x)) ↔ ¬p(x))\nfor all p ∈ p.\nLemma 6 Formula\n(υp 6= p)Σ2\nis equivalent to (υp, υp̂) < (p,¬p)."
    }, {
      "heading" : "Proof",
      "text" : "Formula (υp 6= p)Σ2 is equivalent to\n∨\np∈p\n∃x(υp(x) ↔ ¬p(x))Σ2\nthat is, ∨\np∈p\n∃x((((υp, υp̂) ≤ (p,¬p)) ∧ ¬υp(x) ∧ ¬υp̂(x) ↔ ¬p(x)) ↔ ¬p(x))·\nThis formula can be equivalently rewritten as ∨\np∈p\n(((υp, υp̂) ≤ (p,¬p)) ∧ ∃x(¬υp(x) ∧ ¬υp̂(x))),\nwhich is equivalent to (υp, υp̂) < (p,¬p) by Lemma 1.\nLemma 7 The implication\n(υp, υp̂) ≤ (p,¬p) → (T †(υp)Σ2 ↔ H (υp, υp̂))\nis logically valid."
    }, {
      "heading" : "Proof",
      "text" : "Recall that T †(υp) is the conjunction of implications (46) for all rules (38) in T . Consequently T †(υp)Σ2 is the conjunction of the formulas\n∀̃obj\n G → ∨\nA∈Pos\n(υA)Σ2 ∨ ∨\nA∈Neg\n¬(υA)Σ2\n  ,\nthat is to say,\n∀̃obj (G → ∨\nA∈Pos((((υp, υp̂) ≤ (p,¬p)) ∧ ¬υA ∧ ¬υÂ) ↔ ¬A)∨∨ A∈Neg ¬((((υp, υp̂) ≤ (p,¬p)) ∧ ¬υA ∧ ¬υÂ) ↔ ¬A)·\nUnder the assumption\n(υp, υp̂) ≤ (p,¬p) (48)\nthe last formula can be equivalently rewritten as\n∀̃obj\n G → ∨\nA∈Pos\n((υA ∨ υÂ) ↔ A) ∨ ∨\nA∈Neg\n((υA ∨ υÂ) ↔ ¬A)   ·\nIt remains to check that, under assumption (48),\n(υA ∨ υÂ) ↔ A (49)\ncan be equivalently rewritten as\nυÂ ∨ A → υA, (50)\nand\nυA ∨ υÂ ↔ ¬A (51)\ncan be rewritten as\nυA ∨ ¬A → υÂ· (52)\nFormula (49) is equivalent to\n(υA → A) ∧ (υÂ → A) ∧ (A → υA ∨ υÂ)· (53)\nSince assumption (48) entails υA → A and υÂ → ¬A, formula (53) can be rewritten as\n¬υÂ ∧ (A → υA)· (54)\nOn the other hand, formula (50) is equivalent to\n(υÂ → υA) ∧ (A → υA),\nwhich, under assumption (48), can be rewritten as (54) as well. In a similar way, each of the formulas (51), (52) can be transformed into\n¬υA ∧ (¬A → υÂ) ·\nLemma 8 T ∧CC |= SMpp̂[Π ∧ CC ]."
    }, {
      "heading" : "Proof",
      "text" : "Recall that T is equivalent to\nT †(p) ∧ ∀υp(T †(υp) → (υp = p))· (55)\nSince the first conjunctive term is equivalent to Π, T ∧ CC entails\nΠ ∧ CC · (56)\nFrom the second conjunctive term of (55) we conclude\nT †(υp)Σ2 → (υp = p)Σ2\nand consequently\n∀(υp)(υp̂)((υp 6= p)Σ2 → ¬T †(υp)Σ2)·\nBy Lemma 6, this is equivalent to\n∀(υp)(υp̂)(((υp, υp̂) < (p,¬p)) → ¬T †(υp)Σ2)\nand, by Lemma 7, to\n∀(υp)(υp̂)(((υp, υp̂) < (p,¬p)) → ¬H (υp, υp̂))·\nBy Lemma 3, the conjunction of this formula with (56) is equivalent to sentence SMpp̂[Π ∧ CC ].\nAssertion (41) follows from Lemmas 5 and 8.\n7.2 General Case\nLemma 9 For any C-rule R, Trc [R] is intuitionistically equivalent to Trd [R]."
    }, {
      "heading" : "Proof",
      "text" : "If R is ⊥ ⇐ G then Trc [R] is ∀̃¬G, and Trd [R] is ∀̃(¬¬G → ⊥).\nLemma 10 For any L-rule R, the conjunction CC of completeness constraints intuitionistically entails\nTrl [R] ↔ Trd [R]·"
    }, {
      "heading" : "Proof",
      "text" : "If R is p(t) ⇐ G then Trl [R] is\n∀̃(¬¬G → p(t)),\nand Trd [R] is\n∀̃(¬¬G ∧ (p̂(t) ∨ ¬p̂(t)) → p(t))·\nSince CC intuitionistically entails\n¬(p(t) ↔ p̂(t)), (57)\nit is sufficient to check that p(t) can be derived from (57) and\np̂(t) ∨ ¬p̂(t) → p(t) (58)\nby the deductive means of intuitionistic propositional logic. Since (58) is equivalent to p(t) in classical propositional logic, it is easy to see that ¬p̂(t) can be derived from (57) and (58) in classical propositional logic. By Glivenko’s theorem,20 it follows that it can be derived intuitionistically as well. Since p(t) is intuitionistically derivable from (58) and ¬p̂(t), we can conclude that p(t) is intuitionistically derivable from (57) and (58).\nThe case when R is ¬p(t) ⇐ G is similar.\nLemma 11 If R is an S-rule\nL1 ↔ L2 ⇐ G (59)\nand R1, R2 are the D-rules\nL1 ∨ L2 ⇐ G and L1 ∨ L2 ⇐ G (60)\nthen the conjunction CC of completeness constraints intuitionistically entails\nTrs [R] ↔ Trd [R1] ∧Trd [R2]·"
    }, {
      "heading" : "Proof",
      "text" : "If each of the literals Li is an atom Ai then Trs [R] is the conjunction of the formulas\n∀̃(¬¬G ∧A1 → A2), ∀̃(¬¬G ∧A2 → A1), ∀̃(¬¬G ∧ Â1 → Â2), ∀̃(¬¬G ∧ Â2 → Â1),\n(61)\nTrd [R1] is\n∀̃(¬¬G ∧ (Â1 ∨ ¬Â1) ∧ (A2 ∨ ¬A2) → A1 ∨ Â2), (62)\n20 This theorem (Glivenko 1929), (Mints 2000, Theorem 3.1) asserts that if a formula beginning with negation can be derived from a set Γ of formulas in classical propositional logic then it can be derived from Γ in intuitionistic propositional logic as well.\nand Trd [R2] is\n∀̃(¬¬G ∧ (A1 ∨ ¬A1) ∧ (Â2 ∨ ¬Â2) → Â1 ∨ A2)· (63)\nWe need to show that CC intuitionistically entails the equivalence between the conjunction of formulas (61) and the conjunction of formulas (62), (63). Since CC intuitionistically entails\n¬(A1 ↔ Â1) (64)\nand\n¬(A2 ↔ Â2), (65)\nit is sufficient to check that the conjunction of formulas (64), (65),\nA1 ↔ A2 (66)\nand\nÂ1 ↔ Â2 (67)\nis equivalent in intuitionistic propositional logic to the conjunction of formulas (64), (65),\n(Â1 ∨ ¬Â1) ∧ (A2 ∨ ¬A2) → A1 ∨ Â2 (68)\nand\n(A1 ∨ ¬A1) ∧ (Â2 ∨ ¬Â2) → Â1 ∨ A2· (69)\nLeft-to-right: Assume (64)–(67) and\n(Â1 ∨ ¬Â1) ∧ (A2 ∨ ¬A2); (70)\nour goal is to derive intuitionistically A1 ∨ Â2. Consider two cases, in accordance with the first disjunction in (70). Case 1: Â1. Then, by (67), Â2, and consequently A1∨Â2. Case 2: ¬Â1. Consider two cases, in accordance with the second disjunction in (70). Case 2.1: A2. Then, by (66), A1, and consequently A1∨ Â2. Case 2.2: ¬A2. Then, by (66), ¬A1, which contradicts (64).\nThus we proved that (68) is intuitionistically derivable from (64)–(67). The proof\nfor (69) is similar.\nRight-to-left: Let Γ be the set consisting of formulas (64), (65), (68), (69) and A1. We claim that A2 can be derived from Γ in intuitionistic propositional logic. Note that, classically,\n• Formula (64) is equivalent to A1 ↔ ¬Â1, • Formula (65) is equivalent to A2 ↔ ¬Â2, and • Formula (69) is equivalent to Â1 ∨ A2.\nIt follows that ¬Â2 is derivable from Γ in classical propositional logic. By Glivenko’s theorem, it follows that ¬Â2 is derivable from Γ intuitionistically as well. Hence the antecedent of (69) is an intuitionistic consequence of Γ, and so is the consequent Â1 ∨ A2. In combination with A1 and (64), this gives us A2.\nWe conclude that A1 → A2 is intuitionsistically derivable from (64), (65), (68)\nand (69). The derivability of the implication A2 → A1 from these formulas can be proved in a similar way. Thus (66) is an intuitionistic consequence of (64), (65), (68), and (69).\nThe derivability of (67) from these formulas in propositional intuitionistic logic\nis proved in a similar way.\nThe cases when the literals Li are negative, or when one of them is positive and\nthe other is negative, are similar.\nProof of the soundness property (40). Let C , L, S , and D be sets of causal rules of types C, L, S, and D respectively, and let T be the causal theory with the set of rules C ∪ L ∪ S ∪D . Consider the causal theory T ′ obtained from T by replacing each rule (59) from S with the corresponding rules (60). According to the result (41) of Section 7.1,\nSMpp̂[Π ∧ CC ] is equivalent to T ′ ∧ CC ,\nwhere Π is the conjunction of the program rules Trd [R] for all rules R of T ′. It is clear that Π ∧ CC is Tr[T ′], and that T ′ is equivalent to T . Consequently\nSMpp̂[Tr[T ′]] is equivalent to T ∧CC · (71)\nOn the other hand, Lemmas 9, 10 and 11 show that the formulas Tr[T ′] and Tr[C ,L, S ,D ] are intuitionistically equivalent to each other, because each of them contains CC as a conjunctive term. It follows that\nSMpp̂[Tr[T ′]] is equivalent to SMpp̂[Tr[C ,L, S ,D ]]· (72)\nAssertion (40) follows from (71) and (72)."
    }, {
      "heading" : "8 Conclusion",
      "text" : "In this paper we generalized McCain’s embedding of definite causal theories into logic programming. We expect that this work will provide a theoretical basis for extending the system coala to more expressive action languages, including the modular action language MAD (Ren 2009). It is essential, from this perspective, that our translation is applicable to synonymity rules, because such rules are closely related to the main new feature of MAD, its import construct.\nOur translation is not applicable to causal rules with quantifiers in the head. It may be possible to extend it to positive occurrences of existential quantifiers, since an existentially quantified formula can be thought of as an infinite disjunction. But the translation would be a formula with positive occurrences of existential quantifiers as well, and it is not clear how to turn such a formula into executable code.\nIn the future, we would like to extend the translation described above to causal theories with explainable function symbols, which correspond to non-Boolean fluents in action languages. Since the definition of a stable model does not allow function symbols to be intensional, such a generalization would have to involve extending the language by auxiliary predicate symbols."
    }, {
      "heading" : "Acknowledgements",
      "text" : "We are grateful to the anonymous referees for useful comments. Joohyung Lee was partially supported by the National Science Foundation under grant IIS-0916116 and by the Office of the Director of National Intelligence (ODNI), Intelligence Advanced Research Projects Activity (IARPA), through US Army. Yuliya Lierler was supported by a 2010 Computing Innovation Fellowship. Vladimir Lifschitz and Fangkai Yang were supported by the National Science Foundation under grant IIS0712113. All statements of fact, opinion or conclusions contained herein are those of the authors and should not be construed as representing the official views or policies of IARPA, the ODNI or the U.S. Government."
    } ],
    "references" : [ {
      "title" : "Representing the Zoo World and the Traffic World in the language of the Causal Calculator",
      "author" : [ "V. Akman", "S. Erdoğan", "J. Lee", "V. Lifschitz", "H. Turner" ],
      "venue" : "Artificial Intelligence 153(1–2), 105–140.",
      "citeRegEx" : "Akman et al\\.,? 2004",
      "shortCiteRegEx" : "Akman et al\\.",
      "year" : 2004
    }, {
      "title" : "Formal specification and automatic analysis of business processes under authorization constraints: an actionbased approach",
      "author" : [ "A. Armando", "E. Giunchiglia", "S.E. Ponta" ],
      "venue" : "Proceedings of the 6th International Conference on Trust, Privacy and Security in Digital Business (TrustBus’09).",
      "citeRegEx" : "Armando et al\\.,? 2009",
      "shortCiteRegEx" : "Armando et al\\.",
      "year" : 2009
    }, {
      "title" : "Specifying norm-governed computational societies",
      "author" : [ "A. Artikis", "M. Sergot", "J. Pitt" ],
      "venue" : "ACM Transactions on Computational Logic 9, 1.",
      "citeRegEx" : "Artikis et al\\.,? 2009",
      "shortCiteRegEx" : "Artikis et al\\.",
      "year" : 2009
    }, {
      "title" : "Bridging the gap between high-level reasoning and low-level control",
      "author" : [ "O. Caldiran", "K. Haspalamutgil", "A. Ok", "C. Palaz", "E. Erdem", "V. Patoglu" ],
      "venue" : "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR). 242–354. Clark, K. 1978. Negation as failure. In Logic and Data Bases, H. Gallaire and J. Minker,",
      "citeRegEx" : "Caldiran et al\\.,? 2009",
      "shortCiteRegEx" : "Caldiran et al\\.",
      "year" : 2009
    }, {
      "title" : "Answer sets for propositional theories",
      "author" : [ "P. Ferraris" ],
      "venue" : "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR). 119–131. Ferraris, P. 2006. Causal theories as logic programs. In Proceedings of Workshop on Logic Programming (WLP). 35–44. Ferraris, P. 2007. A logic program characterization of causal theories. In Proceedings",
      "citeRegEx" : "Ferraris,? 2005",
      "shortCiteRegEx" : "Ferraris",
      "year" : 2005
    }, {
      "title" : "Stable models and circumscription",
      "author" : [ "P. Ferraris", "J. Lee", "V. Lifschitz" ],
      "venue" : "Artificial Intelligence 175, 236–263.",
      "citeRegEx" : "Ferraris et al\\.,? 2011",
      "shortCiteRegEx" : "Ferraris et al\\.",
      "year" : 2011
    }, {
      "title" : "Symmetric splitting in the general theory of stable models",
      "author" : [ "P. Ferraris", "J. Lee", "V. Lifschitz", "R. Palla" ],
      "venue" : "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI). 797–803.",
      "citeRegEx" : "Ferraris et al\\.,? 2009",
      "shortCiteRegEx" : "Ferraris et al\\.",
      "year" : 2009
    }, {
      "title" : "Coala: a compiler from action languages to ASP",
      "author" : [ "M. Gebser", "T. Grote", "T. Schaub" ],
      "venue" : "Proceedings of European Conference on Logics in Artificial Intelligence (JELIA). 169–181.",
      "citeRegEx" : "Gebser et al\\.,? 2010",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2010
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "Proceedings of International Logic Programming Conference and Symposium, R. Kowalski and K. Bowen, Eds. MIT Press, 1070–1080.",
      "citeRegEx" : "Gelfond and Lifschitz,? 1988",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1988
    }, {
      "title" : "Classical negation in logic programs and disjunctive databases",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "New Generation Computing 9, 365–385.",
      "citeRegEx" : "Gelfond and Lifschitz,? 1991",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1991
    }, {
      "title" : "Nonmonotonic causal theories",
      "author" : [ "E. Giunchiglia", "J. Lee", "V. Lifschitz", "N. McCain", "H. Turner" ],
      "venue" : "Artificial Intelligence 153(1–2), 49–104.",
      "citeRegEx" : "Giunchiglia et al\\.,? 2004",
      "shortCiteRegEx" : "Giunchiglia et al\\.",
      "year" : 2004
    }, {
      "title" : "An action language based on causal explanation: Preliminary report",
      "author" : [ "E. Giunchiglia", "V. Lifschitz" ],
      "venue" : "Proceedings of National Conference on Artificial Intelligence (AAAI). AAAI Press, 623–630. Glivenko, V. 1929. Sur quelques points de la logique de M. Brouwer. Académie Royale de Belgique. Bulletins de la Classe des Sciences, se’rie 5 15, 183–188.",
      "citeRegEx" : "Giunchiglia and Lifschitz,? 1998",
      "shortCiteRegEx" : "Giunchiglia and Lifschitz",
      "year" : 1998
    }, {
      "title" : "Representing synonymity in causal logic and in logic programming",
      "author" : [ "J. Lee", "Y. Lierler", "V. Lifschitz", "F. Yang" ],
      "venue" : "Proceedings of International Workshop on Nonmonotonic Reasoning (NMR).",
      "citeRegEx" : "Lee et al\\.,? 2010",
      "shortCiteRegEx" : "Lee et al\\.",
      "year" : 2010
    }, {
      "title" : "System F2LP — computing answer sets of first-order formulas",
      "author" : [ "J. Lee", "R. Palla" ],
      "venue" : "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR). 515–521. Lifschitz, V. 1985. Computing circumscription. In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI). 121–127.",
      "citeRegEx" : "Lee and Palla,? 2009",
      "shortCiteRegEx" : "Lee and Palla",
      "year" : 2009
    }, {
      "title" : "Circumscription",
      "author" : [ "V. Lifschitz" ],
      "venue" : "Handbook of Logic in AI and Logic Programming, D. Gabbay, C. Hogger, and J. Robinson, Eds. Vol. 3. Oxford University Press, 298–352.",
      "citeRegEx" : "Lifschitz,? 1994",
      "shortCiteRegEx" : "Lifschitz",
      "year" : 1994
    }, {
      "title" : "On the logic of causal explanation",
      "author" : [ "V. Lifschitz" ],
      "venue" : "Artificial Intelligence 96, 451–465. Lifschitz, V. 2008. What is answer set programming? In Proceedings of the AAAI Conference on Artificial Intelligence. MIT Press, 1594–1597. Lifschitz, V. and Ren, W. 2006. A modular action description language. In Proceedings of National Conference on Artificial Intelligence (AAAI). 853–859.",
      "citeRegEx" : "Lifschitz,? 1997",
      "shortCiteRegEx" : "Lifschitz",
      "year" : 1997
    }, {
      "title" : "The semantics of variables in action descriptions",
      "author" : [ "V. Lifschitz", "W. Ren" ],
      "venue" : "Proceedings of National Conference on Artificial Intelligence (AAAI). 1025–1030.",
      "citeRegEx" : "Lifschitz and Ren,? 2007",
      "shortCiteRegEx" : "Lifschitz and Ren",
      "year" : 2007
    }, {
      "title" : "Translating first-order causal theories into answer set programming",
      "author" : [ "V. Lifschitz", "F. Yang" ],
      "venue" : "Proceedings of the European Conference on Logics in Artificial Intelligence (JELIA). 247–259.",
      "citeRegEx" : "Lifschitz and Yang,? 2010",
      "shortCiteRegEx" : "Lifschitz and Yang",
      "year" : 2010
    }, {
      "title" : "Stable models and an alternative logic programming paradigm",
      "author" : [ "V. Marek", "M. Truszczyński" ],
      "venue" : "The Logic Programming Paradigm: a 25-Year Perspective. Springer Verlag, 375–398. McCain, N. 1997. Causality in commonsense reasoning about actions. Ph.D. thesis, University of Texas at Austin.",
      "citeRegEx" : "Marek and Truszczyński,? 1999",
      "shortCiteRegEx" : "Marek and Truszczyński",
      "year" : 1999
    }, {
      "title" : "Causal theories of action and change",
      "author" : [ "N. McCain", "H. Turner" ],
      "venue" : "Proceedings of National Conference on Artificial Intelligence (AAAI). 460–465.",
      "citeRegEx" : "McCain and Turner,? 1997",
      "shortCiteRegEx" : "McCain and Turner",
      "year" : 1997
    }, {
      "title" : "Applications of circumscription to formalizing common sense knowledge",
      "author" : [ "J. McCarthy" ],
      "venue" : "Artificial Intelligence 26, 3, 89–116. Mints, G. 2000. A Short Introduction to Intuitionistic Logic. Kluwer.",
      "citeRegEx" : "McCarthy,? 1986",
      "shortCiteRegEx" : "McCarthy",
      "year" : 1986
    }, {
      "title" : "Logic programs with stable model semantics as a constraint programming paradigm",
      "author" : [ "I. Niemelä" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 25, 241–273. Ren, W. 2009. A modular language for describing actions . Ph.D. thesis, University of Texas at Austin.",
      "citeRegEx" : "Niemelä,? 1999",
      "shortCiteRegEx" : "Niemelä",
      "year" : 1999
    }, {
      "title" : "Solving the Frame Problem: A Mathematical Investigation of the Common Sense Law of Inertia",
      "author" : [ "M. Shanahan" ],
      "venue" : "MIT Press.",
      "citeRegEx" : "Shanahan,? 1997",
      "shortCiteRegEx" : "Shanahan",
      "year" : 1997
    } ],
    "referenceMentions" : [ {
      "referenceID" : 19,
      "context" : "Propositional nonmonotonic causal logic (McCain and Turner 1997) and its generalizations became a basis for the semantics of several expressive action languages (Giunchiglia and Lifschitz 1998; Giunchiglia et al.",
      "startOffset" : 40,
      "endOffset" : 64
    }, {
      "referenceID" : 11,
      "context" : "Propositional nonmonotonic causal logic (McCain and Turner 1997) and its generalizations became a basis for the semantics of several expressive action languages (Giunchiglia and Lifschitz 1998; Giunchiglia et al. 2004; Lifschitz and Ren 2006; Lifschitz and Ren 2007; Ren 2009).",
      "startOffset" : 161,
      "endOffset" : 276
    }, {
      "referenceID" : 10,
      "context" : "Propositional nonmonotonic causal logic (McCain and Turner 1997) and its generalizations became a basis for the semantics of several expressive action languages (Giunchiglia and Lifschitz 1998; Giunchiglia et al. 2004; Lifschitz and Ren 2006; Lifschitz and Ren 2007; Ren 2009).",
      "startOffset" : 161,
      "endOffset" : 276
    }, {
      "referenceID" : 16,
      "context" : "Propositional nonmonotonic causal logic (McCain and Turner 1997) and its generalizations became a basis for the semantics of several expressive action languages (Giunchiglia and Lifschitz 1998; Giunchiglia et al. 2004; Lifschitz and Ren 2006; Lifschitz and Ren 2007; Ren 2009).",
      "startOffset" : 161,
      "endOffset" : 276
    }, {
      "referenceID" : 0,
      "context" : "It has been used to solve several challenging commonsense reasoning problems, including problems of nontrivial size (Akman et al. 2004), to provide a group of robots with high-level reasoning (Caldiran et al.",
      "startOffset" : 116,
      "endOffset" : 135
    }, {
      "referenceID" : 3,
      "context" : "2004), to provide a group of robots with high-level reasoning (Caldiran et al. 2009), to give executable specifications of norm-governed computational societies (Artikis et al.",
      "startOffset" : 62,
      "endOffset" : 84
    }, {
      "referenceID" : 2,
      "context" : "2009), to give executable specifications of norm-governed computational societies (Artikis et al. 2009), and to automate the analysis of business processes under authorization constraints (Armando et al.",
      "startOffset" : 82,
      "endOffset" : 103
    }, {
      "referenceID" : 1,
      "context" : "2009), and to automate the analysis of business processes under authorization constraints (Armando et al. 2009).",
      "startOffset" : 90,
      "endOffset" : 111
    }, {
      "referenceID" : 9,
      "context" : "7) shows how to embed a fragment of propositional causal logic into the language of logic programming under the answer set semantics (Gelfond and Lifschitz 1991).",
      "startOffset" : 133,
      "endOffset" : 161
    }, {
      "referenceID" : 7,
      "context" : "This result, reviewed below, paved the way to the development of an attractive alternative to CCalc—the software system coala (Gebser et al. 2010) that uses answer set programming (Marek and Truszczyński 1999; Niemelä 1999; Lifschitz 2008) for answering queries about actions described in causal logic.",
      "startOffset" : 126,
      "endOffset" : 146
    }, {
      "referenceID" : 18,
      "context" : "2010) that uses answer set programming (Marek and Truszczyński 1999; Niemelä 1999; Lifschitz 2008) for answering queries about actions described in causal logic.",
      "startOffset" : 39,
      "endOffset" : 98
    }, {
      "referenceID" : 21,
      "context" : "2010) that uses answer set programming (Marek and Truszczyński 1999; Niemelä 1999; Lifschitz 2008) for answering queries about actions described in causal logic.",
      "startOffset" : 39,
      "endOffset" : 98
    }, {
      "referenceID" : 19,
      "context" : "A causal theory in the sense of (McCain and Turner 1997) is a set of “causal rules” of the form F ⇐ G, where F and G are propositional formulas (the head and the body of the rule).",
      "startOffset" : 32,
      "endOffset" : 56
    }, {
      "referenceID" : 19,
      "context" : "has one model, according to the semantics from (McCain and Turner 1997).",
      "startOffset" : 47,
      "endOffset" : 71
    }, {
      "referenceID" : 15,
      "context" : "If, for instance, G in (5) is a literal then the following group of nondisjunctive rules will do: L1 ← L2, not G L2 ← L1, not G L1 ← L2, not G L2 ← L1, not G · Finally, we extend the translation from propositional causal rules to first-order causal rules in the sense of (Lifschitz 1997).",
      "startOffset" : 271,
      "endOffset" : 287
    }, {
      "referenceID" : 16,
      "context" : "This version of causal logic is useful for defining the semantics of variables in action descriptions (Lifschitz and Ren 2007).",
      "startOffset" : 102,
      "endOffset" : 126
    }, {
      "referenceID" : 12,
      "context" : "Preliminary reports on this work are published in (Ferraris 2006; Ferraris 2007; Lee et al. 2010; Lifschitz and Yang 2010).",
      "startOffset" : 50,
      "endOffset" : 122
    }, {
      "referenceID" : 17,
      "context" : "Preliminary reports on this work are published in (Ferraris 2006; Ferraris 2007; Lee et al. 2010; Lifschitz and Yang 2010).",
      "startOffset" : 50,
      "endOffset" : 122
    }, {
      "referenceID" : 9,
      "context" : "As observed in (Gelfond and Lifschitz 1991), strong negation can be eliminated from a logic program in favor of additional atoms.",
      "startOffset" : 15,
      "endOffset" : 43
    }, {
      "referenceID" : 4,
      "context" : "The definition of a stable model for propositional formulas given in (Ferraris 2005) and the definition of a stable model for first-order sentences proposed in (Ferraris et al.",
      "startOffset" : 69,
      "endOffset" : 84
    }, {
      "referenceID" : 5,
      "context" : "The definition of a stable model for propositional formulas given in (Ferraris 2005) and the definition of a stable model for first-order sentences proposed in (Ferraris et al. 2011) become generalizations of the original definition (Gelfond and Lifschitz 1988) when we rewrite rules as logical formulas.",
      "startOffset" : 160,
      "endOffset" : 182
    }, {
      "referenceID" : 8,
      "context" : "2011) become generalizations of the original definition (Gelfond and Lifschitz 1988) when we rewrite rules as logical formulas.",
      "startOffset" : 56,
      "endOffset" : 84
    }, {
      "referenceID" : 8,
      "context" : "2 The term “stable model” was introduced in (Gelfond and Lifschitz 1988) to describe the meaning of logic programs with negation as failure but without strong negation.",
      "startOffset" : 44,
      "endOffset" : 72
    }, {
      "referenceID" : 9,
      "context" : "When the stable model semantics was extended to programs with strong negation in (Gelfond and Lifschitz 1991), the term “answer set” was proposed as a replacement.",
      "startOffset" : 81,
      "endOffset" : 109
    }, {
      "referenceID" : 15,
      "context" : "According to (Lifschitz 1997), a first-order causal theory T is defined by • a list p of distinct predicate constants, called the explainable symbols of T , and • a finite set of causal rules of the form F ⇐ G, where F and G are first-order formulas.",
      "startOffset" : 13,
      "endOffset" : 29
    }, {
      "referenceID" : 19,
      "context" : "4) second-order formula (24) can be replaced by an equivalent first-order formula using a process similar to Clark’s completion (Clark 1978), called literal completion (McCain and Turner 1997), (Lifschitz 1997, Section 5).",
      "startOffset" : 168,
      "endOffset" : 192
    }, {
      "referenceID" : 15,
      "context" : "5 To be precise, the definition in (Lifschitz 1997) is more general: object and function constants can be treated as explainable as well.",
      "startOffset" : 35,
      "endOffset" : 51
    }, {
      "referenceID" : 5,
      "context" : "Some details of the definition of a stable model proposed in (Ferraris et al. 2011) depend on which propositional connectives are treated as primitives, and which are viewed as abbreviations.",
      "startOffset" : 61,
      "endOffset" : 83
    }, {
      "referenceID" : 5,
      "context" : "The definition of a stable model below is more limited than the definition from (Ferraris et al. 2011) because it is only applicable to programs, not to arbitrary sentences.",
      "startOffset" : 80,
      "endOffset" : 102
    }, {
      "referenceID" : 14,
      "context" : "We need the following notation from (Lifschitz 1994).",
      "startOffset" : 36,
      "endOffset" : 52
    }, {
      "referenceID" : 8,
      "context" : "The original definition of a stable model (Gelfond and Lifschitz 1988) treats all predicates as intensional.",
      "startOffset" : 42,
      "endOffset" : 70
    }, {
      "referenceID" : 20,
      "context" : "First, if we drop from the definition of SM the words “that is not in the scope of negation” then it will turn into the definition of parallel circumscription (McCarthy 1986; Lifschitz 1985).",
      "startOffset" : 159,
      "endOffset" : 190
    }, {
      "referenceID" : 5,
      "context" : "Second, the operator of SM as defined in (Ferraris et al. 2011) produces, in application to a logic program, a second-order formula that is usually more complex than (27) but is equivalent to it.",
      "startOffset" : 41,
      "endOffset" : 63
    }, {
      "referenceID" : 5,
      "context" : "11 Methods for simplifying the result of applying the operator SM are discussed in (Ferraris et al. 2011).",
      "startOffset" : 83,
      "endOffset" : 105
    }, {
      "referenceID" : 22,
      "context" : "The second pair solves the frame problem (Shanahan 1997) for the fluent on(x ) by postulating that if the value of that fluent at time 1 is equal to its previous value then there is a cause for this.",
      "startOffset" : 41,
      "endOffset" : 56
    }, {
      "referenceID" : 13,
      "context" : "There exists a tool, called f2lp (Lee and Palla 2009), that converts first-order formulas of a rather general kind into logic programs accepted by lparse.",
      "startOffset" : 33,
      "endOffset" : 53
    }, {
      "referenceID" : 6,
      "context" : "This can be proved using the splitting theorem from (Ferraris et al. 2009).",
      "startOffset" : 52,
      "endOffset" : 74
    } ],
    "year" : 2011,
    "abstractText" : "Nonmonotonic causal logic, introduced by Norman McCain and Hudson Turner, became a basis for the semantics of several expressive action languages. McCain’s embedding of definite propositional causal theories into logic programming paved the way to the use of answer set solvers for answering queries about actions described in such languages. In this paper we extend this embedding to nondefinite theories and to first-order causal logic.",
    "creator" : "dvips(k) 5.98 Copyright 2009 Radical Eye Software"
  }
}