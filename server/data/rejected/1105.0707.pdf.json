{
  "name" : "1105.0707.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Parameterized Complexity of Problems in Coalitional Resource Games",
    "authors" : [ "Rajesh Chitnis", "MohammadTaghi Hajiaghayi", "Vahid Liaghat" ],
    "emails" : [ "rchitnis@cs.umd.edu", "hajiagha@cs.umd.edu", "vliaghat@cs.umd.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n10 5.\n07 07\nv1 [\ncs .A\nI] 3\nM ay\nWe answer an important question left open by Shrot, Aumann and Kraus by showing that the SC Problem (checking whether a Coalition is Successful) is W[1]-hard when parameterized by the size of the coalition. Then via a single theme of reduction from SC, we are able to show that various problems related to resources, resource bounds and resource conflicts introduced by Wooldridge et al are\n1. W[1]-hard or co-W[1]-hard when parameterized by the size of the coalition.\n2. para-NP-hard or co-para-NP-hard when parameterized by |R|.\n3. FPT when parameterized by either |G| or |Ag|+ |R|.\n∗Supported in part by Google Faculty Research Award, ONR Young Investigator Award and NSF CAREER award. †Department of Computer Science , University of Maryland at College Park, USA, email: rchitnis@cs.umd.edu ‡Department of Computer Science , University of Maryland at College Park, USA. email: hajiagha@cs.umd.edu §Department of Computer Science , University of Maryland at College Park, USA. email: vliaghat@cs.umd.edu"
    }, {
      "heading" : "1 Introduction",
      "text" : ""
    }, {
      "heading" : "1.1 Coalitions",
      "text" : "In multi-agent systems (MAS), where each agent has limited resources, the formation of coalitions of agents is a very powerful tool [6]. Coalitions enable agents to accomplish goals they may not have been able to accomplish individually. As such, understanding and predicting the dynamics of coalitions formation, e.g., which coalitions are more beneficial and/or more likely to emerge, is a question of considerable interest in multi-agent settings. Unfortunately, a range of previous studies have shown that many of these problems are computationally complex [7, 8]. Nonetheless, as noted by Garey and Johnson [4], hardness results, such as NP-completeness, should merely constitute the beginning of the research. NP-hardness just indicates that a general solution for all instances of the problem most probably does not exist. Still, efficient solutions for important sub-classes may well exist."
    }, {
      "heading" : "1.2 Formal Model of Coalition Resource Games",
      "text" : "The framework we use to model coalitions is the CRG model introduced in [8], defined as follows. The model contains a non-empty, finite set Ag = {a1, . . . ,an} of agents. A coalition, typically denoted by C, is simply a set of agents, i.e., a subset of Ag. The grand coalition is the set of all agents, Ag. There is also a finite set of goals G. Each agent i ∈ Ag is associated with a subset Gi of the goals. Agent i is satisfied if at least one member of Gi is achieved, and unsatisfied otherwise. Achieving the goals requires the expenditure of resources, drawn from the total set of resource types R. Achieving different goals may require different quantities of each resource type. The quantity req(g,r) denotes the amount of resource r required to achieve goal g. It is assumed that req(g,r) is a non-negative integer. Each agent is endowed certain amounts of some or all of the resource types. The quantity en(i,r) denotes the amount of resource r endowed to agent i. Again, it is assumed that en(i,r) is a non-negative integer. Formally, a Coalition Resource Game Γ is a (n+5)-tuple given by\nΓ = 〈Ag,G,R,G1,G2, . . . ,Gn,en,req〉\nwhere:\n• Ag = {a1,a2, . . . ,an} is the set of agents\n• G = {g1,g2, . . . ,gm} is the set of possible goals\n• R = {r1,r2, . . . ,rt} is the set of resources\n• For each i ∈ Ag, Gi is a subset of G such that any of the goals in Gi would satisfy i but i is indifferent between the members of Gi\n• en : Ag×R → N∪{0} is the endowment function\n• req : G×R → N∪{0} is the requirement function\nThe endowment function en extends to coalitions by summing up endowments of its members as\nen(C,r) = ∑i∈C en(i,r) ∀r ∈ R\nThe requirement function req extends to sets of goals by summing up requirements of its members as\nreq(G′,r) = ∑g∈G′ req(g,r) ∀r ∈ R\nA set of goals G′ satisfies agent i if Gi∩G′ 6= /0 and satisfies a coalition C if it satisfies every member of C. A set of goals G′ is feasible for coalition C if that coalition is endowed with sufficient resources to achieve all goals in G′, i.e., for all r ∈ R we have req(G′,r)≤ en(C,r). Finally we say that a coalition C is successful if there exists a non-empty set of goals G′ that satisfies C and is feasible for it. In general, we use the notation succ(C) = {G′ | G′ ⊆ G, G′ 6= /0 and G′ is successful for C}. The CRG models many real-world situations like the virtual organizations problem [1] and voting domains."
    }, {
      "heading" : "2 Problem Definitions and Previous Work",
      "text" : ""
    }, {
      "heading" : "2.1 Problems Related to Coalition Formation",
      "text" : "Shrot et al. [5] considered the following four problems related to coalitions.\n1. SUCCESSFUL COALITION (SC) Instance: A CRG Γ and a coalition C Question: Is C successful?\n2. EXISTS A SUCCESSFUL COALITION OF SIZE k (ESCK) Instance: A CRG Γ and an integer k Question: Does there exist a successful coalition of size exactly k?\n3. MAXIMAL COALITION (MAXC) Instance: A CRG Γ and a coalition C Question: Is every proper superset of C not successful?\n4. MAXIMAL SUCCESSFUL COALITION (MAXS) Instance: A CRG Γ and a coalition C Question: Is C successful and every proper superset of C not successful?\nThe results from Shrot et al. [5] are summarized in Figure 1. In this work we consider the problems which were defined by Wooldridge et al. [8] but were not considered by Shrot et al. [5]. We define these problems in detail in the following sections.\n5. NECESSARY RESOURCE (NR) Instance: A CRG Γ, coalition C and resource r Question: Is req(G′,r) > 0 ∀ G′ ∈ succ(C)?\n6. STRICTLY NECESSARY RESOURCE (SNR) Instance: A CRG Γ, coalition C and resource r Question: Is succ(C) 6= /0 and ∀ G′ ∈ succ(C) we have req(G′,r)> 0?\n7. (C,G0,r)-OPTIMALITY (CGRO) Instance: A CRG Γ, coalition C, goal set G0 ∈ succ(C) and resource r Question: Is req(G′,r) ≥ req(G0,r) ∀ G′ ∈ succ(C)?\n8. R-PARETO EFFICIENT GOAL SET (RPEGS) Instance: A CRG Γ, coalition C and a goal set G0 Question: Is G0 R-Pareto Efficient for coalition C?\n9. SUCCESSFUL COALITION WITH RESOURCE BOUND (SCRB) Instance: A CRG Γ, coalition C and a resource bound b Question: Does ∃ G0 ∈ succ(C) such that G0 respects b?\n10. CONFLICTING COALITIONS (CC) Instance: A CRG Γ, coalitions C1,C2 and a resource bound b Question: If ∀ G1 ∈ succ(C1) and ∀ G2 ∈ succ(C2) we have cgs(G1,G2,b)?"
    }, {
      "heading" : "3 Parameterized Complexity",
      "text" : "We now provide a brief introduction to the key relevant concepts from the theory of parameterized complexity. The definitions in this section are taken from [3] and [2]. The core idea of parameterized complexity is to single out a specific part of the input as the parameter and ask whether the problem admits an algorithm that is efficient in all but the parameter. In most cases the parameter is simply one of the elements of the input (e.g., the size of the goal set), but it can actually be any computable function of the input:\nDefinition 3.1. Let Σ be a finite alphabet.\n1. A parametrization of Σ∗ is a mapping κ : Σ∗ → N that is polynomial time computable.\n2. A parameterized problem (over Σ) is a pair (Q,κ) consisting of a set Q ⊆ Σ∗ of strings over Σ and a parameterization κ of Σ∗.\nAs stated, given a parameterized problem we seek an algorithm that is efficient in all but the parameter. This is captured by the notion of fixed parameter tractability, as follows:\nDefinition 3.2. A parameterized problem (Q,κ) is fixed parameter tractable (FPT) if there exist an algorithm A, a constant α , and a computable function f , such that A decides Q in time f (κ(x))|x|α .\nThus, while the fixed-parameter notion allows inefficiency in the parameter κ(x), by means of the function f , it requires polynomial complexity in all the rest of the input. In particular, a problem that is FPT is tractable for any bounded parameter value. While the core aim of parameterized complexity is to identify problems that are fixed-parameter tractable, it has also developed an extensive complexity theory, allowing to prove hardness results, e.g., that certain problems are (most probably) not FPT. To this end, several parameterized complexity classes have been defined. Two of these classes are the class W[1] and the class para-NP. We will formally define these classes shortly, but the important point to know is that there is strong evidence to believe that both classes are not contained in FPT (much like NP is probably not contained in P). Thus, W[1]-hard and para-NP-hard problems are most probably not fixed-parameter tractable. The class W[1] can be defined by its core complete problem, defined as follows:\nSHORT NONDETERMINISTIC TURING MACHINE COMPUTATION Instance: A single-tape, single-head non-deterministic Turing machine M, a word x and an integer k Question: Is there a computation of M on input x that reaches the accepting state in at most k steps?\nParameter: k\nNote that this definition is analogous to that of NP, with the addition of the parameter k.\nDefinition 3.3. The class W[1] contains all parameterized problems FPT-reducible (defined hereunder) to Short-Nondeterministic-Turing-Machine-Computation.\nThe class para-NP is defined as follows :\nDefinition 3.4. A parameterized problem (Q,κ) is in para-NP if there exists a non-deterministic Turing machine M, constant α and an arbitrary computable function f , such that for any input x, M decides if x ∈ Q in time ≤ |x|α f (κ(x)).\nEstablishing hardness results most frequently requires reductions. In parameterized complexity, we use FPT-reduction, defined as follows:\nDefinition 3.5. Let (Q,κ) and (Q′,κ ′) be parameterized problems over the alphabets Σ and Σ′ respectively. An FPT-reduction (FPT many-to-one reduction) from (Q,κ) to (Q′,κ ′) is a mapping R : Σ∗ → (Σ′)∗ such that:\n1. For all x ∈ Σ∗ we have x ∈ Q ⇔ R(x) ∈ Q′.\n2. R is computable in time f (κ(x))|x|α for some constant α and an arbitrary function f .\n3. There is a computable function g : N→ N such that κ ′(R(x)) ≤ g(κ(x)) for all x ∈ Σ∗.\nPoint (1) simply states that R is indeed a reduction. Point (2) says that it can be computed in the right amount of time - efficient in all but the parameter. Point (3) states that the parameter of the image is bounded by (a function of) that of the source. This is necessary in order to guarantee that FPT-reductions preserve FPT-ness, i.e. with this definition we obtain that if (Q,κ) reduces to (Q′,κ ′) and (Q′,κ ′) ∈ FPT then (Q,κ) is also in FPT."
    }, {
      "heading" : "4 Our Results & Techniques",
      "text" : "We consider problems regarding resources bounds and resource conflicts which were shown to be computationally hard in Wooldridge et al. ([8]) but were not considered in Shrot et al. [5]. We also solve three open questions posed in Shrot et al. by showing that\n1. SC parameterized by |C| is W[1]-hard\n2. ESCK parameterized by |Ag|+ |R| is FPT\n3. ESCK parameterized by |R| is para-NP-hard\nWe study the complexity of NR, SNR, CGRO, RPEGS, SCRB and CC problems when parameterized by natural parameters |G|, |C|, |R| and |Ag|+ |R|. We also give a general integer program which with slight modifications for each problem shows that these problems are FPT when parameterized by |G| or |Ag|+ |R| (except CC parameterized by |Ag|+ |R| which is open). We note that Shrot et al. showed that SC parameterized by |R| is para-NP-hard. We complete this hardness result by showing that SC parameterized by |C| is W[1]-hard and thus answer their open question. Using these hardness results and via a single theme of parameter preserving reductions we show that hardness results for all of the above problems when parameterized by |R| and |C|. We also show that Theorem 3.2 of Shrot et al. [5] is false - which claims that\nESCK is FPT when parameterized by |G|. We give a counterexample to their proposed algorithm and show that the problem is indeed para-NP-hard.\nThese results help us to understand the role of various components of the input and identify which ones actually make the input hard. Since all the problems we considered remain intractable when parameterized by |C| or |R|, there is no point in trying to restrict these parameters. On the other hand, most of the problems are FPT when parameterized by |G| or |Ag|+ |R| and thus we might enforce this restriction in real-life situations to ensure the tractability of these problems.\nWe summarize all the results in Figure 2. The results from [8] are in green, from [5] in black and our results are in red color. We use the abbreviations NPC for NP-complete, and pNP for para-NP."
    }, {
      "heading" : "5 Problems Left Open in Shrot et al. [5]",
      "text" : "First we show that SC parameterized by |C| is W[1]-hard.\nTheorem 5.1. SC is W[1]-hard when parameterized by |C|.\nProof. We prove this by reduction from Independent Set (parameterized by size of independent set) which is a well-known W[1]-complete problem. Let H = (V,E) be a graph with V = {x1, . . . ,xn} and E = {e1, . . . ,em}. Let k be a given integer. We also assume that H has no isolated points as we can just add those points to the independent set and decrease the parameter appropriately. We build a CRG Γ as follows:\nΓ = 〈Ag,G,R,G1,G2, . . . ,Gk,en,req〉\nwhere\n• Ag = {c1, . . . ,ck}\n• Gi = {g1i , . . . ,g n i } for all i ∈ [k]\n• G = ⋃k\ni=1 Gi\n• R = {r1, . . . ,rm}\n• For all i ∈ [k], j ∈ [m] , en(ci,r j) = 1\n• For all i∈ [k], j ∈ [m] and ℓ∈ [n], we have req(gℓi ,r j)= k if e j and xℓ are incident in H and req(g ℓ i ,r j)=\n0 otherwise\nWe claim that H has an independent set of size k if and only if the grand coalition Ag is successful in Γ.\nSuppose INDEPENDENT SET answers YES, i.e., H has an independent set of size k say I = {xβ1 , . . . ,xβk}.\nConsider the goal set given by G′ = {gβ11 , . . . ,g βk k }. Clearly G ′ satisfies Ag as gβii ∈ Gi for all i ∈ [k]. Now consider any edge e j ∈ E(H). Let λ be the number of vertices from I incident on e j. Clearly 2 ≥ λ but as I is independent set we have 1 ≥ λ . Now, for every j ∈ [m] we have req(G′,r j) = kλ ≤ k = en(Ag,r j). Thus G′ is feasible for Ag. Summing up, G′ is successful for Ag and hence SC answers YES for C = Ag.\nSuppose now that SC answers YES for C = Ag. Let G′′ 6= /0 be successful for Ag. Claim is that both gβi and g β j cannot be in G ′′ if i 6= j. To see this, let eℓ be any edge incident on xβ (we had assumed earlier that graph has no isolated vertices). Then req(G′′,rℓ) ≥ req(g β i ,rℓ) + req(g β i ,rℓ) = 2k > k = en(Ag,rℓ) which contradicts the fact that G′′ is successful for Ag. Since Gi’s are disjoint and G′′ is successful (hence also satisfiable) for Ag, we know that G′′ contains at least one goal from each Gi. Also we have seen before that gβi ,g γ j ∈ G\n′′ and i 6= j implies that β 6= γ . From each Gi we pick any goal that is in G′′. Let us call this as G′ = {gβ11 , . . . ,g βk k }. We know that βi 6= β j when i 6= j. We claim that I = {xβ1 , . . . ,xβk} is an independent set in H . Suppose not and let el be an edge between xβi and xβ j for some i, j ∈ [k]. Then req(G′′,rℓ) ≥ req(G′,rℓ) ≥ req(g βi i ,rℓ)+ req(g β j j ,rℓ) = k + k > k = en(Ag,rℓ) which contradicts the fact that G′′ is successful for Ag. Thus I is an independent set of size k in H and so INDEPENDENT SET also answers YES.\nNote that |Ag|= k, |G|= nk, |R|= m and so this reduction shows that the SC problem is W[1]-hard.\nWe note that the SC problem can be solved in O(|G||C| × |R|) time (since we only need to check the subsets of size at most |C| of G) and thus SC parameterized by |C| is not para-NP-hard. Now we answer the only remaining open problem by Shrot et al. by showing that ESCK parameterized by |R| is para-NP-hard.\nTheorem 5.2. Checking whether there exists a successful coalition of size k (ESCK) is para-NP-hard when parameterized by |R|.\nProof. We prove this by reduction from SC which was shown to be para-NP-hard with respect to the parameter |R| in Theorem 3.8 of [5]. Let (Γ,C) be a given instance of SC. We consider an instance (Γ′,k) of ESCK\n• Ag′ =C\n• R′ = R\n• G′i = Gi for all i ∈C\n• k = |C|\nWe claim that SC answers YES if and only if ESCK answers YES. Suppose SC answers YES, i.e., C is a successful coalition in Γ. In Γ′ we just remove all agents not belonging to C from Γ. All the resources and the en and req functions carry over. So C is a successful coalition for Γ′ also. But we had chosen k = |C| and so ESCK answers YES.\nSuppose that ESCK answers YES. So there exists a successful coalition of size k in Γ′. But Ag′ =C and we had chosen k = |C| and so the only coalition of size k in Γ′ is the grand coalition C = Ag′. As ESCK answered YES we know that C is successful in Γ′. So it is also successful in Γ and so SC also answers YES.\nNote that |Ag′|= k, |G′|= |G|, |R′|= |R| and so this reduction shows that the ESCK problem is para-NPhard."
    }, {
      "heading" : "6 Problems Related to Resources",
      "text" : "For a coalition C, we recollect the notation we use: succ(C) = {G′ | G′ ⊆ G ; G′ 6= /0 and G′ both satisfies C and is feasible for it}. In this section we show hardness results for three different problems related to resources."
    }, {
      "heading" : "6.1 Necessary Resource (NR)",
      "text" : "The idea of a necessary resource is similar to that of a veto player in the context of conventional coalition games. A resource is said to be necessary if the accomplishment of any set of goals which is successful for the coalition would need a non-zero consumption of this resource. Thus if a necessary resource is scarce then the agents possessing the resource become important. We consider the NECESSARY RESOURCE problem: Given a coalition C and a resource r answer YES if and only if req(G′,r) > 0 for all G′ ∈ succ(C). NR was shown to be co-NP-complete in Wooldridge et al. [8]. We note that if C is not successful, then NR vacuously answers YES. We give a reduction from SC to NR.\nLemma 6.1. Given an instance (Γ,C) of SC we can construct an instance (Γ′,C′,r′) of NR such that SC answers YES iff NR answers NO.\nProof. We keep everything the same except R′ = R∪ {r′}. We extend the en and req functions to r′ by en(i,r′) = 1 for all i ∈ Ag and req(g,r′) = 0 for all g ∈ G. Now claim is that SC answers YES iff NR answers NO.\nSuppose SC answers YES. So ∃ G′ 6= /0 such that G′ ∈ succΓ(C). Now C 6= /0 and so en(C,r′) > 0 = req(G′,r′) and thus G′ ∈ succΓ′(C). But req(G′,r′) = 0 and so NR answers NO.\nSuppose NR answers NO. So succΓ′(C) 6= /0 as ∃ G′ ∈ succΓ′(C) such that G′ 6= /0 and req(G′,r′) = 0. Now Γ′ is obtained from Γ by only adding a new resource and so clearly G′ ∈ succΓ(C). Thus SC will answer YES.\nTheorem 6.2. The parameterized complexity status of Necessary Resource is as follows :\n• FPT when parameterized by |G|\n• co-W[1]-hard when parameterized by |C|\n• co-para-NP-hard when parameterized by |R|\nProof. When parameterized by |G|, we consider all 2|G| subsets of G. For each subset, we can check in polynomial time if it is a member of succ(C) and if it requires non-zero quantity of the resource given in the input.\nThe other two claims follow from Lemma 6.1, Theorem 3.8 in Shrot et al., and Theorem 5.1."
    }, {
      "heading" : "6.2 Strictly Necessary Resource (SNR)",
      "text" : "The fact that a resource is necessary does not mean that it will be used. Because the coalition in question can be unsuccessful and hence the resource is trivially necessary. So we have the STRICTLY NECESSARY RESOURCE problem: Given a coalition C and a resource r answer YES if and only if succ(C) 6= /0 and ∀ G′ ∈ succ(C) we have req(G′,r) > 0. SNR was shown to be strongly Dp-complete in Wooldridge et al. [8]. To prove the parameterized hardness results, we give a reduction from SC to SNR.\nLemma 6.3. Given an instance (Γ,C) of SC we can construct an instance (Γ′,C′,r′) of SNR such that SC answers YES iff SNR answers YES.\nProof. We keep everything the same except R′ = R∪ {r′}. We extend the en and req functions to r′ by en(i,r′) = |G| for all i ∈ Ag and req(g,r′) = 1 for all g ∈ G. Now claim is that SC answers YES iff SNR answers YES.\nWe first show that succΓ(C) = succΓ′(C). As Γ′ is obtained from Γ by just adding one resource and keeping everything else the same, we have succΓ′(C) ⊆ succΓ(C). Now let G0 ∈ succΓ(C). Any coalition has at least one member and hence at least one |G| endowment of resource r′. But req(G0,r′) = |G0| ≤ |G| ≤ en(C,r′) and so G0 ∈ succΓ′(C). Summing up we have succΓ(C) = succΓ′(C).\nSuppose SC answers YES. This implies succΓ(C) 6= /0. So succΓ′(C) = succΓ(C) 6= /0. For every G0 ∈ succΓ′(C),req(G0,r′) = |G0|> 0 as G0 6= /0. Therefore SNR answers YES\nSuppose SNR answers YES. So succΓ′(C) 6= /0 as otherwise SNR would have said NO. Hence succΓ(C)= succΓ′(C) = /0 and SC so answers YES.\nTheorem 6.4. The parameterized complexity status of Strictly Necessary Resource is as follows :\n• FPT when parameterized by |G|\n• W[1]-hard when parameterized by |C|\n• para-NP-hard when parameterized by |R|\nProof. When parameterized by |G|, we consider all 2|G| subsets of G. For each subset, we can check in polynomial time if it is a member of succ(C) and if it requires non-zero quantity of the resource given in the input.\nThe other two claims follow from Lemma 6.3, Theorem 3.8 in Shrot et al., and Theorem 5.1.\n6.3 (C,G0,r)-Optimality (CGRO)\nWe may want to consider the issue of minimizing usage of a particular resource. If satisfaction is the only issue, then a coalition C will be equally happy between any of the goal sets in succ(C). However in practical situations we may want to choose a goal set among succ(C) which minimizes the usage of some particular costly resource. Thus we have the (C,G0,r)-OPTIMALITY problem: Given a coalition C, resource r and a goal set G0 ∈ succ(C) answer YES if and only if req(G′,r) ≥ req(G0,r) for all G′ ∈ succ(C). CGRO was shown to be strongly co-NP-complete in Wooldridge et al. [8]. To prove the parameterized hardness results, we give a reduction from SC to CGRO.\nLemma 6.5. Given an instance (Γ,C) of SC we can construct an instance (Γ′,C′,G0,r′) of CGRO such that SC answers YES iff CGRO answers NO.\nProof. Define G′ = G∪{g′}, R′ = R∪{r′} and C′ =C. We extend the en to r′ as follows: en(i,r′) = 1 for all i ∈ C and en(i,r′) = 0 if i /∈ C. We extend req to g′ and r′ as follows: req(g′,r′) = |C|, req(g′,r) = 0 for all r ∈ R and req(g,r′) = 0 for all g ∈ G. Let G0 = {g′}. Now claim is that SC answers YES iff CGRO answers NO.\nSuppose SC answers YES. So, ∃ G1 ∈ succΓ(C). Claim is that G1 ∈ succΓ′(C) because en(C,r′) = |C|> 0 = req(G1,r′) as G1 ⊆ G. Note also that G0 = {g′} ∈ succΓ′(C) as en(C,r′) = |C| = req(G0,r′) and for every r ∈ R, en(C,r) ≥ 0 = req(G0,r). Therefore req(G1,r′) = 0 < |C| = req(G0,r′) and hence CGRO answers NO.\nSuppose CGRO answers NO. So ∃ G1 ∈ succΓ′(C) such that req(G1,r′) < req(G0,r′) = |C|. Claim is g′ /∈ G1 otherwise req(G1,r′)≥ req(g′,r′) = |C|. So G1 ⊆ G and we already had G1 ∈ succΓ′(C). Therefore G1 ∈ succΓ(C) and so SC answers YES.\nTheorem 6.6. The parameterized complexity status of (C,G0,r)-Optimality is as follows :\n• FPT when parameterized by |G|\n• co-W[1]-hard when parameterized by |C|\n• co-para-NP-hard when parameterized by |R|\nProof. When parameterized by |G|, we consider all 2|G| subsets of G. For each subset, we can check in polynomial time if it is a member of succ(C) and if it requires atleast req(G0,r′) quantity of resource r′ where G0 and r′ are given in the input. The other two claims follow from Lemma 6.5, Theorem 3.8 in Shrot et al., and Theorem 5.1."
    }, {
      "heading" : "7 Problems Related to Resource Bounds",
      "text" : ""
    }, {
      "heading" : "7.1 R-Pareto Efficient Goal Set (RPEGS)",
      "text" : "We use the idea of Pareto Efficiency to measure the optimality of a goal set w.r.t the set of all resources. In our model we say that a goal set G′ is R-Pareto Efficient w.r.t a coalition C if no goal set in succΓ(C) requires at most as much of every resource and strictly less of some resource. More formally we say that a goal set G′ is R-Pareto Efficient w.r.t a coalition C if and only if ∀ G′′ ∈ succΓ(C),\n∃ r1 ∈ R : req(G′′,r1)< req(G′,r1) ⇒ ∃ r2 ∈ R : req(G′′,r2)> req(G′,r2)\nWe note that G′ is not necessarily in succ(C). Thus we have the R-PARETO EFFICIENT GOAL SET problem: Given a coalition C and a goal set G0 answer YES if and only if G0 is R-Pareto Efficient w.r.t C. Wooldridge et al. [8] show that RPEGS is strongly co-NP-complete. To prove the parameterized hardness results, we give a reduction from SC to RPEGS.\nLemma 7.1. Given an instance (Γ,C) of SC we can construct an instance (Γ′,C′,G0) of RPEGS such that SC answers YES iff RPEGS answers NO.\nProof. Define R′ = R∪{r′},G′ = G∪{g′} and C′ = C. We extend the en to r′ as follows: en(i,r′) = |G| for all i ∈ C and en(i,r′) = 0 if i /∈ C. We extend req to r′ as follows: req(g,r′) = |C| for all g ∈ G; req(g′,r′) = |G| · |C|+1 and req(g′,r) = ∞ for all r ∈ R. Let G0 = {g′}. Now claim is that SC answers YES iff RPEGS answers NO.\nWe first show that succΓ(C) = succΓ′(C). Let G1 ∈ succΓ′(C). Then claim is that g′ /∈ G1 because otherwise for all r ∈ R we have req(G1,r) ≥ req(g′,r) = ∞ > |G| · |C| = en(C,r). Also claim is that any goal set G2 in succΓ(C) also is in succΓ′(C). All other things carry over from Γ and we have additionally that req(G2,r′) = |G2| · |C| ≤ |G| · |C|= en(C,r′) as G2 ⊆ G. Hence we have succΓ(C) = succΓ′(C).\nSuppose SC answers YES, i.e., ∃ G1 ∈ succΓ(C). As succΓ(C) = succΓ′(C) we have G1 ∈ succΓ′(C). Now for every r ∈ R, req(G1,r) < ∞ = req(G0,r). Also req(G1,r′) = |G1| · |C| ≤ |G| · |C|< |G| · |C|+1 = req(G0,r′). Therefore G0 requires strictly more of every resource in R′ than G1 and hence RPEGS answers NO.\nSuppose RPEGS answers NO. Claim is that succΓ′(C) 6= /0 otherwise it would have answered YES vacuously. As succΓ(C) = succΓ′(C) we have succΓ(C) 6= /0 and hence SC answers YES.\nTheorem 7.2. The parameterized complexity status of R-Pareto Efficient Goal Set is as follows :\n• FPT when parameterized by |G|\n• co-W[1]-hard when parameterized by |C|\n• co-para-NP-hard when parameterized by |R|\nProof. When parameterized by |G|, we consider all 2|G| subsets of G. For each subset, we can check in polynomial time if it is a member of succ(C) and if it shows that G0 is not R-Pareto Efficient.\nThe other two claims follow from Lemma 7.1, Theorem 3.8 in Shrot et al., and Theorem 5.1."
    }, {
      "heading" : "7.2 Successful Coalition with Resource Bound (SCRB)",
      "text" : "In real-life situations we typically have a bound on the amount of each resource. A resource bound is a function b : R → N with the interpretation that each coalition has at most b(r) quantity of resource r for every r ∈ R. We say that a goal set G0 respects a resource bound b w.r.t. a given CRG Γ iff ∀ r ∈ R we have b(r)≥ req(G0,r). Thus we have the SUCCESSFUL COALITION WITH RESOURCE BOUND problem: Given a coalition C and a resource bound b answer YES if and only if ∃ G0 ∈ succ(C) such that G0 respects b. Wooldridge et al. [8] show that SCRB is strongly NP-complete. To prove the parameterized hardness results, we give a reduction from SC to SCRB.\nLemma 7.3. Given an instance (Γ,C) of SC we can construct an instance (Γ′,C′,b’) of SCRB such that SC answers YES if and only if SCRB answers NO.\nProof. Define R′ = R∪{r′} and C′ =C. Let b be a vector with |R′| components whose first |R′|−1 entries are 1 and the last entry is |C| − 1, i.e., b = {1,1, . . . ,1,1, |C| − 1}. We extend the en to r′ as follows: en(i,r′) = |G| for all i ∈C and en(i,r′) = 0 if i /∈C. We extend req to r′ as follows: req(g,r′) = |C| for all g ∈ G. Now the claim is that SC answers YES if and only if SCRB answers NO.\nSuppose SC answers YES. So, there exists G0 6= /0 such that G0 ∈ succΓ(C). In Γ′ we have en(C,r′) = |G| · |C| ≥ req(G0,r′) as G0 ⊆ G and req(g,r′) = |C| for all g ∈ G. Thus G0 ∈ succΓ′(C) and so SCRB cannot vacuously answer YES. Now, for any G′′ ∈ succΓ′(C) such that G′′ 6= /0 we have req(G′′,r′)≥ |C|> |C|− 1 = b(r′). This means that no goal set in the non-empty set succΓ′(C) respects b which implies that SCRB answers NO.\nSuppose SCRB answers NO. So ∃ G0 ∈ succΓ′(C) such that G0 6= /0 and G0 respects b. As Γ′ was obtained from Γ by adding a resource and keeping everything else same, we have G0 ∈ succΓ(C) and hence SC answers YES.\nTheorem 7.4. The parameterized complexity status of Successful Coalition With Resource Bound (SCRB) is as follows:\n• FPT when parameterized by |G|\n• co-W[1]-hard when parameterized by |C|\n• co-para-NP-hard when parameterized by |R|\nProof. When parameterized by |G|, we consider all 2|G| subsets of G. For each subset,we can check in polynomial time if it is a member of succ(C) and if it requires non-zero quantity of the resource given in the input.\nThe other two claims follow from Lemma 7.3, Theorem 3.8 in Shrot et al., and Theorem 5.1."
    }, {
      "heading" : "8 Problems Related to Resource Conflicts",
      "text" : ""
    }, {
      "heading" : "8.1 Conflicting Coalitions (CC)",
      "text" : "When two or more coalitions desire to use some scarce resource, it leads to a conflict in the system. This issue is a classic problem in distributed and concurrent systems. In our framework we say that two goal\nsets are in conflict w.r.t a resource bound if they are individually achievable within the resource bound but their union is not. Formally a resource bound is a function b : R → N with the interpretation that each coalition has at most b(r) quantity of resource r for every r ∈ R. We say that a goal set G0 respects a resource bound b w.r.t. a given CRG Γ if and only if ∀ r ∈ R we have b(r) ≥ req(G0,r). We denote by cgs(G1,G2,b) the fact that G1 and G2 are in conflict w.r.t b. Formally, cgs(G1,G2,b) is defined as respects(G1,b)∧ respects(G2,b)∧¬respects(G1 ∪G2,b). Thus we have the CONFLICTING COALITIONS problem: Given coalitions C1,C2 and a resource bound b answer YES if and only if ∀ G1 ∈ succ(C1) and ∀ G2 ∈ succ(C2) we have cgs(G1,G2,b). Wooldridge et al. [8] show that CC is strongly co-NP-complete. To prove the parameterized hardness results, we give a reduction from SC to CC.\nLemma 8.1. Given an instance (Γ,C) of SC we can construct an instance (Γ′,C′1,C′2,b) of CC such that SC answers YES if and only if CC answers NO.\nProof. Define R′ = R∪{r′} and C′1 = C = C ′ 2. Let b be a vector with |R ′| components whose first |R′|− 1 entries are ∞ and the last entry is |G| · |C|, i.e., b = {∞,∞, . . . ,∞,∞, |G| · |C|}. We extend the en to r′ as follows: en(i,r′) = |G| for all i ∈C and en(i,r′) = 0 if i /∈C. We extend req to r′ as follows: req(g,r′) = |C| for all g ∈ G. Now the claim is that SC answers YES if and only if CC answers NO.\nFirst we claim that succΓ(C) = succΓ′(C). We built Γ′ from Γ by just adding one resource and so clearly succΓ′(C) ⊆ succΓ(C). Now let G′′ ∈ succΓ(C). Then req(G′′,r′) = |G′′| · |C| ≤ |G| · |C| = en(C,r′) and G′′ ∈ succΓ′(C). Summarizing we have our claim.\nSuppose SC answers YES. So, there exists G0 6= /0 such that G0 ∈ succΓ(C). As succΓ(C) = succΓ′(C) we have G0 ∈ succΓ′(C). As C′1 =C =C ′ 2 the cgs condition fails for G1 = G0 = G2 and so CC answers NO.\nSuppose CC answers NO. Claim is that succΓ′(C) 6= /0. If not then succΓ′(C′1) = /0 = succΓ′(C ′ 2) and in fact CC would have vacuously answered YES. But succΓ(C) = succΓ′(C) and so succΓ(C) 6= /0. Thus SC answers YES.\nTheorem 8.2. The parameterized complexity status of Conflicting Coalitions (CC) is as follows :\n• FPT when parameterized by |G|\n• co-W[1]-hard when parameterized by |C|\n• co-para-NP-hard when parameterized by |R|\nProof. When parameterized by |G|, we consider all 2|G| choices for G1 and G2. Given a choice (G1,G2) we can check in polynomial time if G1 and G2 are members of succ(C1) and succ(C2) respectively. Also we can check the condition cgs(G1,G2,b) in polynomial time.\nThe other two claims follow from Lemma 8.1, Theorem 3.8 in Shrot et al., and Theorem 5.1.\n9 The Parameter |Ag|+ |R| : Case of Bounded Agents plus Resources\nConsidering the results in previous sections, we can see that even in the case that size of coalition or number of resources is bounded the problem still remains computationally hard. So a natural question is what happens if we have a bound on |Ag|+ |R| ? Can we do better if total number of agents plus resources is bounded? Shrot et.al [5] show that by this parameterization the problems SC, MAXC and MAXSC have FPT algorithms and they left the corresponding question for the ESCK open. We will generalize the integer program given in Theorem 3.1 of [5], to give a FPT algorithm for the open problem of Existence of Successful Coalition of size k (ESCK). Then by using a similar approach we will design FPT algorithms for the four other problems (NR, SNR, CGRO, SCRB) considered in this paper.\nThe integer program we define is a satisfiability problem (rather than an optimization problem). It consists of a set of constraints, and the question is whether there exists an integral solution to this set. Consider the following integer program (which we will name as IP):\n∀i ∈ Ag : ∑ g∈Gi xg ≥ yi (1) ∀r ∈ R : ∑ g∈G xg × req(g,r) ≤ ∑ i∈Ag yi × en(i,r) (2)\n∀g ∈ G : xg ∈ {0,1}\n∀i ∈ Ag : yi ∈ {0,1}\nIn this setting, yi = 1, for each i ∈ Ag, represents the situation that the agent i is participating in the coalition and xg = 1, for each g ∈ G, represents the situation that goal g is achieved. The first constraint guarantees that any participating agent has at least one of his goals achieved. The second constraint ensures that the participating agents have enough endowment to achieve all of the chosen goals. It is clear that any solution for this integer program is a coalition of agents and a successful set of goals for that coalition.\nThe above integer program has |Ag|+ |R| constraints and in Flum and Grohe [3] it is shown that checking feasibility of INTEGER LINEAR PROGRAMMING is FPT in the number of constraints or in the number of variables. Now for each of our problems we will add some constraints to get new integer programs which solve those problems.\nTheorem 9.1. Checking whether there is a Successful Coalition of size k (ESCK) is FPT when parameterized by |Ag|+ |R|.\nProof. For ESCK, the general integer program given above needs only one additional constraint: We have to ensure that exactly k number of agents will be selected. Therefore adding the constraint ∑i∈Ag yi = k gives us the integer program for the problem ESCK. The number of constraints, i.e., |Ag|+ |R|+1 for this integer program is |Ag|+ |R|+ 1 and as INTEGER LINEAR PROGRAMMING is FPT w.r.t number of variables or constraints we have that ESCK parameterized by |Ag|+ |R| is FPT.\nIn the problems NR, SNR and CGRO the coalition C is always given. So we will change the variables yi’s to constants where yi = 1 if i ∈C and 0 otherwise. We call this new integer program a Fixed Coalition Integer Program (FCIP). The coalition C is successful if and only if FCIP is satisfiable.\nTheorem 9.2. Checking whether the Resource r is Needed for a Coalition C to be Successful (NR) is FPT when parameterized by |Ag|+ |R|.\nProof. We start with the integer program FCIP. The answer to NR is YES, if and only if in any successful subset of goals, there is at least one goal g with req(g,r) > 0. So we just need to check and see if the coalition is successful by only using the goals which do not need the resource r. Therefore in FCIP, for all goals g ∈ G where req(g,r) > 0 we will set the variable xg to zero. Now the answer to NR is YES iff the resulting integer program is not satisfiable. Note that the number of constraints is still same as previously - |Ag|+ |R|. As INTEGER LINEAR PROGRAMMING is FPT wrt number of variables or constraints we have that NR parameterized by |Ag|+ |R| is FPT.\nTheorem 9.3. Checking whether the Resource r is Strictly Needed for a Coalition C to be Successful (SNR) is FPT when parameterized by |Ag|+ |R|.\nProof. We start with the integer program FCIP. Since SNR answers NO when the coalition is not successful, we should first check if the coalition is successful. Therefore we will check the answer to FCIP. If it is not satisfiable, then the answer for SNR would be NO. But if FCIP is satisfiable, i.e., succ(C) 6= /0, then we just need to check and see if the coalition is successful by only using the goals which do not need the resource r. Again with the same approach as the proof of Theorem 9.2, for all goals g ∈ G where req(g,r) > 0 we will set the variable xg to zero. Now the answer to SNR is YES iff the resulting IP is not satisfiable. Note that the number of constraints is still same as previously - |Ag|+ |R|. As INTEGER LINEAR PROGRAMMING is FPT w.r.t number of variables or constraints we have that SNR parameterized by |Ag|+ |R| is FPT.\nTheorem 9.4. Checking whether the successful goal set G0 has optimal usage of Resource r for a Coalition C (CGRO) is FPT when parameterized by |Ag|+ |R|.\nProof. We start with the integer program FCIP. The limit on usage of resource r is req(G0,r). Let β = req(G0,r) be the limit. So the answer for CGRO is YES iff there is no successful set of goals G′ with req(G′,r) < β . So by adding the constraint ∑g∈G xg × req(g,r) < β to FCIP, the answer for CGRO would be YES iff the resulting IP is not satisfiable. Note that the number of constraints |Ag|+ |R|+1. As INTEGER LINEAR PROGRAMMING is FPT w.r.t number of variables or constraints we have that CGRO parameterized by |Ag|+ |R| is FPT.\nTheorem 9.5. Checking whether a given coalition C is Successful by respecting the Resource Bound b (SCRB) is FPT when parameterized by |Ag|+ |R|.\nProof. We start with the integer program FCIP. Now the limit on usage of any resource r ∈ R is b(r). So for every resource r ∈ R we will bound its usage by adding the constraint ∑g∈G xg × req(g,r) ≤ b(r) to FCIP. Now the answer for SCRB would be YES if and only if the resulting integer program is satisfiable. Note that number of constraints now is |Ag|+ 2|R| and INTEGER LINEAR PROGRAMMING is FPT w.r.t number of variables or constraints we have that SCRB is FPT w.r.t |Ag|+2|R| and hence wrt |Ag|+ |R|.\nTheorem 9.6. Checking whether a given goal set G0 is R-Pareto Efficient (RPEGS) is FPT when parameterized by |Ag|+ |R|.\nProof. As in the proof of Theorem 9.5, set the variables yi = 1 if i ∈ C and 0 otherwise. The answer for the problem is NO if there exists a successful G′ such that there is a resource r ∈ R such that req(G′,r) < req(G0,r) and for every other resource r′ ∈R we have req(G′,r′)≤ req(G0,r′). Since G0 is given, req(G0,r) is a constant. So we can write |R| IPs, such that in the integer program for the resource r, we have the constraint req(G′,r)< req(G0,r), and |R|−1 constraints req(G′,r′)≤ req(G0,r′), one for each resource r′ 6= r. Now the answer for RPEGS would be YES iff all |R| integer programs are not satisfiable. Note that the number of constraints in each of the integer programs is |Ag|+ 2|R| and INTEGER LINEAR PROGRAMMING is FPT w.r.t number of variables or constraints we have that RPEGS is FPT w.r.t |Ag|+ 2|R| and hence w.r.t |Ag|+ |R|.\nNow we give an integer quadratic program for the CC problem :\n∀i ∈ Ag : ∑ g∈Gi xg ≥ yi (1)\n∀r ∈ R : ∑ g∈G xg × req(g,r) ≤ ∑ i∈Ag yi × en(i,r) (2)\n∀g ∈ G : xg ∈ {0,1}\n∀i ∈ Ag : yi ∈ {0,1}\n∀i ∈ Ag : ∑ g∈Gi Xg ≥ Yi (3)\n∀r ∈ R : ∑ g∈G Xg × req(g,r) ≤ ∑ i∈Ag Yi × en(i,r) (4)\n∀g ∈ G : Xg ∈ {0,1}\n∀i ∈ Ag : Yi ∈ {0,1}\nIn the first sub-program, we set yi = 1 if i ∈C1 and 0 otherwise. Then this sub-program finds a goal set G1 ∈ succΓ(C1). The second sub-program is similar. Now we add the resource bound conditions :\n∀ r ∈ R ∑ g∈G xg × req(g,r) ≤ b(r)\n∀ r ∈ R ∑ g∈G Xg × req(g,r) ≤ b(r)\n∃ r ∈ R s.t. ∑ g∈G\n( xg +Xg −xg ·Xg ) × req(g,r) > b(r)\nThe first two conditions state that both G1 and G2 respect b and the third condition says that G1 ∪G2 does not respect b. However the above program is quadratic due to the last constraint and there is no known result about fixed parameter tractability for quadratic integer programs. Hence we leave open the question about status of CC parameterized by |Ag|+ |R|.\n10 Revisiting ESCK Parameterized by |G|\nShrot et al. [5] show in Theorem 3.2 of their paper that ESCK parameterized by |G| is FPT. We first show their proposed FPT algorithm is wrong by giving an instance when their algorithm gives incorrect answer. Then we show that in fact the problem is para-NP-hard via a reduction from the independent set problem."
    }, {
      "heading" : "10.1 Counterexample to the Algorithm Given in Theorem 3.2 of Shrot et al. [5]",
      "text" : "The algorithm is as follows:\n1. For each G′ ⊆ G\n• Let C′ be set of all agents satisfied by G′\n• If |C′| 6= k , go to 1.\n• If G′ is feasible for C′, return TRUE\n2. return FALSE\nWe give an instance Γ where the above algorithm gives an incorrect answer. Suppose |Ag| > k, each agent has 1 unit of endowment of each resource, each goal requires 0 of each resource, and Gi = G for all agents i ∈ Ag. Thus each coalition is successful and ∀ G′ ⊆ G we have C′ = Ag which means that |C′| = |Ag| > k and so the algorithm answers NO while the correct answer is YES. Indeed by reducing Independent Set to a CRG instance with |G|= 1, we prove the following theorem.\nTheorem 10.1. ESCK parameterized by |G| is para-NP-hard.\nProof. We prove this by reduction from INDEPENDENT SET to a CRG with |G| = 1. Let H = (V,E) be a given graph and let k be the given parameter. Let V = {v1,v2, . . . ,vn} and E = {e1,e2, . . . ,em}. We build an instance (Γ,k) of ESCK where\n• Ag = {a1,a2, . . . ,an}\n• R = {r1,r2, . . . ,rm}\n• G = {g}\n• Gi = G ∀ i ∈ Ag\n• req(g,r j) = k−1 ∀ j ∈ [m]\n• en(ai,r j) = 0 if vi and e j are incident and 1 otherwise\nWe now claim that INDEPENDENT SET answers YES if and only if ESCK answers YES. Suppose INDEPENDENT SET answers YES, i.e., H has an independent set of size k say I = {vβ1 ,vβ2 , . . . ,vβk}. Consider the following coalition of size k: C = {aβ1 ,aβ2 , . . . ,aβk}. Clearly the goal set {g} is satisfying for C. Also, as I is independent set the number of vertices from I incident on any r j is atmost 1. So ∀ j ∈ [m] we have req(g,r j) = k−1 ≤ en(C,r j) and so {g} is feasible for C which means that C is successful coalition. As |C|= k we have that ESCK answers YES.\nSuppose that ESCK answers YES. So there exists a successful coalition of size k in Γ say C = {aβ1 ,aβ2 , . . . ,aβk}. Consider the set of vertices I = {vβ1 ,vβ2 , . . . ,vβk} in V . We claim that it is an independent set. Suppose not and let e j be an edge joining vβi and vβl such that vβl ,vβl ∈ I. Then we have en(C,r j) ≤ k− 2 < k− 1 = req(g,r j) which contradicts the fact that C is successful (Since G = {g} the only possible goal set is {g}). Therefore I is an independent set and as |I|= k we have that INDEPENDENT SET answers YES.\nNote that as |G|= 1 in our CRG Γ and INDEPENDENT SET is known to be NP-hard we have that ESCK parameterized by |G| is para-NP-hard."
    }, {
      "heading" : "11 Conclusions and Directions for Future Work",
      "text" : "We considered some of the problems regarding resources bounds and resource conflicts which were shown to be computationally hard in [8] but were not considered in [5]. We also solved 3 open questions posed in [5] by showing that\n1. SC parameterized by |C| is W[1]-hard\n2. ESCK parameterized by |Ag|+ |R| is FPT\n3. ESCK parameterized by |R| is para-NP-hard\nWe also found a bug in Theorem 3.2 of [5] which claimed that ESCK parameterized by |G| is FPT. We give a counterexample to their algorithm and in fact show that the problem is para-NP-hard. Then for some problems related to resources, resource bounds and resource conflicts like NR, SNR, CGRO, RPEGS, SCRB and CC we have results when parameterized by various natural parameters like |G|, |C|, |R| and |Ag|+ |R| (only CC parameterized by |Ag|+ |R| is left open).\nThese results help us to understand better the role of the various components of the input and identify exactly the ones which make the input hard. Since all the problems are known to be FPT when parameterized by |G| and all of them except CC are known to be FPT when parameterized by |Ag|+ |R| we know that our problems are tractable when the goal set is small. With this knowledge we can even want to enforce this restriction in real-life situations as much as possible. On the other hand we know that all the problems we considered remain intractable when parameterized by |C| or |R| and hence there is no point in trying to restrict size of coalition or number of resources as it does not make the computation faster\nThe study of problems arising in coalitions of agents in multi-agents systems using the parameterized complexity paradigm was initiated by Shrot et al. [5] In this paper we have tried to take a further step in this direction which we believe is still unexplored. There are various (classically) computationally hard problems which need to be better analyzed through the rich theory of parameterized complexity.\nBoth in Shrot et al. [5] and this paper only the CRG model has been considered. In CRG model the status of CC parameterized by |Ag|+ |R| is left open. Alternatively one might consider other natural parameters like |Ag| or try to examine other models like the QCG model [7] through parameterized complexity analysis."
    }, {
      "heading" : "12 Acknowledgments",
      "text" : "We would like to thank Yuk Hei (Tom) Chan, Dana Nau and Kanthi Sarpatwar for helpful discussions."
    } ],
    "references" : [ {
      "title" : "Complexity of constructing solutions in the core based on synergies among coalitions",
      "author" : [ "V. Conitzer", "T. Sandholm" ],
      "venue" : "Artificial Intelligence 170 (6-7) ",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Parameterized complexity for the skeptic",
      "author" : [ "R. Downey" ],
      "venue" : "in: In Proc. 18th IEEE Annual Conference on Computational Complexity",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Parameterized Complexity Theory (Texts in Theoretical Computer Science",
      "author" : [ "J. Flum", "M. Grohe" ],
      "venue" : "An EATCS Series), Springer-Verlag New York, Inc.",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "D",
      "author" : [ "M.R. Garey" ],
      "venue" : "S. Johnson, Computers and Intractability: A Guide to the Theory of NP-Completeness",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 1979
    }, {
      "title" : "Easy and hard coalition resource game formation problems: a parameterized complexity analysis",
      "author" : [ "T. Shrot", "Y. Aumann", "S. Kraus" ],
      "venue" : "in: AAMAS (1)",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "An Introduction to Multiagent Systems",
      "author" : [ "M. Wooldridge" ],
      "venue" : "2nd ed., Wiley, Chichester, UK",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "On the computational complexity of qualitative coalitional games",
      "author" : [ "M. Wooldridge", "P.E. Dunne" ],
      "venue" : "Artificial Intelligence 158 (1) ",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "On the computational complexity of coalitional resource games",
      "author" : [ "M. Wooldridge", "P.E. Dunne" ],
      "venue" : "Artificial Intelligence 170 (10) ",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2006
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "We answer an important question left open by Shrot, Aumann and Kraus by showing that the SC Problem (checking whether a Coalition is Successful) is W[1]-hard when parameterized by the size of the coalition.",
      "startOffset" : 149,
      "endOffset" : 152
    }, {
      "referenceID" : 0,
      "context" : "W[1]-hard or co-W[1]-hard when parameterized by the size of the coalition.",
      "startOffset" : 1,
      "endOffset" : 4
    }, {
      "referenceID" : 0,
      "context" : "W[1]-hard or co-W[1]-hard when parameterized by the size of the coalition.",
      "startOffset" : 17,
      "endOffset" : 20
    }, {
      "referenceID" : 5,
      "context" : "1 Coalitions In multi-agent systems (MAS), where each agent has limited resources, the formation of coalitions of agents is a very powerful tool [6].",
      "startOffset" : 145,
      "endOffset" : 148
    }, {
      "referenceID" : 6,
      "context" : "Unfortunately, a range of previous studies have shown that many of these problems are computationally complex [7, 8].",
      "startOffset" : 110,
      "endOffset" : 116
    }, {
      "referenceID" : 7,
      "context" : "Unfortunately, a range of previous studies have shown that many of these problems are computationally complex [7, 8].",
      "startOffset" : 110,
      "endOffset" : 116
    }, {
      "referenceID" : 3,
      "context" : "Nonetheless, as noted by Garey and Johnson [4], hardness results, such as NP-completeness, should merely constitute the beginning of the research.",
      "startOffset" : 43,
      "endOffset" : 46
    }, {
      "referenceID" : 7,
      "context" : "2 Formal Model of Coalition Resource Games The framework we use to model coalitions is the CRG model introduced in [8], defined as follows.",
      "startOffset" : 115,
      "endOffset" : 118
    }, {
      "referenceID" : 0,
      "context" : "SC ESCK MAXC, MAXSC |G| FPT FPT FPT |C| ? W[1]-Hard W[1]-Hard |R| para-NP-Hard ? para-NP-Hard |Ag|+ |R| FPT ? FPT",
      "startOffset" : 43,
      "endOffset" : 46
    }, {
      "referenceID" : 0,
      "context" : "SC ESCK MAXC, MAXSC |G| FPT FPT FPT |C| ? W[1]-Hard W[1]-Hard |R| para-NP-Hard ? para-NP-Hard |Ag|+ |R| FPT ? FPT",
      "startOffset" : 53,
      "endOffset" : 56
    }, {
      "referenceID" : 4,
      "context" : "[5]",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 0,
      "context" : "The CRG models many real-world situations like the virtual organizations problem [1] and voting domains.",
      "startOffset" : 81,
      "endOffset" : 84
    }, {
      "referenceID" : 4,
      "context" : "[5] considered the following four problems related to coalitions.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "[5] are summarized in Figure 1.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 7,
      "context" : "[8] but were not considered by Shrot et al.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "[5].",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 2,
      "context" : "The definitions in this section are taken from [3] and [2].",
      "startOffset" : 47,
      "endOffset" : 50
    }, {
      "referenceID" : 1,
      "context" : "The definitions in this section are taken from [3] and [2].",
      "startOffset" : 55,
      "endOffset" : 58
    }, {
      "referenceID" : 0,
      "context" : "Two of these classes are the class W[1] and the class para-NP.",
      "startOffset" : 36,
      "endOffset" : 39
    }, {
      "referenceID" : 0,
      "context" : "Thus, W[1]-hard and para-NP-hard problems are most probably not fixed-parameter tractable.",
      "startOffset" : 7,
      "endOffset" : 10
    }, {
      "referenceID" : 0,
      "context" : "The class W[1] can be defined by its core complete problem, defined as follows:",
      "startOffset" : 11,
      "endOffset" : 14
    }, {
      "referenceID" : 0,
      "context" : "The class W[1] contains all parameterized problems FPT-reducible (defined hereunder) to Short-Nondeterministic-Turing-Machine-Computation.",
      "startOffset" : 11,
      "endOffset" : 14
    }, {
      "referenceID" : 7,
      "context" : "([8]) but were not considered in Shrot et al.",
      "startOffset" : 1,
      "endOffset" : 4
    }, {
      "referenceID" : 4,
      "context" : "[5].",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 0,
      "context" : "SC parameterized by |C| is W[1]-hard",
      "startOffset" : 28,
      "endOffset" : 31
    }, {
      "referenceID" : 0,
      "context" : "We complete this hardness result by showing that SC parameterized by |C| is W[1]-hard and thus answer their open question.",
      "startOffset" : 77,
      "endOffset" : 80
    }, {
      "referenceID" : 4,
      "context" : "[5] is false - which claims that",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 0,
      "context" : "SC ESCK NR,CGRO,RPEGS SNR SCRB CC NPC NPC co-NPC Dp-complete NPC co-NPC |G| FPT FPT p-NP-hard FPT FPT FPT FPT |C| W[1]-hard W[1]-hard co-W[1]-hard W[1]-hard co-W[1]-hard co-W[1]-hard |R| p-NP-hard p-NP-hard co-pNP-hard pNP-hard co-pNP-hard co-pNP-hard |Ag|+ |R| FPT FPT FPT FPT FPT ?",
      "startOffset" : 115,
      "endOffset" : 118
    }, {
      "referenceID" : 0,
      "context" : "SC ESCK NR,CGRO,RPEGS SNR SCRB CC NPC NPC co-NPC Dp-complete NPC co-NPC |G| FPT FPT p-NP-hard FPT FPT FPT FPT |C| W[1]-hard W[1]-hard co-W[1]-hard W[1]-hard co-W[1]-hard co-W[1]-hard |R| p-NP-hard p-NP-hard co-pNP-hard pNP-hard co-pNP-hard co-pNP-hard |Ag|+ |R| FPT FPT FPT FPT FPT ?",
      "startOffset" : 125,
      "endOffset" : 128
    }, {
      "referenceID" : 0,
      "context" : "SC ESCK NR,CGRO,RPEGS SNR SCRB CC NPC NPC co-NPC Dp-complete NPC co-NPC |G| FPT FPT p-NP-hard FPT FPT FPT FPT |C| W[1]-hard W[1]-hard co-W[1]-hard W[1]-hard co-W[1]-hard co-W[1]-hard |R| p-NP-hard p-NP-hard co-pNP-hard pNP-hard co-pNP-hard co-pNP-hard |Ag|+ |R| FPT FPT FPT FPT FPT ?",
      "startOffset" : 138,
      "endOffset" : 141
    }, {
      "referenceID" : 0,
      "context" : "SC ESCK NR,CGRO,RPEGS SNR SCRB CC NPC NPC co-NPC Dp-complete NPC co-NPC |G| FPT FPT p-NP-hard FPT FPT FPT FPT |C| W[1]-hard W[1]-hard co-W[1]-hard W[1]-hard co-W[1]-hard co-W[1]-hard |R| p-NP-hard p-NP-hard co-pNP-hard pNP-hard co-pNP-hard co-pNP-hard |Ag|+ |R| FPT FPT FPT FPT FPT ?",
      "startOffset" : 148,
      "endOffset" : 151
    }, {
      "referenceID" : 0,
      "context" : "SC ESCK NR,CGRO,RPEGS SNR SCRB CC NPC NPC co-NPC Dp-complete NPC co-NPC |G| FPT FPT p-NP-hard FPT FPT FPT FPT |C| W[1]-hard W[1]-hard co-W[1]-hard W[1]-hard co-W[1]-hard co-W[1]-hard |R| p-NP-hard p-NP-hard co-pNP-hard pNP-hard co-pNP-hard co-pNP-hard |Ag|+ |R| FPT FPT FPT FPT FPT ?",
      "startOffset" : 161,
      "endOffset" : 164
    }, {
      "referenceID" : 0,
      "context" : "SC ESCK NR,CGRO,RPEGS SNR SCRB CC NPC NPC co-NPC Dp-complete NPC co-NPC |G| FPT FPT p-NP-hard FPT FPT FPT FPT |C| W[1]-hard W[1]-hard co-W[1]-hard W[1]-hard co-W[1]-hard co-W[1]-hard |R| p-NP-hard p-NP-hard co-pNP-hard pNP-hard co-pNP-hard co-pNP-hard |Ag|+ |R| FPT FPT FPT FPT FPT ?",
      "startOffset" : 174,
      "endOffset" : 177
    }, {
      "referenceID" : 7,
      "context" : "The results from [8] are in green, from [5] in black and our results are in red color.",
      "startOffset" : 17,
      "endOffset" : 20
    }, {
      "referenceID" : 4,
      "context" : "The results from [8] are in green, from [5] in black and our results are in red color.",
      "startOffset" : 40,
      "endOffset" : 43
    }, {
      "referenceID" : 4,
      "context" : "[5]",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 0,
      "context" : "First we show that SC parameterized by |C| is W[1]-hard.",
      "startOffset" : 47,
      "endOffset" : 50
    }, {
      "referenceID" : 0,
      "context" : "SC is W[1]-hard when parameterized by |C|.",
      "startOffset" : 7,
      "endOffset" : 10
    }, {
      "referenceID" : 0,
      "context" : "We prove this by reduction from Independent Set (parameterized by size of independent set) which is a well-known W[1]-complete problem.",
      "startOffset" : 114,
      "endOffset" : 117
    }, {
      "referenceID" : 0,
      "context" : "Note that |Ag|= k, |G|= nk, |R|= m and so this reduction shows that the SC problem is W[1]-hard.",
      "startOffset" : 87,
      "endOffset" : 90
    }, {
      "referenceID" : 4,
      "context" : "8 of [5].",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 7,
      "context" : "[8].",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 0,
      "context" : "• co-W[1]-hard when parameterized by |C|",
      "startOffset" : 6,
      "endOffset" : 9
    }, {
      "referenceID" : 7,
      "context" : "[8].",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 0,
      "context" : "• W[1]-hard when parameterized by |C|",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 7,
      "context" : "[8].",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 0,
      "context" : "• co-W[1]-hard when parameterized by |C|",
      "startOffset" : 6,
      "endOffset" : 9
    }, {
      "referenceID" : 7,
      "context" : "[8] show that RPEGS is strongly co-NP-complete.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 0,
      "context" : "• co-W[1]-hard when parameterized by |C|",
      "startOffset" : 6,
      "endOffset" : 9
    }, {
      "referenceID" : 7,
      "context" : "[8] show that SCRB is strongly NP-complete.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 0,
      "context" : "• co-W[1]-hard when parameterized by |C|",
      "startOffset" : 6,
      "endOffset" : 9
    }, {
      "referenceID" : 7,
      "context" : "[8] show that CC is strongly co-NP-complete.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 0,
      "context" : "• co-W[1]-hard when parameterized by |C|",
      "startOffset" : 6,
      "endOffset" : 9
    }, {
      "referenceID" : 4,
      "context" : "al [5] show that by this parameterization the problems SC, MAXC and MAXSC have FPT algorithms and they left the corresponding question for the ESCK open.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 4,
      "context" : "1 of [5], to give a FPT algorithm for the open problem of Existence of Successful Coalition of size k (ESCK).",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 2,
      "context" : "The above integer program has |Ag|+ |R| constraints and in Flum and Grohe [3] it is shown that checking feasibility of INTEGER LINEAR PROGRAMMING is FPT in the number of constraints or in the number of variables.",
      "startOffset" : 74,
      "endOffset" : 77
    }, {
      "referenceID" : 4,
      "context" : "[5] show in Theorem 3.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "[5] The algorithm is as follows: 1.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 7,
      "context" : "We considered some of the problems regarding resources bounds and resource conflicts which were shown to be computationally hard in [8] but were not considered in [5].",
      "startOffset" : 132,
      "endOffset" : 135
    }, {
      "referenceID" : 4,
      "context" : "We considered some of the problems regarding resources bounds and resource conflicts which were shown to be computationally hard in [8] but were not considered in [5].",
      "startOffset" : 163,
      "endOffset" : 166
    }, {
      "referenceID" : 4,
      "context" : "We also solved 3 open questions posed in [5] by showing that",
      "startOffset" : 41,
      "endOffset" : 44
    }, {
      "referenceID" : 0,
      "context" : "SC parameterized by |C| is W[1]-hard",
      "startOffset" : 28,
      "endOffset" : 31
    }, {
      "referenceID" : 4,
      "context" : "2 of [5] which claimed that ESCK parameterized by |G| is FPT.",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 4,
      "context" : "[5] In this paper we have tried to take a further step in this direction which we believe is still unexplored.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "[5] and this paper only the CRG model has been considered.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 6,
      "context" : "Alternatively one might consider other natural parameters like |Ag| or try to examine other models like the QCG model [7] through parameterized complexity analysis.",
      "startOffset" : 118,
      "endOffset" : 121
    } ],
    "year" : 2011,
    "abstractText" : "Coalition formation is a key topic in multi-agent systems. Coalitions enable agents to achieve goals that they may not have been able to achieve on their own. Previous work has shown problems in coalition games to be computationally hard. Wooldridge and Dunne (Artificial Intelligence 2006) studied the classical computational complexity of several natural decision problems in Coalitional Resource Games (CRG) games in which each agent is endowed with a set of resources and coalitions can bring about a set of goals if they are collectively endowed with the necessary amount of resources. The input of coalitional resource games bundles together several elements, e.g., the agent set Ag, the goal set G, the resource set R, etc. Shrot, Aumann and Kraus (AAMAS 2009) examine coalition formation problems in the CRG model using the theory of Parameterized Complexity. Their refined analysis shows that not all parts of input act equal some instances of the problem are indeed tractable while others still remain intractable. We answer an important question left open by Shrot, Aumann and Kraus by showing that the SC Problem (checking whether a Coalition is Successful) is W[1]-hard when parameterized by the size of the coalition. Then via a single theme of reduction from SC, we are able to show that various problems related to resources, resource bounds and resource conflicts introduced by Wooldridge et al are 1. W[1]-hard or co-W[1]-hard when parameterized by the size of the coalition. 2. para-NP-hard or co-para-NP-hard when parameterized by |R|. 3. FPT when parameterized by either |G| or |Ag|+ |R|. ∗Supported in part by Google Faculty Research Award, ONR Young Investigator Award and NSF CAREER award. †Department of Computer Science , University of Maryland at College Park, USA, email: rchitnis@cs.umd.edu ‡Department of Computer Science , University of Maryland at College Park, USA. email: hajiagha@cs.umd.edu §Department of Computer Science , University of Maryland at College Park, USA. email: vliaghat@cs.umd.edu",
    "creator" : "LaTeX with hyperref package"
  }
}