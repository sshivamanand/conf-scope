{
  "name" : "66.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "1 000\n013\n014\n015\n016\n017\n018\n019\n020\n021\n022\n023\n024\n025\n026\n027\n028\n029\n030\n031\n032\n033\n034\n035\n036\n037\n038\n039\n040\n041\n042\n043\n044\n045\n046\n047\n048\n049\n063\n064\n065\n066\n067\n068\n069\n070\n071\n072\n073\n074\n075\n076\n077\n078\n079\n080\n081\n082\n083\n084\n085\n086\n087\n088\n089\n090\n091\n092\n093\n094\n095\n096\n097\n098\n099"
    }, {
      "heading" : "1 Introduction",
      "text" : "We introduce a new joint syntactic and semantic dependency parser. Our parser draws from the algorithmic insights of the incremental structure building approach of Henderson et al. (2008), with two key differences. First, it learns representations for the parser’s entire algorithmic state, not just the top items on the stack or the most recent parser states; in fact, it uses no expert-crafted features at all. Second, it uses entirely greedy inference rather than beam search. We find that it outperforms all previous joint parsing models, including Henderson et al. (2008) and variants (Gesmundo et al., 2009; Titov et al., 2009; Henderson et al., 2013) on the CoNLL 2008 and 2009 (English) shared tasks. Our multilingual results are comparable to the top systems at CoNLL 2009.\nJoint models like ours have frequently been proposed as a way to avoid cascading errors in NLP pipelines; varying degrees of success have been attained for a range of joint syntactic-semantic analysis tasks (Sutton and McCallum, 2005; Henderson et al., 2008; Toutanova et al., 2008; Johansson, 2009; Lluı́s et al., 2013, inter alia).\nOne reason pipelines often dominate is that they make available the complete syntactic parse tree,\nand arbitrarily-scoped syntactic features—such as the “path” between predicate and argument, proposed by Gildea and Jurafsky (2002)—for semantic analysis. Such features are a mainstay of highperformance semantic role labeling (SRL) systems (Roth and Woodsend, 2014; Lei et al., 2015; FitzGerald et al., 2015; Foland and Martin, 2015), but they are expensive to extract (Johansson, 2009; He et al., 2013).\nThis study shows how recent advances in representation learning can bypass those expensive features, discovering cheap alternatives available during a greedy parsing procedure. The specific advance we employ is the stack LSTM (Dyer et al., 2015), a neural network that continuously summarizes the contents of the stack data structures in which a transition-based parser’s state is conventionally encoded. Stack LSTMs were shown to obviate many features used in syntactic dependency parsing; here we find them to do the same for joint syntactic-semantic dependency parsing.\nWe believe this is an especially important finding for greedy models that cast parsing as a sequence of decisions made based on algorithmic state, where linguistic theory and researcher intuitions offer less guidance in feature design.\nOur system’s performance does not match that of the top expert-crafted feature-based systems (Zhao et al., 2009; Björkelund et al., 2010; Roth and Woodsend, 2014; Lei et al., 2015), systems which perform optimal decoding (Täckström et al., 2015), or of systems that exploit additional, differently-annotated datasets (FitzGerald et al., 2015). Many advances in those systems are orthogonal to our model, and we expect future work to achieve further gains by integrating them.\nBecause our system is very fast—with an endto-end runtime of 177.6±18 seconds to parse the\n2\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\nCoNLL 2009 English test data on a single core— we believe it will be useful in practical settings. An open-source implementation will be made available on publication."
    }, {
      "heading" : "2 Joint Syntactic and Semantic Dependency Parsing",
      "text" : "We largely follow the transition-based, synchronized algorithm of Henderson et al. (2013) to predict joint parse structures. The input to the algorithm is a sentence annotated with part-of-speech tags. The output consists of a labeled syntactic dependency tree and a directed SRL graph, in which a subset of words in the sentence are selected as predicates, disambiguated to a sense, and linked by labeled, directed edges to their semantic arguments and modifiers. Figure 1 shows an example."
    }, {
      "heading" : "2.1 Transition-Based Procedure",
      "text" : "The two parses are constructed in a bottom-up fashion, incrementally processing words in the sentence from left to right. The state of the parsing algorithm at timestep t is represented by three stack data structures: a syntactic stack St, a semantic stack Mt—each containing partially built structures—and a buffer of input words Bt. Our algorithm also places partial syntactic and semantic parse structures onto the front of the buffer, so it is also implemented as a stack. Each arc in the output corresponds to a transition (or “action”) chosen based on the current state; every transition modifies the state by updating St, Mt, and Bt to St+1, Mt+1, and Bt+1, respectively. While each state may license several valid actions, each action has a deterministic effect on the state of the algorithm.\nInitially, S0 and M0 are empty, and B0 contains the input sentence with the first word at the front of B and a special root symbol at the end.1 Execution ends on iteration t such that Bt is empty and St and Mt contain only a single structure headed by root."
    }, {
      "heading" : "2.2 Transitions for Joint Parsing",
      "text" : "There are separate sets of syntactic and semantic transitions; the former manipulate S and B, the latter M and B. All are formally defined in Table 1. The syntactic transitions are from the “arceager” algorithm of Nivre (2008). They include:\n• S-SHIFT, which copies2 an item from the front of B and pushes it on S. • S-REDUCE pops an item from S. • S-RIGHT(`) creates a syntactic dependency.\nLet u be the element at the top of S and v be the element at the front of B. The new dependency has u as head, v as dependent, and label `. u is popped off S, and the resulting structure, rooted at u, is pushed on S. Finally, v is copied to the top of S. • S-LEFT(`) creates a syntactic dependency with label ` in the reverse direction as S-RIGHT. The top of S, u is popped. The front of B, v is replaced by the new structure, rooted at v.\nThe semantic transitions are similar, operating on the semantic stack.\n• M-SHIFT removes an item from the front of B and pushes it on M . • M-REDUCE pops an item from M . • M-RIGHT(r) creates a semantic dependency.\nLet u be the element at the top of M and v, the front of B. The new dependency has u as head, v as dependent, and label r. u is popped off the semantic stack, and the resulting structure, rooted at u, is pushed on M . • M-LEFT(r) creates a semantic dependency with label r in the reverse direction as MRIGHT. The buffer front, v is replaced by the new v-rooted structure. M remains unchanged.\nBecause SRL graphs allow a node to be a semantic argument of two parents—like all in the\n1This works better for the arc-eager algorithm (Ballesteros and Nivre, 2013), in contrast to Henderson et al. (2013), who initialized with root at the buffer front.\n2Note that in the original arc-eager algorithm (Nivre, 2008), SHIFT and RIGHT-ARC actions move the item on the buffer front to the stack, whereas we only copy it (to allow the semantic operations to have access to it).\n3\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\nexample in Figure 1—M-LEFT and M-RIGHT do not remove the dependent from the semantic stack and buffer respectively, unlike their syntactic equivalents, S-LEFT and S-RIGHT. We use two other semantic transitions from Henderson et al. (2013) which have no syntactic analogues:\n• M-SWAP swaps the top two items on M , to allow for crossing semantic arcs. • M-PRED(p) marks the item at the front of B as a semantic predicate with the sense p, and replaces it with the disambiguated predicate.\nThe CoNLL 2009 corpus introduces semantic self-dependencies where many nominal predicates (from NomBank) are marked as their own arguments; these account for 6.68% of all semantic arcs in the English corpus. An example involving an eventive noun is shown in Figure 2. We introduce a new semantic transition to handle such cases:\n• M-SELF(r) adds a dependency, with label r between the item at the front of B and itself. The result replaces the item at the front of B.\nNote that the syntactic and semantic transitions both operate on the same buffer, though they independently specify the syntax and semantics, respectively. In order to ensure that both syntactic and semantic parses are produced, the syntactic and semantic transitions are interleaved. Only syntactic transitions are considered until a transition is chosen that copies an item from the buffer front to the syntactic stack (either S-SHIFT or S-RIGHT). The algorithm then switches to semantic transitions until a buffer-modifying transition is taken (M-SHIFT).3 At this point, the buffer is modified and the algorithm returns to syntactic transitions. This implies that, for each word, its left-side\n3Had we moved the item at the buffer front during the syntactic transitions, it would have been unavailable for the semantic transitions, hence we only copy it.\nsyntactic dependencies are resolved before its leftside semantic dependencies. For interested readers, an example run of the algorithm is given in §A."
    }, {
      "heading" : "2.3 Constraints on Transitions",
      "text" : "To ensure that the parser never enters an invalid state, the sequence of transitions is constrained, following Henderson et al. (2013). Actions that copy or move items from the buffer (S-SHIFT, S-RIGHT and M-SHIFT) are forbidden when the buffer is empty. Actions that pop from a stack (S-REDUCE and M-REDUCE) are forbidden when that stack is empty. We disallow actions corresponding to the same dependency, or the same predicate to be repeated in the sequence. Repetitive M-SWAP transitions are disallowed to avoid infinite swapping. Finally, as noted above, we restrict the parser to syntactic actions until it needs to shift an item from B to S, after which it can only execute semantic actions until it executes an M-SHIFT.\nAsymptotic runtime complexity of this greedy algorithm is linear in the length of the input, as analyzed by Nivre (2009)."
    }, {
      "heading" : "3 Statistical Model",
      "text" : "The transitions in §2 describe the execution paths our algorithm can take; like past work, we apply a statistical classifier to decide which transition to take at each timestep, given the current state. (A full example of a transition sequence is given in the supplementary material.) The novelty of our model is that it learns a finite-length vector representation of the entire joint parser’s state (S, M , and B) in order to make this decision."
    }, {
      "heading" : "3.1 Stack Long Short-Term Memory (LSTM)",
      "text" : "LSTMs are recurrent neural networks equipped with specialized memory components in addition to a hidden state (Hochreiter and Schmidhuber, 1997; Graves, 2013) to model sequences. Stack LSTMs (Dyer et al., 2015) are LSTMs that allow for stack-based operations: query, push, and pop. A “stack pointer” is maintained which determines which cell in the LSTM provides memory unit and the hidden unit when computing the new memory cell contents. Query provides a summary of the stack in a single fixed-length vector. Push adds an element to the top of the stack, resulting in a new summary. Pop, which does not correspond to\n4\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\nSt Mt Bt Action St+1 Mt+1 Bt+1 Dependency S M (v, v), B S-SHIFT (v, v), S M (v, v), B —\n(u, u), S M B S-REDUCE S M B — (u, u), S M (v, v), B S-RIGHT(`) (v, v), (gs(u,v, l), u), S M (v, v), B S [ u\n`! v (u, u), S M (v, v), B S-LEFT(`) S M (gs(v,u, l), v), B S [ u\n` v S M (v, v), B M-SHIFT S (v, v),M B — S (u, u),M B M-REDUCE S M B — S (u, u),M (v, v), B M-RIGHT(r) S (gm(u,v, r), u),M (v, v), B M [ u\nr! v S (u, u),M (v, v), B M-LEFT(r) S (u, u),M (gm(v,u, r), v), B M [ u\nr v S (u, u), (v, v),M B M-SWAP S (v, v), (u, u),M B — S M (v, v), B M-PRED(p) S M (gd(v,p), v), B — S M (v, v), B M-SELF(r) S M (gm(v,v, r), v), B M [ v r$ v\nTable 1: Parser transitions along with the modifications to the stacks and the buffer resulting from each. Syntactic transitions are shown above, semantic below. Script symbols denote symbolic representations of words and relations, and bold symbols indicate (learned) embeddings (§3.5) of words and relations; each element in a stack or buffer includes both symbolic and vector representations, either atomic or recursive. S represents the set of syntactic transitions; M the set of semantic transitions.\na conventional LSTM operation, moves the stack pointer to the preceding timestep, resulting in a stack summary as it was before the popped item was observed. Implementation details (Dyer et al., 2015; Goldberg, 2015) and code were made publicly available.4\nUsing stack LSTMs, we construct a representation of the algorithm state by decomposing it into smaller pieces that are combined by recursive function evaluations (similar to the way a list is built by a concatenate operation that operates on a list and an element). This enables information that would be distant from the “top” of the stack to be carried forward, potentially helping the learner."
    }, {
      "heading" : "3.2 Stack LSTMs for Joint Parsing",
      "text" : "Our algorithm employs four stack LSTMs, one each for the S, M , and B data structures, so that already-built partial structures are available to the classifier. Like Dyer et al. (2015), we use a fourth stack LSTM, A, for the history of actions—A is never popped from, only pushed to. Figure 3 illustrates the architecture. The algorithm’s state at timestep t is encoded by the four vectors summarizing the four stack LSTMs, and this is the input to the classifier that chooses among the allowable transitions at that timestep.\nLet st, mt, bt, and at denote the summaries of St, Mt, Bt, and At, respectively. Let At = Allowed(St,Mt, Bt, At) denote the allowed transitions given the current stacks and buffer. The parser state at time t is given by a rectified linear unit (Nair and Hinton, 2010) in vector yt:\nyt = elementwisemax {0,d+W[st;mt;bt,at]}\n4 https://github.com/clab/lstm-parser\nroot soon reopen to\nall\nare expected\nexpect.01 all\nall\nsbj\nA1\nM\nB\nS\nS-RIGHT (oprd)\n... M-PRED\n(expect.01) M-REDUCE M-LEFT\n(A1)\nA\nare\nvc\nM-SHIFT\nFigure 3: Stack LSTM for joint parsing. The state illustrated corresponds to the ***-marked row in the example transition sequence in Fig. 5 in the supplementary material.\nwhere W and d are the parameters of the classifier. The transition selected at timestep t is\nargmax ⌧2At q⌧ + ✓⌧ · yt (1)\n⌘ argmax ⌧2At score(⌧ ;St,Mt, Bt, At) (2)\nwhere ✓⌧ and q⌧ are parameters for each transition type ⌧ . Note that only allowed transitions are considered in the decision rule (see §2.3)."
    }, {
      "heading" : "3.3 Composition Functions",
      "text" : "To use stack LSTMs, we require vector representations of the elements that are stored in the stacks. Specifically, we require vector representations of atoms (words, possibly with part-of-speech tags) and parse fragments. Word vectors can be pretrained or learned directly; we consider a concate-\n5\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\nnation of both in our experiments; part-of-speech vectors are learned and concatenated to the same.\nTo obtain vector representations of parse fragments, we use neural networks which recursively compute representations of the complex structured output (Dyer et al., 2015). The tree structures here are always ternary trees, with each internal node’s three children including a head, a dependent, and a label. The vectors for leaves are word vectors and vectors corresponding to syntactic and semantic relation types.\nThe vector for an internal node is a squashed (tanh) affine transformation of its children’s vectors. For syntactic and semantic attachments, respectively, the composition function is:\ngs(v,u, l) = tanh(Zs[v;u; l] + es) (3) gm(v,u, r) = tanh(Zm[v;u; r] + em) (4)\nwhere v and u are vectors correspodning to atomic words or composed parse fragments; l and r are learned vector representations for a syntactic and semantic labels respectively. Syntactic and semantic parameters are separated (Zs, es and Zm, em, respectively).\nFinally, for predicates, we use another recursive function to compose the word representation, v with a learned representation for the dismabiguated sense of the predicate, p:\ngd(v,p) = tanh(Zd[v;p] + ed) (5)\nwhere Zd and ed are parameters of the model. Note that, because syntactic and semantic transitions are interleaved, the fragmented structures are a blend of syntactic and semantic compositions. Figure 4 shows an example."
    }, {
      "heading" : "3.4 Training",
      "text" : "Training the classifier requires transforming each training instance (a joint parse) into a transition sequence, a deterministic operation under our transition set. Given a collection of algorithm states at time t and correct classification decisions ⌧t, we minimize the sum of log-loss terms, given (for one timestep) by:\nlog exp(q⌧t + ✓⌧t · yt)P ⌧ 02At exp(q⌧ 0 + ✓⌧ 0 · yt)\n(6)\nwith respect to the classifier and LSTM parameters. Note that the loss is differentiable with respect to the parameters; gradients are calculated\nusing backpropagation. We apply stochastic gradient descent with dropout for all neural network parameters."
    }, {
      "heading" : "3.5 Pretrained Embeddings",
      "text" : "Following Dyer et al. (2015), “structured skipgram” embeddings (Ling et al., 2015) were used, trained on the English (AFP section), German, Spanish and Chinese Gigaword corpora, with a window of size 5; training was stopped after 5 epochs. For out-of-vocabulary words, a randomly initialized vector of the same dimension was used."
    }, {
      "heading" : "3.6 Predicate Sense Disambiguation",
      "text" : "Predicate sense disambiguation is handled within the model (M-PRED transitions), but since senses are lexeme-specific, we need a way to handle unseen predicates at test time. When a predicate is encountered at test time that was not observed in training, our system constructs a predicate from the predicted lemma of the word at that position and defaults to the “01” sense, which is correct for 91.22% of predicates by type in the English CoNLL 2009 training data."
    }, {
      "heading" : "4 Experimental Setup",
      "text" : "Our model is evaluated on the CoNLL shared tasks on joint syntactic and semantic dependency parsing in 2008 (Surdeanu et al., 2008) and 2009 (Hajič et al., 2009). The standard training, development and test splits of all datasets were\n6\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\nused. Per the shared task guidelines, automatically predicted POS tags and lemmas provided in the datasets were used for all experiments. As a preprocessing step, pseudo-projectivization of the syntactic trees (Nivre et al., 2007) was used, which allowed an accurate conversion of even the nonprojective syntactic trees into syntactic transitions. However, the oracle conversion of semantic parses into transitions is not perfect despite using the MSWAP action due to the presence of multiple crossing arcs.5\nThe standard evaluation metrics include the syntactic labeled attachment score (LAS), the semantic F1 score on both in-domain (WSJ) and outof-domain (Brown corpus) data, and their macro average (Macro F1) to score joint systems. Because the task was defined somewhat differently in each year, each dataset is considered in turn."
    }, {
      "heading" : "4.1 CoNLL 2008",
      "text" : "The CoNLL 2008 dataset contains annotations from the Penn Treebank (Marcus et al., 1993), PropBank (Palmer et al., 2005) and NomBank (Meyers et al., 2004). The shared task evaluated systems on predicate identification in addition to predicate sense disambiguation and SRL.\nTo identify predicates, we trained a zeroMarkov order bidirectional LSTM two-class classifier. As input to the classifier, we use learned representations of word lemmas and POS tags. This model achieves an F1 score of 91.43% on marking words as predicates (or not).\nHyperparameters The input representation for a word consists of pretrained embeddings (size 100 for English, 80 for Chinese, 64 for German and Spanish), concatenated with additional learned word and POS tag embeddings (size 32 and 10, resp.). Learned embeddings for syntactic and semantic arc labels are of size 20 and predicates 100. Two-layer LSTMs, with hidden state dimension 100 were used for each of the four stacks. The parser state, yt and the composition function, g are of dimension 100. A dropout rate of 0.2 (Zaremba et al., 2014) was used on all layers at training time, tuned on the dev data from the set of values {0.1, 0.2, 0.3, 1.0}. The learned representations for actions are of size 100, similarly tuned from {10, 20, 30, 40, 100}. Other hyperpa-\n5For 1.5% of English sentences in the CoNLL 2009 English dataset, the transition sequence incorrectly encodes the gold-standard joint parse; details in Henderson et al. (2013).\nrameters have been set intuitively; careful tuning is expected to yield improvements (Weiss et al., 2015).\nAn initial learning rate of 0.1 for stochastic gradient descent was used and updated in every training epoch with a decay rate of 0.1 (Dyer et al., 2015). Training is stopped when the dev performance does not improve for approximately 6–7 hours of elapsed time. Experiments were run on a single thread on a CPU, with memory requirements of up to 512 MB."
    }, {
      "heading" : "4.2 CoNLL 2009",
      "text" : "Relative to the CoNLL 2008 task (above), the main change in 2009 is that predicates are preidentified, and systems are only evaluated on predicate sense disambiguation (not identification). Hence, the bidirectional LSTM classifier is not used here. The preprocessing for projectivity, and the hyperparameter selection is the same as in §4.1.\nIn addition to the joint approach described in the preceding sections, we experiment here with several variants:\nSemantics-only: all syntactic transitions in S , the syntactic stack S, and the syntactic composition function, gs are discarded. As a result, the set of constraints on transitions is a subset of the full set of constraints in §2.3. Effectively, this model does not use any syntactic features, similar to Collobert et al. (2011) and Zhou and Xu (2015). It provides a controlled test of the benefit of jointly predicting syntax in a semantic parser.\nSyntax-only: all semantic transitions in M, the semantic stack M , and the semantic composition function gm are discarded. S-SHIFT and S-RIGHT now move the item from the front of the buffer to the syntactic stack, instead of copying. The set of constraints on the transitions is again a subset of the full set of constraints. This model is an arceager variant of Dyer et al. (2015), and serves to check whether semantic parsing degrades syntactic performance.\nHybrid: the semantics parameters are trained using automatically predicted syntax from the syntax-only model. At test time, only semantic parses are predicted. This setup bears similarity to other approaches which pipeline syntax and semantics, extracting features from the syntactic parse to help SRL. However, unlike other\n7\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n643\n644\n645\n646\n647\n648\n649\n650\n651\n652\n653\n654\n655\n656\n657\n658\n659\n660\n661\n662\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697\n698\n699\napproaches, this model does not offer the entire syntactic tree for feature extraction, since only the partial syntactic structures present on the syntactic stack (and potentially the buffer) are visible at a given timestep."
    }, {
      "heading" : "5 Results and Discussion",
      "text" : "CoNLL 2008 (Table 2) Our joint model significantly outperforms the joint model of Henderson et al. (2008), from which our set of transitions is derived, showing the benefit of learning a representation for the entire algorithmic state. Several other joint learning models have been proposed (Lluı́s and Màrquez, 2008; Johansson, 2009; Titov et al., 2009) for the same task; our joint model surpasses the performance of all these models. The best reported systems on the CoNLL 2008 task are due to Johansson and Nugues (2008), Che et al. (2008), Ciaramita et al. (2008) and Zhao and Kit (2008), all of which pipeline syntax and semantics; our system’s semantic and overall performance is comparable to these. We fall behind only Johansson and Nugues (2008), whose success was attributed to carefully designed global SRL features integrated into a pipeline of classifiers, making them asymptotically slower.\nCoNLL 2009 English (Table 3) All of our models (Syntax-only, Semantics-only, Hybrid and Joint) improve over Gesmundo et al. (2009) and Henderson et al. (2013); demonstrating the benefit of our entire-parser-state representation learner compared to the more locally scoped model.\nGiven that syntax has consistently proven useful\nin SRL, our Semantics-only model underperforms Hybrid and Joint, as expected. In the training domain, syntax and semantics benefit each other (Joint outperforms Hybrid). Out-of-domain (the Brown test set), the Hybrid pulls ahead, a sign that Joint overfits to WSJ. As a syntactic parser, our Syntax-only model performs slightly better than Dyer et al. (2015), who achieve 89.56 LAS on this task.\nThe overall performance of Joint is on par with the other winning participants at the CoNLL 2009 shared task (Zhao et al., 2009; Che et al., 2009; Gesmundo et al., 2009), falling behind only Zhao et al. (2009), who also carefully design languagespecific features, and use a series of pipelines for the joint task, resulting in an accurate but computationally expensive system.\nState-of-the-art SRL systems (shown in the last block of Table 3) which use advancements orthogonal to the contributions in this paper, perform better than our models. Many of these systems use expert-crafted features derived from full syntactic parses in a pipeline of classifiers followed by a global reranker (Björkelund et al., 2009; Björkelund et al., 2010; Roth and Woodsend, 2014); we have not used these features or reranking. Lei et al. (2015) use syntactic parses to obtain interaction features between predicates and their arguments and then compress feature representations using low-rank tensor. Täckström et al. (2015) present an exact inference algorithm for SRL based on dynamic programming and their local and structured models make use of many syntactic features from a pipeline; our search procedure is greedy. Their algorithm is adopted by FitzGerald et al. (2015) for inference in a model that jointly learns representations from a combination of PropBank and FrameNet annotations; we have not experimented with extra annotations.\nOur system achieves an end-to-end runtime of 177.6±18 seconds to parse the CoNLL 2009 English test set on a single core. This is almost 2.5 times faster than the pipeline model of Lei et al. (2015) (439.9±42 seconds) under identical settings.6\nCoNLL 2009 Multilingual (Table 4) We tested the joint model on the non-English CoNLL 2009 datasets, and the results demonstrate that it adapts\n6See https://github.com/taolei87/ SRLParser; we chose this system since it is publicly available, and other state-of-the-art systems are not.\n8\n714\n715\n716\n717\n718\n719\n720\n721\n722\n723\n724\n725\n726\n727\n728\n729\n730\n731\n732\n733\n734\n735\n736\n737\n747\n748\n749\n750\n751\n752\n753\n754\n755\n756\n757\n758\n759\n760\n761\n762\n763\n764\n765\n766\n767\n768\n769\n770\n771\n772\n773\n774\n775\n776\n777\n778\n779\n780\n781\n782\n783\n784\n785\n786\n787\n788\n789\n790\n791\n792\n793\n794\n795\n796\n797\n798\n799\neasily—it is on par with the top three systems in most cases. We note that our Chinese parser relies on pretrained word embeddings for its superior performance; without them (not shown), it was on par with the others. Japanese is a small-data case (4,393 training examples), illustrating our model’s dependence on reasonably large training datasets.\nWe have not extended our model to incorporate morphological features, used by the systems to which we compare. Future work might incorporate morphological features where available; this could potentially improve performance, especially in highly inflective languages like Czech. An alternative might be to infer word-internal representations using character-based word embeddings, which was found beneficial for syntactic parsing (Ballesteros et al., 2015)."
    }, {
      "heading" : "6 Related Work",
      "text" : "Other approaches to joint modeling, not considered in our experiments, are notable. Lluı́s et al. (2013) propose a graph-based joint model using dual decomposition for agreement between syntax and semantics, but do not achieve competitive performance on the CoNLL 2009 task. Lewis et al. (2015) proposed an efficient joint model for CCG syntax and SRL, which performs better than a pipelined model. However, their training necessitates CCG annotation, ours does not. Moreover, their evaluation metric rewards semantic dependencies regardless of where they attach within the argument span given by a PropBank constituent, making direct comparison to our evaluation is infeasible. Krishnamurthy and Mitchell (2014) propose a joint CCG parsing and relation extraction model which improves over pipelines, but their task is different from ours. Li et al. (2010) also perform joint syntactic and semantic dependency parsing for Chinese, but do not report results on the CoNLL 2009 dataset.\nThere has also been an increased interest in models which use neural networks for SRL. Collobert et al. (2011) proposed models which perform many NLP tasks without hand-crafted features. Though they did not achieve the best results on the constituent-based SRL task (Carreras and Màrquez, 2005), their approach inspired Zhou and Xu (2015), who achieved state-of-the-art results using deep bidirectional LSTMs.7 Our approach for dependency-based SRL is not directly comparable."
    }, {
      "heading" : "7 Conclusion",
      "text" : "We presented an incremental, greedy parser for joint syntactic and semantic dependency parsing. Our model surpasses the performance of previous joint models on the CoNLL 2008 and 2009 English tasks, despite not using expert-crafted features of the full syntactic parse, as done by asymptotically more expensive models. An open-source implementation of our parser will be made available on publication."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "We present a transition-based parser that jointly produces syntactic and semantic dependencies. It learns a representation of the entire algorithm state, using stack long short-term memories. Our greedy inference algorithm has linear time, including feature extraction. On the CoNLL 2008– 9 English shared tasks, we obtain the best parsing performance among models that jointly learn syntax and semantics.",
    "creator" : "Preview"
  }
}