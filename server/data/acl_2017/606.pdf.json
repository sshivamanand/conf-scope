{
  "name" : "606.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Neural Symbolic Machines: Learning Semantic Parsers on Freebase with Weak Supervision",
    "authors" : [ ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "1 000\n011\n012\n013\n014\n015\n016\n017\n018\n019\n020\n021\n022\n023\n024\n025\n026\n027\n028\n029\n030\n031\n032\n033\n034\n035\n036\n037\n038\n039\n040\n041\n042\n043\n044\n045\n046\n047\n048\n049\n073\n074\n075\n076\n077\n078\n079\n080\n081\n082\n083\n084\n085\n086\n087\n088\n089\n090\n091\n092\n093\n094\n095\n096\n097\n098\n099"
    }, {
      "heading" : "1 Introduction",
      "text" : "Deep neural networks have achieved impressive performance in supervised classification and structured prediction tasks such as speech recognition (Hinton et al., 2012), machine translation (Bahdanau et al., 2014; Wu et al., 2016) and more. However, training neural networks for semantic parsing (Zelle and Mooney, 1996; Zettlemoyer and Collins, 2005; Liang et al., 2011) or program induction, where language is mapped to a symbolic representation that is executed by a com-\nputer, through weak supervision remains challenging. This is because the model must interact with a computer through non-differentiable operations at training time.\nIn semantic parsing, recent work handled this (Dong and Lapata, 2016; Jia and Liang, 2016) by training from manually annotated programs and avoiding program execution at training time. However, annotating programs is known to be expensive and scales poorly. In program induction, attempts to address this problem (Graves et al., 2014; Reed and de Freitas, 2016; Kaiser and Sutskever, 2015; Graves et al., 2016b; Andreas et al., 2016) either utilized low-level memory (Zaremba and Sutskever, 2015), or required memory to be differentiable (Neelakantan et al., 2015) so that the model can be trained with backpropagation. This makes it difficult to use the efficient discrete operations and memory of a traditional computer, and limited the application to synthetic or small knowledge bases.\nIn this paper, we propose to utilize the mem-\n2\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\nory and discrete operations of a traditional computer in a novel Manager-Programmer-Computer (MPC) framework for neural program induction, which integrates three components:\n1. A “manager” that provides weak supervision (e.g., ‘NYC’ in Figure 1) through a reward indicating how well a task is accomplished. Unlike full supervision, weak supervision is easy to obtain at scale (Section 3.1). 2. A “programmer” that takes natural language as input and generates a program that is a sequence of tokens (Figure 2). The programmer learns from the reward and must overcome the hard search problem of finding correct programs (Section 2.2). 3. A “computer” that executes programs in a high level programming language. Its nondifferentiable memory enables abstract, scalable and precise operations, but makes training more challenging. It provides a friendly neural computer interface by detecting and eliminating invalid choices (Section 2.1).\nWithin this framework, we introduce the Neural Symbolic Machine (NSM) and apply it to semantic parsing. NSM contains a sequence-to-sequence (seq2seq) “programmer” (Sutskever et al., 2014) and a symbolic non-differentiable Lisp interpreter (“computer”) that executes programs against a large knowledge-base (KB).\nOur technical contribution in this work is threefold. First, to support language compositionality, we augment the standard seq2seq model with a key-variable memory to save and reuse intermediate execution results (Figure 1). This is a novel application of pointer networks (Vinyals et al., 2015) to compositional semantics.\nSecond, to alleviate the search problem of finding correct programs when training from questionanswer pairs (Figure 1), we use the computer to execute partial programs and prune the programmer’s search space by checking the syntax and semantics of generated programs. This generalized past work on training from weak supervision (Liang et al., 2011; Berant et al., 2013) by using the semantic denotations for structural search.\nThird, to train from weak supervision and directly maximize the expected reward we turn to the REINFORCE (Williams, 1992) algorithm. Since learning from scratch is difficult for REINFORCE, we combine it with an iterative maximum likelihood (ML) process, where beam search is\nused to find pseudo-gold programs, which are then used to augment the objective of REINFORCE.\nOn the WEBQUESTIONSSP dataset (Yih et al., 2016), NSM achieves new state-of-the-art results with weak supervision, significantly closing the gap between weak and full supervision for this task. Unlike prior work, it is trained end-toend, and does not require feature engineering or domain-specific knowledge."
    }, {
      "heading" : "2 Neural Symbolic Machines",
      "text" : "We now introduce NSM by first describe the “computer”, a non-differentiable Lisp interpreter that executes programs against a large KB and provides code assistance (Section 2.1). We then propose a seq2seq model (“programmer”) that supports compositionality using a key-variable memory to save and reuse intermediate results (Section 2.2). Finally, we describe a training procedure that is based on REINFORCE, but is augmented with pseudo-gold programs found by an iterative ML training procedure (Section 2.3).\nBefore diving into details, we define the semantic parsing task: given a knowledge base K, and a question x = (w1, w2, ..., wm), produce a program or logical form z that when executed against K generates the right answer y. Let E denote a set of entities (e.g., ABELINCOLN),1 and let P denote a set of properties (e.g., PLACEOFBIRTH). A knowledge base K is a set of assertions or triples (e1, p, e2) ∈ E × P × E , such as (ABELINCOLN, PLACEOFBIRTH, HODGENVILLE)."
    }, {
      "heading" : "2.1 Computer: Lisp Interpreter with Code Assistance",
      "text" : "Semantic parsing typically requires using a set of operations to query the knowledge base and process the results. Operations learned with neural networks such as addition and sorting do not perfectly generalize to inputs that are larger than the ones observed in the training data (Graves et al., 2014; Reed and de Freitas, 2016). In contrast, operations implemented in high level programming languages are abstract, scalable, and precise, thus generalizes perfectly to inputs of arbitrary size. Based on this observation, we implement operations necessary for semantic parsing with an ordinary programming language instead of trying to learn them with a neural network.\n1We also consider numbers (e.g., “1.33”) and date-times (e.g., “1999-1-1”) as entities.\n3\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n( Hop v p )⇒ {e2|e1 ∈ v, (e1, p, e2) ∈ K} ( ArgMax v p )⇒ {e1|e1 ∈ v,∃e2 ∈ E : (e1, p, e2) ∈ K,∀e : (e1, p, e) ∈ K, e2 ≥ e} ( ArgMin v p )⇒ {e1|e1 ∈ v,∃e2 ∈ E : (e1, p, e2) ∈ K,∀e : (e1, p, e) ∈ K, e2 ≤ e}\n( Filter v1 v2 p )⇒ {e1|e1 ∈ v1,∃e2 ∈ v2 : (e1, p, e2) ∈ K}\nTable 1: Interpreter functions. v represents a variable, p a property in Freebase. ≥ and ≤ are defined on numbers and dates.\nWe adopt a Lisp interpreter as the “computer”. A program C is a list of expressions (c1...cN ), where each expression is either a special token ”RETURN” indicating the end of the program, or a list of tokens enclosed by parentheses ”( F A0 ... AK )”. F is one of the functions in Table 1, which takes as input K arguments of specific types. Table 1 defines the semantics of each function and the types of arguments (either a property p or a variable v). When functions are executed, they return an entity list that is the expression’s denotation in K, and save it to a new variable.\nBy introducing variables that save the intermediate results of execution, the program naturally models language compositionality and describes from left to right a bottom-up derivation of the full meaning of the natural language input, which is convenient in a seq2seq model (Figure 1). This is reminiscent of the floating parser (Wang et al., 2015; Pasupat and Liang, 2015), where a derivation tree that is not grounded in the input is incrementally constructed.\nThe set of programs defined by our functions is equivalent to the subset of λ-calculus presented in (Yih et al., 2015). We did not use full Lisp programming language here, because constructs like control flow and loops are unnecessary for most current semantic parsing tasks, and it is simple to add more functions to the model when necessary.\nTo create a friendly neural computer interface, the interpreter provides code assistance to the programmer by producing a list of valid tokens at each step. First, a valid token should not cause a syntax error: e.g., if the previous token is “(”, the next token must be a function name, and if the previous token is “Hop”, the next token must be a variable. More importantly, a valid token should not cause a semantic (run-time) error: this is detected using the denotation saved in the variables. For example, if the previously generated tokens were “( Hop v”, the next available token is restricted to properties {p | ∃e, e′ : e ∈ v, (e, p, e′) ∈ K} that are reachable from entities in v in the KB graph. These checks are enabled by the variables and can\nbe derived from the definition of the functions in Table 1. With this code assistance, the interpreter prunes the “programmer”’s search space by orders of magnitude, and enables learning from weak supervision on a large KB."
    }, {
      "heading" : "2.2 Programmer: Seq2seq Model with Key-Variable Memory",
      "text" : "Given the “computer”, the “programmer” needs to map natural language into a program, which is a sequence of tokens that references operations and values in the “computer”. We base our programmer on a standard seq2seq model with attention, but extend it with a key-variable memory that allows the model to learn to represent and refer to program variables (Figure 2).\nSequence-to-sequence models consist of two RNNs, an encoder and a decoder. We used a 1-layer GRU (Cho et al., 2014) for both the encoder and decoder. Given a sequence of words w1, w2...wm, each word wt is mapped to an embedding qt (embedding details are Section 3). Then, the encoder reads these embeddings and updates its hidden state step by step using ht+1 = GRU(ht, qt, θEncoder), where θEncoder are the GRU parameters. The decoder updates its hidden states ut by ut+1 = GRU(ut, ct−1, θDecoder), where ct−1 is the embedding of last step’s output token at−1, and θDecoder are the GRU parameters. The last hidden state of the encoder hT is used as the decoder’s initial state. We also adopt a dot-product attention similar to Dong and Lapata (2016). The tokens of the program a1, a2...an are generated one by one using a softmax over the vocabulary of valid tokens at each step, as provided by the “computer” (Section 2.1).\nTo achieve compositionality, the decoder must learn to represent and refer to intermediate variables whose value was saved in the “computer” after execution. Therefore, we augment the model with a key-variable memory, where each entry has two components: a continuous embedding key vi, and a corresponding variable token Ri referencing the value in the “computer” (see Figure 2).\n4\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\nKey Variable\nv1 R1(m.USA) Execute ( Argmax R2 Population )\nExecute Return\nm.NYCKey Variable\n... ...\nv3 R3(m.NYC)\nKey Variable\nv1 R1(m.USA)\nv2 R2(list of US cities)\nExecute ( Hop R1 !CityIn )\nHop R1 !CityIn( )\nLargest city ( Hop R1in US GO !CityIn Argmax R2( )Population)\nR2 Population ReturnArgmax )(\nEntity Resolver\nFigure 2: Semantic Parsing with NSM. The key embeddings of the key-variable memory are the output of the sequence model at certain encoding or decoding steps. For illustration purposes, we also show the values of the variables in parentheses, but the sequence model never sees these values, and only references them with the name of the variable (“R1”). A special token “GO” indicates the start of decoding, and “RETURN” indicates the end of decoding.\nDuring encoding, we use an entity linker to link text spans (e.g., “US”) to KB entities. For each linked entity we add a memory entry where the key is the average of GRU hidden states over the entity span, and the variable token (R1) is the name of a variable in the computer holding the linked entity (m.USA) as its value. During decoding, when a full expression is generated (i.e., the decoder reads ”)”), it gets executed, and the result is stored as the value of a new variable in the “computer”. This variable is keyed by the GRU hidden state at that step. Every time a new variable is added to memory, the variable token is added to the output vocabulary of the decoder. The final answer returned by the “programmer” is the value of the last computed variable.\nNote that, similar to pointer networks (Vinyals et al., 2015), the key embeddings for variables are dynamically generated for each example. During training, the model learns to represent variables by backpropagating gradients from a time step where a variable is selected by the decoder, through the key-variable memory, to an earlier time step when the key embedding was computed. Thus, the encoder/decoder learns to generate representations for variables such that they can be used at the right time to construct the correct program.\nWhile the key embeddings are differentiable, the values referenced by the variables (lists of entities), stored in the “computer”, are symbolic and non-differentiable. This distinguishes the keyvariable memory from other memory-augmented neural networks that use continuous differentiable embeddings as the value of each memory entry (Weston et al., 2014; Graves et al., 2016a)."
    }, {
      "heading" : "2.3 Training NSM with Weak Supervision",
      "text" : "NSM executes non-differentiable operations against a KB, and thus end-to-end backpropa-\ngation is not possible. Therefore, we base our training procedure on REINFORCE (Williams, 1992; Norouzi et al., 2016).\nWhen the reward signal is sparse and the search space is large, it is common to utilize some full supervision to pre-train REINFORCE (Silver et al., 2016). Since we assume only weak supervision, we suggest an iterative ML procedure for finding pseudo-gold programs that will bootstrap REINFORCE.\nREINFORCE We can formulate training as a reinforcement learning problem: given a question x, the state, action and reward at each time step t ∈ {0, 1, ..., T} are (st, at, rt). Since the environment is deterministic, the state is defined by the question x and the action sequence: st = (x, a0:t−1), where a0:t−1 = (a0, ..., at−1) is the history of actions at time t. A valid action at time t is at ∈ A(st), where A(st) is the set of valid tokens given by the “computer”. Since each action corresponds to a token, the full history a0:T corresponds to a program. The reward rt = I[t = T ] · F1(x, a0:T ) is non-zero at the last step of decoding, and is the F1 score computed comparing the gold answer and the answer generated by executing the program a0:T . Thus, the reward of a program or action sequence is\nR(x, a0:T ) = ∑ t rt = F1(x, a0:T ).\nThe agent’s decision making is characterized by a policy, πθ(s, a) = Pθ(at = a|x, a0:t−1), where θ are the model parameters. Since the environment is deterministic, the probability of an action sequence a0:T is\nPθ(a0:T |x) = ∏ t Pθ(at | x, a0:t−1).\nWe can define our objective to be the expected reward and use policy gradient methods such as\n5\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\nREINFORCE for training. The objective and gradient are:\nJRL(θ) = ∑ x EPθ(a0:T |x)[R(x, a0:T )],\n∇θJRL(θ) = ∑ x ∑ a0:T Pθ(a0:T | x) · [R(x, a0:T )−\nB(x)] · ∇θ logPθ(a0:T | x), where B(x) = ∑\na0:T Pθ(a0:T | x)R(x, a0:T ) is a\nbaseline that reduces the variance of the gradient estimation without introducing bias.\nWhile REINFORCE assumes a stochastic policy, we rely on beam search for gradient estimation. Thus, in contrast with common practice of approximating the gradient by sampling from the model, we use the top-k action sequences (programs) in the beam with normalized probabilities. This allows training to focus on sequences with high probability, which are on the decision boundaries, and reduces the variance of the gradient.\nEmpirically (and in line with prior work), REINFORCE converged slowly and often got stuck in local optima (see Section 3). The difficulty of training resulted from the sparse reward signal in the large search space, which caused model probabilities for programs with non-zero reward to be very small at the beginning. If the beam size k is small, good programs fall off the beam, leading to zero gradients for all programs in the beam. If the beam size k is large, training is very slow, and the normalized probabilities of good programs when the model is untrained are still very small, leading to (1) near zero baselines, thus near zero gradients on ”bad” programs (2) near zero gradients on good programs due to the low probability Pθ(a0:T | x). To combat this, we present an alternative training strategy based on maximum-likelihood.\nIterative ML If we had gold programs, we could directly optimize their likelihood. Since we do not have gold programs, we can perform an iterative procedure (similar to hard EM), where we search for good programs given fixed parameters, and then optimize the probability of the best program found so far. We do decoding on an example with a large beam size and declare abest0:T (x) to be the pseudo-gold program that achieved highest reward with shortest length among the programs decoded on x in all previous iterations. Then, we can optimize the ML objective:\nJML(θ) = ∑ x logPθ(a best 0:T (x) | x) (1)\nA question x is not included if we did not find any program with positive reward.\nTraining with iterative ML is fast because there is at most one program per example and the gradient is not weighted by model probability. while decoding with a large beam size is slow, we could train for multiple epochs after each decoding. This iterative process has a bootstrapping effect that a better model leads to a better program abest0:T (x) through decoding, and a better program abest0:T (x) leads to a better model through training.\nEven with a large beam size, some programs are hard to find because of the large search space. A common solution to this problem is to use curriculum learning (Zaremba and Sutskever, 2015; Reed and de Freitas, 2016). The size of the search space is controlled by both the set of functions used in the program and the program length. We apply curriculum learning by gradually increasing both these quantities (see details in Section 3) when performing iterative ML.\nNevertheless, iterative ML uses only pseudogold programs and does not optimize the objective we truly care about. This has two adverse effects: (1) The best program abest0:T (x) could be a spurious program that accidentally produces the correct answer (e.g., using the property PLACEOFBIRTH instead of PLACEOFDEATH when the two places are the same), and thus does not generalize to other questions. (2) Because training does not observe full negative programs, the model often fails to distinguish between tokens that are related to one another. For example, differentiating PARENTSOF vs. SIBLINGSOF vs. CHILDRENOF can be challenging. We now present learning where we combine iterative ML with REINFORCE.\nAugmented REINFORCE To bootstrap REINFORCE, we can use iterative ML to find pseudogold programs, and then add these programs to the beam with a reasonably large probability. This is similar to methods from imitation learning (Ross et al., 2011; Jiang et al., 2012) that define a proposal distribution by linearly interpolating the model distribution and an oracle.\nAlgorithm 1 describes our overall training procedure. We first run iterative ML for NML iterations and record the best program found for every example xi. Then, we run REINFORCE, where we normalize the probabilities of the programs in beam to sum to (1 − α) and add α to the probability of the best found program C∗(xi).\n6\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\nAlgorithm 1 IML-REINFORCE Input: question-answer pairs D = {(xi, yi)}, mix ratio α, reward function R(·), training iterations NML, NRL, and beam sizes BML, BRL. Procedure: Initialize C∗x = φ the best program so far for x Initialize model θ randomly . Iterative ML for n = 1 to NML do\nfor (x, y) in D do C← Decode BML programs given x for j in 1...|C| do if Rx,y(Cj) > Rx,y(C∗x) then C∗x ← Cj θ ←ML training with DML = {(x,C∗x)}\nInitialize model θ randomly . REINFORCE for n = 1 to NRL do\nDRL ← ∅ is the RL training set for (x, y) in D do\nC← Decode BRL programs from x for j in 1...|C| do\nif Rx,y(Cj) > Rx,y(C∗x) then C∗x ← Cj C← C ∪ {C∗x} for j in 1...|C| do\np̂j ← (1−α)· pj∑ j′ pj′\nwhere pj = Pθ(Cj | x) if Cj = C∗x then p̂j ← p̂j + α DRL ← DRL ∪ {(x,Cj , p̂j)}\nθ ← REINFORCE training with DRL\nConsequently, the model always puts a reasonable amount of probability on a program with high reward during training.\nOn top of imitation learning, our approach is related to the common practice in reinforcement learning (Schaul et al., 2016) to replay rare successful experiences to reduce the training variance and improve training efficiency. This is also similar to recent developments (Wu et al., 2016) in machine translation, where ML and RL objectives are linearly combined, because anchoring the model to some high-reward outputs stabilizes training."
    }, {
      "heading" : "3 Experiments and Analysis",
      "text" : "We now empirically show that NSM can learn a semantic parser from weak supervision over a large KB. We evaluate on WEBQUESTIONSSP, a challenging semantic parsing dataset with strong baselines. Experiments show that NSM achieves new state-of-the-art performance on WEBQUESTIONSSP with weak supervision, and significantly closing the gap between weak and full supervisions for this task. Hyper-parameter settings are in the supplemental material due to page limits."
    }, {
      "heading" : "3.1 The WEBQUESTIONSSP dataset",
      "text" : "Collecting semantic parse labels is a difficult, time consuming task, but can increase the accuracy of state-of-the-art question-answering systems by\nfull supervision. The WEBQUESTIONSSP dataset (Yih et al., 2016) contains semantic parses for the questions from WEBQUESTIONS (Berant et al., 2013) that are answerable using Freebase. It consists of 3,098 question-answer pairs for training and 1,639 for testing. These questions were collected using Google Suggest API and the answers were originally obtained using Amazon Mechanical Turk and updated by annotators who were familiar with the design of Freebase. We further separated out 620 questions from the training set as a validation set. For query pre-processing we used an in-house named entity linking system to find the entities in a question. The quality of the entity linker is similar to that of (Yih et al., 2015) at 94% of the gold root entities being included. Similar to Dong and Lapata (2016), we replaced named entity tokens with a special token ”ENT”. For example, the question ”who plays meg in family guy” is changed to ”who plays ENT in ENT ENT”.\nFollowing (Yih et al., 2015) we used the last publicly available snapshot of Freebase (Bollacker et al., 2008). Since NSM training requires random access to Freebase during decoding, we preprocessed Freebase by removing predicates that are not related to world knowledge (starting with ”/common/”, ”/type/”, ”/freebase/”),2 and removing all text valued predicates, which are rarely the answer. Out of all 23K relations, 434 relations are removed during preprocessing. This results in a graph that fits in memory with 23K relations, 82M nodes, and 417M edges."
    }, {
      "heading" : "3.2 Model And Training Details",
      "text" : "For pre-trained word embeddings, we used the 300 dimension GloVe word embeddings trained on 840B tokens (Pennington et al., 2014). On the encoder side, we added a projection matrix to transform the embeddings into 50 dimensions. On the decoder side, we used the same GloVe embeddings to construct an embedding for each property using its Freebase id, and also added a projection matrix to transform this embedding to 50 dimension. A Freebase id contains three parts: domain, type, and property. For example, the Freebase id for PARENTSOF is “/people/person/parents”. “people” is the domain, “person” is the type and ”parents” is the property. The embedding is constructed by concatenating the average of word embeddings in the domain and type name\n2We kept “/common/topic/notable types”.\n7\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n643\n644\n645\n646\n647\n648\n649\n650\n651\n652\n653\n654\n655\n656\n657\n658\n659\n660\n661\n662\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697\n698\n699\nto the average of word embeddings in the property name. For example, if the embedding dimension is 300, the embedding dimension for “/people/person/parents” will be 600. The first 300 dimensions will be the average of the embeddings for “people” and “person”, and the second 300 dimensions will be the embedding for “parents”.\nInspired by the staged generation process in Yih et al. (2015), curriculum learning includes two steps. We first run iterative ML for 10 iterations with programs constrained to only use the “Hop” function and the maximum number of expressions is 2. Then, we run iterative ML again, but use both “Hop” and “Filter”, and the maximum number of expressions is 3. However, the relations used by “Hop” are restricted to those that appeared in abest0:T (q) in the first step."
    }, {
      "heading" : "3.3 Results and discussion",
      "text" : "We evaluate performance using the offical evaluation script for WEBQUESTIONSSP. Because the answer to a question may contain multiple entities or values, precision, recall and F1 are computed based on the output of each individual question, and average F1 is reported as the main evaluation metric. Accuracy measures the proportion of questions that are answered exactly.\nA comparison to STAGG, the prior state-of-theart model (Yih et al., 2016, 2015) is shown in Table 2. Our model beats STAGG with weak supervision by a significant margin on all metrics, while relying on no feature engineering or handcrafted rules. When STAGG is trained with strong supervision it obtains an F1 of 71.7, and thus NSM closes half the gap between training with weak and strong supervision.\nModel Prec. Rec. F1 Acc. STAGG 67.3 73.1 66.8 58.8 NSM 70.8 76.0 69.0 59.5\nTable 2: Results on the test set. Average F1 is the main evaluation metric and NSM outperforms STAGG with no domainspecific knowledge or feature engineering.\nFour key ingredients lead to the final performance of NSM. The first one is the neural computer interface that provides code assistance by checking for syntax and semantic errors. We find that semantic checks are very effective for opendomain KBs with a large number of properties. For our task, the average number of choices is reduced from 23K per step (all properties) to less\nthan 100 (the average number of relations connected to an entity).\nThe second ingredient is augmented REINFORCE training. Table 3 compares augmented REINFORCE, REINFORCE, and iterative ML on the validation set. REINFORCE gets stuck in local maxima and performs poorly, while iterative ML training is not directly optimizing the F1 measure, and achieves sub-optimal results. In contrast, augmented REINFORCE is able to bootstrap using pseudo-gold programs found by iterative ML and achieves the best performance on both the training and validation set.\nSettings Train F1 Valid F1 iterative ML 68.6 60.1 REINFORCE 55.1 47.8 Augmented REINFORCE 83.0 67.2\nTable 3: Average F1 on the validation set for augmented REINFORCE, REINFORCE, and iterative ML.\nThe third ingredient is curriculum learning during iterative ML. We compare the performance of the best programs found with and without curriculum learning in Table 4. We find that the best programs found with curriculum learning are substantially better than those found without curriculum learning by a large margin on every metric.\nSettings Prec. Rec. F1 Acc. No curriculum 79.1 91.1 78.5 67.2 Curriculum 88.6 96.1 89.5 79.8\nTable 4: Evaluation of the program with the highest F1 score in the beam (abest0:t ) with and without curriculum learning.\nThe last important ingredient is reducing overfitting. Given the small size of the dataset, overfitting is a major problem for training neural network models. We show the contributions of different techniques for controlling overfitting in Table 5. Note that after all the techniques have been applied, the model is still overfitting with training F1@1=83.0% and validation F1@1=67.2%.\nError analysis Two main sources of errors arise in manual error analysis\n1. Search failure: the correct program is not found during search for pseudo-gold programs, either because the beam size is not large enough, or because the set of functions implemented by the interpreter is insufficient.\n8\n701\n702\n703\n704\n705\n706\n707\n708\n709\n710\n711\n712\n713\n714\n715\n716\n717\n718\n719\n720\n721\n722\n723\n724\n725\n726\n727\n728\n729\n730\n731\n732\n733\n734\n735\n736\n737\n738\n739\n740\n741\n742\n743\n744\n745\n746\n747\n748\n749\n750\n751\n752\n753\n754\n755\n756\n757\n758\n759\n760\n761\n762\n763\n764\n765\n766\n767\n768\n769\n770\n771\n772\n773\n774\n775\n776\n777\n778\n779\n780\n781\n782\n783\n784\n785\n786\n787\n788\n789\n790\n791\n792\n793\n794\n795\n796\n797\n798\n799\nSettings ∆ F1@1 -Pretrained word embeddings -5.5 -Pretrained property embeddings -2.7 -Dropout on GRU input and output -2.4 -Dropout on softmax -1.1 -Anonymize entity tokens -2.0\nTable 5: Contributions of different overfitting techniques on the validation set.\nThe 89.5% F1 score in Table 4 indicates that at least 10% of the queries are of this kind. 2. Ranking failure: Pseudo-gold programs with high reward are found, but are not ranked at the top. Because training error is low, this is largely due to over-fitting. The 67.2% F1 score in Table 3 indicates that about 20% of examples are of this kind."
    }, {
      "heading" : "4 Related work",
      "text" : "Among deep learning models for program induction, Reinforcement Learning Neural Turing Machines (RL-NTMs) (Zaremba and Sutskever, 2015) are the most similar to NSM, as a nondifferentiable machine is controlled by a sequence model. Therefore, both models rely on REINFORCE for training. The main difference between the two is the abstraction level of the programming language. RL-NTM uses lower level operations such as memory address manipulation and byte reading/writing, while NSM uses a high level programming language over a large knowledge base that includes operations such as following properties from entities, or sorting based on a property, which is more suitable for representing semantics. Earlier work such as OOPS (Schmidhuber, 2004) has desirable characteristics, such as the ability to define new functions and modify code storage. These remain to be future improvements for NSM.\nWe formulate NSM training as an instance of reinforcement learning (Sutton and Barto, 1998) in order to directly optimize the task reward of the structured prediction problem (Norouzi et al., 2016). Compared to imitation learning methods (Daume et al., 2009; Ross et al., 2011) that interpolate a model distribution with an oracle, NSM needs to solve a challenging search problem of training from weak supervisions in a large program space. Our solution employs two techniques (a) a symbolic “computer” helps find good programs by pruning the search space (b) an it-\nerative maximum likelihood (ML) process, where beam search is used to find pseudo-gold programs. Wiseman and Rush (Wiseman and Rush, 2016) proposed a max-margin approach to train a sequence-to-sequence scorer. However, their training procedure is more involved, and we did not implement it in this work.\nNSM is similar to Neural Programmer (Neelakantan et al., 2015) and Dynamic Neural Module Network (Andreas et al., 2016) in that they all solve the problem of semantic parsing from structured data, and generate programs using similar semantics. The main difference between these approaches is how an intermediate result (the memory) is represented. Neural Programmer and Dynamic-NMN chose to represent results as vectors of weights (row selectors and attention vectors), which enables backpropagation and search through all possible programs in parallel. However, their strategy is not applicable to a large KB such as Freebase, which contains about 100M entities, and more than 20k properties. Instead, NSM chooses a more scalable approach, where the “computer” saves intermediate results, and the neural net only refers to them with variable names (e.g., “R1” for all cities in the US)."
    }, {
      "heading" : "5 Conclusion",
      "text" : "We propose the Manager-Programmer-Computer framework for neural program induction. It integrates neural networks with a symbolic nondifferentiable computer to support abstract, scalable and precise operations through a friendly neural computer interface. Within this framework, we introduce the Neural Symbolic Machine, which integrates a sequence-to-sequence neural “programmer” with key-variable memory, and a Lisp interpreter with code assistance. Because the interpreter is non-differentiable and to directly optimize the task reward, we apply reinforcement learning and use pseudo-gold programs found by an iterative ML training process to bootstrap training. NSM achieves new state-of-the-art results on a challenging semantic parsing dataset with weak supervision, and significantly closing the gap between weak and full supervision. It is trained endto-end, and does not require any feature engineering or domain-specific knowledge.\n9\n801\n802\n803\n804\n805\n806\n807\n808\n809\n810\n811\n812\n813\n814\n815\n816\n817\n818\n819\n820\n821\n822\n823\n824\n825\n826\n827\n828\n829\n830\n831\n832\n833\n834\n835\n836\n837\n838\n839\n840\n841\n842\n843\n844\n845\n846\n847\n848\n849\n850\n851\n852\n853\n854\n855\n856\n857\n858\n859\n860\n861\n862\n863\n864\n865\n866\n867\n868\n869\n870\n871\n872\n873\n874\n875\n876\n877\n878\n879\n880\n881\n882\n883\n884\n885\n886\n887\n888\n889\n890\n891\n892\n893\n894\n895\n896\n897\n898\n899"
    }, {
      "heading" : "A Supplemental Material",
      "text" : "A.1 More Model Details The dimension of encoder hidden state, decoder hidden state and key embeddings are all 50. The embeddings for the functions and special tokens (e.g., ”UNK”, ”GO”) are randomly initialized by a truncated normal distribution with mean=0.0 and stddev=0.1. All the weight matrices are initialized with a uniform distribution in [− √ 3 d , √ 3 d ] where d is the input dimension. Dropout rate is set to 0.5, and we see a clear tendency that larger dropout produces better performance, indicating overfitting is a major problem for learning.\nA.2 More Training Details In iterative maximum likelihood training, the decoding uses beam size k = 100 to update the approximate gold programs and the model is trained for 20 epochs after each decoding. We use Adam optimizer (Kingma and Ba, 2014) with initial learning rate 0.001 for optimization. In our experiment, this process usually converges after a few (5-8) iterations.\nFor REINFORCE training, the best hyperparameters are chosen using the validation set. We use beam size k = 5 for decoding, and α is set to 0.1. Because the dataset is small and some relations are only used once in the whole training set, we train the model on the entire training set for 200 iterations with the best hyperparameters. Then we train the model with learning rate decay until convergence. Learning rate is decayed as gt = g0×β max(0,t−ts) m , where g0 = 0.001, β = 0.5 m = 1000, and ts is the number of training steps at the end of iteration 200.\nSince decoding needs to query the knowledge graph constantly, the speed bottleneck for training is decoding. We address this problem in our implementation by partitioning the dataset, and using multiple decoders in parallel to handle each partition. We use 100 decoders, which queries 50\n1000\n1001\n1002\n1003\n1004\n1005\n1006\n1007\n1008\n1009\n1010\n1011\n1012\n1013\n1014\n1015\n1016\n1017\n1018\n1019\n1020\n1021\n1022\n1023\n1024\n1025\n1026\n1027\n1028\n1029\n1030\n1031\n1032\n1033\n1034\n1035\n1036\n1037\n1038\n1039\n1040\n1041\n1042\n1043\n1044\n1045\n1046\n1047\n1048\n1049\n1050\n1051\n1052\n1053\n1054\n1055\n1056\n1057\n1058\n1059\n1060\n1061\n1062\n1063\n1064\n1065\n1066\n1067\n1068\n1069\n1070\n1071\n1072\n1073\n1074\n1075\n1076\n1077\n1078\n1079\n1080\n1081\n1082\n1083\n1084\n1085\n1086\n1087\n1088\n1089\n1090\n1091\n1092\n1093\n1094\n1095\n1096\n1097\n1098\n1099\nKG servers, and one trainer. The neural network model is implemented in TensorFlow. Since the model is small, we didn’t see a significant speedup by using GPU, so all the decoders and the trainer are using CPU only.\nA.3 Extra Figures\nProgrammer ComputerManager\nprogram\ncode assist\nquestion & reward\nanswer built-in functions\nWeak supervision\nNeural knowledge base (built-in data)\nnon-differentiable\nSymbolic\nFigure 3: Manager-Programmer-Computer framework\nEncoder a0 a1 an\nSoftMax\nq0 q1 qm\ndot product\nLinear Projection 300*50=15k\nLinear Projection 600*50=30k\nGRU 2*50*3*50=15k\nAttention\nDecoder\nGRU 2*50*3*50=15k\nLinear Projection 100*50=5k\nFigure 4: Seq2Seq model architecture with dot-product attention and Dropout at GRU input, output, and softmax layers.\nKG server 1\nKG server m\n…...\nDecoder 1\nDecoder 2\nDecoder n\n…...\nTrainer\nQA pairs 1\nQA pairs 2\nQA pairs n\nSolutions 1\nSolutions 2\nSolutions n\n…...…...\nModel checkpoint\nFigure 5: System Architecture. 100 decoders, 50 KG servers and 1 trainer."
    } ],
    "references" : [ {
      "title" : "Learning to compose neural networks for question answering",
      "author" : [ "Jacob Andreas", "Marcus Rohrbach", "Trevor Darrell", "Dan Klein." ],
      "venue" : "CoRR abs/1601.01705.",
      "citeRegEx" : "Andreas et al\\.,? 2016",
      "shortCiteRegEx" : "Andreas et al\\.",
      "year" : 2016
    }, {
      "title" : "Neural machine translation by jointly learning to align and translate",
      "author" : [ "Dzmitry Bahdanau", "Kyunghyun Cho", "Yoshua Bengio." ],
      "venue" : "CoRR abs/1409.0473. http://arxiv.org/abs/1409.0473.",
      "citeRegEx" : "Bahdanau et al\\.,? 2014",
      "shortCiteRegEx" : "Bahdanau et al\\.",
      "year" : 2014
    }, {
      "title" : "Semantic parsing on freebase from question-answer pairs",
      "author" : [ "Jonathan Berant", "Andrew Chou", "Roy Frostig", "Percy Liang." ],
      "venue" : "EMNLP. volume 2, page 6.",
      "citeRegEx" : "Berant et al\\.,? 2013",
      "shortCiteRegEx" : "Berant et al\\.",
      "year" : 2013
    }, {
      "title" : "Freebase: a collaboratively created graph database for structuring human knowledge",
      "author" : [ "K. Bollacker", "C. Evans", "P. Paritosh", "T. Sturge", "J. Taylor." ],
      "venue" : "International Conference on Management of Data (SIGMOD). pages 1247–1250.",
      "citeRegEx" : "Bollacker et al\\.,? 2008",
      "shortCiteRegEx" : "Bollacker et al\\.",
      "year" : 2008
    }, {
      "title" : "Learning phrase representations using rnn encoder–decoder for statistical machine translation",
      "author" : [ "Kyunghyun Cho", "Bart van Merrienboer", "Caglar Gulcehre", "Dzmitry Bahdanau", "Fethi Bougares", "Holger Schwenk", "Yoshua Bengio." ],
      "venue" : "Proceedings of",
      "citeRegEx" : "Cho et al\\.,? 2014",
      "shortCiteRegEx" : "Cho et al\\.",
      "year" : 2014
    }, {
      "title" : "Searchbased structured prediction",
      "author" : [ "H. Daume", "J. Langford", "D. Marcu." ],
      "venue" : "Machine Learning 75:297–325.",
      "citeRegEx" : "Daume et al\\.,? 2009",
      "shortCiteRegEx" : "Daume et al\\.",
      "year" : 2009
    }, {
      "title" : "Language to logical form with neural attention",
      "author" : [ "Li Dong", "Mirella Lapata." ],
      "venue" : "Association for Computational Linguistics (ACL).",
      "citeRegEx" : "Dong and Lapata.,? 2016",
      "shortCiteRegEx" : "Dong and Lapata.",
      "year" : 2016
    }, {
      "title" : "Neural turing machines",
      "author" : [ "Alex Graves", "Greg Wayne", "Ivo Danihelka." ],
      "venue" : "arXiv preprint arXiv:1410.5401 .",
      "citeRegEx" : "Graves et al\\.,? 2014",
      "shortCiteRegEx" : "Graves et al\\.",
      "year" : 2014
    }, {
      "title" : "Hybrid computing using a neural network with dynamic external memory",
      "author" : [ "Ostrovski", "Adam Cain", "Helen King", "Christopher Summerfield", "Phil Blunsom", "Koray Kavukcuoglu", "Demis Hassabis." ],
      "venue" : "Nature advance online publication.",
      "citeRegEx" : "Ostrovski et al\\.,? 2016a",
      "shortCiteRegEx" : "Ostrovski et al\\.",
      "year" : 2016
    }, {
      "title" : "Hybrid computing using a neural network",
      "author" : [ "Alex Graves", "Greg Wayne", "Malcolm Reynolds", "Tim Harley", "Ivo Danihelka", "Agnieszka GrabskaBarwińska", "Sergio Gómez Colmenarejo", "Edward Grefenstette", "Tiago Ramalho", "John Agapiou" ],
      "venue" : null,
      "citeRegEx" : "Graves et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Graves et al\\.",
      "year" : 2016
    }, {
      "title" : "Deep neural networks for acoustic modeling in speech recognition: The shared",
      "author" : [ "Geoffrey Hinton", "Li Deng", "Dong Yu", "George E Dahl", "Abdel-rahman Mohamed", "Navdeep Jaitly", "Andrew Senior", "Vincent Vanhoucke", "Patrick Nguyen", "Tara N Sainath" ],
      "venue" : null,
      "citeRegEx" : "Hinton et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Hinton et al\\.",
      "year" : 2012
    }, {
      "title" : "Data recombination for neural semantic parsing",
      "author" : [ "Robin Jia", "Percy Liang." ],
      "venue" : "Association for Computational Linguistics (ACL).",
      "citeRegEx" : "Jia and Liang.,? 2016",
      "shortCiteRegEx" : "Jia and Liang.",
      "year" : 2016
    }, {
      "title" : "Learned prioritization for trading off accuracy and speed",
      "author" : [ "J. Jiang", "A. Teichert", "J. Eisner", "H. Daume." ],
      "venue" : "Advances in Neural Information Processing Systems (NIPS).",
      "citeRegEx" : "Jiang et al\\.,? 2012",
      "shortCiteRegEx" : "Jiang et al\\.",
      "year" : 2012
    }, {
      "title" : "Neural gpus learn algorithms",
      "author" : [ "Łukasz Kaiser", "Ilya Sutskever." ],
      "venue" : "arXiv preprint arXiv:1511.08228 .",
      "citeRegEx" : "Kaiser and Sutskever.,? 2015",
      "shortCiteRegEx" : "Kaiser and Sutskever.",
      "year" : 2015
    }, {
      "title" : "Adam: A method for stochastic optimization",
      "author" : [ "Diederik P. Kingma", "Jimmy Ba." ],
      "venue" : "CoRR abs/1412.6980. http://arxiv.org/abs/1412.6980.",
      "citeRegEx" : "Kingma and Ba.,? 2014",
      "shortCiteRegEx" : "Kingma and Ba.",
      "year" : 2014
    }, {
      "title" : "Learning dependency-based compositional semantics",
      "author" : [ "P. Liang", "M.I. Jordan", "D. Klein." ],
      "venue" : "Association for Computational Linguistics (ACL). pages 590–599.",
      "citeRegEx" : "Liang et al\\.,? 2011",
      "shortCiteRegEx" : "Liang et al\\.",
      "year" : 2011
    }, {
      "title" : "Neural programmer: Inducing latent programs with gradient descent",
      "author" : [ "Arvind Neelakantan", "Quoc V. Le", "Ilya Sutskever." ],
      "venue" : "CoRR abs/1511.04834.",
      "citeRegEx" : "Neelakantan et al\\.,? 2015",
      "shortCiteRegEx" : "Neelakantan et al\\.",
      "year" : 2015
    }, {
      "title" : "Reward augmented maximum likelihood for neural structured prediction",
      "author" : [ "Mohammad Norouzi", "Samy Bengio", "zhifeng Chen", "Navdeep Jaitly", "Mike Schuster", "Yonghui Wu", "Dale Schuurmans" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Norouzi et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Norouzi et al\\.",
      "year" : 2016
    }, {
      "title" : "Compositional semantic parsing on semi-structured tables",
      "author" : [ "Panupong Pasupat", "Percy Liang." ],
      "venue" : "ACL.",
      "citeRegEx" : "Pasupat and Liang.,? 2015",
      "shortCiteRegEx" : "Pasupat and Liang.",
      "year" : 2015
    }, {
      "title" : "Glove: Global vectors for word representation",
      "author" : [ "Jeffrey Pennington", "Richard Socher", "Christopher D. Manning." ],
      "venue" : "EMNLP.",
      "citeRegEx" : "Pennington et al\\.,? 2014",
      "shortCiteRegEx" : "Pennington et al\\.",
      "year" : 2014
    }, {
      "title" : "Neural programmer-interpreters",
      "author" : [ "Scott Reed", "Nando de Freitas." ],
      "venue" : "ICLR.",
      "citeRegEx" : "Reed and Freitas.,? 2016",
      "shortCiteRegEx" : "Reed and Freitas.",
      "year" : 2016
    }, {
      "title" : "A reduction of imitation learning and structured prediction to noregret online learning",
      "author" : [ "S. Ross", "G. Gordon", "A. Bagnell." ],
      "venue" : "Artificial Intelligence and Statistics (AISTATS).",
      "citeRegEx" : "Ross et al\\.,? 2011",
      "shortCiteRegEx" : "Ross et al\\.",
      "year" : 2011
    }, {
      "title" : "Prioritized experience replay",
      "author" : [ "Tom Schaul", "John Quan", "Ioannis Antonoglou", "David Silver." ],
      "venue" : "International Conference on Learning Representations. Puerto Rico.",
      "citeRegEx" : "Schaul et al\\.,? 2016",
      "shortCiteRegEx" : "Schaul et al\\.",
      "year" : 2016
    }, {
      "title" : "Optimal ordered problem solver",
      "author" : [ "Jürgen Schmidhuber." ],
      "venue" : "Machine Learning 54(3):211–254.",
      "citeRegEx" : "Schmidhuber.,? 2004",
      "shortCiteRegEx" : "Schmidhuber.",
      "year" : 2004
    }, {
      "title" : "Mastering the game of go with deep neural networks and tree",
      "author" : [ "David Silver", "Aja Huang", "Chris J Maddison", "Arthur Guez", "Laurent Sifre", "George Van Den Driessche", "Julian Schrittwieser", "Ioannis Antonoglou", "Veda Panneershelvam", "Marc Lanctot" ],
      "venue" : null,
      "citeRegEx" : "Silver et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Silver et al\\.",
      "year" : 2016
    }, {
      "title" : "Sequence to sequence learning with neural networks",
      "author" : [ "Ilya Sutskever", "Oriol Vinyals", "Quoc V Le." ],
      "venue" : "Advances in neural information processing systems. pages 3104–3112.",
      "citeRegEx" : "Sutskever et al\\.,? 2014",
      "shortCiteRegEx" : "Sutskever et al\\.",
      "year" : 2014
    }, {
      "title" : "Reinforcement Learning: An Introduction",
      "author" : [ "Richard S. Sutton", "Andrew G. Barto." ],
      "venue" : "MIT Press, Cambridge, MA.",
      "citeRegEx" : "Sutton and Barto.,? 1998",
      "shortCiteRegEx" : "Sutton and Barto.",
      "year" : 1998
    }, {
      "title" : "Pointer networks",
      "author" : [ "Oriol Vinyals", "Meire Fortunato", "Navdeep Jaitly." ],
      "venue" : "Advances in Neural Information Processing Systems (NIPS).",
      "citeRegEx" : "Vinyals et al\\.,? 2015",
      "shortCiteRegEx" : "Vinyals et al\\.",
      "year" : 2015
    }, {
      "title" : "Building a semantic parser overnight",
      "author" : [ "Yushi Wang", "Jonathan Berant", "Percy Liang." ],
      "venue" : "Association for Computational Linguistics (ACL).",
      "citeRegEx" : "Wang et al\\.,? 2015",
      "shortCiteRegEx" : "Wang et al\\.",
      "year" : 2015
    }, {
      "title" : "Memory networks",
      "author" : [ "Jason Weston", "Sumit Chopra", "Antoine Bordes." ],
      "venue" : "arXiv preprint arXiv:1410.3916 .",
      "citeRegEx" : "Weston et al\\.,? 2014",
      "shortCiteRegEx" : "Weston et al\\.",
      "year" : 2014
    }, {
      "title" : "Simple statistical gradientfollowing algorithms for connectionist reinforcement learning",
      "author" : [ "Ronald J. Williams." ],
      "venue" : "Machine Learning. pages 229– 256.",
      "citeRegEx" : "Williams.,? 1992",
      "shortCiteRegEx" : "Williams.",
      "year" : 1992
    }, {
      "title" : "Sequence-to-sequence learning as beamsearch optimization",
      "author" : [ "Sam Wiseman", "Alexander M. Rush." ],
      "venue" : "CoRR abs/1606.02960. http://arxiv.org/abs/1606.02960.",
      "citeRegEx" : "Wiseman and Rush.,? 2016",
      "shortCiteRegEx" : "Wiseman and Rush.",
      "year" : 2016
    }, {
      "title" : "Semantic parsing via staged query graph generation: Question answering with knowledge base",
      "author" : [ "Wen-tau Yih", "Ming-Wei Chang", "Xiaodong He", "Jianfeng Gao." ],
      "venue" : "Association for Computational Linguistics (ACL).",
      "citeRegEx" : "Yih et al\\.,? 2015",
      "shortCiteRegEx" : "Yih et al\\.",
      "year" : 2015
    }, {
      "title" : "The value of semantic parse labeling for knowledge base question answering",
      "author" : [ "Wen-tau Yih", "Matthew Richardson", "Chris Meek", "MingWei Chang", "Jina Suh." ],
      "venue" : "Association for Computational Linguistics (ACL).",
      "citeRegEx" : "Yih et al\\.,? 2016",
      "shortCiteRegEx" : "Yih et al\\.",
      "year" : 2016
    }, {
      "title" : "Reinforcement learning neural turing machines",
      "author" : [ "Wojciech Zaremba", "Ilya Sutskever." ],
      "venue" : "arXiv preprint arXiv:1505.00521 .",
      "citeRegEx" : "Zaremba and Sutskever.,? 2015",
      "shortCiteRegEx" : "Zaremba and Sutskever.",
      "year" : 2015
    }, {
      "title" : "Learning to parse database queries using inductive logic programming",
      "author" : [ "M. Zelle", "R.J. Mooney." ],
      "venue" : "Association for the Advancement of Artificial Intelligence (AAAI). pages 1050–1055.",
      "citeRegEx" : "Zelle and Mooney.,? 1996",
      "shortCiteRegEx" : "Zelle and Mooney.",
      "year" : 1996
    }, {
      "title" : "Learning to map sentences to logical form: Structured classification with probabilistic categorial grammars",
      "author" : [ "L.S. Zettlemoyer", "M. Collins." ],
      "venue" : "Uncertainty in Artificial Intelligence (UAI). pages 658– 666.",
      "citeRegEx" : "Zettlemoyer and Collins.,? 2005",
      "shortCiteRegEx" : "Zettlemoyer and Collins.",
      "year" : 2005
    } ],
    "referenceMentions" : [ {
      "referenceID" : 10,
      "context" : "Deep neural networks have achieved impressive performance in supervised classification and structured prediction tasks such as speech recognition (Hinton et al., 2012), machine translation (Bahdanau et al.",
      "startOffset" : 146,
      "endOffset" : 167
    }, {
      "referenceID" : 1,
      "context" : ", 2012), machine translation (Bahdanau et al., 2014; Wu et al., 2016) and more.",
      "startOffset" : 29,
      "endOffset" : 69
    }, {
      "referenceID" : 35,
      "context" : "However, training neural networks for semantic parsing (Zelle and Mooney, 1996; Zettlemoyer and Collins, 2005; Liang et al., 2011) or program induction, where language is mapped to a symbolic representation that is executed by a comx: Largest city in the US ⇒ y: NYC",
      "startOffset" : 55,
      "endOffset" : 130
    }, {
      "referenceID" : 36,
      "context" : "However, training neural networks for semantic parsing (Zelle and Mooney, 1996; Zettlemoyer and Collins, 2005; Liang et al., 2011) or program induction, where language is mapped to a symbolic representation that is executed by a comx: Largest city in the US ⇒ y: NYC",
      "startOffset" : 55,
      "endOffset" : 130
    }, {
      "referenceID" : 15,
      "context" : "However, training neural networks for semantic parsing (Zelle and Mooney, 1996; Zettlemoyer and Collins, 2005; Liang et al., 2011) or program induction, where language is mapped to a symbolic representation that is executed by a comx: Largest city in the US ⇒ y: NYC",
      "startOffset" : 55,
      "endOffset" : 130
    }, {
      "referenceID" : 6,
      "context" : "In semantic parsing, recent work handled this (Dong and Lapata, 2016; Jia and Liang, 2016) by training from manually annotated programs and avoiding program execution at training time.",
      "startOffset" : 46,
      "endOffset" : 90
    }, {
      "referenceID" : 11,
      "context" : "In semantic parsing, recent work handled this (Dong and Lapata, 2016; Jia and Liang, 2016) by training from manually annotated programs and avoiding program execution at training time.",
      "startOffset" : 46,
      "endOffset" : 90
    }, {
      "referenceID" : 7,
      "context" : "In program induction, attempts to address this problem (Graves et al., 2014; Reed and de Freitas, 2016; Kaiser and Sutskever, 2015; Graves et al., 2016b; Andreas et al., 2016) either utilized low-level memory (Zaremba and Sutskever, 2015), or required memory to be differentiable (Neelakantan et al.",
      "startOffset" : 55,
      "endOffset" : 175
    }, {
      "referenceID" : 13,
      "context" : "In program induction, attempts to address this problem (Graves et al., 2014; Reed and de Freitas, 2016; Kaiser and Sutskever, 2015; Graves et al., 2016b; Andreas et al., 2016) either utilized low-level memory (Zaremba and Sutskever, 2015), or required memory to be differentiable (Neelakantan et al.",
      "startOffset" : 55,
      "endOffset" : 175
    }, {
      "referenceID" : 0,
      "context" : "In program induction, attempts to address this problem (Graves et al., 2014; Reed and de Freitas, 2016; Kaiser and Sutskever, 2015; Graves et al., 2016b; Andreas et al., 2016) either utilized low-level memory (Zaremba and Sutskever, 2015), or required memory to be differentiable (Neelakantan et al.",
      "startOffset" : 55,
      "endOffset" : 175
    }, {
      "referenceID" : 34,
      "context" : ", 2016) either utilized low-level memory (Zaremba and Sutskever, 2015), or required memory to be differentiable (Neelakantan et al.",
      "startOffset" : 41,
      "endOffset" : 70
    }, {
      "referenceID" : 16,
      "context" : ", 2016) either utilized low-level memory (Zaremba and Sutskever, 2015), or required memory to be differentiable (Neelakantan et al., 2015) so that the model can be trained with backpropagation.",
      "startOffset" : 112,
      "endOffset" : 138
    }, {
      "referenceID" : 25,
      "context" : "NSM contains a sequence-to-sequence (seq2seq) “programmer” (Sutskever et al., 2014) and a symbolic non-differentiable Lisp interpreter (“computer”) that executes programs against a large knowledge-base (KB).",
      "startOffset" : 59,
      "endOffset" : 83
    }, {
      "referenceID" : 27,
      "context" : "This is a novel application of pointer networks (Vinyals et al., 2015) to compositional semantics.",
      "startOffset" : 48,
      "endOffset" : 70
    }, {
      "referenceID" : 15,
      "context" : "This generalized past work on training from weak supervision (Liang et al., 2011; Berant et al., 2013) by using the semantic denotations for structural search.",
      "startOffset" : 61,
      "endOffset" : 102
    }, {
      "referenceID" : 2,
      "context" : "This generalized past work on training from weak supervision (Liang et al., 2011; Berant et al., 2013) by using the semantic denotations for structural search.",
      "startOffset" : 61,
      "endOffset" : 102
    }, {
      "referenceID" : 30,
      "context" : "Third, to train from weak supervision and directly maximize the expected reward we turn to the REINFORCE (Williams, 1992) algorithm.",
      "startOffset" : 105,
      "endOffset" : 121
    }, {
      "referenceID" : 33,
      "context" : "On the WEBQUESTIONSSP dataset (Yih et al., 2016), NSM achieves new state-of-the-art results with weak supervision, significantly closing the gap between weak and full supervision for this task.",
      "startOffset" : 30,
      "endOffset" : 48
    }, {
      "referenceID" : 7,
      "context" : "Operations learned with neural networks such as addition and sorting do not perfectly generalize to inputs that are larger than the ones observed in the training data (Graves et al., 2014; Reed and de Freitas, 2016).",
      "startOffset" : 167,
      "endOffset" : 215
    }, {
      "referenceID" : 28,
      "context" : "This is reminiscent of the floating parser (Wang et al., 2015; Pasupat and Liang, 2015), where a derivation tree that is not grounded in the input is incrementally constructed.",
      "startOffset" : 43,
      "endOffset" : 87
    }, {
      "referenceID" : 18,
      "context" : "This is reminiscent of the floating parser (Wang et al., 2015; Pasupat and Liang, 2015), where a derivation tree that is not grounded in the input is incrementally constructed.",
      "startOffset" : 43,
      "endOffset" : 87
    }, {
      "referenceID" : 32,
      "context" : "The set of programs defined by our functions is equivalent to the subset of λ-calculus presented in (Yih et al., 2015).",
      "startOffset" : 100,
      "endOffset" : 118
    }, {
      "referenceID" : 4,
      "context" : "We used a 1-layer GRU (Cho et al., 2014) for both the encoder and decoder.",
      "startOffset" : 22,
      "endOffset" : 40
    }, {
      "referenceID" : 4,
      "context" : "We used a 1-layer GRU (Cho et al., 2014) for both the encoder and decoder. Given a sequence of words w1, w2...wm, each word wt is mapped to an embedding qt (embedding details are Section 3). Then, the encoder reads these embeddings and updates its hidden state step by step using ht+1 = GRU(ht, qt, θEncoder), where θEncoder are the GRU parameters. The decoder updates its hidden states ut by ut+1 = GRU(ut, ct−1, θDecoder), where ct−1 is the embedding of last step’s output token at−1, and θDecoder are the GRU parameters. The last hidden state of the encoder hT is used as the decoder’s initial state. We also adopt a dot-product attention similar to Dong and Lapata (2016). The tokens of the program a1, a2.",
      "startOffset" : 23,
      "endOffset" : 676
    }, {
      "referenceID" : 27,
      "context" : "Note that, similar to pointer networks (Vinyals et al., 2015), the key embeddings for variables are dynamically generated for each example.",
      "startOffset" : 39,
      "endOffset" : 61
    }, {
      "referenceID" : 29,
      "context" : "This distinguishes the keyvariable memory from other memory-augmented neural networks that use continuous differentiable embeddings as the value of each memory entry (Weston et al., 2014; Graves et al., 2016a).",
      "startOffset" : 166,
      "endOffset" : 209
    }, {
      "referenceID" : 30,
      "context" : "Therefore, we base our training procedure on REINFORCE (Williams, 1992; Norouzi et al., 2016).",
      "startOffset" : 55,
      "endOffset" : 93
    }, {
      "referenceID" : 17,
      "context" : "Therefore, we base our training procedure on REINFORCE (Williams, 1992; Norouzi et al., 2016).",
      "startOffset" : 55,
      "endOffset" : 93
    }, {
      "referenceID" : 24,
      "context" : "When the reward signal is sparse and the search space is large, it is common to utilize some full supervision to pre-train REINFORCE (Silver et al., 2016).",
      "startOffset" : 133,
      "endOffset" : 154
    }, {
      "referenceID" : 34,
      "context" : "A common solution to this problem is to use curriculum learning (Zaremba and Sutskever, 2015; Reed and de Freitas, 2016).",
      "startOffset" : 64,
      "endOffset" : 120
    }, {
      "referenceID" : 21,
      "context" : "This is similar to methods from imitation learning (Ross et al., 2011; Jiang et al., 2012) that define a proposal distribution by linearly interpolating the model distribution and an oracle.",
      "startOffset" : 51,
      "endOffset" : 90
    }, {
      "referenceID" : 12,
      "context" : "This is similar to methods from imitation learning (Ross et al., 2011; Jiang et al., 2012) that define a proposal distribution by linearly interpolating the model distribution and an oracle.",
      "startOffset" : 51,
      "endOffset" : 90
    }, {
      "referenceID" : 22,
      "context" : "On top of imitation learning, our approach is related to the common practice in reinforcement learning (Schaul et al., 2016) to replay rare successful experiences to reduce the training variance and improve training efficiency.",
      "startOffset" : 103,
      "endOffset" : 124
    }, {
      "referenceID" : 33,
      "context" : "The WEBQUESTIONSSP dataset (Yih et al., 2016) contains semantic parses for the questions from WEBQUESTIONS (Berant et al.",
      "startOffset" : 27,
      "endOffset" : 45
    }, {
      "referenceID" : 2,
      "context" : ", 2016) contains semantic parses for the questions from WEBQUESTIONS (Berant et al., 2013) that are answerable using Freebase.",
      "startOffset" : 69,
      "endOffset" : 90
    }, {
      "referenceID" : 32,
      "context" : "The quality of the entity linker is similar to that of (Yih et al., 2015) at 94% of the gold root entities being included.",
      "startOffset" : 55,
      "endOffset" : 73
    }, {
      "referenceID" : 32,
      "context" : "Following (Yih et al., 2015) we used the last publicly available snapshot of Freebase (Bollacker et al.",
      "startOffset" : 10,
      "endOffset" : 28
    }, {
      "referenceID" : 3,
      "context" : ", 2015) we used the last publicly available snapshot of Freebase (Bollacker et al., 2008).",
      "startOffset" : 65,
      "endOffset" : 89
    }, {
      "referenceID" : 2,
      "context" : ", 2016) contains semantic parses for the questions from WEBQUESTIONS (Berant et al., 2013) that are answerable using Freebase. It consists of 3,098 question-answer pairs for training and 1,639 for testing. These questions were collected using Google Suggest API and the answers were originally obtained using Amazon Mechanical Turk and updated by annotators who were familiar with the design of Freebase. We further separated out 620 questions from the training set as a validation set. For query pre-processing we used an in-house named entity linking system to find the entities in a question. The quality of the entity linker is similar to that of (Yih et al., 2015) at 94% of the gold root entities being included. Similar to Dong and Lapata (2016), we replaced named entity tokens with a special token ”ENT”.",
      "startOffset" : 70,
      "endOffset" : 753
    }, {
      "referenceID" : 19,
      "context" : "For pre-trained word embeddings, we used the 300 dimension GloVe word embeddings trained on 840B tokens (Pennington et al., 2014).",
      "startOffset" : 104,
      "endOffset" : 129
    }, {
      "referenceID" : 32,
      "context" : "Inspired by the staged generation process in Yih et al. (2015), curriculum learning includes two steps.",
      "startOffset" : 45,
      "endOffset" : 63
    }, {
      "referenceID" : 34,
      "context" : "Among deep learning models for program induction, Reinforcement Learning Neural Turing Machines (RL-NTMs) (Zaremba and Sutskever, 2015) are the most similar to NSM, as a nondifferentiable machine is controlled by a sequence model.",
      "startOffset" : 106,
      "endOffset" : 135
    }, {
      "referenceID" : 23,
      "context" : "Earlier work such as OOPS (Schmidhuber, 2004) has desirable characteristics, such as the ability to define new functions and modify code storage.",
      "startOffset" : 26,
      "endOffset" : 45
    }, {
      "referenceID" : 26,
      "context" : "We formulate NSM training as an instance of reinforcement learning (Sutton and Barto, 1998) in order to directly optimize the task reward of the structured prediction problem (Norouzi et al.",
      "startOffset" : 67,
      "endOffset" : 91
    }, {
      "referenceID" : 17,
      "context" : "We formulate NSM training as an instance of reinforcement learning (Sutton and Barto, 1998) in order to directly optimize the task reward of the structured prediction problem (Norouzi et al., 2016).",
      "startOffset" : 175,
      "endOffset" : 197
    }, {
      "referenceID" : 5,
      "context" : "Compared to imitation learning methods (Daume et al., 2009; Ross et al., 2011) that interpolate a model distribution with an oracle, NSM needs to solve a challenging search problem of training from weak supervisions in a large program space.",
      "startOffset" : 39,
      "endOffset" : 78
    }, {
      "referenceID" : 21,
      "context" : "Compared to imitation learning methods (Daume et al., 2009; Ross et al., 2011) that interpolate a model distribution with an oracle, NSM needs to solve a challenging search problem of training from weak supervisions in a large program space.",
      "startOffset" : 39,
      "endOffset" : 78
    }, {
      "referenceID" : 31,
      "context" : "Wiseman and Rush (Wiseman and Rush, 2016) proposed a max-margin approach to train a sequence-to-sequence scorer.",
      "startOffset" : 17,
      "endOffset" : 41
    }, {
      "referenceID" : 16,
      "context" : "NSM is similar to Neural Programmer (Neelakantan et al., 2015) and Dynamic Neural Module Network (Andreas et al.",
      "startOffset" : 36,
      "endOffset" : 62
    }, {
      "referenceID" : 0,
      "context" : ", 2015) and Dynamic Neural Module Network (Andreas et al., 2016) in that they all solve the problem of semantic parsing from structured data, and generate programs using similar semantics.",
      "startOffset" : 42,
      "endOffset" : 64
    } ],
    "year" : 2017,
    "abstractText" : "Harnessing the statistical power of neural networks to perform language understanding and symbolic reasoning is difficult, when it requires executing efficient discrete operations against a large knowledge-base. In this work, we introduce a Neural Symbolic Machine, which contains (a) a neural “programmer”, i.e., a sequence-to-sequence model that maps language utterances to programs and utilizes a key-variable memory to handle compositionality (b) a symbolic “computer”, i.e., a Lisp interpreter that performs program execution, and helps find good programs by pruning the search space. We apply REINFORCE to directly optimize the task reward of this structured prediction problem. To train with weak supervision and improve the stability of REINFORCE we augment it with an iterative maximum-likelihood process. NSM outperforms state-of-the-art on the WEBQUESTIONSSP dataset when trained from question-answer pairs only, without requiring any feature engineering or domain-specific knowledge.",
    "creator" : "LaTeX with hyperref package"
  }
}